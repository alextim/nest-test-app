var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-cb3f5e89.js"(exports, module) {
    function _mergeNamespaces(n2, m2) {
      for (var i2 = 0; i2 < m2.length; i2++) {
        const e2 = m2[i2];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (const k2 in e2) {
            if (k2 !== "default" && !(k2 in n2)) {
              const d2 = Object.getOwnPropertyDescriptor(e2, k2);
              if (d2) {
                Object.defineProperty(n2, k2, d2.get ? d2 : {
                  enumerable: true,
                  get: () => e2[k2]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
    }
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link2);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node2 of mutation.addedNodes) {
            if (node2.tagName === "LINK" && node2.rel === "modulepreload")
              processPreload(node2);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link2) {
        const fetchOpts = {};
        if (link2.integrity)
          fetchOpts.integrity = link2.integrity;
        if (link2.referrerPolicy)
          fetchOpts.referrerPolicy = link2.referrerPolicy;
        if (link2.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link2.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link2) {
        if (link2.ep)
          return;
        link2.ep = true;
        const fetchOpts = getFetchOpts(link2);
        fetch(link2.href, fetchOpts);
      }
    })();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    function getAugmentedNamespace(n2) {
      if (n2.__esModule)
        return n2;
      var f2 = n2.default;
      if (typeof f2 == "function") {
        var a = function a2() {
          if (this instanceof a2) {
            var args = [null];
            args.push.apply(args, arguments);
            var Ctor = Function.bind.apply(f2, args);
            return new Ctor();
          }
          return f2.apply(this, arguments);
        };
        a.prototype = f2.prototype;
      } else
        a = {};
      Object.defineProperty(a, "__esModule", { value: true });
      Object.keys(n2).forEach(function(k2) {
        var d2 = Object.getOwnPropertyDescriptor(n2, k2);
        Object.defineProperty(a, k2, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return n2[k2];
          }
        });
      });
      return a;
    }
    var jsxRuntimeExports = {};
    var jsxRuntime = {
      get exports() {
        return jsxRuntimeExports;
      },
      set exports(v2) {
        jsxRuntimeExports = v2;
      }
    };
    var reactJsxRuntime_production_min = {};
    var reactExports = {};
    var react = {
      get exports() {
        return reactExports;
      },
      set exports(v2) {
        reactExports = v2;
      }
    };
    var react_production_min = {};
    /**
     * @license React
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l$5 = Symbol.for("react.element"), n$6 = Symbol.for("react.portal"), p$7 = Symbol.for("react.fragment"), q$5 = Symbol.for("react.strict_mode"), r$3 = Symbol.for("react.profiler"), t$4 = Symbol.for("react.provider"), u$e = Symbol.for("react.context"), v$4 = Symbol.for("react.forward_ref"), w$4 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$3 = Symbol.iterator;
    function A$4(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = z$3 && a[z$3] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var B$3 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C$2 = Object.assign, D$2 = {};
    function E$4(a, b2, e2) {
      this.props = a;
      this.context = b2;
      this.refs = D$2;
      this.updater = e2 || B$3;
    }
    E$4.prototype.isReactComponent = {};
    E$4.prototype.setState = function(a, b2) {
      if ("object" !== typeof a && "function" !== typeof a && null != a)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b2, "setState");
    };
    E$4.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F$2() {
    }
    F$2.prototype = E$4.prototype;
    function G$2(a, b2, e2) {
      this.props = a;
      this.context = b2;
      this.refs = D$2;
      this.updater = e2 || B$3;
    }
    var H$4 = G$2.prototype = new F$2();
    H$4.constructor = G$2;
    C$2(H$4, E$4.prototype);
    H$4.isPureReactComponent = true;
    var I$2 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$2 = { key: true, ref: true, __self: true, __source: true };
    function M$2(a, b2, e2) {
      var d2, c2 = {}, k2 = null, h2 = null;
      if (null != b2)
        for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
          J$1.call(b2, d2) && !L$2.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
      var g2 = arguments.length - 2;
      if (1 === g2)
        c2.children = e2;
      else if (1 < g2) {
        for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
          f2[m2] = arguments[m2 + 2];
        c2.children = f2;
      }
      if (a && a.defaultProps)
        for (d2 in g2 = a.defaultProps, g2)
          void 0 === c2[d2] && (c2[d2] = g2[d2]);
      return { $$typeof: l$5, type: a, key: k2, ref: h2, props: c2, _owner: K$1.current };
    }
    function N$2(a, b2) {
      return { $$typeof: l$5, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O$2(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l$5;
    }
    function escape$2(a) {
      var b2 = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b2[a2];
      });
    }
    var P$1 = /\/+/g;
    function Q$2(a, b2) {
      return "object" === typeof a && null !== a && null != a.key ? escape$2("" + a.key) : b2.toString(36);
    }
    function R$1(a, b2, e2, d2, c2) {
      var k2 = typeof a;
      if ("undefined" === k2 || "boolean" === k2)
        a = null;
      var h2 = false;
      if (null === a)
        h2 = true;
      else
        switch (k2) {
          case "string":
          case "number":
            h2 = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l$5:
              case n$6:
                h2 = true;
            }
        }
      if (h2)
        return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$2(h2, 0) : d2, I$2(c2) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a2) {
          return a2;
        })) : null != c2 && (O$2(c2) && (c2 = N$2(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a)), b2.push(c2)), 1;
      h2 = 0;
      d2 = "" === d2 ? "." : d2 + ":";
      if (I$2(a))
        for (var g2 = 0; g2 < a.length; g2++) {
          k2 = a[g2];
          var f2 = d2 + Q$2(k2, g2);
          h2 += R$1(k2, b2, e2, f2, c2);
        }
      else if (f2 = A$4(a), "function" === typeof f2)
        for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
          k2 = k2.value, f2 = d2 + Q$2(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
      else if ("object" === k2)
        throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
      return h2;
    }
    function S$1(a, b2, e2) {
      if (null == a)
        return a;
      var d2 = [], c2 = 0;
      R$1(a, d2, "", "", function(a2) {
        return b2.call(e2, a2, c2++);
      });
      return d2;
    }
    function T$2(a) {
      if (-1 === a._status) {
        var b2 = a._result;
        b2 = b2();
        b2.then(function(b3) {
          if (0 === a._status || -1 === a._status)
            a._status = 1, a._result = b3;
        }, function(b3) {
          if (0 === a._status || -1 === a._status)
            a._status = 2, a._result = b3;
        });
        -1 === a._status && (a._status = 0, a._result = b2);
      }
      if (1 === a._status)
        return a._result.default;
      throw a._result;
    }
    var U$2 = { current: null }, V$1 = { transition: null }, W$3 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
    react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
      S$1(a, function() {
        b2.apply(this, arguments);
      }, e2);
    }, count: function(a) {
      var b2 = 0;
      S$1(a, function() {
        b2++;
      });
      return b2;
    }, toArray: function(a) {
      return S$1(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O$2(a))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    react_production_min.Component = E$4;
    react_production_min.Fragment = p$7;
    react_production_min.Profiler = r$3;
    react_production_min.PureComponent = G$2;
    react_production_min.StrictMode = q$5;
    react_production_min.Suspense = w$4;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$3;
    react_production_min.cloneElement = function(a, b2, e2) {
      if (null === a || void 0 === a)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d2 = C$2({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
      if (null != b2) {
        void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
        void 0 !== b2.key && (c2 = "" + b2.key);
        if (a.type && a.type.defaultProps)
          var g2 = a.type.defaultProps;
        for (f2 in b2)
          J$1.call(b2, f2) && !L$2.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
      }
      var f2 = arguments.length - 2;
      if (1 === f2)
        d2.children = e2;
      else if (1 < f2) {
        g2 = Array(f2);
        for (var m2 = 0; m2 < f2; m2++)
          g2[m2] = arguments[m2 + 2];
        d2.children = g2;
      }
      return { $$typeof: l$5, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
    };
    react_production_min.createContext = function(a) {
      a = { $$typeof: u$e, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t$4, _context: a };
      return a.Consumer = a;
    };
    react_production_min.createElement = M$2;
    react_production_min.createFactory = function(a) {
      var b2 = M$2.bind(null, a);
      b2.type = a;
      return b2;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a) {
      return { $$typeof: v$4, render: a };
    };
    react_production_min.isValidElement = O$2;
    react_production_min.lazy = function(a) {
      return { $$typeof: y$2, _payload: { _status: -1, _result: a }, _init: T$2 };
    };
    react_production_min.memo = function(a, b2) {
      return { $$typeof: x$2, type: a, compare: void 0 === b2 ? null : b2 };
    };
    react_production_min.startTransition = function(a) {
      var b2 = V$1.transition;
      V$1.transition = {};
      try {
        a();
      } finally {
        V$1.transition = b2;
      }
    };
    react_production_min.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    react_production_min.useCallback = function(a, b2) {
      return U$2.current.useCallback(a, b2);
    };
    react_production_min.useContext = function(a) {
      return U$2.current.useContext(a);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a) {
      return U$2.current.useDeferredValue(a);
    };
    react_production_min.useEffect = function(a, b2) {
      return U$2.current.useEffect(a, b2);
    };
    react_production_min.useId = function() {
      return U$2.current.useId();
    };
    react_production_min.useImperativeHandle = function(a, b2, e2) {
      return U$2.current.useImperativeHandle(a, b2, e2);
    };
    react_production_min.useInsertionEffect = function(a, b2) {
      return U$2.current.useInsertionEffect(a, b2);
    };
    react_production_min.useLayoutEffect = function(a, b2) {
      return U$2.current.useLayoutEffect(a, b2);
    };
    react_production_min.useMemo = function(a, b2) {
      return U$2.current.useMemo(a, b2);
    };
    react_production_min.useReducer = function(a, b2, e2) {
      return U$2.current.useReducer(a, b2, e2);
    };
    react_production_min.useRef = function(a) {
      return U$2.current.useRef(a);
    };
    react_production_min.useState = function(a) {
      return U$2.current.useState(a);
    };
    react_production_min.useSyncExternalStore = function(a, b2, e2) {
      return U$2.current.useSyncExternalStore(a, b2, e2);
    };
    react_production_min.useTransition = function() {
      return U$2.current.useTransition();
    };
    react_production_min.version = "18.2.0";
    (function(module2) {
      {
        module2.exports = react_production_min;
      }
    })(react);
    const React$3 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    const React$4 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: React$3
    }, [reactExports]);
    /**
     * @license React
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var f$3 = reactExports, k$5 = Symbol.for("react.element"), l$4 = Symbol.for("react.fragment"), m$5 = Object.prototype.hasOwnProperty, n$5 = f$3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$6 = { key: true, ref: true, __self: true, __source: true };
    function q$4(c2, a, g2) {
      var b2, d2 = {}, e2 = null, h2 = null;
      void 0 !== g2 && (e2 = "" + g2);
      void 0 !== a.key && (e2 = "" + a.key);
      void 0 !== a.ref && (h2 = a.ref);
      for (b2 in a)
        m$5.call(a, b2) && !p$6.hasOwnProperty(b2) && (d2[b2] = a[b2]);
      if (c2 && c2.defaultProps)
        for (b2 in a = c2.defaultProps, a)
          void 0 === d2[b2] && (d2[b2] = a[b2]);
      return { $$typeof: k$5, type: c2, key: e2, ref: h2, props: d2, _owner: n$5.current };
    }
    reactJsxRuntime_production_min.Fragment = l$4;
    reactJsxRuntime_production_min.jsx = q$4;
    reactJsxRuntime_production_min.jsxs = q$4;
    (function(module2) {
      {
        module2.exports = reactJsxRuntime_production_min;
      }
    })(jsxRuntime);
    const Fragment = jsxRuntimeExports.Fragment;
    const jsx = jsxRuntimeExports.jsx;
    const jsxs = jsxRuntimeExports.jsxs;
    var reactDomExports = {};
    var reactDom = {
      get exports() {
        return reactDomExports;
      },
      set exports(v2) {
        reactDomExports = v2;
      }
    };
    var reactDom_production_min = {};
    var schedulerExports = {};
    var scheduler = {
      get exports() {
        return schedulerExports;
      },
      set exports(v2) {
        schedulerExports = v2;
      }
    };
    var scheduler_production_min = {};
    /**
     * @license React
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports2) {
      function f2(a, b2) {
        var c2 = a.length;
        a.push(b2);
        a:
          for (; 0 < c2; ) {
            var d2 = c2 - 1 >>> 1, e2 = a[d2];
            if (0 < g2(e2, b2))
              a[d2] = b2, a[c2] = e2, c2 = d2;
            else
              break a;
          }
      }
      function h2(a) {
        return 0 === a.length ? null : a[0];
      }
      function k2(a) {
        if (0 === a.length)
          return null;
        var b2 = a[0], c2 = a.pop();
        if (c2 !== b2) {
          a[0] = c2;
          a:
            for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
              var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
              if (0 > g2(C2, c2))
                n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
              else if (n2 < e2 && 0 > g2(x2, c2))
                a[d2] = x2, a[n2] = c2, d2 = n2;
              else
                break a;
            }
        }
        return b2;
      }
      function g2(a, b2) {
        var c2 = a.sortIndex - b2.sortIndex;
        return 0 !== c2 ? c2 : a.id - b2.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l2 = performance;
        exports2.unstable_now = function() {
          return l2.now();
        };
      } else {
        var p2 = Date, q2 = p2.now();
        exports2.unstable_now = function() {
          return p2.now() - q2;
        };
      }
      var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G2(a) {
        for (var b2 = h2(t2); null !== b2; ) {
          if (null === b2.callback)
            k2(t2);
          else if (b2.startTime <= a)
            k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
          else
            break;
          b2 = h2(t2);
        }
      }
      function H2(a) {
        B2 = false;
        G2(a);
        if (!A2)
          if (null !== h2(r2))
            A2 = true, I2(J2);
          else {
            var b2 = h2(t2);
            null !== b2 && K2(H2, b2.startTime - a);
          }
      }
      function J2(a, b2) {
        A2 = false;
        B2 && (B2 = false, E2(L2), L2 = -1);
        z2 = true;
        var c2 = y2;
        try {
          G2(b2);
          for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
            var d2 = v2.callback;
            if ("function" === typeof d2) {
              v2.callback = null;
              y2 = v2.priorityLevel;
              var e2 = d2(v2.expirationTime <= b2);
              b2 = exports2.unstable_now();
              "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
              G2(b2);
            } else
              k2(r2);
            v2 = h2(r2);
          }
          if (null !== v2)
            var w2 = true;
          else {
            var m2 = h2(t2);
            null !== m2 && K2(H2, m2.startTime - b2);
            w2 = false;
          }
          return w2;
        } finally {
          v2 = null, y2 = c2, z2 = false;
        }
      }
      var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
      function M2() {
        return exports2.unstable_now() - Q2 < P2 ? false : true;
      }
      function R2() {
        if (null !== O2) {
          var a = exports2.unstable_now();
          Q2 = a;
          var b2 = true;
          try {
            b2 = O2(true, a);
          } finally {
            b2 ? S2() : (N2 = false, O2 = null);
          }
        } else
          N2 = false;
      }
      var S2;
      if ("function" === typeof F2)
        S2 = function() {
          F2(R2);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var T2 = new MessageChannel(), U2 = T2.port2;
        T2.port1.onmessage = R2;
        S2 = function() {
          U2.postMessage(null);
        };
      } else
        S2 = function() {
          D2(R2, 0);
        };
      function I2(a) {
        O2 = a;
        N2 || (N2 = true, S2());
      }
      function K2(a, b2) {
        L2 = D2(function() {
          a(exports2.unstable_now());
        }, b2);
      }
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        A2 || z2 || (A2 = true, I2(J2));
      };
      exports2.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return y2;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return h2(r2);
      };
      exports2.unstable_next = function(a) {
        switch (y2) {
          case 1:
          case 2:
          case 3:
            var b2 = 3;
            break;
          default:
            b2 = y2;
        }
        var c2 = y2;
        y2 = b2;
        try {
          return a();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = function() {
      };
      exports2.unstable_runWithPriority = function(a, b2) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c2 = y2;
        y2 = a;
        try {
          return b2();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_scheduleCallback = function(a, b2, c2) {
        var d2 = exports2.unstable_now();
        "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
        switch (a) {
          case 1:
            var e2 = -1;
            break;
          case 2:
            e2 = 250;
            break;
          case 5:
            e2 = 1073741823;
            break;
          case 4:
            e2 = 1e4;
            break;
          default:
            e2 = 5e3;
        }
        e2 = c2 + e2;
        a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
        c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
        return a;
      };
      exports2.unstable_shouldYield = M2;
      exports2.unstable_wrapCallback = function(a) {
        var b2 = y2;
        return function() {
          var c2 = y2;
          y2 = b2;
          try {
            return a.apply(this, arguments);
          } finally {
            y2 = c2;
          }
        };
      };
    })(scheduler_production_min);
    (function(module2) {
      {
        module2.exports = scheduler_production_min;
      }
    })(scheduler);
    /**
     * @license React
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa = reactExports, ca = schedulerExports;
    function p$5(a) {
      for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
        b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da$1 = /* @__PURE__ */ new Set(), ea = {};
    function fa(a, b2) {
      ha(a, b2);
      ha(a + "Capture", b2);
    }
    function ha(a, b2) {
      ea[a] = b2;
      for (a = 0; a < b2.length; a++)
        da$1.add(b2[a]);
    }
    var ia$1 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja$1 = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la$1 = {}, ma = {};
    function oa$1(a) {
      if (ja$1.call(ma, a))
        return true;
      if (ja$1.call(la$1, a))
        return false;
      if (ka.test(a))
        return ma[a] = true;
      la$1[a] = true;
      return false;
    }
    function pa(a, b2, c2, d2) {
      if (null !== c2 && 0 === c2.type)
        return false;
      switch (typeof b2) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d2)
            return false;
          if (null !== c2)
            return !c2.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    function qa(a, b2, c2, d2) {
      if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2))
        return true;
      if (d2)
        return false;
      if (null !== c2)
        switch (c2.type) {
          case 3:
            return !b2;
          case 4:
            return false === b2;
          case 5:
            return isNaN(b2);
          case 6:
            return isNaN(b2) || 1 > b2;
        }
      return false;
    }
    function v$3(a, b2, c2, d2, e2, f2, g2) {
      this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
      this.attributeName = d2;
      this.attributeNamespace = e2;
      this.mustUseProperty = c2;
      this.propertyName = a;
      this.type = b2;
      this.sanitizeURL = f2;
      this.removeEmptyString = g2;
    }
    var z$2 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z$2[a] = new v$3(a, 0, false, a, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b2 = a[0];
      z$2[b2] = new v$3(b2, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z$2[a] = new v$3(a, 2, false, a.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z$2[a] = new v$3(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z$2[a] = new v$3(a, 3, false, a.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z$2[a] = new v$3(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function(a) {
      z$2[a] = new v$3(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z$2[a] = new v$3(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z$2[a] = new v$3(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa$1(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b2 = a.replace(
        ra,
        sa$1
      );
      z$2[b2] = new v$3(b2, 1, false, a, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b2 = a.replace(ra, sa$1);
      z$2[b2] = new v$3(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b2 = a.replace(ra, sa$1);
      z$2[b2] = new v$3(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z$2[a] = new v$3(a, 1, false, a.toLowerCase(), null, false, false);
    });
    z$2.xlinkHref = new v$3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z$2[a] = new v$3(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function ta(a, b2, c2, d2) {
      var e2 = z$2.hasOwnProperty(b2) ? z$2[b2] : null;
      if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
        qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa$1(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va$1 = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya$1 = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca$2 = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea$2 = Symbol.for("react.suspense"), Fa$1 = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha$1 = Symbol.for("react.lazy");
    var Ia$1 = Symbol.for("react.offscreen");
    var Ja = Symbol.iterator;
    function Ka(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = Ja && a[Ja] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var A$3 = Object.assign, La$1;
    function Ma(a) {
      if (void 0 === La$1)
        try {
          throw Error();
        } catch (c2) {
          var b2 = c2.stack.trim().match(/\n( *(at )?)/);
          La$1 = b2 && b2[1] || "";
        }
      return "\n" + La$1 + a;
    }
    var Na$1 = false;
    function Oa$1(a, b2) {
      if (!a || Na$1)
        return "";
      Na$1 = true;
      var c2 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b2)
          if (b2 = function() {
            throw Error();
          }, Object.defineProperty(b2.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b2, []);
            } catch (l2) {
              var d2 = l2;
            }
            Reflect.construct(a, [], b2);
          } else {
            try {
              b2.call();
            } catch (l2) {
              d2 = l2;
            }
            a.call(b2.prototype);
          }
        else {
          try {
            throw Error();
          } catch (l2) {
            d2 = l2;
          }
          a();
        }
      } catch (l2) {
        if (l2 && d2 && "string" === typeof l2.stack) {
          for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
            h2--;
          for (; 1 <= g2 && 0 <= h2; g2--, h2--)
            if (e2[g2] !== f2[h2]) {
              if (1 !== g2 || 1 !== h2) {
                do
                  if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                    var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                    a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                    return k2;
                  }
                while (1 <= g2 && 0 <= h2);
              }
              break;
            }
        }
      } finally {
        Na$1 = false, Error.prepareStackTrace = c2;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    function Pa$1(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa$1(a.type, false), a;
        case 11:
          return a = Oa$1(a.type.render, false), a;
        case 1:
          return a = Oa$1(a.type, true), a;
        default:
          return "";
      }
    }
    function Qa(a) {
      if (null == a)
        return null;
      if ("function" === typeof a)
        return a.displayName || a.name || null;
      if ("string" === typeof a)
        return a;
      switch (a) {
        case ya$1:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea$2:
          return "Suspense";
        case Fa$1:
          return "SuspenseList";
      }
      if ("object" === typeof a)
        switch (a.$$typeof) {
          case Ca$2:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b2 = a.render;
            a = a.displayName;
            a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga:
            return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
          case Ha$1:
            b2 = a._payload;
            a = a._init;
            try {
              return Qa(a(b2));
            } catch (c2) {
            }
        }
      return null;
    }
    function Ra$1(a) {
      var b2 = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b2.displayName || "Context") + ".Consumer";
        case 10:
          return (b2._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b2;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b2);
        case 8:
          return b2 === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b2)
            return b2.displayName || b2.name || null;
          if ("string" === typeof b2)
            return b2;
      }
      return null;
    }
    function Sa$1(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    function Ta$1(a) {
      var b2 = a.type;
      return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
    }
    function Ua$1(a) {
      var b2 = Ta$1(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
      if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
        var e2 = c2.get, f2 = c2.set;
        Object.defineProperty(a, b2, { configurable: true, get: function() {
          return e2.call(this);
        }, set: function(a2) {
          d2 = "" + a2;
          f2.call(this, a2);
        } });
        Object.defineProperty(a, b2, { enumerable: c2.enumerable });
        return { getValue: function() {
          return d2;
        }, setValue: function(a2) {
          d2 = "" + a2;
        }, stopTracking: function() {
          a._valueTracker = null;
          delete a[b2];
        } };
      }
    }
    function Va$1(a) {
      a._valueTracker || (a._valueTracker = Ua$1(a));
    }
    function Wa(a) {
      if (!a)
        return false;
      var b2 = a._valueTracker;
      if (!b2)
        return true;
      var c2 = b2.getValue();
      var d2 = "";
      a && (d2 = Ta$1(a) ? a.checked ? "true" : "false" : a.value);
      a = d2;
      return a !== c2 ? (b2.setValue(a), true) : false;
    }
    function Xa(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a)
        return null;
      try {
        return a.activeElement || a.body;
      } catch (b2) {
        return a.body;
      }
    }
    function Ya(a, b2) {
      var c2 = b2.checked;
      return A$3({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
    }
    function Za(a, b2) {
      var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
      c2 = Sa$1(null != b2.value ? b2.value : c2);
      a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
    }
    function ab(a, b2) {
      b2 = b2.checked;
      null != b2 && ta(a, "checked", b2, false);
    }
    function bb(a, b2) {
      ab(a, b2);
      var c2 = Sa$1(b2.value), d2 = b2.type;
      if (null != c2)
        if ("number" === d2) {
          if (0 === c2 && "" === a.value || a.value != c2)
            a.value = "" + c2;
        } else
          a.value !== "" + c2 && (a.value = "" + c2);
      else if ("submit" === d2 || "reset" === d2) {
        a.removeAttribute("value");
        return;
      }
      b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa$1(b2.defaultValue));
      null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
    }
    function db(a, b2, c2) {
      if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
        var d2 = b2.type;
        if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
          return;
        b2 = "" + a._wrapperState.initialValue;
        c2 || b2 === a.value || (a.value = b2);
        a.defaultValue = b2;
      }
      c2 = a.name;
      "" !== c2 && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c2 && (a.name = c2);
    }
    function cb(a, b2, c2) {
      if ("number" !== b2 || Xa(a.ownerDocument) !== a)
        null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
    }
    var eb = Array.isArray;
    function fb(a, b2, c2, d2) {
      a = a.options;
      if (b2) {
        b2 = {};
        for (var e2 = 0; e2 < c2.length; e2++)
          b2["$" + c2[e2]] = true;
        for (c2 = 0; c2 < a.length; c2++)
          e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
      } else {
        c2 = "" + Sa$1(c2);
        b2 = null;
        for (e2 = 0; e2 < a.length; e2++) {
          if (a[e2].value === c2) {
            a[e2].selected = true;
            d2 && (a[e2].defaultSelected = true);
            return;
          }
          null !== b2 || a[e2].disabled || (b2 = a[e2]);
        }
        null !== b2 && (b2.selected = true);
      }
    }
    function gb(a, b2) {
      if (null != b2.dangerouslySetInnerHTML)
        throw Error(p$5(91));
      return A$3({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    function hb(a, b2) {
      var c2 = b2.value;
      if (null == c2) {
        c2 = b2.children;
        b2 = b2.defaultValue;
        if (null != c2) {
          if (null != b2)
            throw Error(p$5(92));
          if (eb(c2)) {
            if (1 < c2.length)
              throw Error(p$5(93));
            c2 = c2[0];
          }
          b2 = c2;
        }
        null == b2 && (b2 = "");
        c2 = b2;
      }
      a._wrapperState = { initialValue: Sa$1(c2) };
    }
    function ib(a, b2) {
      var c2 = Sa$1(b2.value), d2 = Sa$1(b2.defaultValue);
      null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
      null != d2 && (a.defaultValue = "" + d2);
    }
    function jb(a) {
      var b2 = a.textContent;
      b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
    }
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a, b2) {
      return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
    }
    var mb, nb = function(a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b2, c2, d2, e2);
        });
      } : a;
    }(function(a, b2) {
      if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
        a.innerHTML = b2;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
        for (b2 = mb.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; b2.firstChild; )
          a.appendChild(b2.firstChild);
      }
    });
    function ob(a, b2) {
      if (b2) {
        var c2 = a.firstChild;
        if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
          c2.nodeValue = b2;
          return;
        }
      }
      a.textContent = b2;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a) {
      qb.forEach(function(b2) {
        b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
        pb[b2] = pb[a];
      });
    });
    function rb(a, b2, c2) {
      return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
    }
    function sb(a, b2) {
      a = a.style;
      for (var c2 in b2)
        if (b2.hasOwnProperty(c2)) {
          var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
          "float" === c2 && (c2 = "cssFloat");
          d2 ? a.setProperty(c2, e2) : a[c2] = e2;
        }
    }
    var tb = A$3({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a, b2) {
      if (b2) {
        if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
          throw Error(p$5(137, a));
        if (null != b2.dangerouslySetInnerHTML) {
          if (null != b2.children)
            throw Error(p$5(60));
          if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
            throw Error(p$5(61));
        }
        if (null != b2.style && "object" !== typeof b2.style)
          throw Error(p$5(62));
      }
    }
    function vb(a, b2) {
      if (-1 === a.indexOf("-"))
        return "string" === typeof b2.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if ("function" !== typeof yb)
          throw Error(p$5(280));
        var b2 = a.stateNode;
        b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
      }
    }
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    function Fb() {
      if (zb) {
        var a = zb, b2 = Ab;
        Ab = zb = null;
        Bb(a);
        if (b2)
          for (a = 0; a < b2.length; a++)
            Bb(b2[a]);
      }
    }
    function Gb(a, b2) {
      return a(b2);
    }
    function Hb() {
    }
    var Ib = false;
    function Jb(a, b2, c2) {
      if (Ib)
        return a(b2, c2);
      Ib = true;
      try {
        return Gb(a, b2, c2);
      } finally {
        if (Ib = false, null !== zb || null !== Ab)
          Hb(), Fb();
      }
    }
    function Kb(a, b2) {
      var c2 = a.stateNode;
      if (null === c2)
        return null;
      var d2 = Db(c2);
      if (null === d2)
        return null;
      c2 = d2[b2];
      a:
        switch (b2) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d2;
            break a;
          default:
            a = false;
        }
      if (a)
        return null;
      if (c2 && "function" !== typeof c2)
        throw Error(p$5(231, b2, typeof c2));
      return c2;
    }
    var Lb = false;
    if (ia$1)
      try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
    function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      var l2 = Array.prototype.slice.call(arguments, 3);
      try {
        b2.apply(c2, l2);
      } catch (m2) {
        this.onError(m2);
      }
    }
    var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
      Ob = true;
      Pb = a;
    } };
    function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l2 = Pb;
          Ob = false;
          Pb = null;
        } else
          throw Error(p$5(198));
        Qb || (Qb = true, Rb = l2);
      }
    }
    function Vb(a) {
      var b2 = a, c2 = a;
      if (a.alternate)
        for (; b2.return; )
          b2 = b2.return;
      else {
        a = b2;
        do
          b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
        while (a);
      }
      return 3 === b2.tag ? c2 : null;
    }
    function Wb(a) {
      if (13 === a.tag) {
        var b2 = a.memoizedState;
        null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
        if (null !== b2)
          return b2.dehydrated;
      }
      return null;
    }
    function Xb(a) {
      if (Vb(a) !== a)
        throw Error(p$5(188));
    }
    function Yb(a) {
      var b2 = a.alternate;
      if (!b2) {
        b2 = Vb(a);
        if (null === b2)
          throw Error(p$5(188));
        return b2 !== a ? null : a;
      }
      for (var c2 = a, d2 = b2; ; ) {
        var e2 = c2.return;
        if (null === e2)
          break;
        var f2 = e2.alternate;
        if (null === f2) {
          d2 = e2.return;
          if (null !== d2) {
            c2 = d2;
            continue;
          }
          break;
        }
        if (e2.child === f2.child) {
          for (f2 = e2.child; f2; ) {
            if (f2 === c2)
              return Xb(e2), a;
            if (f2 === d2)
              return Xb(e2), b2;
            f2 = f2.sibling;
          }
          throw Error(p$5(188));
        }
        if (c2.return !== d2.return)
          c2 = e2, d2 = f2;
        else {
          for (var g2 = false, h2 = e2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = e2;
              d2 = f2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = e2;
              c2 = f2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) {
            for (h2 = f2.child; h2; ) {
              if (h2 === c2) {
                g2 = true;
                c2 = f2;
                d2 = e2;
                break;
              }
              if (h2 === d2) {
                g2 = true;
                d2 = f2;
                c2 = e2;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g2)
              throw Error(p$5(189));
          }
        }
        if (c2.alternate !== d2)
          throw Error(p$5(190));
      }
      if (3 !== c2.tag)
        throw Error(p$5(188));
      return c2.stateNode.current === c2 ? a : b2;
    }
    function Zb(a) {
      a = Yb(a);
      return null !== a ? $b(a) : null;
    }
    function $b(a) {
      if (5 === a.tag || 6 === a.tag)
        return a;
      for (a = a.child; null !== a; ) {
        var b2 = $b(a);
        if (null !== b2)
          return b2;
        a = a.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$2 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a) {
      if (lc && "function" === typeof lc.onCommitFiberRoot)
        try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b2) {
        }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a) {
      a >>>= 0;
      return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    function uc(a, b2) {
      var c2 = a.pendingLanes;
      if (0 === c2)
        return 0;
      var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
      if (0 !== g2) {
        var h2 = g2 & ~e2;
        0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
      } else
        g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
      if (0 === d2)
        return 0;
      if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
        return b2;
      0 !== (d2 & 4) && (d2 |= c2 & 16);
      b2 = a.entangledLanes;
      if (0 !== b2)
        for (a = a.entanglements, b2 &= d2; 0 < b2; )
          c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
      return d2;
    }
    function vc(a, b2) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b2 + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b2 + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a, b2) {
      for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
        var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
        if (-1 === k2) {
          if (0 === (h2 & c2) || 0 !== (h2 & d2))
            e2[g2] = vc(h2, b2);
        } else
          k2 <= b2 && (a.expiredLanes |= h2);
        f2 &= ~h2;
      }
    }
    function xc(a) {
      a = a.pendingLanes & -1073741825;
      return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a;
    }
    function zc(a) {
      for (var b2 = [], c2 = 0; 31 > c2; c2++)
        b2.push(a);
      return b2;
    }
    function Ac(a, b2, c2) {
      a.pendingLanes |= b2;
      536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
      a = a.eventTimes;
      b2 = 31 - oc(b2);
      a[b2] = c2;
    }
    function Bc(a, b2) {
      var c2 = a.pendingLanes & ~b2;
      a.pendingLanes = b2;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= b2;
      a.mutableReadLanes &= b2;
      a.entangledLanes &= b2;
      b2 = a.entanglements;
      var d2 = a.eventTimes;
      for (a = a.expirationTimes; 0 < c2; ) {
        var e2 = 31 - oc(c2), f2 = 1 << e2;
        b2[e2] = 0;
        d2[e2] = -1;
        a[e2] = -1;
        c2 &= ~f2;
      }
    }
    function Cc(a, b2) {
      var c2 = a.entangledLanes |= b2;
      for (a = a.entanglements; c2; ) {
        var d2 = 31 - oc(c2), e2 = 1 << d2;
        e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
        c2 &= ~e2;
      }
    }
    var C$1 = 0;
    function Dc(a) {
      a &= -a;
      return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a, b2) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b2.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b2.pointerId);
      }
    }
    function Tc(a, b2, c2, d2, e2, f2) {
      if (null === a || a.nativeEvent !== f2)
        return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
      a.eventSystemFlags |= d2;
      b2 = a.targetContainers;
      null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
      return a;
    }
    function Uc(a, b2, c2, d2, e2) {
      switch (b2) {
        case "focusin":
          return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
        case "dragenter":
          return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
        case "mouseover":
          return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
        case "pointerover":
          var f2 = e2.pointerId;
          Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
          return true;
        case "gotpointercapture":
          return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
      }
      return false;
    }
    function Vc(a) {
      var b2 = Wc(a.target);
      if (null !== b2) {
        var c2 = Vb(b2);
        if (null !== c2) {
          if (b2 = c2.tag, 13 === b2) {
            if (b2 = Wb(c2), null !== b2) {
              a.blockedOn = b2;
              Ic(a.priority, function() {
                Gc(c2);
              });
              return;
            }
          } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Xc(a) {
      if (null !== a.blockedOn)
        return false;
      for (var b2 = a.targetContainers; 0 < b2.length; ) {
        var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
        if (null === c2) {
          c2 = a.nativeEvent;
          var d2 = new c2.constructor(c2.type, c2);
          wb = d2;
          c2.target.dispatchEvent(d2);
          wb = null;
        } else
          return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
        b2.shift();
      }
      return true;
    }
    function Zc(a, b2, c2) {
      Xc(a) && c2.delete(b2);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a, b2) {
      a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a) {
      function b2(b3) {
        return ad(b3, a);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c2 = 1; c2 < Kc.length; c2++) {
          var d2 = Kc[c2];
          d2.blockedOn === a && (d2.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a);
      null !== Mc && ad(Mc, a);
      null !== Nc && ad(Nc, a);
      Oc.forEach(b2);
      Pc.forEach(b2);
      for (c2 = 0; c2 < Qc.length; c2++)
        d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
      for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
        Vc(c2), null === c2.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = true;
    function ed(a, b2, c2, d2) {
      var e2 = C$1, f2 = cd.transition;
      cd.transition = null;
      try {
        C$1 = 1, fd(a, b2, c2, d2);
      } finally {
        C$1 = e2, cd.transition = f2;
      }
    }
    function gd(a, b2, c2, d2) {
      var e2 = C$1, f2 = cd.transition;
      cd.transition = null;
      try {
        C$1 = 4, fd(a, b2, c2, d2);
      } finally {
        C$1 = e2, cd.transition = f2;
      }
    }
    function fd(a, b2, c2, d2) {
      if (dd) {
        var e2 = Yc(a, b2, c2, d2);
        if (null === e2)
          hd(a, b2, d2, id, c2), Sc(a, d2);
        else if (Uc(e2, a, b2, c2, d2))
          d2.stopPropagation();
        else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
          for (; null !== e2; ) {
            var f2 = Cb(e2);
            null !== f2 && Ec(f2);
            f2 = Yc(a, b2, c2, d2);
            null === f2 && hd(a, b2, d2, id, c2);
            if (f2 === e2)
              break;
            e2 = f2;
          }
          null !== e2 && d2.stopPropagation();
        } else
          hd(a, b2, d2, null, c2);
      }
    }
    var id = null;
    function Yc(a, b2, c2, d2) {
      id = null;
      a = xb(d2);
      a = Wc(a);
      if (null !== a)
        if (b2 = Vb(a), null === b2)
          a = null;
        else if (c2 = b2.tag, 13 === c2) {
          a = Wb(b2);
          if (null !== a)
            return a;
          a = null;
        } else if (3 === c2) {
          if (b2.stateNode.current.memoizedState.isDehydrated)
            return 3 === b2.tag ? b2.stateNode.containerInfo : null;
          a = null;
        } else
          b2 !== a && (a = null);
      id = a;
      return null;
    }
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md)
        return md;
      var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
      for (a = 0; a < c2 && b2[a] === e2[a]; a++)
        ;
      var g2 = c2 - a;
      for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
        ;
      return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
    }
    function od(a) {
      var b2 = a.keyCode;
      "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a) {
      function b2(b3, d2, e2, f2, g2) {
        this._reactName = b3;
        this._targetInst = e2;
        this.type = d2;
        this.nativeEvent = f2;
        this.target = g2;
        this.currentTarget = null;
        for (var c2 in a)
          a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
        this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A$3(b2.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b2;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$3({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$3({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, movementX: function(a) {
      if ("movementX" in a)
        return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    }, movementY: function(a) {
      return "movementY" in a ? a.movementY : xd;
    } }), Bd = rd(Ad), Cd = A$3({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$3({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$3({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$3({}, sd, { clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = A$3({}, sd, { data: 0 }), Ld = rd(Kd), Md$1 = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a) {
      var b2 = this.nativeEvent;
      return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A$3({}, ud, { key: function(a) {
      if (a.key) {
        var b2 = Md$1[a.key] || a.key;
        if ("Unidentified" !== b2)
          return b2;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
      return "keypress" === a.type ? od(a) : 0;
    }, keyCode: function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, which: function(a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A$3({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td$1 = rd(Sd), Ud = A$3({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$3({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$3({}, Ad, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia$1 && "CompositionEvent" in window, be$2 = null;
    ia$1 && "documentMode" in document && (be$2 = document.documentMode);
    var ce = ia$1 && "TextEvent" in window && !be$2, de$2 = ia$1 && (!ae$1 || be$2 && 8 < be$2 && 11 >= be$2), ee$2 = String.fromCharCode(32), fe = false;
    function ge$1(a, b2) {
      switch (a) {
        case "keyup":
          return -1 !== $d.indexOf(b2.keyCode);
        case "keydown":
          return 229 !== b2.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    var ie$2 = false;
    function je$2(a, b2) {
      switch (a) {
        case "compositionend":
          return he(b2);
        case "keypress":
          if (32 !== b2.which)
            return null;
          fe = true;
          return ee$2;
        case "textInput":
          return a = b2.data, a === ee$2 && fe ? null : a;
        default:
          return null;
      }
    }
    function ke$2(a, b2) {
      if (ie$2)
        return "compositionend" === a || !ae$1 && ge$1(a, b2) ? (a = nd(), md = ld = kd = null, ie$2 = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
            if (b2.char && 1 < b2.char.length)
              return b2.char;
            if (b2.which)
              return String.fromCharCode(b2.which);
          }
          return null;
        case "compositionend":
          return de$2 && "ko" !== b2.locale ? null : b2.data;
        default:
          return null;
      }
    }
    var le$2 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a) {
      var b2 = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b2 ? !!le$2[a.type] : "textarea" === b2 ? true : false;
    }
    function ne$2(a, b2, c2, d2) {
      Eb(d2);
      b2 = oe$1(b2, "onChange");
      0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
    }
    var pe = null, qe$2 = null;
    function re(a) {
      se(a, 0);
    }
    function te$1(a) {
      var b2 = ue$1(a);
      if (Wa(b2))
        return a;
    }
    function ve(a, b2) {
      if ("change" === a)
        return b2;
    }
    var we$1 = false;
    if (ia$1) {
      var xe$1;
      if (ia$1) {
        var ye$1 = "oninput" in document;
        if (!ye$1) {
          var ze$2 = document.createElement("div");
          ze$2.setAttribute("oninput", "return;");
          ye$1 = "function" === typeof ze$2.oninput;
        }
        xe$1 = ye$1;
      } else
        xe$1 = false;
      we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae$1() {
      pe && (pe.detachEvent("onpropertychange", Be), qe$2 = pe = null);
    }
    function Be(a) {
      if ("value" === a.propertyName && te$1(qe$2)) {
        var b2 = [];
        ne$2(b2, qe$2, a, xb(a));
        Jb(re, b2);
      }
    }
    function Ce$1(a, b2, c2) {
      "focusin" === a ? (Ae$1(), pe = b2, qe$2 = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae$1();
    }
    function De(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a)
        return te$1(qe$2);
    }
    function Ee(a, b2) {
      if ("click" === a)
        return te$1(b2);
    }
    function Fe$1(a, b2) {
      if ("input" === a || "change" === a)
        return te$1(b2);
    }
    function Ge$1(a, b2) {
      return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
    }
    var He = "function" === typeof Object.is ? Object.is : Ge$1;
    function Ie$2(a, b2) {
      if (He(a, b2))
        return true;
      if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
        return false;
      var c2 = Object.keys(a), d2 = Object.keys(b2);
      if (c2.length !== d2.length)
        return false;
      for (d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2];
        if (!ja$1.call(b2, e2) || !He(a[e2], b2[e2]))
          return false;
      }
      return true;
    }
    function Je(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function Ke$1(a, b2) {
      var c2 = Je(a);
      a = 0;
      for (var d2; c2; ) {
        if (3 === c2.nodeType) {
          d2 = a + c2.textContent.length;
          if (a <= b2 && d2 >= b2)
            return { node: c2, offset: b2 - a };
          a = d2;
        }
        a: {
          for (; c2; ) {
            if (c2.nextSibling) {
              c2 = c2.nextSibling;
              break a;
            }
            c2 = c2.parentNode;
          }
          c2 = void 0;
        }
        c2 = Je(c2);
      }
    }
    function Le$1(a, b2) {
      return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le$1(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
    }
    function Me() {
      for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
        try {
          var c2 = "string" === typeof b2.contentWindow.location.href;
        } catch (d2) {
          c2 = false;
        }
        if (c2)
          a = b2.contentWindow;
        else
          break;
        b2 = Xa(a.document);
      }
      return b2;
    }
    function Ne$1(a) {
      var b2 = a && a.nodeName && a.nodeName.toLowerCase();
      return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
    }
    function Oe$1(a) {
      var b2 = Me(), c2 = a.focusedElem, d2 = a.selectionRange;
      if (b2 !== c2 && c2 && c2.ownerDocument && Le$1(c2.ownerDocument.documentElement, c2)) {
        if (null !== d2 && Ne$1(c2)) {
          if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2)
            c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
          else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
            d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
            !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
            e2 = Ke$1(c2, f2);
            var g2 = Ke$1(
              c2,
              d2
            );
            e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
          }
        }
        b2 = [];
        for (a = c2; a = a.parentNode; )
          1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        "function" === typeof c2.focus && c2.focus();
        for (c2 = 0; c2 < b2.length; c2++)
          a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    var Pe$2 = ia$1 && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re$1 = null, Se$1 = null, Te = false;
    function Ue$2(a, b2, c2) {
      var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
      Te || null == Qe$1 || Qe$1 !== Xa(d2) || (d2 = Qe$1, "selectionStart" in d2 && Ne$1(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Ie$2(Se$1, d2) || (Se$1 = d2, d2 = oe$1(Re$1, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe$1)));
    }
    function Ve$1(a, b2) {
      var c2 = {};
      c2[a.toLowerCase()] = b2.toLowerCase();
      c2["Webkit" + a] = "webkit" + b2;
      c2["Moz" + a] = "moz" + b2;
      return c2;
    }
    var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe = {}, Ye$1 = {};
    ia$1 && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
    function Ze$1(a) {
      if (Xe[a])
        return Xe[a];
      if (!We$1[a])
        return a;
      var b2 = We$1[a], c2;
      for (c2 in b2)
        if (b2.hasOwnProperty(c2) && c2 in Ye$1)
          return Xe[a] = b2[c2];
      return a;
    }
    var $e$1 = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a, b2) {
      df.set(a, b2);
      fa(b2, [a]);
    }
    for (var gf = 0; gf < ef.length; gf++) {
      var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    ff($e$1, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a, b2, c2) {
      var d2 = a.type || "unknown-event";
      a.currentTarget = c2;
      Ub(d2, b2, void 0, a);
      a.currentTarget = null;
    }
    function se(a, b2) {
      b2 = 0 !== (b2 & 4);
      for (var c2 = 0; c2 < a.length; c2++) {
        var d2 = a[c2], e2 = d2.event;
        d2 = d2.listeners;
        a: {
          var f2 = void 0;
          if (b2)
            for (var g2 = d2.length - 1; 0 <= g2; g2--) {
              var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
          else
            for (g2 = 0; g2 < d2.length; g2++) {
              h2 = d2[g2];
              k2 = h2.instance;
              l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
        }
      }
      if (Qb)
        throw a = Rb, Qb = false, Rb = null, a;
    }
    function D$1(a, b2) {
      var c2 = b2[of];
      void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
      var d2 = a + "__bubble";
      c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
    }
    function qf(a, b2, c2) {
      var d2 = 0;
      b2 && (d2 |= 4);
      pf(c2, a, d2, b2);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = true;
        da$1.forEach(function(b3) {
          "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
        });
        var b2 = 9 === a.nodeType ? a : a.ownerDocument;
        null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
      }
    }
    function pf(a, b2, c2, d2) {
      switch (jd(b2)) {
        case 1:
          var e2 = ed;
          break;
        case 4:
          e2 = gd;
          break;
        default:
          e2 = fd;
      }
      c2 = e2.bind(null, b2, c2, a);
      e2 = void 0;
      !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
      d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
    }
    function hd(a, b2, c2, d2, e2) {
      var f2 = d2;
      if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
        a:
          for (; ; ) {
            if (null === d2)
              return;
            var g2 = d2.tag;
            if (3 === g2 || 4 === g2) {
              var h2 = d2.stateNode.containerInfo;
              if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
                break;
              if (4 === g2)
                for (g2 = d2.return; null !== g2; ) {
                  var k2 = g2.tag;
                  if (3 === k2 || 4 === k2) {
                    if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                      return;
                  }
                  g2 = g2.return;
                }
              for (; null !== h2; ) {
                g2 = Wc(h2);
                if (null === g2)
                  return;
                k2 = g2.tag;
                if (5 === k2 || 6 === k2) {
                  d2 = f2 = g2;
                  continue a;
                }
                h2 = h2.parentNode;
              }
            }
            d2 = d2.return;
          }
      Jb(function() {
        var d3 = f2, e3 = xb(c2), g3 = [];
        a: {
          var h3 = df.get(a);
          if (void 0 !== h3) {
            var k3 = td, n2 = a;
            switch (a) {
              case "keypress":
                if (0 === od(c2))
                  break a;
              case "keydown":
              case "keyup":
                k3 = Rd;
                break;
              case "focusin":
                n2 = "focus";
                k3 = Fd;
                break;
              case "focusout":
                n2 = "blur";
                k3 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k3 = Fd;
                break;
              case "click":
                if (2 === c2.button)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k3 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k3 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k3 = Vd;
                break;
              case $e$1:
              case af:
              case bf:
                k3 = Hd;
                break;
              case cf:
                k3 = Xd;
                break;
              case "scroll":
                k3 = vd;
                break;
              case "wheel":
                k3 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k3 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k3 = Td$1;
            }
            var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
            t2 = [];
            for (var w2 = d3, u2; null !== w2; ) {
              u2 = w2;
              var F2 = u2.stateNode;
              5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
              if (J2)
                break;
              w2 = w2.return;
            }
            0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
          }
        }
        if (0 === (b2 & 7)) {
          a: {
            h3 = "mouseover" === a || "pointerover" === a;
            k3 = "mouseout" === a || "pointerout" === a;
            if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf$1]))
              break a;
            if (k3 || h3) {
              h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
              if (k3) {
                if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
                  n2 = null;
              } else
                k3 = null, n2 = d3;
              if (k3 !== n2) {
                t2 = Bd;
                F2 = "onMouseLeave";
                x2 = "onMouseEnter";
                w2 = "mouse";
                if ("pointerout" === a || "pointerover" === a)
                  t2 = Td$1, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
                J2 = null == k3 ? h3 : ue$1(k3);
                u2 = null == n2 ? h3 : ue$1(n2);
                h3 = new t2(F2, w2 + "leave", k3, c2, e3);
                h3.target = J2;
                h3.relatedTarget = u2;
                F2 = null;
                Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
                J2 = F2;
                if (k3 && n2)
                  b: {
                    t2 = k3;
                    x2 = n2;
                    w2 = 0;
                    for (u2 = t2; u2; u2 = vf(u2))
                      w2++;
                    u2 = 0;
                    for (F2 = x2; F2; F2 = vf(F2))
                      u2++;
                    for (; 0 < w2 - u2; )
                      t2 = vf(t2), w2--;
                    for (; 0 < u2 - w2; )
                      x2 = vf(x2), u2--;
                    for (; w2--; ) {
                      if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                        break b;
                      t2 = vf(t2);
                      x2 = vf(x2);
                    }
                    t2 = null;
                  }
                else
                  t2 = null;
                null !== k3 && wf(g3, h3, k3, t2, false);
                null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
              }
            }
          }
          a: {
            h3 = d3 ? ue$1(d3) : window;
            k3 = h3.nodeName && h3.nodeName.toLowerCase();
            if ("select" === k3 || "input" === k3 && "file" === h3.type)
              var na = ve;
            else if (me(h3))
              if (we$1)
                na = Fe$1;
              else {
                na = De;
                var xa = Ce$1;
              }
            else
              (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
            if (na && (na = na(a, d3))) {
              ne$2(g3, na, c2, e3);
              break a;
            }
            xa && xa(a, h3, d3);
            "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
          }
          xa = d3 ? ue$1(d3) : window;
          switch (a) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable)
                Qe$1 = xa, Re$1 = d3, Se$1 = null;
              break;
            case "focusout":
              Se$1 = Re$1 = Qe$1 = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue$2(g3, c2, e3);
              break;
            case "selectionchange":
              if (Pe$2)
                break;
            case "keydown":
            case "keyup":
              Ue$2(g3, c2, e3);
          }
          var $a;
          if (ae$1)
            b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
          else
            ie$2 ? ge$1(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
          ba && (de$2 && "ko" !== c2.locale && (ie$2 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$2 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$2 = true)), xa = oe$1(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
          if ($a = ce ? je$2(a, c2) : ke$2(a, c2))
            d3 = oe$1(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
        }
        se(g3, b2);
      });
    }
    function tf(a, b2, c2) {
      return { instance: a, listener: b2, currentTarget: c2 };
    }
    function oe$1(a, b2) {
      for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
        var e2 = a, f2 = e2.stateNode;
        5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
        a = a.return;
      }
      return d2;
    }
    function vf(a) {
      if (null === a)
        return null;
      do
        a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    function wf(a, b2, c2, d2, e2) {
      for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
        var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
        if (null !== k2 && k2 === d2)
          break;
        5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
        c2 = c2.return;
      }
      0 !== g2.length && a.push({ event: b2, listeners: g2 });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
    }
    function Af(a, b2, c2) {
      b2 = zf(b2);
      if (zf(a) !== b2 && c2)
        throw Error(p$5(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a, b2) {
      return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
      return Hf.resolve(null).then(a).catch(If);
    } : Ff;
    function If(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function Kf(a, b2) {
      var c2 = b2, d2 = 0;
      do {
        var e2 = c2.nextSibling;
        a.removeChild(c2);
        if (e2 && 8 === e2.nodeType)
          if (c2 = e2.data, "/$" === c2) {
            if (0 === d2) {
              a.removeChild(e2);
              bd(b2);
              return;
            }
            d2--;
          } else
            "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
        c2 = e2;
      } while (c2);
      bd(b2);
    }
    function Lf(a) {
      for (; null != a; a = a.nextSibling) {
        var b2 = a.nodeType;
        if (1 === b2 || 3 === b2)
          break;
        if (8 === b2) {
          b2 = a.data;
          if ("$" === b2 || "$!" === b2 || "$?" === b2)
            break;
          if ("/$" === b2)
            return null;
        }
      }
      return a;
    }
    function Mf(a) {
      a = a.previousSibling;
      for (var b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c2 = a.data;
          if ("$" === c2 || "$!" === c2 || "$?" === c2) {
            if (0 === b2)
              return a;
            b2--;
          } else
            "/$" === c2 && b2++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf$1 = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b2 = a[Of];
      if (b2)
        return b2;
      for (var c2 = a.parentNode; c2; ) {
        if (b2 = c2[uf$1] || c2[Of]) {
          c2 = b2.alternate;
          if (null !== b2.child || null !== c2 && null !== c2.child)
            for (a = Mf(a); null !== a; ) {
              if (c2 = a[Of])
                return c2;
              a = Mf(a);
            }
          return b2;
        }
        a = c2;
        c2 = a.parentNode;
      }
      return null;
    }
    function Cb(a) {
      a = a[Of] || a[uf$1];
      return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
    }
    function ue$1(a) {
      if (5 === a.tag || 6 === a.tag)
        return a.stateNode;
      throw Error(p$5(33));
    }
    function Db(a) {
      return a[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    function E$3(a) {
      0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G$1(a, b2) {
      Tf++;
      Sf[Tf] = a.current;
      a.current = b2;
    }
    var Vf = {}, H$3 = Uf(Vf), Wf = Uf(false), Xf = Vf;
    function Yf(a, b2) {
      var c2 = a.type.contextTypes;
      if (!c2)
        return Vf;
      var d2 = a.stateNode;
      if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
        return d2.__reactInternalMemoizedMaskedChildContext;
      var e2 = {}, f2;
      for (f2 in c2)
        e2[f2] = b2[f2];
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
      return e2;
    }
    function Zf(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    function $f() {
      E$3(Wf);
      E$3(H$3);
    }
    function ag(a, b2, c2) {
      if (H$3.current !== Vf)
        throw Error(p$5(168));
      G$1(H$3, b2);
      G$1(Wf, c2);
    }
    function bg(a, b2, c2) {
      var d2 = a.stateNode;
      b2 = b2.childContextTypes;
      if ("function" !== typeof d2.getChildContext)
        return c2;
      d2 = d2.getChildContext();
      for (var e2 in d2)
        if (!(e2 in b2))
          throw Error(p$5(108, Ra$1(a) || "Unknown", e2));
      return A$3({}, c2, d2);
    }
    function cg(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H$3.current;
      G$1(H$3, a);
      G$1(Wf, Wf.current);
      return true;
    }
    function dg(a, b2, c2) {
      var d2 = a.stateNode;
      if (!d2)
        throw Error(p$5(169));
      c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E$3(Wf), E$3(H$3), G$1(H$3, a)) : E$3(Wf);
      G$1(Wf, c2);
    }
    var eg = null, fg = false, gg = false;
    function hg(a) {
      null === eg ? eg = [a] : eg.push(a);
    }
    function ig(a) {
      fg = true;
      hg(a);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a = 0, b2 = C$1;
        try {
          var c2 = eg;
          for (C$1 = 1; a < c2.length; a++) {
            var d2 = c2[a];
            do
              d2 = d2(true);
            while (null !== d2);
          }
          eg = null;
          fg = false;
        } catch (e2) {
          throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
        } finally {
          C$1 = b2, gg = false;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a, b2) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a;
      ng = b2;
    }
    function ug(a, b2, c2) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a;
      var d2 = rg;
      a = sg;
      var e2 = 32 - oc(d2) - 1;
      d2 &= ~(1 << e2);
      c2 += 1;
      var f2 = 32 - oc(b2) + e2;
      if (30 < f2) {
        var g2 = e2 - e2 % 5;
        f2 = (d2 & (1 << g2) - 1).toString(32);
        d2 >>= g2;
        e2 -= g2;
        rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
        sg = f2 + a;
      } else
        rg = 1 << f2 | c2 << e2 | d2, sg = a;
    }
    function vg(a) {
      null !== a.return && (tg(a, 1), ug(a, 1, 0));
    }
    function wg(a) {
      for (; a === mg; )
        mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a === qg; )
        qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I$1 = false, zg = null;
    function Ag(a, b2) {
      var c2 = Bg(5, null, null, 0);
      c2.elementType = "DELETED";
      c2.stateNode = b2;
      c2.return = a;
      b2 = a.deletions;
      null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
    }
    function Cg(a, b2) {
      switch (a.tag) {
        case 5:
          var c2 = a.type;
          b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
          return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
        case 6:
          return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
        case 13:
          return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
        default:
          return false;
      }
    }
    function Dg(a) {
      return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
    }
    function Eg(a) {
      if (I$1) {
        var b2 = yg;
        if (b2) {
          var c2 = b2;
          if (!Cg(a, b2)) {
            if (Dg(a))
              throw Error(p$5(418));
            b2 = Lf(c2.nextSibling);
            var d2 = xg;
            b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I$1 = false, xg = a);
          }
        } else {
          if (Dg(a))
            throw Error(p$5(418));
          a.flags = a.flags & -4097 | 2;
          I$1 = false;
          xg = a;
        }
      }
    }
    function Fg(a) {
      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
        a = a.return;
      xg = a;
    }
    function Gg(a) {
      if (a !== xg)
        return false;
      if (!I$1)
        return Fg(a), I$1 = true, false;
      var b2;
      (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
      if (b2 && (b2 = yg)) {
        if (Dg(a))
          throw Hg(), Error(p$5(418));
        for (; b2; )
          Ag(a, b2), b2 = Lf(b2.nextSibling);
      }
      Fg(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a)
          throw Error(p$5(317));
        a: {
          a = a.nextSibling;
          for (b2 = 0; a; ) {
            if (8 === a.nodeType) {
              var c2 = a.data;
              if ("/$" === c2) {
                if (0 === b2) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b2--;
              } else
                "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else
        yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a = yg; a; )
        a = Lf(a.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I$1 = false;
    }
    function Jg(a) {
      null === zg ? zg = [a] : zg.push(a);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b2) {
      if (a && a.defaultProps) {
        b2 = A$3({}, b2);
        a = a.defaultProps;
        for (var c2 in a)
          void 0 === b2[c2] && (b2[c2] = a[c2]);
        return b2;
      }
      return b2;
    }
    var Mg = Uf(null), Ng = null, Og = null, Pg = null;
    function Qg() {
      Pg = Og = Ng = null;
    }
    function Rg(a) {
      var b2 = Mg.current;
      E$3(Mg);
      a._currentValue = b2;
    }
    function Sg(a, b2, c2) {
      for (; null !== a; ) {
        var d2 = a.alternate;
        (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
        if (a === c2)
          break;
        a = a.return;
      }
    }
    function Tg(a, b2) {
      Ng = a;
      Pg = Og = null;
      a = a.dependencies;
      null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (Ug = true), a.firstContext = null);
    }
    function Vg(a) {
      var b2 = a._currentValue;
      if (Pg !== a)
        if (a = { context: a, memoizedValue: b2, next: null }, null === Og) {
          if (null === Ng)
            throw Error(p$5(308));
          Og = a;
          Ng.dependencies = { lanes: 0, firstContext: a };
        } else
          Og = Og.next = a;
      return b2;
    }
    var Wg = null;
    function Xg(a) {
      null === Wg ? Wg = [a] : Wg.push(a);
    }
    function Yg(a, b2, c2, d2) {
      var e2 = b2.interleaved;
      null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
      b2.interleaved = c2;
      return Zg(a, d2);
    }
    function Zg(a, b2) {
      a.lanes |= b2;
      var c2 = a.alternate;
      null !== c2 && (c2.lanes |= b2);
      c2 = a;
      for (a = a.return; null !== a; )
        a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
      return 3 === c2.tag ? c2.stateNode : null;
    }
    var $g = false;
    function ah(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function bh(a, b2) {
      a = a.updateQueue;
      b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    function ch(a, b2) {
      return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
    }
    function dh(a, b2, c2) {
      var d2 = a.updateQueue;
      if (null === d2)
        return null;
      d2 = d2.shared;
      if (0 !== (K & 2)) {
        var e2 = d2.pending;
        null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
        d2.pending = b2;
        return Zg(a, c2);
      }
      e2 = d2.interleaved;
      null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
      d2.interleaved = b2;
      return Zg(a, c2);
    }
    function eh(a, b2, c2) {
      b2 = b2.updateQueue;
      if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
        var d2 = b2.lanes;
        d2 &= a.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a, c2);
      }
    }
    function fh(a, b2) {
      var c2 = a.updateQueue, d2 = a.alternate;
      if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
        var e2 = null, f2 = null;
        c2 = c2.firstBaseUpdate;
        if (null !== c2) {
          do {
            var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
            null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
            c2 = c2.next;
          } while (null !== c2);
          null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
        } else
          e2 = f2 = b2;
        c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
        a.updateQueue = c2;
        return;
      }
      a = c2.lastBaseUpdate;
      null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
      c2.lastBaseUpdate = b2;
    }
    function gh(a, b2, c2, d2) {
      var e2 = a.updateQueue;
      $g = false;
      var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
      if (null !== h2) {
        e2.shared.pending = null;
        var k2 = h2, l2 = k2.next;
        k2.next = null;
        null === g2 ? f2 = l2 : g2.next = l2;
        g2 = k2;
        var m2 = a.alternate;
        null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
      }
      if (null !== f2) {
        var q2 = e2.baseState;
        g2 = 0;
        m2 = l2 = k2 = null;
        h2 = f2;
        do {
          var r2 = h2.lane, y2 = h2.eventTime;
          if ((d2 & r2) === r2) {
            null !== m2 && (m2 = m2.next = {
              eventTime: y2,
              lane: 0,
              tag: h2.tag,
              payload: h2.payload,
              callback: h2.callback,
              next: null
            });
            a: {
              var n2 = a, t2 = h2;
              r2 = b2;
              y2 = c2;
              switch (t2.tag) {
                case 1:
                  n2 = t2.payload;
                  if ("function" === typeof n2) {
                    q2 = n2.call(y2, q2, r2);
                    break a;
                  }
                  q2 = n2;
                  break a;
                case 3:
                  n2.flags = n2.flags & -65537 | 128;
                case 0:
                  n2 = t2.payload;
                  r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                  if (null === r2 || void 0 === r2)
                    break a;
                  q2 = A$3({}, q2, r2);
                  break a;
                case 2:
                  $g = true;
              }
            }
            null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
          } else
            y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
          h2 = h2.next;
          if (null === h2)
            if (h2 = e2.shared.pending, null === h2)
              break;
            else
              r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
        } while (1);
        null === m2 && (k2 = q2);
        e2.baseState = k2;
        e2.firstBaseUpdate = l2;
        e2.lastBaseUpdate = m2;
        b2 = e2.shared.interleaved;
        if (null !== b2) {
          e2 = b2;
          do
            g2 |= e2.lane, e2 = e2.next;
          while (e2 !== b2);
        } else
          null === f2 && (e2.shared.lanes = 0);
        hh |= g2;
        a.lanes = g2;
        a.memoizedState = q2;
      }
    }
    function ih(a, b2, c2) {
      a = b2.effects;
      b2.effects = null;
      if (null !== a)
        for (b2 = 0; b2 < a.length; b2++) {
          var d2 = a[b2], e2 = d2.callback;
          if (null !== e2) {
            d2.callback = null;
            d2 = c2;
            if ("function" !== typeof e2)
              throw Error(p$5(191, e2));
            e2.call(d2);
          }
        }
    }
    var jh = new aa.Component().refs;
    function kh(a, b2, c2, d2) {
      b2 = a.memoizedState;
      c2 = c2(d2, b2);
      c2 = null === c2 || void 0 === c2 ? b2 : A$3({}, b2, c2);
      a.memoizedState = c2;
      0 === a.lanes && (a.updateQueue.baseState = c2);
    }
    var nh = { isMounted: function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : false;
    }, enqueueSetState: function(a, b2, c2) {
      a = a._reactInternals;
      var d2 = L$1(), e2 = lh(a), f2 = ch(d2, e2);
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a, f2, e2);
      null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
    }, enqueueReplaceState: function(a, b2, c2) {
      a = a._reactInternals;
      var d2 = L$1(), e2 = lh(a), f2 = ch(d2, e2);
      f2.tag = 1;
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a, f2, e2);
      null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
    }, enqueueForceUpdate: function(a, b2) {
      a = a._reactInternals;
      var c2 = L$1(), d2 = lh(a), e2 = ch(c2, d2);
      e2.tag = 2;
      void 0 !== b2 && null !== b2 && (e2.callback = b2);
      b2 = dh(a, e2, d2);
      null !== b2 && (mh(b2, a, d2, c2), eh(b2, a, d2));
    } };
    function oh(a, b2, c2, d2, e2, f2, g2) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$2(c2, d2) || !Ie$2(e2, f2) : true;
    }
    function ph(a, b2, c2) {
      var d2 = false, e2 = Vf;
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$3.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
      b2 = new b2(c2, f2);
      a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
      b2.updater = nh;
      a.stateNode = b2;
      b2._reactInternals = a;
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
      return b2;
    }
    function qh(a, b2, c2, d2) {
      a = b2.state;
      "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
      "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
      b2.state !== a && nh.enqueueReplaceState(b2, b2.state, null);
    }
    function rh(a, b2, c2, d2) {
      var e2 = a.stateNode;
      e2.props = c2;
      e2.state = a.memoizedState;
      e2.refs = jh;
      ah(a);
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$3.current, e2.context = Yf(a, f2));
      e2.state = a.memoizedState;
      f2 = b2.getDerivedStateFromProps;
      "function" === typeof f2 && (kh(a, b2, f2, c2), e2.state = a.memoizedState);
      "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a, c2, e2, d2), e2.state = a.memoizedState);
      "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
    }
    function sh(a, b2, c2) {
      a = c2.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c2._owner) {
          c2 = c2._owner;
          if (c2) {
            if (1 !== c2.tag)
              throw Error(p$5(309));
            var d2 = c2.stateNode;
          }
          if (!d2)
            throw Error(p$5(147, a));
          var e2 = d2, f2 = "" + a;
          if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
            return b2.ref;
          b2 = function(a2) {
            var b3 = e2.refs;
            b3 === jh && (b3 = e2.refs = {});
            null === a2 ? delete b3[f2] : b3[f2] = a2;
          };
          b2._stringRef = f2;
          return b2;
        }
        if ("string" !== typeof a)
          throw Error(p$5(284));
        if (!c2._owner)
          throw Error(p$5(290, a));
      }
      return a;
    }
    function th(a, b2) {
      a = Object.prototype.toString.call(b2);
      throw Error(p$5(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
    }
    function uh(a) {
      var b2 = a._init;
      return b2(a._payload);
    }
    function vh(a) {
      function b2(b3, c3) {
        if (a) {
          var d3 = b3.deletions;
          null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
        }
      }
      function c2(c3, d3) {
        if (!a)
          return null;
        for (; null !== d3; )
          b2(c3, d3), d3 = d3.sibling;
        return null;
      }
      function d2(a2, b3) {
        for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
          null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
        return a2;
      }
      function e2(a2, b3) {
        a2 = wh(a2, b3);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      function f2(b3, c3, d3) {
        b3.index = d3;
        if (!a)
          return b3.flags |= 1048576, c3;
        d3 = b3.alternate;
        if (null !== d3)
          return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
        b3.flags |= 2;
        return c3;
      }
      function g2(b3) {
        a && null === b3.alternate && (b3.flags |= 2);
        return b3;
      }
      function h2(a2, b3, c3, d3) {
        if (null === b3 || 6 !== b3.tag)
          return b3 = xh(c3, a2.mode, d3), b3.return = a2, b3;
        b3 = e2(b3, c3);
        b3.return = a2;
        return b3;
      }
      function k2(a2, b3, c3, d3) {
        var f3 = c3.type;
        if (f3 === ya$1)
          return m2(a2, b3, c3.props.children, d3, c3.key);
        if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha$1 && uh(f3) === b3.type))
          return d3 = e2(b3, c3.props), d3.ref = sh(a2, b3, c3), d3.return = a2, d3;
        d3 = yh(c3.type, c3.key, c3.props, null, a2.mode, d3);
        d3.ref = sh(a2, b3, c3);
        d3.return = a2;
        return d3;
      }
      function l2(a2, b3, c3, d3) {
        if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
          return b3 = zh(c3, a2.mode, d3), b3.return = a2, b3;
        b3 = e2(b3, c3.children || []);
        b3.return = a2;
        return b3;
      }
      function m2(a2, b3, c3, d3, f3) {
        if (null === b3 || 7 !== b3.tag)
          return b3 = Ah(c3, a2.mode, d3, f3), b3.return = a2, b3;
        b3 = e2(b3, c3);
        b3.return = a2;
        return b3;
      }
      function q2(a2, b3, c3) {
        if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
          return b3 = xh("" + b3, a2.mode, c3), b3.return = a2, b3;
        if ("object" === typeof b3 && null !== b3) {
          switch (b3.$$typeof) {
            case va$1:
              return c3 = yh(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = sh(a2, null, b3), c3.return = a2, c3;
            case wa:
              return b3 = zh(b3, a2.mode, c3), b3.return = a2, b3;
            case Ha$1:
              var d3 = b3._init;
              return q2(a2, d3(b3._payload), c3);
          }
          if (eb(b3) || Ka(b3))
            return b3 = Ah(b3, a2.mode, c3, null), b3.return = a2, b3;
          th(a2, b3);
        }
        return null;
      }
      function r2(a2, b3, c3, d3) {
        var e3 = null !== b3 ? b3.key : null;
        if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
          return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
        if ("object" === typeof c3 && null !== c3) {
          switch (c3.$$typeof) {
            case va$1:
              return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
            case wa:
              return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
            case Ha$1:
              return e3 = c3._init, r2(
                a2,
                b3,
                e3(c3._payload),
                d3
              );
          }
          if (eb(c3) || Ka(c3))
            return null !== e3 ? null : m2(a2, b3, c3, d3, null);
          th(a2, c3);
        }
        return null;
      }
      function y2(a2, b3, c3, d3, e3) {
        if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
          return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
        if ("object" === typeof d3 && null !== d3) {
          switch (d3.$$typeof) {
            case va$1:
              return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
            case wa:
              return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
            case Ha$1:
              var f3 = d3._init;
              return y2(a2, b3, c3, f3(d3._payload), e3);
          }
          if (eb(d3) || Ka(d3))
            return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
          th(b3, d3);
        }
        return null;
      }
      function n2(e3, g3, h3, k3) {
        for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
          u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
          var n3 = r2(e3, u2, h3[w2], k3);
          if (null === n3) {
            null === u2 && (u2 = x2);
            break;
          }
          a && u2 && null === n3.alternate && b2(e3, u2);
          g3 = f2(n3, g3, w2);
          null === m3 ? l3 = n3 : m3.sibling = n3;
          m3 = n3;
          u2 = x2;
        }
        if (w2 === h3.length)
          return c2(e3, u2), I$1 && tg(e3, w2), l3;
        if (null === u2) {
          for (; w2 < h3.length; w2++)
            u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
          I$1 && tg(e3, w2);
          return l3;
        }
        for (u2 = d2(e3, u2); w2 < h3.length; w2++)
          x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
        a && u2.forEach(function(a2) {
          return b2(e3, a2);
        });
        I$1 && tg(e3, w2);
        return l3;
      }
      function t2(e3, g3, h3, k3) {
        var l3 = Ka(h3);
        if ("function" !== typeof l3)
          throw Error(p$5(150));
        h3 = l3.call(h3);
        if (null == h3)
          throw Error(p$5(151));
        for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
          m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
          var t3 = r2(e3, m3, n3.value, k3);
          if (null === t3) {
            null === m3 && (m3 = x2);
            break;
          }
          a && m3 && null === t3.alternate && b2(e3, m3);
          g3 = f2(t3, g3, w2);
          null === u2 ? l3 = t3 : u2.sibling = t3;
          u2 = t3;
          m3 = x2;
        }
        if (n3.done)
          return c2(
            e3,
            m3
          ), I$1 && tg(e3, w2), l3;
        if (null === m3) {
          for (; !n3.done; w2++, n3 = h3.next())
            n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
          I$1 && tg(e3, w2);
          return l3;
        }
        for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
          n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        a && m3.forEach(function(a2) {
          return b2(e3, a2);
        });
        I$1 && tg(e3, w2);
        return l3;
      }
      function J2(a2, d3, f3, h3) {
        "object" === typeof f3 && null !== f3 && f3.type === ya$1 && null === f3.key && (f3 = f3.props.children);
        if ("object" === typeof f3 && null !== f3) {
          switch (f3.$$typeof) {
            case va$1:
              a: {
                for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                  if (l3.key === k3) {
                    k3 = f3.type;
                    if (k3 === ya$1) {
                      if (7 === l3.tag) {
                        c2(a2, l3.sibling);
                        d3 = e2(l3, f3.props.children);
                        d3.return = a2;
                        a2 = d3;
                        break a;
                      }
                    } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha$1 && uh(k3) === l3.type) {
                      c2(a2, l3.sibling);
                      d3 = e2(l3, f3.props);
                      d3.ref = sh(a2, l3, f3);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    }
                    c2(a2, l3);
                    break;
                  } else
                    b2(a2, l3);
                  l3 = l3.sibling;
                }
                f3.type === ya$1 ? (d3 = Ah(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = sh(a2, d3, f3), h3.return = a2, a2 = h3);
              }
              return g2(a2);
            case wa:
              a: {
                for (l3 = f3.key; null !== d3; ) {
                  if (d3.key === l3)
                    if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                      c2(a2, d3.sibling);
                      d3 = e2(d3, f3.children || []);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    } else {
                      c2(a2, d3);
                      break;
                    }
                  else
                    b2(a2, d3);
                  d3 = d3.sibling;
                }
                d3 = zh(f3, a2.mode, h3);
                d3.return = a2;
                a2 = d3;
              }
              return g2(a2);
            case Ha$1:
              return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
          }
          if (eb(f3))
            return n2(a2, d3, f3, h3);
          if (Ka(f3))
            return t2(a2, d3, f3, h3);
          th(a2, f3);
        }
        return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = xh(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
      }
      return J2;
    }
    var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
    function Hh(a) {
      if (a === Dh)
        throw Error(p$5(174));
      return a;
    }
    function Ih(a, b2) {
      G$1(Gh, b2);
      G$1(Fh, a);
      G$1(Eh, Dh);
      a = b2.nodeType;
      switch (a) {
        case 9:
        case 11:
          b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
          break;
        default:
          a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
      }
      E$3(Eh);
      G$1(Eh, b2);
    }
    function Jh() {
      E$3(Eh);
      E$3(Fh);
      E$3(Gh);
    }
    function Kh(a) {
      Hh(Gh.current);
      var b2 = Hh(Eh.current);
      var c2 = lb(b2, a.type);
      b2 !== c2 && (G$1(Fh, a), G$1(Eh, c2));
    }
    function Lh(a) {
      Fh.current === a && (E$3(Eh), E$3(Fh));
    }
    var M$1 = Uf(0);
    function Mh(a) {
      for (var b2 = a; null !== b2; ) {
        if (13 === b2.tag) {
          var c2 = b2.memoizedState;
          if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
            return b2;
        } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
          if (0 !== (b2.flags & 128))
            return b2;
        } else if (null !== b2.child) {
          b2.child.return = b2;
          b2 = b2.child;
          continue;
        }
        if (b2 === a)
          break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a)
            return null;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
      return null;
    }
    var Nh = [];
    function Oh() {
      for (var a = 0; a < Nh.length; a++)
        Nh[a]._workInProgressVersionPrimary = null;
      Nh.length = 0;
    }
    var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$1 = null, O$1 = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
    function Q$1() {
      throw Error(p$5(321));
    }
    function Wh(a, b2) {
      if (null === b2)
        return false;
      for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++)
        if (!He(a[c2], b2[c2]))
          return false;
      return true;
    }
    function Xh(a, b2, c2, d2, e2, f2) {
      Rh = f2;
      N$1 = b2;
      b2.memoizedState = null;
      b2.updateQueue = null;
      b2.lanes = 0;
      Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
      a = c2(d2, e2);
      if (Th) {
        f2 = 0;
        do {
          Th = false;
          Uh = 0;
          if (25 <= f2)
            throw Error(p$5(301));
          f2 += 1;
          P = O$1 = null;
          b2.updateQueue = null;
          Ph.current = $h;
          a = c2(d2, e2);
        } while (Th);
      }
      Ph.current = ai;
      b2 = null !== O$1 && null !== O$1.next;
      Rh = 0;
      P = O$1 = N$1 = null;
      Sh = false;
      if (b2)
        throw Error(p$5(300));
      return a;
    }
    function bi() {
      var a = 0 !== Uh;
      Uh = 0;
      return a;
    }
    function ci() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === P ? N$1.memoizedState = P = a : P = P.next = a;
      return P;
    }
    function di() {
      if (null === O$1) {
        var a = N$1.alternate;
        a = null !== a ? a.memoizedState : null;
      } else
        a = O$1.next;
      var b2 = null === P ? N$1.memoizedState : P.next;
      if (null !== b2)
        P = b2, O$1 = a;
      else {
        if (null === a)
          throw Error(p$5(310));
        O$1 = a;
        a = { memoizedState: O$1.memoizedState, baseState: O$1.baseState, baseQueue: O$1.baseQueue, queue: O$1.queue, next: null };
        null === P ? N$1.memoizedState = P = a : P = P.next = a;
      }
      return P;
    }
    function ei(a, b2) {
      return "function" === typeof b2 ? b2(a) : b2;
    }
    function fi(a) {
      var b2 = di(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$5(311));
      c2.lastRenderedReducer = a;
      var d2 = O$1, e2 = d2.baseQueue, f2 = c2.pending;
      if (null !== f2) {
        if (null !== e2) {
          var g2 = e2.next;
          e2.next = f2.next;
          f2.next = g2;
        }
        d2.baseQueue = e2 = f2;
        c2.pending = null;
      }
      if (null !== e2) {
        f2 = e2.next;
        d2 = d2.baseState;
        var h2 = g2 = null, k2 = null, l2 = f2;
        do {
          var m2 = l2.lane;
          if ((Rh & m2) === m2)
            null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
          else {
            var q2 = {
              lane: m2,
              action: l2.action,
              hasEagerState: l2.hasEagerState,
              eagerState: l2.eagerState,
              next: null
            };
            null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
            N$1.lanes |= m2;
            hh |= m2;
          }
          l2 = l2.next;
        } while (null !== l2 && l2 !== f2);
        null === k2 ? g2 = d2 : k2.next = h2;
        He(d2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = d2;
        b2.baseState = g2;
        b2.baseQueue = k2;
        c2.lastRenderedState = d2;
      }
      a = c2.interleaved;
      if (null !== a) {
        e2 = a;
        do
          f2 = e2.lane, N$1.lanes |= f2, hh |= f2, e2 = e2.next;
        while (e2 !== a);
      } else
        null === e2 && (c2.lanes = 0);
      return [b2.memoizedState, c2.dispatch];
    }
    function gi(a) {
      var b2 = di(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$5(311));
      c2.lastRenderedReducer = a;
      var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
      if (null !== e2) {
        c2.pending = null;
        var g2 = e2 = e2.next;
        do
          f2 = a(f2, g2.action), g2 = g2.next;
        while (g2 !== e2);
        He(f2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = f2;
        null === b2.baseQueue && (b2.baseState = f2);
        c2.lastRenderedState = f2;
      }
      return [f2, d2];
    }
    function hi() {
    }
    function ii$1(a, b2) {
      var c2 = N$1, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
      f2 && (d2.memoizedState = e2, Ug = true);
      d2 = d2.queue;
      ji(ki.bind(null, c2, d2, a), [a]);
      if (d2.getSnapshot !== b2 || f2 || null !== P && P.memoizedState.tag & 1) {
        c2.flags |= 2048;
        li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
        if (null === R)
          throw Error(p$5(349));
        0 !== (Rh & 30) || ni(c2, b2, e2);
      }
      return e2;
    }
    function ni(a, b2, c2) {
      a.flags |= 16384;
      a = { getSnapshot: b2, value: c2 };
      b2 = N$1.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
    }
    function mi(a, b2, c2, d2) {
      b2.value = c2;
      b2.getSnapshot = d2;
      oi(b2) && pi(a);
    }
    function ki(a, b2, c2) {
      return c2(function() {
        oi(b2) && pi(a);
      });
    }
    function oi(a) {
      var b2 = a.getSnapshot;
      a = a.value;
      try {
        var c2 = b2();
        return !He(a, c2);
      } catch (d2) {
        return true;
      }
    }
    function pi(a) {
      var b2 = Zg(a, 1);
      null !== b2 && mh(b2, a, 1, -1);
    }
    function qi(a) {
      var b2 = ci();
      "function" === typeof a && (a = a());
      b2.memoizedState = b2.baseState = a;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
      b2.queue = a;
      a = a.dispatch = ri.bind(null, N$1, a);
      return [b2.memoizedState, a];
    }
    function li(a, b2, c2, d2) {
      a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
      b2 = N$1.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
      return a;
    }
    function si() {
      return di().memoizedState;
    }
    function ti(a, b2, c2, d2) {
      var e2 = ci();
      N$1.flags |= a;
      e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
    }
    function ui$1(a, b2, c2, d2) {
      var e2 = di();
      d2 = void 0 === d2 ? null : d2;
      var f2 = void 0;
      if (null !== O$1) {
        var g2 = O$1.memoizedState;
        f2 = g2.destroy;
        if (null !== d2 && Wh(d2, g2.deps)) {
          e2.memoizedState = li(b2, c2, f2, d2);
          return;
        }
      }
      N$1.flags |= a;
      e2.memoizedState = li(1 | b2, c2, f2, d2);
    }
    function vi(a, b2) {
      return ti(8390656, 8, a, b2);
    }
    function ji(a, b2) {
      return ui$1(2048, 8, a, b2);
    }
    function wi$1(a, b2) {
      return ui$1(4, 2, a, b2);
    }
    function xi(a, b2) {
      return ui$1(4, 4, a, b2);
    }
    function yi(a, b2) {
      if ("function" === typeof b2)
        return a = a(), b2(a), function() {
          b2(null);
        };
      if (null !== b2 && void 0 !== b2)
        return a = a(), b2.current = a, function() {
          b2.current = null;
        };
    }
    function zi(a, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
      return ui$1(4, 4, yi.bind(null, b2, a), c2);
    }
    function Ai() {
    }
    function Bi(a, b2) {
      var c2 = di();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      c2.memoizedState = [a, b2];
      return a;
    }
    function Ci(a, b2) {
      var c2 = di();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      a = a();
      c2.memoizedState = [a, b2];
      return a;
    }
    function Di$1(a, b2, c2) {
      if (0 === (Rh & 21))
        return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c2;
      He(c2, b2) || (c2 = yc(), N$1.lanes |= c2, hh |= c2, a.baseState = true);
      return b2;
    }
    function Ei(a, b2) {
      var c2 = C$1;
      C$1 = 0 !== c2 && 4 > c2 ? c2 : 4;
      a(true);
      var d2 = Qh.transition;
      Qh.transition = {};
      try {
        a(false), b2();
      } finally {
        C$1 = c2, Qh.transition = d2;
      }
    }
    function Fi$1() {
      return di().memoizedState;
    }
    function Gi(a, b2, c2) {
      var d2 = lh(a);
      c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi$1(a))
        Ii$1(b2, c2);
      else if (c2 = Yg(a, b2, c2, d2), null !== c2) {
        var e2 = L$1();
        mh(c2, a, d2, e2);
        Ji(c2, b2, d2);
      }
    }
    function ri(a, b2, c2) {
      var d2 = lh(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi$1(a))
        Ii$1(b2, e2);
      else {
        var f2 = a.alternate;
        if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
          try {
            var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
            e2.hasEagerState = true;
            e2.eagerState = h2;
            if (He(h2, g2)) {
              var k2 = b2.interleaved;
              null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
              b2.interleaved = e2;
              return;
            }
          } catch (l2) {
          } finally {
          }
        c2 = Yg(a, b2, e2, d2);
        null !== c2 && (e2 = L$1(), mh(c2, a, d2, e2), Ji(c2, b2, d2));
      }
    }
    function Hi$1(a) {
      var b2 = a.alternate;
      return a === N$1 || null !== b2 && b2 === N$1;
    }
    function Ii$1(a, b2) {
      Th = Sh = true;
      var c2 = a.pending;
      null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
      a.pending = b2;
    }
    function Ji(a, b2, c2) {
      if (0 !== (c2 & 4194240)) {
        var d2 = b2.lanes;
        d2 &= a.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a, c2);
      }
    }
    var ai = { readContext: Vg, useCallback: Q$1, useContext: Q$1, useEffect: Q$1, useImperativeHandle: Q$1, useInsertionEffect: Q$1, useLayoutEffect: Q$1, useMemo: Q$1, useReducer: Q$1, useRef: Q$1, useState: Q$1, useDebugValue: Q$1, useDeferredValue: Q$1, useTransition: Q$1, useMutableSource: Q$1, useSyncExternalStore: Q$1, useId: Q$1, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a, b2) {
      ci().memoizedState = [a, void 0 === b2 ? null : b2];
      return a;
    }, useContext: Vg, useEffect: vi, useImperativeHandle: function(a, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
      return ti(
        4194308,
        4,
        yi.bind(null, b2, a),
        c2
      );
    }, useLayoutEffect: function(a, b2) {
      return ti(4194308, 4, a, b2);
    }, useInsertionEffect: function(a, b2) {
      return ti(4, 2, a, b2);
    }, useMemo: function(a, b2) {
      var c2 = ci();
      b2 = void 0 === b2 ? null : b2;
      a = a();
      c2.memoizedState = [a, b2];
      return a;
    }, useReducer: function(a, b2, c2) {
      var d2 = ci();
      b2 = void 0 !== c2 ? c2(b2) : b2;
      d2.memoizedState = d2.baseState = b2;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
      d2.queue = a;
      a = a.dispatch = Gi.bind(null, N$1, a);
      return [d2.memoizedState, a];
    }, useRef: function(a) {
      var b2 = ci();
      a = { current: a };
      return b2.memoizedState = a;
    }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
      return ci().memoizedState = a;
    }, useTransition: function() {
      var a = qi(false), b2 = a[0];
      a = Ei.bind(null, a[1]);
      ci().memoizedState = a;
      return [b2, a];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a, b2, c2) {
      var d2 = N$1, e2 = ci();
      if (I$1) {
        if (void 0 === c2)
          throw Error(p$5(407));
        c2 = c2();
      } else {
        c2 = b2();
        if (null === R)
          throw Error(p$5(349));
        0 !== (Rh & 30) || ni(d2, b2, c2);
      }
      e2.memoizedState = c2;
      var f2 = { value: c2, getSnapshot: b2 };
      e2.queue = f2;
      vi(ki.bind(
        null,
        d2,
        f2,
        a
      ), [a]);
      d2.flags |= 2048;
      li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
      return c2;
    }, useId: function() {
      var a = ci(), b2 = R.identifierPrefix;
      if (I$1) {
        var c2 = sg;
        var d2 = rg;
        c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
        b2 = ":" + b2 + "R" + c2;
        c2 = Uh++;
        0 < c2 && (b2 += "H" + c2.toString(32));
        b2 += ":";
      } else
        c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
      return a.memoizedState = b2;
    }, unstable_isNewReconciler: false }, Zh = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi$1,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: fi,
      useRef: si,
      useState: function() {
        return fi(ei);
      },
      useDebugValue: Ai,
      useDeferredValue: function(a) {
        var b2 = di();
        return Di$1(b2, O$1.memoizedState, a);
      },
      useTransition: function() {
        var a = fi(ei)[0], b2 = di().memoizedState;
        return [a, b2];
      },
      useMutableSource: hi,
      useSyncExternalStore: ii$1,
      useId: Fi$1,
      unstable_isNewReconciler: false
    }, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi$1, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
      return gi(ei);
    }, useDebugValue: Ai, useDeferredValue: function(a) {
      var b2 = di();
      return null === O$1 ? b2.memoizedState = a : Di$1(b2, O$1.memoizedState, a);
    }, useTransition: function() {
      var a = gi(ei)[0], b2 = di().memoizedState;
      return [a, b2];
    }, useMutableSource: hi, useSyncExternalStore: ii$1, useId: Fi$1, unstable_isNewReconciler: false };
    function Ki(a, b2) {
      try {
        var c2 = "", d2 = b2;
        do
          c2 += Pa$1(d2), d2 = d2.return;
        while (d2);
        var e2 = c2;
      } catch (f2) {
        e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
      }
      return { value: a, source: b2, stack: e2, digest: null };
    }
    function Li(a, b2, c2) {
      return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
    }
    function Mi(a, b2) {
      try {
        console.error(b2.value);
      } catch (c2) {
        setTimeout(function() {
          throw c2;
        });
      }
    }
    var Ni = "function" === typeof WeakMap ? WeakMap : Map;
    function Oi$1(a, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      c2.payload = { element: null };
      var d2 = b2.value;
      c2.callback = function() {
        Pi$1 || (Pi$1 = true, Qi = d2);
        Mi(a, b2);
      };
      return c2;
    }
    function Ri(a, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      var d2 = a.type.getDerivedStateFromError;
      if ("function" === typeof d2) {
        var e2 = b2.value;
        c2.payload = function() {
          return d2(e2);
        };
        c2.callback = function() {
          Mi(a, b2);
        };
      }
      var f2 = a.stateNode;
      null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
        Mi(a, b2);
        "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
        var c3 = b2.stack;
        this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
      });
      return c2;
    }
    function Ti(a, b2, c2) {
      var d2 = a.pingCache;
      if (null === d2) {
        d2 = a.pingCache = new Ni();
        var e2 = /* @__PURE__ */ new Set();
        d2.set(b2, e2);
      } else
        e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
      e2.has(c2) || (e2.add(c2), a = Ui.bind(null, a, b2, c2), b2.then(a, a));
    }
    function Vi(a) {
      do {
        var b2;
        if (b2 = 13 === a.tag)
          b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
        if (b2)
          return a;
        a = a.return;
      } while (null !== a);
      return null;
    }
    function Wi(a, b2, c2, d2, e2) {
      if (0 === (a.mode & 1))
        return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a;
      a.flags |= 65536;
      a.lanes = e2;
      return a;
    }
    var Xi = ua.ReactCurrentOwner, Ug = false;
    function Yi(a, b2, c2, d2) {
      b2.child = null === a ? Ch(b2, null, c2, d2) : Bh(b2, a.child, c2, d2);
    }
    function Zi(a, b2, c2, d2, e2) {
      c2 = c2.render;
      var f2 = b2.ref;
      Tg(b2, e2);
      d2 = Xh(a, b2, c2, d2, f2, e2);
      c2 = bi();
      if (null !== a && !Ug)
        return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
      I$1 && c2 && vg(b2);
      b2.flags |= 1;
      Yi(a, b2, d2, e2);
      return b2.child;
    }
    function aj(a, b2, c2, d2, e2) {
      if (null === a) {
        var f2 = c2.type;
        if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
          return b2.tag = 15, b2.type = f2, cj(a, b2, f2, d2, e2);
        a = yh(c2.type, null, d2, b2, b2.mode, e2);
        a.ref = b2.ref;
        a.return = b2;
        return b2.child = a;
      }
      f2 = a.child;
      if (0 === (a.lanes & e2)) {
        var g2 = f2.memoizedProps;
        c2 = c2.compare;
        c2 = null !== c2 ? c2 : Ie$2;
        if (c2(g2, d2) && a.ref === b2.ref)
          return $i(a, b2, e2);
      }
      b2.flags |= 1;
      a = wh(f2, d2);
      a.ref = b2.ref;
      a.return = b2;
      return b2.child = a;
    }
    function cj(a, b2, c2, d2, e2) {
      if (null !== a) {
        var f2 = a.memoizedProps;
        if (Ie$2(f2, d2) && a.ref === b2.ref)
          if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2))
            0 !== (a.flags & 131072) && (Ug = true);
          else
            return b2.lanes = a.lanes, $i(a, b2, e2);
      }
      return dj(a, b2, c2, d2, e2);
    }
    function ej(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
      if ("hidden" === d2.mode)
        if (0 === (b2.mode & 1))
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(fj, gj), gj |= c2;
        else {
          if (0 === (c2 & 1073741824))
            return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G$1(fj, gj), gj |= a, null;
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d2 = null !== f2 ? f2.baseLanes : c2;
          G$1(fj, gj);
          gj |= d2;
        }
      else
        null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$1(fj, gj), gj |= d2;
      Yi(a, b2, e2, c2);
      return b2.child;
    }
    function hj(a, b2) {
      var c2 = b2.ref;
      if (null === a && null !== c2 || null !== a && a.ref !== c2)
        b2.flags |= 512, b2.flags |= 2097152;
    }
    function dj(a, b2, c2, d2, e2) {
      var f2 = Zf(c2) ? Xf : H$3.current;
      f2 = Yf(b2, f2);
      Tg(b2, e2);
      c2 = Xh(a, b2, c2, d2, f2, e2);
      d2 = bi();
      if (null !== a && !Ug)
        return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
      I$1 && d2 && vg(b2);
      b2.flags |= 1;
      Yi(a, b2, c2, e2);
      return b2.child;
    }
    function ij(a, b2, c2, d2, e2) {
      if (Zf(c2)) {
        var f2 = true;
        cg(b2);
      } else
        f2 = false;
      Tg(b2, e2);
      if (null === b2.stateNode)
        jj(a, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
      else if (null === a) {
        var g2 = b2.stateNode, h2 = b2.memoizedProps;
        g2.props = h2;
        var k2 = g2.context, l2 = c2.contextType;
        "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$3.current, l2 = Yf(b2, l2));
        var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
        q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
        $g = false;
        var r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        k2 = b2.memoizedState;
        h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
      } else {
        g2 = b2.stateNode;
        bh(a, b2);
        h2 = b2.memoizedProps;
        l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
        g2.props = l2;
        q2 = b2.pendingProps;
        r2 = g2.context;
        k2 = c2.contextType;
        "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$3.current, k2 = Yf(b2, k2));
        var y2 = c2.getDerivedStateFromProps;
        (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
        $g = false;
        r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        var n2 = b2.memoizedState;
        h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
      }
      return kj(a, b2, c2, d2, f2, e2);
    }
    function kj(a, b2, c2, d2, e2, f2) {
      hj(a, b2);
      var g2 = 0 !== (b2.flags & 128);
      if (!d2 && !g2)
        return e2 && dg(b2, c2, false), $i(a, b2, f2);
      d2 = b2.stateNode;
      Xi.current = b2;
      var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
      b2.flags |= 1;
      null !== a && g2 ? (b2.child = Bh(b2, a.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a, b2, h2, f2);
      b2.memoizedState = d2.state;
      e2 && dg(b2, c2, true);
      return b2.child;
    }
    function lj(a) {
      var b2 = a.stateNode;
      b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
      Ih(a, b2.containerInfo);
    }
    function mj(a, b2, c2, d2, e2) {
      Ig();
      Jg(e2);
      b2.flags |= 256;
      Yi(a, b2, c2, d2);
      return b2.child;
    }
    var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function oj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    function pj(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = M$1.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
      (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
      if (h2)
        f2 = true, b2.flags &= -129;
      else if (null === a || null !== a.memoizedState)
        e2 |= 1;
      G$1(M$1, e2 & 1);
      if (null === a) {
        Eg(b2);
        a = b2.memoizedState;
        if (null !== a && (a = a.dehydrated, null !== a))
          return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
        g2 = d2.children;
        a = d2.fallback;
        return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a = Ah(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a) : rj(b2, g2);
      }
      e2 = a.memoizedState;
      if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
        return sj(a, b2, g2, d2, h2, e2, c2);
      if (f2) {
        f2 = d2.fallback;
        g2 = b2.mode;
        e2 = a.child;
        h2 = e2.sibling;
        var k2 = { mode: "hidden", children: d2.children };
        0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
        null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
        f2.return = b2;
        d2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        d2 = f2;
        f2 = b2.child;
        g2 = a.child.memoizedState;
        g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
        f2.memoizedState = g2;
        f2.childLanes = a.childLanes & ~c2;
        b2.memoizedState = nj;
        return d2;
      }
      f2 = a.child;
      a = f2.sibling;
      d2 = wh(f2, { mode: "visible", children: d2.children });
      0 === (b2.mode & 1) && (d2.lanes = c2);
      d2.return = b2;
      d2.sibling = null;
      null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
      b2.child = d2;
      b2.memoizedState = null;
      return d2;
    }
    function rj(a, b2) {
      b2 = qj({ mode: "visible", children: b2 }, a.mode, 0, null);
      b2.return = a;
      return a.child = b2;
    }
    function tj(a, b2, c2, d2) {
      null !== d2 && Jg(d2);
      Bh(b2, a.child, null, c2);
      a = rj(b2, b2.pendingProps.children);
      a.flags |= 2;
      b2.memoizedState = null;
      return a;
    }
    function sj(a, b2, c2, d2, e2, f2, g2) {
      if (c2) {
        if (b2.flags & 256)
          return b2.flags &= -257, d2 = Li(Error(p$5(422))), tj(a, b2, g2, d2);
        if (null !== b2.memoizedState)
          return b2.child = a.child, b2.flags |= 128, null;
        f2 = d2.fallback;
        e2 = b2.mode;
        d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
        f2 = Ah(f2, e2, g2, null);
        f2.flags |= 2;
        d2.return = b2;
        f2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        0 !== (b2.mode & 1) && Bh(b2, a.child, null, g2);
        b2.child.memoizedState = oj(g2);
        b2.memoizedState = nj;
        return f2;
      }
      if (0 === (b2.mode & 1))
        return tj(a, b2, g2, null);
      if ("$!" === e2.data) {
        d2 = e2.nextSibling && e2.nextSibling.dataset;
        if (d2)
          var h2 = d2.dgst;
        d2 = h2;
        f2 = Error(p$5(419));
        d2 = Li(f2, d2, void 0);
        return tj(a, b2, g2, d2);
      }
      h2 = 0 !== (g2 & a.childLanes);
      if (Ug || h2) {
        d2 = R;
        if (null !== d2) {
          switch (g2 & -g2) {
            case 4:
              e2 = 2;
              break;
            case 16:
              e2 = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e2 = 32;
              break;
            case 536870912:
              e2 = 268435456;
              break;
            default:
              e2 = 0;
          }
          e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
          0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a, e2), mh(d2, a, e2, -1));
        }
        uj();
        d2 = Li(Error(p$5(421)));
        return tj(a, b2, g2, d2);
      }
      if ("$?" === e2.data)
        return b2.flags |= 128, b2.child = a.child, b2 = vj.bind(null, a), e2._reactRetry = b2, null;
      a = f2.treeContext;
      yg = Lf(e2.nextSibling);
      xg = b2;
      I$1 = true;
      zg = null;
      null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
      b2 = rj(b2, d2.children);
      b2.flags |= 4096;
      return b2;
    }
    function wj(a, b2, c2) {
      a.lanes |= b2;
      var d2 = a.alternate;
      null !== d2 && (d2.lanes |= b2);
      Sg(a.return, b2, c2);
    }
    function xj(a, b2, c2, d2, e2) {
      var f2 = a.memoizedState;
      null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
    }
    function yj(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
      Yi(a, b2, d2.children, c2);
      d2 = M$1.current;
      if (0 !== (d2 & 2))
        d2 = d2 & 1 | 2, b2.flags |= 128;
      else {
        if (null !== a && 0 !== (a.flags & 128))
          a:
            for (a = b2.child; null !== a; ) {
              if (13 === a.tag)
                null !== a.memoizedState && wj(a, c2, b2);
              else if (19 === a.tag)
                wj(a, c2, b2);
              else if (null !== a.child) {
                a.child.return = a;
                a = a.child;
                continue;
              }
              if (a === b2)
                break a;
              for (; null === a.sibling; ) {
                if (null === a.return || a.return === b2)
                  break a;
                a = a.return;
              }
              a.sibling.return = a.return;
              a = a.sibling;
            }
        d2 &= 1;
      }
      G$1(M$1, d2);
      if (0 === (b2.mode & 1))
        b2.memoizedState = null;
      else
        switch (e2) {
          case "forwards":
            c2 = b2.child;
            for (e2 = null; null !== c2; )
              a = c2.alternate, null !== a && null === Mh(a) && (e2 = c2), c2 = c2.sibling;
            c2 = e2;
            null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
            xj(b2, false, e2, c2, f2);
            break;
          case "backwards":
            c2 = null;
            e2 = b2.child;
            for (b2.child = null; null !== e2; ) {
              a = e2.alternate;
              if (null !== a && null === Mh(a)) {
                b2.child = e2;
                break;
              }
              a = e2.sibling;
              e2.sibling = c2;
              c2 = e2;
              e2 = a;
            }
            xj(b2, true, c2, null, f2);
            break;
          case "together":
            xj(b2, false, null, null, void 0);
            break;
          default:
            b2.memoizedState = null;
        }
      return b2.child;
    }
    function jj(a, b2) {
      0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
    }
    function $i(a, b2, c2) {
      null !== a && (b2.dependencies = a.dependencies);
      hh |= b2.lanes;
      if (0 === (c2 & b2.childLanes))
        return null;
      if (null !== a && b2.child !== a.child)
        throw Error(p$5(153));
      if (null !== b2.child) {
        a = b2.child;
        c2 = wh(a, a.pendingProps);
        b2.child = c2;
        for (c2.return = b2; null !== a.sibling; )
          a = a.sibling, c2 = c2.sibling = wh(a, a.pendingProps), c2.return = b2;
        c2.sibling = null;
      }
      return b2.child;
    }
    function zj(a, b2, c2) {
      switch (b2.tag) {
        case 3:
          lj(b2);
          Ig();
          break;
        case 5:
          Kh(b2);
          break;
        case 1:
          Zf(b2.type) && cg(b2);
          break;
        case 4:
          Ih(b2, b2.stateNode.containerInfo);
          break;
        case 10:
          var d2 = b2.type._context, e2 = b2.memoizedProps.value;
          G$1(Mg, d2._currentValue);
          d2._currentValue = e2;
          break;
        case 13:
          d2 = b2.memoizedState;
          if (null !== d2) {
            if (null !== d2.dehydrated)
              return G$1(M$1, M$1.current & 1), b2.flags |= 128, null;
            if (0 !== (c2 & b2.child.childLanes))
              return pj(a, b2, c2);
            G$1(M$1, M$1.current & 1);
            a = $i(a, b2, c2);
            return null !== a ? a.sibling : null;
          }
          G$1(M$1, M$1.current & 1);
          break;
        case 19:
          d2 = 0 !== (c2 & b2.childLanes);
          if (0 !== (a.flags & 128)) {
            if (d2)
              return yj(a, b2, c2);
            b2.flags |= 128;
          }
          e2 = b2.memoizedState;
          null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
          G$1(M$1, M$1.current);
          if (d2)
            break;
          else
            return null;
        case 22:
        case 23:
          return b2.lanes = 0, ej(a, b2, c2);
      }
      return $i(a, b2, c2);
    }
    var Aj, Bj, Cj, Dj;
    Aj = function(a, b2) {
      for (var c2 = b2.child; null !== c2; ) {
        if (5 === c2.tag || 6 === c2.tag)
          a.appendChild(c2.stateNode);
        else if (4 !== c2.tag && null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b2)
          break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === b2)
            return;
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    };
    Bj = function() {
    };
    Cj = function(a, b2, c2, d2) {
      var e2 = a.memoizedProps;
      if (e2 !== d2) {
        a = b2.stateNode;
        Hh(Eh.current);
        var f2 = null;
        switch (c2) {
          case "input":
            e2 = Ya(a, e2);
            d2 = Ya(a, d2);
            f2 = [];
            break;
          case "select":
            e2 = A$3({}, e2, { value: void 0 });
            d2 = A$3({}, d2, { value: void 0 });
            f2 = [];
            break;
          case "textarea":
            e2 = gb(a, e2);
            d2 = gb(a, d2);
            f2 = [];
            break;
          default:
            "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
        }
        ub(c2, d2);
        var g2;
        c2 = null;
        for (l2 in e2)
          if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
            if ("style" === l2) {
              var h2 = e2[l2];
              for (g2 in h2)
                h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
            } else
              "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
        for (l2 in d2) {
          var k2 = d2[l2];
          h2 = null != e2 ? e2[l2] : void 0;
          if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
            if ("style" === l2)
              if (h2) {
                for (g2 in h2)
                  !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
                for (g2 in k2)
                  k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
              } else
                c2 || (f2 || (f2 = []), f2.push(
                  l2,
                  c2
                )), c2 = k2;
            else
              "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$1("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
        }
        c2 && (f2 = f2 || []).push("style", c2);
        var l2 = f2;
        if (b2.updateQueue = l2)
          b2.flags |= 4;
      }
    };
    Dj = function(a, b2, c2, d2) {
      c2 !== d2 && (b2.flags |= 4);
    };
    function Ej(a, b2) {
      if (!I$1)
        switch (a.tailMode) {
          case "hidden":
            b2 = a.tail;
            for (var c2 = null; null !== b2; )
              null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
            null === c2 ? a.tail = null : c2.sibling = null;
            break;
          case "collapsed":
            c2 = a.tail;
            for (var d2 = null; null !== c2; )
              null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
            null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
        }
    }
    function S(a) {
      var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
      if (b2)
        for (var e2 = a.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
      else
        for (e2 = a.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
      a.subtreeFlags |= d2;
      a.childLanes = c2;
      return b2;
    }
    function Fj(a, b2, c2) {
      var d2 = b2.pendingProps;
      wg(b2);
      switch (b2.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b2), null;
        case 1:
          return Zf(b2.type) && $f(), S(b2), null;
        case 3:
          d2 = b2.stateNode;
          Jh();
          E$3(Wf);
          E$3(H$3);
          Oh();
          d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
          if (null === a || null === a.child)
            Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
          Bj(a, b2);
          S(b2);
          return null;
        case 5:
          Lh(b2);
          var e2 = Hh(Gh.current);
          c2 = b2.type;
          if (null !== a && null != b2.stateNode)
            Cj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          else {
            if (!d2) {
              if (null === b2.stateNode)
                throw Error(p$5(166));
              S(b2);
              return null;
            }
            a = Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.type;
              var f2 = b2.memoizedProps;
              d2[Of] = b2;
              d2[Pf] = f2;
              a = 0 !== (b2.mode & 1);
              switch (c2) {
                case "dialog":
                  D$1("cancel", d2);
                  D$1("close", d2);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D$1("load", d2);
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf.length; e2++)
                    D$1(lf[e2], d2);
                  break;
                case "source":
                  D$1("error", d2);
                  break;
                case "img":
                case "image":
                case "link":
                  D$1(
                    "error",
                    d2
                  );
                  D$1("load", d2);
                  break;
                case "details":
                  D$1("toggle", d2);
                  break;
                case "input":
                  Za(d2, f2);
                  D$1("invalid", d2);
                  break;
                case "select":
                  d2._wrapperState = { wasMultiple: !!f2.multiple };
                  D$1("invalid", d2);
                  break;
                case "textarea":
                  hb(d2, f2), D$1("invalid", d2);
              }
              ub(c2, f2);
              e2 = null;
              for (var g2 in f2)
                if (f2.hasOwnProperty(g2)) {
                  var h2 = f2[g2];
                  "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                    d2.textContent,
                    h2,
                    a
                  ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$1("scroll", d2);
                }
              switch (c2) {
                case "input":
                  Va$1(d2);
                  db(d2, f2, true);
                  break;
                case "textarea":
                  Va$1(d2);
                  jb(d2);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f2.onClick && (d2.onclick = Bf);
              }
              d2 = e2;
              b2.updateQueue = d2;
              null !== d2 && (b2.flags |= 4);
            } else {
              g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
              "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
              a[Of] = b2;
              a[Pf] = d2;
              Aj(a, b2, false, false);
              b2.stateNode = a;
              a: {
                g2 = vb(c2, d2);
                switch (c2) {
                  case "dialog":
                    D$1("cancel", a);
                    D$1("close", a);
                    e2 = d2;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D$1("load", a);
                    e2 = d2;
                    break;
                  case "video":
                  case "audio":
                    for (e2 = 0; e2 < lf.length; e2++)
                      D$1(lf[e2], a);
                    e2 = d2;
                    break;
                  case "source":
                    D$1("error", a);
                    e2 = d2;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D$1(
                      "error",
                      a
                    );
                    D$1("load", a);
                    e2 = d2;
                    break;
                  case "details":
                    D$1("toggle", a);
                    e2 = d2;
                    break;
                  case "input":
                    Za(a, d2);
                    e2 = Ya(a, d2);
                    D$1("invalid", a);
                    break;
                  case "option":
                    e2 = d2;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d2.multiple };
                    e2 = A$3({}, d2, { value: void 0 });
                    D$1("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d2);
                    e2 = gb(a, d2);
                    D$1("invalid", a);
                    break;
                  default:
                    e2 = d2;
                }
                ub(c2, e2);
                h2 = e2;
                for (f2 in h2)
                  if (h2.hasOwnProperty(f2)) {
                    var k2 = h2[f2];
                    "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$1("scroll", a) : null != k2 && ta(a, f2, k2, g2));
                  }
                switch (c2) {
                  case "input":
                    Va$1(a);
                    db(a, d2, false);
                    break;
                  case "textarea":
                    Va$1(a);
                    jb(a);
                    break;
                  case "option":
                    null != d2.value && a.setAttribute("value", "" + Sa$1(d2.value));
                    break;
                  case "select":
                    a.multiple = !!d2.multiple;
                    f2 = d2.value;
                    null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                      a,
                      !!d2.multiple,
                      d2.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e2.onClick && (a.onclick = Bf);
                }
                switch (c2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d2 = !!d2.autoFocus;
                    break a;
                  case "img":
                    d2 = true;
                    break a;
                  default:
                    d2 = false;
                }
              }
              d2 && (b2.flags |= 4);
            }
            null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          }
          S(b2);
          return null;
        case 6:
          if (a && null != b2.stateNode)
            Dj(a, b2, a.memoizedProps, d2);
          else {
            if ("string" !== typeof d2 && null === b2.stateNode)
              throw Error(p$5(166));
            c2 = Hh(Gh.current);
            Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.memoizedProps;
              d2[Of] = b2;
              if (f2 = d2.nodeValue !== c2) {
                if (a = xg, null !== a)
                  switch (a.tag) {
                    case 3:
                      Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                  }
              }
              f2 && (b2.flags |= 4);
            } else
              d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
          }
          S(b2);
          return null;
        case 13:
          E$3(M$1);
          d2 = b2.memoizedState;
          if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
            if (I$1 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
              Hg(), Ig(), b2.flags |= 98560, f2 = false;
            else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
              if (null === a) {
                if (!f2)
                  throw Error(p$5(318));
                f2 = b2.memoizedState;
                f2 = null !== f2 ? f2.dehydrated : null;
                if (!f2)
                  throw Error(p$5(317));
                f2[Of] = b2;
              } else
                Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
              S(b2);
              f2 = false;
            } else
              null !== zg && (Gj(zg), zg = null), f2 = true;
            if (!f2)
              return b2.flags & 65536 ? b2 : null;
          }
          if (0 !== (b2.flags & 128))
            return b2.lanes = c2, b2;
          d2 = null !== d2;
          d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (M$1.current & 1) ? 0 === T$1 && (T$1 = 3) : uj()));
          null !== b2.updateQueue && (b2.flags |= 4);
          S(b2);
          return null;
        case 4:
          return Jh(), Bj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
        case 10:
          return Rg(b2.type._context), S(b2), null;
        case 17:
          return Zf(b2.type) && $f(), S(b2), null;
        case 19:
          E$3(M$1);
          f2 = b2.memoizedState;
          if (null === f2)
            return S(b2), null;
          d2 = 0 !== (b2.flags & 128);
          g2 = f2.rendering;
          if (null === g2)
            if (d2)
              Ej(f2, false);
            else {
              if (0 !== T$1 || null !== a && 0 !== (a.flags & 128))
                for (a = b2.child; null !== a; ) {
                  g2 = Mh(a);
                  if (null !== g2) {
                    b2.flags |= 128;
                    Ej(f2, false);
                    d2 = g2.updateQueue;
                    null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                    b2.subtreeFlags = 0;
                    d2 = c2;
                    for (c2 = b2.child; null !== c2; )
                      f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
                    G$1(M$1, M$1.current & 1 | 2);
                    return b2.child;
                  }
                  a = a.sibling;
                }
              null !== f2.tail && B$2() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            }
          else {
            if (!d2)
              if (a = Mh(g2), null !== a) {
                if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$1)
                  return S(b2), null;
              } else
                2 * B$2() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
          }
          if (null !== f2.tail)
            return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$2(), b2.sibling = null, c2 = M$1.current, G$1(M$1, d2 ? c2 & 1 | 2 : c2 & 1), b2;
          S(b2);
          return null;
        case 22:
        case 23:
          return Ij(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p$5(156, b2.tag));
    }
    function Jj(a, b2) {
      wg(b2);
      switch (b2.tag) {
        case 1:
          return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
        case 3:
          return Jh(), E$3(Wf), E$3(H$3), Oh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
        case 5:
          return Lh(b2), null;
        case 13:
          E$3(M$1);
          a = b2.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            if (null === b2.alternate)
              throw Error(p$5(340));
            Ig();
          }
          a = b2.flags;
          return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
        case 19:
          return E$3(M$1), null;
        case 4:
          return Jh(), null;
        case 10:
          return Rg(b2.type._context), null;
        case 22:
        case 23:
          return Ij(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Kj = false, U$1 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
    function Mj(a, b2) {
      var c2 = a.ref;
      if (null !== c2)
        if ("function" === typeof c2)
          try {
            c2(null);
          } catch (d2) {
            W$2(a, b2, d2);
          }
        else
          c2.current = null;
    }
    function Nj(a, b2, c2) {
      try {
        c2();
      } catch (d2) {
        W$2(a, b2, d2);
      }
    }
    var Oj = false;
    function Pj(a, b2) {
      Cf = dd;
      a = Me();
      if (Ne$1(a)) {
        if ("selectionStart" in a)
          var c2 = { start: a.selectionStart, end: a.selectionEnd };
        else
          a: {
            c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
            var d2 = c2.getSelection && c2.getSelection();
            if (d2 && 0 !== d2.rangeCount) {
              c2 = d2.anchorNode;
              var e2 = d2.anchorOffset, f2 = d2.focusNode;
              d2 = d2.focusOffset;
              try {
                c2.nodeType, f2.nodeType;
              } catch (F2) {
                c2 = null;
                break a;
              }
              var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
              b:
                for (; ; ) {
                  for (var y2; ; ) {
                    q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                    q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                    3 === q2.nodeType && (g2 += q2.nodeValue.length);
                    if (null === (y2 = q2.firstChild))
                      break;
                    r2 = q2;
                    q2 = y2;
                  }
                  for (; ; ) {
                    if (q2 === a)
                      break b;
                    r2 === c2 && ++l2 === e2 && (h2 = g2);
                    r2 === f2 && ++m2 === d2 && (k2 = g2);
                    if (null !== (y2 = q2.nextSibling))
                      break;
                    q2 = r2;
                    r2 = q2.parentNode;
                  }
                  q2 = y2;
                }
              c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
            } else
              c2 = null;
          }
        c2 = c2 || { start: 0, end: 0 };
      } else
        c2 = null;
      Df = { focusedElem: a, selectionRange: c2 };
      dd = false;
      for (V = b2; null !== V; )
        if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a)
          a.return = b2, V = a;
        else
          for (; null !== V; ) {
            b2 = V;
            try {
              var n2 = b2.alternate;
              if (0 !== (b2.flags & 1024))
                switch (b2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (null !== n2) {
                      var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                      x2.__reactInternalSnapshotBeforeUpdate = w2;
                    }
                    break;
                  case 3:
                    var u2 = b2.stateNode.containerInfo;
                    1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p$5(163));
                }
            } catch (F2) {
              W$2(b2, b2.return, F2);
            }
            a = b2.sibling;
            if (null !== a) {
              a.return = b2.return;
              V = a;
              break;
            }
            V = b2.return;
          }
      n2 = Oj;
      Oj = false;
      return n2;
    }
    function Qj(a, b2, c2) {
      var d2 = b2.updateQueue;
      d2 = null !== d2 ? d2.lastEffect : null;
      if (null !== d2) {
        var e2 = d2 = d2.next;
        do {
          if ((e2.tag & a) === a) {
            var f2 = e2.destroy;
            e2.destroy = void 0;
            void 0 !== f2 && Nj(b2, c2, f2);
          }
          e2 = e2.next;
        } while (e2 !== d2);
      }
    }
    function Rj(a, b2) {
      b2 = b2.updateQueue;
      b2 = null !== b2 ? b2.lastEffect : null;
      if (null !== b2) {
        var c2 = b2 = b2.next;
        do {
          if ((c2.tag & a) === a) {
            var d2 = c2.create;
            c2.destroy = d2();
          }
          c2 = c2.next;
        } while (c2 !== b2);
      }
    }
    function Sj(a) {
      var b2 = a.ref;
      if (null !== b2) {
        var c2 = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c2;
            break;
          default:
            a = c2;
        }
        "function" === typeof b2 ? b2(a) : b2.current = a;
      }
    }
    function Tj(a) {
      var b2 = a.alternate;
      null !== b2 && (a.alternate = null, Tj(b2));
      a.child = null;
      a.deletions = null;
      a.sibling = null;
      5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
      a.stateNode = null;
      a.return = null;
      a.dependencies = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.stateNode = null;
      a.updateQueue = null;
    }
    function Uj(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    function Vj(a) {
      a:
        for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Uj(a.return))
              return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2)
              continue a;
            if (null === a.child || 4 === a.tag)
              continue a;
            else
              a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2))
            return a.stateNode;
        }
    }
    function Wj(a, b2, c2) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2)
        a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
      else if (4 !== d2 && (a = a.child, null !== a))
        for (Wj(a, b2, c2), a = a.sibling; null !== a; )
          Wj(a, b2, c2), a = a.sibling;
    }
    function Xj(a, b2, c2) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2)
        a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
      else if (4 !== d2 && (a = a.child, null !== a))
        for (Xj(a, b2, c2), a = a.sibling; null !== a; )
          Xj(a, b2, c2), a = a.sibling;
    }
    var X = null, Yj = false;
    function Zj(a, b2, c2) {
      for (c2 = c2.child; null !== c2; )
        ak(a, b2, c2), c2 = c2.sibling;
    }
    function ak(a, b2, c2) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount)
        try {
          lc.onCommitFiberUnmount(kc, c2);
        } catch (h2) {
        }
      switch (c2.tag) {
        case 5:
          U$1 || Mj(c2, b2);
        case 6:
          var d2 = X, e2 = Yj;
          X = null;
          Zj(a, b2, c2);
          X = d2;
          Yj = e2;
          null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X.removeChild(c2.stateNode));
          break;
        case 18:
          null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X, c2.stateNode));
          break;
        case 4:
          d2 = X;
          e2 = Yj;
          X = c2.stateNode.containerInfo;
          Yj = true;
          Zj(a, b2, c2);
          X = d2;
          Yj = e2;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U$1 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
            e2 = d2 = d2.next;
            do {
              var f2 = e2, g2 = f2.destroy;
              f2 = f2.tag;
              void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
              e2 = e2.next;
            } while (e2 !== d2);
          }
          Zj(a, b2, c2);
          break;
        case 1:
          if (!U$1 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
            try {
              d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
            } catch (h2) {
              W$2(c2, b2, h2);
            }
          Zj(a, b2, c2);
          break;
        case 21:
          Zj(a, b2, c2);
          break;
        case 22:
          c2.mode & 1 ? (U$1 = (d2 = U$1) || null !== c2.memoizedState, Zj(a, b2, c2), U$1 = d2) : Zj(a, b2, c2);
          break;
        default:
          Zj(a, b2, c2);
      }
    }
    function bk(a) {
      var b2 = a.updateQueue;
      if (null !== b2) {
        a.updateQueue = null;
        var c2 = a.stateNode;
        null === c2 && (c2 = a.stateNode = new Lj());
        b2.forEach(function(b3) {
          var d2 = ck.bind(null, a, b3);
          c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
        });
      }
    }
    function dk(a, b2) {
      var c2 = b2.deletions;
      if (null !== c2)
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2];
          try {
            var f2 = a, g2 = b2, h2 = g2;
            a:
              for (; null !== h2; ) {
                switch (h2.tag) {
                  case 5:
                    X = h2.stateNode;
                    Yj = false;
                    break a;
                  case 3:
                    X = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                  case 4:
                    X = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                }
                h2 = h2.return;
              }
            if (null === X)
              throw Error(p$5(160));
            ak(f2, g2, e2);
            X = null;
            Yj = false;
            var k2 = e2.alternate;
            null !== k2 && (k2.return = null);
            e2.return = null;
          } catch (l2) {
            W$2(e2, b2, l2);
          }
        }
      if (b2.subtreeFlags & 12854)
        for (b2 = b2.child; null !== b2; )
          ek(b2, a), b2 = b2.sibling;
    }
    function ek(a, b2) {
      var c2 = a.alternate, d2 = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          dk(b2, a);
          fk(a);
          if (d2 & 4) {
            try {
              Qj(3, a, a.return), Rj(3, a);
            } catch (t2) {
              W$2(a, a.return, t2);
            }
            try {
              Qj(5, a, a.return);
            } catch (t2) {
              W$2(a, a.return, t2);
            }
          }
          break;
        case 1:
          dk(b2, a);
          fk(a);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          break;
        case 5:
          dk(b2, a);
          fk(a);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          if (a.flags & 32) {
            var e2 = a.stateNode;
            try {
              ob(e2, "");
            } catch (t2) {
              W$2(a, a.return, t2);
            }
          }
          if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
            var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
            a.updateQueue = null;
            if (null !== k2)
              try {
                "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
                vb(h2, g2);
                var l2 = vb(h2, f2);
                for (g2 = 0; g2 < k2.length; g2 += 2) {
                  var m2 = k2[g2], q2 = k2[g2 + 1];
                  "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
                }
                switch (h2) {
                  case "input":
                    bb(e2, f2);
                    break;
                  case "textarea":
                    ib(e2, f2);
                    break;
                  case "select":
                    var r2 = e2._wrapperState.wasMultiple;
                    e2._wrapperState.wasMultiple = !!f2.multiple;
                    var y2 = f2.value;
                    null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                      e2,
                      !!f2.multiple,
                      f2.defaultValue,
                      true
                    ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
                }
                e2[Pf] = f2;
              } catch (t2) {
                W$2(a, a.return, t2);
              }
          }
          break;
        case 6:
          dk(b2, a);
          fk(a);
          if (d2 & 4) {
            if (null === a.stateNode)
              throw Error(p$5(162));
            e2 = a.stateNode;
            f2 = a.memoizedProps;
            try {
              e2.nodeValue = f2;
            } catch (t2) {
              W$2(a, a.return, t2);
            }
          }
          break;
        case 3:
          dk(b2, a);
          fk(a);
          if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
            try {
              bd(b2.containerInfo);
            } catch (t2) {
              W$2(a, a.return, t2);
            }
          break;
        case 4:
          dk(b2, a);
          fk(a);
          break;
        case 13:
          dk(b2, a);
          fk(a);
          e2 = a.child;
          e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$2()));
          d2 & 4 && bk(a);
          break;
        case 22:
          m2 = null !== c2 && null !== c2.memoizedState;
          a.mode & 1 ? (U$1 = (l2 = U$1) || m2, dk(b2, a), U$1 = l2) : dk(b2, a);
          fk(a);
          if (d2 & 8192) {
            l2 = null !== a.memoizedState;
            if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
              for (V = a, m2 = a.child; null !== m2; ) {
                for (q2 = V = m2; null !== V; ) {
                  r2 = V;
                  y2 = r2.child;
                  switch (r2.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Qj(4, r2, r2.return);
                      break;
                    case 1:
                      Mj(r2, r2.return);
                      var n2 = r2.stateNode;
                      if ("function" === typeof n2.componentWillUnmount) {
                        d2 = r2;
                        c2 = r2.return;
                        try {
                          b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                        } catch (t2) {
                          W$2(d2, c2, t2);
                        }
                      }
                      break;
                    case 5:
                      Mj(r2, r2.return);
                      break;
                    case 22:
                      if (null !== r2.memoizedState) {
                        hk(q2);
                        continue;
                      }
                  }
                  null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
                }
                m2 = m2.sibling;
              }
            a:
              for (m2 = null, q2 = a; ; ) {
                if (5 === q2.tag) {
                  if (null === m2) {
                    m2 = q2;
                    try {
                      e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                    } catch (t2) {
                      W$2(a, a.return, t2);
                    }
                  }
                } else if (6 === q2.tag) {
                  if (null === m2)
                    try {
                      q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                    } catch (t2) {
                      W$2(a, a.return, t2);
                    }
                } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
                  q2.child.return = q2;
                  q2 = q2.child;
                  continue;
                }
                if (q2 === a)
                  break a;
                for (; null === q2.sibling; ) {
                  if (null === q2.return || q2.return === a)
                    break a;
                  m2 === q2 && (m2 = null);
                  q2 = q2.return;
                }
                m2 === q2 && (m2 = null);
                q2.sibling.return = q2.return;
                q2 = q2.sibling;
              }
          }
          break;
        case 19:
          dk(b2, a);
          fk(a);
          d2 & 4 && bk(a);
          break;
        case 21:
          break;
        default:
          dk(
            b2,
            a
          ), fk(a);
      }
    }
    function fk(a) {
      var b2 = a.flags;
      if (b2 & 2) {
        try {
          a: {
            for (var c2 = a.return; null !== c2; ) {
              if (Uj(c2)) {
                var d2 = c2;
                break a;
              }
              c2 = c2.return;
            }
            throw Error(p$5(160));
          }
          switch (d2.tag) {
            case 5:
              var e2 = d2.stateNode;
              d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
              var f2 = Vj(a);
              Xj(a, f2, e2);
              break;
            case 3:
            case 4:
              var g2 = d2.stateNode.containerInfo, h2 = Vj(a);
              Wj(a, h2, g2);
              break;
            default:
              throw Error(p$5(161));
          }
        } catch (k2) {
          W$2(a, a.return, k2);
        }
        a.flags &= -3;
      }
      b2 & 4096 && (a.flags &= -4097);
    }
    function ik(a, b2, c2) {
      V = a;
      jk(a);
    }
    function jk(a, b2, c2) {
      for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
        var e2 = V, f2 = e2.child;
        if (22 === e2.tag && d2) {
          var g2 = null !== e2.memoizedState || Kj;
          if (!g2) {
            var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$1;
            h2 = Kj;
            var l2 = U$1;
            Kj = g2;
            if ((U$1 = k2) && !l2)
              for (V = e2; null !== V; )
                g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V = k2) : kk(e2);
            for (; null !== f2; )
              V = f2, jk(f2), f2 = f2.sibling;
            V = e2;
            Kj = h2;
            U$1 = l2;
          }
          lk(a);
        } else
          0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : lk(a);
      }
    }
    function lk(a) {
      for (; null !== V; ) {
        var b2 = V;
        if (0 !== (b2.flags & 8772)) {
          var c2 = b2.alternate;
          try {
            if (0 !== (b2.flags & 8772))
              switch (b2.tag) {
                case 0:
                case 11:
                case 15:
                  U$1 || Rj(5, b2);
                  break;
                case 1:
                  var d2 = b2.stateNode;
                  if (b2.flags & 4 && !U$1)
                    if (null === c2)
                      d2.componentDidMount();
                    else {
                      var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                      d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                    }
                  var f2 = b2.updateQueue;
                  null !== f2 && ih(b2, f2, d2);
                  break;
                case 3:
                  var g2 = b2.updateQueue;
                  if (null !== g2) {
                    c2 = null;
                    if (null !== b2.child)
                      switch (b2.child.tag) {
                        case 5:
                          c2 = b2.child.stateNode;
                          break;
                        case 1:
                          c2 = b2.child.stateNode;
                      }
                    ih(b2, g2, c2);
                  }
                  break;
                case 5:
                  var h2 = b2.stateNode;
                  if (null === c2 && b2.flags & 4) {
                    c2 = h2;
                    var k2 = b2.memoizedProps;
                    switch (b2.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k2.autoFocus && c2.focus();
                        break;
                      case "img":
                        k2.src && (c2.src = k2.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b2.memoizedState) {
                    var l2 = b2.alternate;
                    if (null !== l2) {
                      var m2 = l2.memoizedState;
                      if (null !== m2) {
                        var q2 = m2.dehydrated;
                        null !== q2 && bd(q2);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p$5(163));
              }
            U$1 || b2.flags & 512 && Sj(b2);
          } catch (r2) {
            W$2(b2, b2.return, r2);
          }
        }
        if (b2 === a) {
          V = null;
          break;
        }
        c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V = c2;
          break;
        }
        V = b2.return;
      }
    }
    function hk(a) {
      for (; null !== V; ) {
        var b2 = V;
        if (b2 === a) {
          V = null;
          break;
        }
        var c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V = c2;
          break;
        }
        V = b2.return;
      }
    }
    function kk(a) {
      for (; null !== V; ) {
        var b2 = V;
        try {
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              var c2 = b2.return;
              try {
                Rj(4, b2);
              } catch (k2) {
                W$2(b2, c2, k2);
              }
              break;
            case 1:
              var d2 = b2.stateNode;
              if ("function" === typeof d2.componentDidMount) {
                var e2 = b2.return;
                try {
                  d2.componentDidMount();
                } catch (k2) {
                  W$2(b2, e2, k2);
                }
              }
              var f2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W$2(b2, f2, k2);
              }
              break;
            case 5:
              var g2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W$2(b2, g2, k2);
              }
          }
        } catch (k2) {
          W$2(b2, b2.return, k2);
        }
        if (b2 === a) {
          V = null;
          break;
        }
        var h2 = b2.sibling;
        if (null !== h2) {
          h2.return = b2.return;
          V = h2;
          break;
        }
        V = b2.return;
      }
    }
    var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok$1 = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T$1 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi$1 = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
    function L$1() {
      return 0 !== (K & 6) ? B$2() : -1 !== Bk ? Bk : Bk = B$2();
    }
    function lh(a) {
      if (0 === (a.mode & 1))
        return 1;
      if (0 !== (K & 2) && 0 !== Z)
        return Z & -Z;
      if (null !== Kg.transition)
        return 0 === Ck && (Ck = yc()), Ck;
      a = C$1;
      if (0 !== a)
        return a;
      a = window.event;
      a = void 0 === a ? 16 : jd(a.type);
      return a;
    }
    function mh(a, b2, c2, d2) {
      if (50 < zk)
        throw zk = 0, Ak = null, Error(p$5(185));
      Ac(a, c2, d2);
      if (0 === (K & 2) || a !== R)
        a === R && (0 === (K & 2) && (rk |= c2), 4 === T$1 && Dk(a, Z)), Ek(a, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Hj = B$2() + 500, fg && jg());
    }
    function Ek(a, b2) {
      var c2 = a.callbackNode;
      wc(a, b2);
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2)
        null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
      else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
        null != c2 && bc(c2);
        if (1 === b2)
          0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
            0 === (K & 6) && jg();
          }), c2 = null;
        else {
          switch (Dc(d2)) {
            case 1:
              c2 = fc;
              break;
            case 4:
              c2 = gc;
              break;
            case 16:
              c2 = hc;
              break;
            case 536870912:
              c2 = jc;
              break;
            default:
              c2 = hc;
          }
          c2 = Gk(c2, Hk.bind(null, a));
        }
        a.callbackPriority = b2;
        a.callbackNode = c2;
      }
    }
    function Hk(a, b2) {
      Bk = -1;
      Ck = 0;
      if (0 !== (K & 6))
        throw Error(p$5(327));
      var c2 = a.callbackNode;
      if (Ik() && a.callbackNode !== c2)
        return null;
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2)
        return null;
      if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2)
        b2 = Jk(a, d2);
      else {
        b2 = d2;
        var e2 = K;
        K |= 2;
        var f2 = Kk();
        if (R !== a || Z !== b2)
          vk = null, Hj = B$2() + 500, Lk(a, b2);
        do
          try {
            Mk();
            break;
          } catch (h2) {
            Nk(a, h2);
          }
        while (1);
        Qg();
        nk.current = f2;
        K = e2;
        null !== Y ? b2 = 0 : (R = null, Z = 0, b2 = T$1);
      }
      if (0 !== b2) {
        2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Ok(a, e2)));
        if (1 === b2)
          throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B$2()), c2;
        if (6 === b2)
          Dk(a, d2);
        else {
          e2 = a.current.alternate;
          if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Ok(a, f2))), 1 === b2))
            throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B$2()), c2;
          a.finishedWork = e2;
          a.finishedLanes = d2;
          switch (b2) {
            case 0:
            case 1:
              throw Error(p$5(345));
            case 2:
              Qk(a, uk, vk);
              break;
            case 3:
              Dk(a, d2);
              if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$2(), 10 < b2)) {
                if (0 !== uc(a, 0))
                  break;
                e2 = a.suspendedLanes;
                if ((e2 & d2) !== d2) {
                  L$1();
                  a.pingedLanes |= a.suspendedLanes & e2;
                  break;
                }
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b2);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 4:
              Dk(a, d2);
              if ((d2 & 4194240) === d2)
                break;
              b2 = a.eventTimes;
              for (e2 = -1; 0 < d2; ) {
                var g2 = 31 - oc(d2);
                f2 = 1 << g2;
                g2 = b2[g2];
                g2 > e2 && (e2 = g2);
                d2 &= ~f2;
              }
              d2 = e2;
              d2 = B$2() - d2;
              d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
              if (10 < d2) {
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d2);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 5:
              Qk(a, uk, vk);
              break;
            default:
              throw Error(p$5(329));
          }
        }
      }
      Ek(a, B$2());
      return a.callbackNode === c2 ? Hk.bind(null, a) : null;
    }
    function Ok(a, b2) {
      var c2 = tk;
      a.current.memoizedState.isDehydrated && (Lk(a, b2).flags |= 256);
      a = Jk(a, b2);
      2 !== a && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
      return a;
    }
    function Gj(a) {
      null === uk ? uk = a : uk.push.apply(uk, a);
    }
    function Pk(a) {
      for (var b2 = a; ; ) {
        if (b2.flags & 16384) {
          var c2 = b2.updateQueue;
          if (null !== c2 && (c2 = c2.stores, null !== c2))
            for (var d2 = 0; d2 < c2.length; d2++) {
              var e2 = c2[d2], f2 = e2.getSnapshot;
              e2 = e2.value;
              try {
                if (!He(f2(), e2))
                  return false;
              } catch (g2) {
                return false;
              }
            }
        }
        c2 = b2.child;
        if (b2.subtreeFlags & 16384 && null !== c2)
          c2.return = b2, b2 = c2;
        else {
          if (b2 === a)
            break;
          for (; null === b2.sibling; ) {
            if (null === b2.return || b2.return === a)
              return true;
            b2 = b2.return;
          }
          b2.sibling.return = b2.return;
          b2 = b2.sibling;
        }
      }
      return true;
    }
    function Dk(a, b2) {
      b2 &= ~sk;
      b2 &= ~rk;
      a.suspendedLanes |= b2;
      a.pingedLanes &= ~b2;
      for (a = a.expirationTimes; 0 < b2; ) {
        var c2 = 31 - oc(b2), d2 = 1 << c2;
        a[c2] = -1;
        b2 &= ~d2;
      }
    }
    function Fk(a) {
      if (0 !== (K & 6))
        throw Error(p$5(327));
      Ik();
      var b2 = uc(a, 0);
      if (0 === (b2 & 1))
        return Ek(a, B$2()), null;
      var c2 = Jk(a, b2);
      if (0 !== a.tag && 2 === c2) {
        var d2 = xc(a);
        0 !== d2 && (b2 = d2, c2 = Ok(a, d2));
      }
      if (1 === c2)
        throw c2 = qk, Lk(a, 0), Dk(a, b2), Ek(a, B$2()), c2;
      if (6 === c2)
        throw Error(p$5(345));
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b2;
      Qk(a, uk, vk);
      Ek(a, B$2());
      return null;
    }
    function Rk(a, b2) {
      var c2 = K;
      K |= 1;
      try {
        return a(b2);
      } finally {
        K = c2, 0 === K && (Hj = B$2() + 500, fg && jg());
      }
    }
    function Sk(a) {
      null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
      var b2 = K;
      K |= 1;
      var c2 = pk.transition, d2 = C$1;
      try {
        if (pk.transition = null, C$1 = 1, a)
          return a();
      } finally {
        C$1 = d2, pk.transition = c2, K = b2, 0 === (K & 6) && jg();
      }
    }
    function Ij() {
      gj = fj.current;
      E$3(fj);
    }
    function Lk(a, b2) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c2 = a.timeoutHandle;
      -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
      if (null !== Y)
        for (c2 = Y.return; null !== c2; ) {
          var d2 = c2;
          wg(d2);
          switch (d2.tag) {
            case 1:
              d2 = d2.type.childContextTypes;
              null !== d2 && void 0 !== d2 && $f();
              break;
            case 3:
              Jh();
              E$3(Wf);
              E$3(H$3);
              Oh();
              break;
            case 5:
              Lh(d2);
              break;
            case 4:
              Jh();
              break;
            case 13:
              E$3(M$1);
              break;
            case 19:
              E$3(M$1);
              break;
            case 10:
              Rg(d2.type._context);
              break;
            case 22:
            case 23:
              Ij();
          }
          c2 = c2.return;
        }
      R = a;
      Y = a = wh(a.current, null);
      Z = gj = b2;
      T$1 = 0;
      qk = null;
      sk = rk = hh = 0;
      uk = tk = null;
      if (null !== Wg) {
        for (b2 = 0; b2 < Wg.length; b2++)
          if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
            c2.interleaved = null;
            var e2 = d2.next, f2 = c2.pending;
            if (null !== f2) {
              var g2 = f2.next;
              f2.next = e2;
              d2.next = g2;
            }
            c2.pending = d2;
          }
        Wg = null;
      }
      return a;
    }
    function Nk(a, b2) {
      do {
        var c2 = Y;
        try {
          Qg();
          Ph.current = ai;
          if (Sh) {
            for (var d2 = N$1.memoizedState; null !== d2; ) {
              var e2 = d2.queue;
              null !== e2 && (e2.pending = null);
              d2 = d2.next;
            }
            Sh = false;
          }
          Rh = 0;
          P = O$1 = N$1 = null;
          Th = false;
          Uh = 0;
          ok$1.current = null;
          if (null === c2 || null === c2.return) {
            T$1 = 1;
            qk = b2;
            Y = null;
            break;
          }
          a: {
            var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
            b2 = Z;
            h2.flags |= 32768;
            if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
              var l2 = k2, m2 = h2, q2 = m2.tag;
              if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
                var r2 = m2.alternate;
                r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
              }
              var y2 = Vi(g2);
              if (null !== y2) {
                y2.flags &= -257;
                Wi(y2, g2, h2, f2, b2);
                y2.mode & 1 && Ti(f2, l2, b2);
                b2 = y2;
                k2 = l2;
                var n2 = b2.updateQueue;
                if (null === n2) {
                  var t2 = /* @__PURE__ */ new Set();
                  t2.add(k2);
                  b2.updateQueue = t2;
                } else
                  n2.add(k2);
                break a;
              } else {
                if (0 === (b2 & 1)) {
                  Ti(f2, l2, b2);
                  uj();
                  break a;
                }
                k2 = Error(p$5(426));
              }
            } else if (I$1 && h2.mode & 1) {
              var J2 = Vi(g2);
              if (null !== J2) {
                0 === (J2.flags & 65536) && (J2.flags |= 256);
                Wi(J2, g2, h2, f2, b2);
                Jg(Ki(k2, h2));
                break a;
              }
            }
            f2 = k2 = Ki(k2, h2);
            4 !== T$1 && (T$1 = 2);
            null === tk ? tk = [f2] : tk.push(f2);
            f2 = g2;
            do {
              switch (f2.tag) {
                case 3:
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var x2 = Oi$1(f2, k2, b2);
                  fh(f2, x2);
                  break a;
                case 1:
                  h2 = k2;
                  var w2 = f2.type, u2 = f2.stateNode;
                  if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                    f2.flags |= 65536;
                    b2 &= -b2;
                    f2.lanes |= b2;
                    var F2 = Ri(f2, h2, b2);
                    fh(f2, F2);
                    break a;
                  }
              }
              f2 = f2.return;
            } while (null !== f2);
          }
          Tk(c2);
        } catch (na) {
          b2 = na;
          Y === c2 && null !== c2 && (Y = c2 = c2.return);
          continue;
        }
        break;
      } while (1);
    }
    function Kk() {
      var a = nk.current;
      nk.current = ai;
      return null === a ? ai : a;
    }
    function uj() {
      if (0 === T$1 || 3 === T$1 || 2 === T$1)
        T$1 = 4;
      null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
    }
    function Jk(a, b2) {
      var c2 = K;
      K |= 2;
      var d2 = Kk();
      if (R !== a || Z !== b2)
        vk = null, Lk(a, b2);
      do
        try {
          Uk();
          break;
        } catch (e2) {
          Nk(a, e2);
        }
      while (1);
      Qg();
      K = c2;
      nk.current = d2;
      if (null !== Y)
        throw Error(p$5(261));
      R = null;
      Z = 0;
      return T$1;
    }
    function Uk() {
      for (; null !== Y; )
        Vk(Y);
    }
    function Mk() {
      for (; null !== Y && !cc(); )
        Vk(Y);
    }
    function Vk(a) {
      var b2 = Wk(a.alternate, a, gj);
      a.memoizedProps = a.pendingProps;
      null === b2 ? Tk(a) : Y = b2;
      ok$1.current = null;
    }
    function Tk(a) {
      var b2 = a;
      do {
        var c2 = b2.alternate;
        a = b2.return;
        if (0 === (b2.flags & 32768)) {
          if (c2 = Fj(c2, b2, gj), null !== c2) {
            Y = c2;
            return;
          }
        } else {
          c2 = Jj(c2, b2);
          if (null !== c2) {
            c2.flags &= 32767;
            Y = c2;
            return;
          }
          if (null !== a)
            a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T$1 = 6;
            Y = null;
            return;
          }
        }
        b2 = b2.sibling;
        if (null !== b2) {
          Y = b2;
          return;
        }
        Y = b2 = a;
      } while (null !== b2);
      0 === T$1 && (T$1 = 5);
    }
    function Qk(a, b2, c2) {
      var d2 = C$1, e2 = pk.transition;
      try {
        pk.transition = null, C$1 = 1, Xk(a, b2, c2, d2);
      } finally {
        pk.transition = e2, C$1 = d2;
      }
      return null;
    }
    function Xk(a, b2, c2, d2) {
      do
        Ik();
      while (null !== xk);
      if (0 !== (K & 6))
        throw Error(p$5(327));
      c2 = a.finishedWork;
      var e2 = a.finishedLanes;
      if (null === c2)
        return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c2 === a.current)
        throw Error(p$5(177));
      a.callbackNode = null;
      a.callbackPriority = 0;
      var f2 = c2.lanes | c2.childLanes;
      Bc(a, f2);
      a === R && (Y = R = null, Z = 0);
      0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
        Ik();
        return null;
      }));
      f2 = 0 !== (c2.flags & 15990);
      if (0 !== (c2.subtreeFlags & 15990) || f2) {
        f2 = pk.transition;
        pk.transition = null;
        var g2 = C$1;
        C$1 = 1;
        var h2 = K;
        K |= 4;
        ok$1.current = null;
        Pj(a, c2);
        ek(c2, a);
        Oe$1(Df);
        dd = !!Cf;
        Df = Cf = null;
        a.current = c2;
        ik(c2);
        dc();
        K = h2;
        C$1 = g2;
        pk.transition = f2;
      } else
        a.current = c2;
      wk && (wk = false, xk = a, yk = e2);
      f2 = a.pendingLanes;
      0 === f2 && (Si = null);
      mc(c2.stateNode);
      Ek(a, B$2());
      if (null !== b2)
        for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
          e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
      if (Pi$1)
        throw Pi$1 = false, a = Qi, Qi = null, a;
      0 !== (yk & 1) && 0 !== a.tag && Ik();
      f2 = a.pendingLanes;
      0 !== (f2 & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
      jg();
      return null;
    }
    function Ik() {
      if (null !== xk) {
        var a = Dc(yk), b2 = pk.transition, c2 = C$1;
        try {
          pk.transition = null;
          C$1 = 16 > a ? 16 : a;
          if (null === xk)
            var d2 = false;
          else {
            a = xk;
            xk = null;
            yk = 0;
            if (0 !== (K & 6))
              throw Error(p$5(331));
            var e2 = K;
            K |= 4;
            for (V = a.current; null !== V; ) {
              var f2 = V, g2 = f2.child;
              if (0 !== (V.flags & 16)) {
                var h2 = f2.deletions;
                if (null !== h2) {
                  for (var k2 = 0; k2 < h2.length; k2++) {
                    var l2 = h2[k2];
                    for (V = l2; null !== V; ) {
                      var m2 = V;
                      switch (m2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(8, m2, f2);
                      }
                      var q2 = m2.child;
                      if (null !== q2)
                        q2.return = m2, V = q2;
                      else
                        for (; null !== V; ) {
                          m2 = V;
                          var r2 = m2.sibling, y2 = m2.return;
                          Tj(m2);
                          if (m2 === l2) {
                            V = null;
                            break;
                          }
                          if (null !== r2) {
                            r2.return = y2;
                            V = r2;
                            break;
                          }
                          V = y2;
                        }
                    }
                  }
                  var n2 = f2.alternate;
                  if (null !== n2) {
                    var t2 = n2.child;
                    if (null !== t2) {
                      n2.child = null;
                      do {
                        var J2 = t2.sibling;
                        t2.sibling = null;
                        t2 = J2;
                      } while (null !== t2);
                    }
                  }
                  V = f2;
                }
              }
              if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
                g2.return = f2, V = g2;
              else
                b:
                  for (; null !== V; ) {
                    f2 = V;
                    if (0 !== (f2.flags & 2048))
                      switch (f2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(9, f2, f2.return);
                      }
                    var x2 = f2.sibling;
                    if (null !== x2) {
                      x2.return = f2.return;
                      V = x2;
                      break b;
                    }
                    V = f2.return;
                  }
            }
            var w2 = a.current;
            for (V = w2; null !== V; ) {
              g2 = V;
              var u2 = g2.child;
              if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
                u2.return = g2, V = u2;
              else
                b:
                  for (g2 = w2; null !== V; ) {
                    h2 = V;
                    if (0 !== (h2.flags & 2048))
                      try {
                        switch (h2.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Rj(9, h2);
                        }
                      } catch (na) {
                        W$2(h2, h2.return, na);
                      }
                    if (h2 === g2) {
                      V = null;
                      break b;
                    }
                    var F2 = h2.sibling;
                    if (null !== F2) {
                      F2.return = h2.return;
                      V = F2;
                      break b;
                    }
                    V = h2.return;
                  }
            }
            K = e2;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot)
              try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
            d2 = true;
          }
          return d2;
        } finally {
          C$1 = c2, pk.transition = b2;
        }
      }
      return false;
    }
    function Yk(a, b2, c2) {
      b2 = Ki(c2, b2);
      b2 = Oi$1(a, b2, 1);
      a = dh(a, b2, 1);
      b2 = L$1();
      null !== a && (Ac(a, 1, b2), Ek(a, b2));
    }
    function W$2(a, b2, c2) {
      if (3 === a.tag)
        Yk(a, a, c2);
      else
        for (; null !== b2; ) {
          if (3 === b2.tag) {
            Yk(b2, a, c2);
            break;
          } else if (1 === b2.tag) {
            var d2 = b2.stateNode;
            if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
              a = Ki(c2, a);
              a = Ri(b2, a, 1);
              b2 = dh(b2, a, 1);
              a = L$1();
              null !== b2 && (Ac(b2, 1, a), Ek(b2, a));
              break;
            }
          }
          b2 = b2.return;
        }
    }
    function Ui(a, b2, c2) {
      var d2 = a.pingCache;
      null !== d2 && d2.delete(b2);
      b2 = L$1();
      a.pingedLanes |= a.suspendedLanes & c2;
      R === a && (Z & c2) === c2 && (4 === T$1 || 3 === T$1 && (Z & 130023424) === Z && 500 > B$2() - gk ? Lk(a, 0) : sk |= c2);
      Ek(a, b2);
    }
    function Zk(a, b2) {
      0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c2 = L$1();
      a = Zg(a, b2);
      null !== a && (Ac(a, b2, c2), Ek(a, c2));
    }
    function vj(a) {
      var b2 = a.memoizedState, c2 = 0;
      null !== b2 && (c2 = b2.retryLane);
      Zk(a, c2);
    }
    function ck(a, b2) {
      var c2 = 0;
      switch (a.tag) {
        case 13:
          var d2 = a.stateNode;
          var e2 = a.memoizedState;
          null !== e2 && (c2 = e2.retryLane);
          break;
        case 19:
          d2 = a.stateNode;
          break;
        default:
          throw Error(p$5(314));
      }
      null !== d2 && d2.delete(b2);
      Zk(a, c2);
    }
    var Wk;
    Wk = function(a, b2, c2) {
      if (null !== a)
        if (a.memoizedProps !== b2.pendingProps || Wf.current)
          Ug = true;
        else {
          if (0 === (a.lanes & c2) && 0 === (b2.flags & 128))
            return Ug = false, zj(a, b2, c2);
          Ug = 0 !== (a.flags & 131072) ? true : false;
        }
      else
        Ug = false, I$1 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
      b2.lanes = 0;
      switch (b2.tag) {
        case 2:
          var d2 = b2.type;
          jj(a, b2);
          a = b2.pendingProps;
          var e2 = Yf(b2, H$3.current);
          Tg(b2, c2);
          e2 = Xh(null, b2, d2, a, e2, c2);
          var f2 = bi();
          b2.flags |= 1;
          "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$1 && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
          return b2;
        case 16:
          d2 = b2.elementType;
          a: {
            jj(a, b2);
            a = b2.pendingProps;
            e2 = d2._init;
            d2 = e2(d2._payload);
            b2.type = d2;
            e2 = b2.tag = $k(d2);
            a = Lg(d2, a);
            switch (e2) {
              case 0:
                b2 = dj(null, b2, d2, a, c2);
                break a;
              case 1:
                b2 = ij(null, b2, d2, a, c2);
                break a;
              case 11:
                b2 = Zi(null, b2, d2, a, c2);
                break a;
              case 14:
                b2 = aj(null, b2, d2, Lg(d2.type, a), c2);
                break a;
            }
            throw Error(p$5(
              306,
              d2,
              ""
            ));
          }
          return b2;
        case 0:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a, b2, d2, e2, c2);
        case 1:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a, b2, d2, e2, c2);
        case 3:
          a: {
            lj(b2);
            if (null === a)
              throw Error(p$5(387));
            d2 = b2.pendingProps;
            f2 = b2.memoizedState;
            e2 = f2.element;
            bh(a, b2);
            gh(b2, d2, null, c2);
            var g2 = b2.memoizedState;
            d2 = g2.element;
            if (f2.isDehydrated)
              if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
                e2 = Ki(Error(p$5(423)), b2);
                b2 = mj(a, b2, d2, c2, e2);
                break a;
              } else if (d2 !== e2) {
                e2 = Ki(Error(p$5(424)), b2);
                b2 = mj(a, b2, d2, c2, e2);
                break a;
              } else
                for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$1 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
                  c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
            else {
              Ig();
              if (d2 === e2) {
                b2 = $i(a, b2, c2);
                break a;
              }
              Yi(a, b2, d2, c2);
            }
            b2 = b2.child;
          }
          return b2;
        case 5:
          return Kh(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a, b2), Yi(a, b2, g2, c2), b2.child;
        case 6:
          return null === a && Eg(b2), null;
        case 13:
          return pj(a, b2, c2);
        case 4:
          return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Bh(b2, null, d2, c2) : Yi(a, b2, d2, c2), b2.child;
        case 11:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a, b2, d2, e2, c2);
        case 7:
          return Yi(a, b2, b2.pendingProps, c2), b2.child;
        case 8:
          return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
        case 12:
          return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
        case 10:
          a: {
            d2 = b2.type._context;
            e2 = b2.pendingProps;
            f2 = b2.memoizedProps;
            g2 = e2.value;
            G$1(Mg, d2._currentValue);
            d2._currentValue = g2;
            if (null !== f2)
              if (He(f2.value, g2)) {
                if (f2.children === e2.children && !Wf.current) {
                  b2 = $i(a, b2, c2);
                  break a;
                }
              } else
                for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
                  var h2 = f2.dependencies;
                  if (null !== h2) {
                    g2 = f2.child;
                    for (var k2 = h2.firstContext; null !== k2; ) {
                      if (k2.context === d2) {
                        if (1 === f2.tag) {
                          k2 = ch(-1, c2 & -c2);
                          k2.tag = 2;
                          var l2 = f2.updateQueue;
                          if (null !== l2) {
                            l2 = l2.shared;
                            var m2 = l2.pending;
                            null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                            l2.pending = k2;
                          }
                        }
                        f2.lanes |= c2;
                        k2 = f2.alternate;
                        null !== k2 && (k2.lanes |= c2);
                        Sg(
                          f2.return,
                          c2,
                          b2
                        );
                        h2.lanes |= c2;
                        break;
                      }
                      k2 = k2.next;
                    }
                  } else if (10 === f2.tag)
                    g2 = f2.type === b2.type ? null : f2.child;
                  else if (18 === f2.tag) {
                    g2 = f2.return;
                    if (null === g2)
                      throw Error(p$5(341));
                    g2.lanes |= c2;
                    h2 = g2.alternate;
                    null !== h2 && (h2.lanes |= c2);
                    Sg(g2, c2, b2);
                    g2 = f2.sibling;
                  } else
                    g2 = f2.child;
                  if (null !== g2)
                    g2.return = f2;
                  else
                    for (g2 = f2; null !== g2; ) {
                      if (g2 === b2) {
                        g2 = null;
                        break;
                      }
                      f2 = g2.sibling;
                      if (null !== f2) {
                        f2.return = g2.return;
                        g2 = f2;
                        break;
                      }
                      g2 = g2.return;
                    }
                  f2 = g2;
                }
            Yi(a, b2, e2.children, c2);
            b2 = b2.child;
          }
          return b2;
        case 9:
          return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a, b2, d2, c2), b2.child;
        case 14:
          return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a, b2, d2, e2, c2);
        case 15:
          return cj(a, b2, b2.type, b2.pendingProps, c2);
        case 17:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a, c2);
        case 19:
          return yj(a, b2, c2);
        case 22:
          return ej(a, b2, c2);
      }
      throw Error(p$5(156, b2.tag));
    };
    function Gk(a, b2) {
      return ac(a, b2);
    }
    function al(a, b2, c2, d2) {
      this.tag = a;
      this.key = c2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b2;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d2;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a, b2, c2, d2) {
      return new al(a, b2, c2, d2);
    }
    function bj(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    function $k(a) {
      if ("function" === typeof a)
        return bj(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === Da)
          return 11;
        if (a === Ga)
          return 14;
      }
      return 2;
    }
    function wh(a, b2) {
      var c2 = a.alternate;
      null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
      c2.flags = a.flags & 14680064;
      c2.childLanes = a.childLanes;
      c2.lanes = a.lanes;
      c2.child = a.child;
      c2.memoizedProps = a.memoizedProps;
      c2.memoizedState = a.memoizedState;
      c2.updateQueue = a.updateQueue;
      b2 = a.dependencies;
      c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
      c2.sibling = a.sibling;
      c2.index = a.index;
      c2.ref = a.ref;
      return c2;
    }
    function yh(a, b2, c2, d2, e2, f2) {
      var g2 = 2;
      d2 = a;
      if ("function" === typeof a)
        bj(a) && (g2 = 1);
      else if ("string" === typeof a)
        g2 = 5;
      else
        a:
          switch (a) {
            case ya$1:
              return Ah(c2.children, e2, f2, b2);
            case za:
              g2 = 8;
              e2 |= 8;
              break;
            case Aa:
              return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
            case Ea$2:
              return a = Bg(13, c2, b2, e2), a.elementType = Ea$2, a.lanes = f2, a;
            case Fa$1:
              return a = Bg(19, c2, b2, e2), a.elementType = Fa$1, a.lanes = f2, a;
            case Ia$1:
              return qj(c2, e2, f2, b2);
            default:
              if ("object" === typeof a && null !== a)
                switch (a.$$typeof) {
                  case Ba:
                    g2 = 10;
                    break a;
                  case Ca$2:
                    g2 = 9;
                    break a;
                  case Da:
                    g2 = 11;
                    break a;
                  case Ga:
                    g2 = 14;
                    break a;
                  case Ha$1:
                    g2 = 16;
                    d2 = null;
                    break a;
                }
              throw Error(p$5(130, null == a ? a : typeof a, ""));
          }
      b2 = Bg(g2, c2, b2, e2);
      b2.elementType = a;
      b2.type = d2;
      b2.lanes = f2;
      return b2;
    }
    function Ah(a, b2, c2, d2) {
      a = Bg(7, a, d2, b2);
      a.lanes = c2;
      return a;
    }
    function qj(a, b2, c2, d2) {
      a = Bg(22, a, d2, b2);
      a.elementType = Ia$1;
      a.lanes = c2;
      a.stateNode = { isHidden: false };
      return a;
    }
    function xh(a, b2, c2) {
      a = Bg(6, a, null, b2);
      a.lanes = c2;
      return a;
    }
    function zh(a, b2, c2) {
      b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
      b2.lanes = c2;
      b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
      return b2;
    }
    function bl(a, b2, c2, d2, e2) {
      this.tag = b2;
      this.containerInfo = a;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d2;
      this.onRecoverableError = e2;
      this.mutableSourceEagerHydrationData = null;
    }
    function cl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      a = new bl(a, b2, c2, h2, k2);
      1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
      f2 = Bg(3, null, null, b2);
      a.current = f2;
      f2.stateNode = a;
      f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      ah(f2);
      return a;
    }
    function dl(a, b2, c2) {
      var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
    }
    function el$1(a) {
      if (!a)
        return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || 1 !== a.tag)
          throw Error(p$5(170));
        var b2 = a;
        do {
          switch (b2.tag) {
            case 3:
              b2 = b2.stateNode.context;
              break a;
            case 1:
              if (Zf(b2.type)) {
                b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b2 = b2.return;
        } while (null !== b2);
        throw Error(p$5(171));
      }
      if (1 === a.tag) {
        var c2 = a.type;
        if (Zf(c2))
          return bg(a, c2, b2);
      }
      return b2;
    }
    function fl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      a = cl(c2, d2, true, a, e2, f2, g2, h2, k2);
      a.context = el$1(null);
      c2 = a.current;
      d2 = L$1();
      e2 = lh(c2);
      f2 = ch(d2, e2);
      f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
      dh(c2, f2, e2);
      a.current.lanes = e2;
      Ac(a, e2, d2);
      Ek(a, d2);
      return a;
    }
    function gl(a, b2, c2, d2) {
      var e2 = b2.current, f2 = L$1(), g2 = lh(e2);
      c2 = el$1(c2);
      null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
      b2 = ch(f2, g2);
      b2.payload = { element: a };
      d2 = void 0 === d2 ? null : d2;
      null !== d2 && (b2.callback = d2);
      a = dh(e2, b2, g2);
      null !== a && (mh(a, e2, g2, f2), eh(a, e2, g2));
      return g2;
    }
    function hl(a) {
      a = a.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function il(a, b2) {
      a = a.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        var c2 = a.retryLane;
        a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
      }
    }
    function jl(a, b2) {
      il(a, b2);
      (a = a.alternate) && il(a, b2);
    }
    function kl() {
      return null;
    }
    var ll = "function" === typeof reportError ? reportError : function(a) {
      console.error(a);
    };
    function ml(a) {
      this._internalRoot = a;
    }
    nl.prototype.render = ml.prototype.render = function(a) {
      var b2 = this._internalRoot;
      if (null === b2)
        throw Error(p$5(409));
      gl(a, b2, null, null);
    };
    nl.prototype.unmount = ml.prototype.unmount = function() {
      var a = this._internalRoot;
      if (null !== a) {
        this._internalRoot = null;
        var b2 = a.containerInfo;
        Sk(function() {
          gl(null, a, null, null);
        });
        b2[uf$1] = null;
      }
    };
    function nl(a) {
      this._internalRoot = a;
    }
    nl.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b2 = Hc();
        a = { blockedOn: null, target: a, priority: b2 };
        for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
          ;
        Qc.splice(c2, 0, a);
        0 === c2 && Vc(a);
      }
    };
    function ol(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
    }
    function pl(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    function ql() {
    }
    function rl(a, b2, c2, d2, e2) {
      if (e2) {
        if ("function" === typeof d2) {
          var f2 = d2;
          d2 = function() {
            var a2 = hl(g2);
            f2.call(a2);
          };
        }
        var g2 = fl(b2, d2, a, 0, null, false, false, "", ql);
        a._reactRootContainer = g2;
        a[uf$1] = g2.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Sk();
        return g2;
      }
      for (; e2 = a.lastChild; )
        a.removeChild(e2);
      if ("function" === typeof d2) {
        var h2 = d2;
        d2 = function() {
          var a2 = hl(k2);
          h2.call(a2);
        };
      }
      var k2 = cl(a, 0, false, null, null, false, false, "", ql);
      a._reactRootContainer = k2;
      a[uf$1] = k2.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Sk(function() {
        gl(b2, k2, c2, d2);
      });
      return k2;
    }
    function sl(a, b2, c2, d2, e2) {
      var f2 = c2._reactRootContainer;
      if (f2) {
        var g2 = f2;
        if ("function" === typeof e2) {
          var h2 = e2;
          e2 = function() {
            var a2 = hl(g2);
            h2.call(a2);
          };
        }
        gl(b2, g2, a, e2);
      } else
        g2 = rl(c2, b2, a, e2, d2);
      return hl(g2);
    }
    Ec = function(a) {
      switch (a.tag) {
        case 3:
          var b2 = a.stateNode;
          if (b2.current.memoizedState.isDehydrated) {
            var c2 = tc(b2.pendingLanes);
            0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$2()), 0 === (K & 6) && (Hj = B$2() + 500, jg()));
          }
          break;
        case 13:
          Sk(function() {
            var b3 = Zg(a, 1);
            if (null !== b3) {
              var c3 = L$1();
              mh(b3, a, 1, c3);
            }
          }), jl(a, 1);
      }
    };
    Fc = function(a) {
      if (13 === a.tag) {
        var b2 = Zg(a, 134217728);
        if (null !== b2) {
          var c2 = L$1();
          mh(b2, a, 134217728, c2);
        }
        jl(a, 134217728);
      }
    };
    Gc = function(a) {
      if (13 === a.tag) {
        var b2 = lh(a), c2 = Zg(a, b2);
        if (null !== c2) {
          var d2 = L$1();
          mh(c2, a, b2, d2);
        }
        jl(a, b2);
      }
    };
    Hc = function() {
      return C$1;
    };
    Ic = function(a, b2) {
      var c2 = C$1;
      try {
        return C$1 = a, b2();
      } finally {
        C$1 = c2;
      }
    };
    yb = function(a, b2, c2) {
      switch (b2) {
        case "input":
          bb(a, c2);
          b2 = c2.name;
          if ("radio" === c2.type && null != b2) {
            for (c2 = a; c2.parentNode; )
              c2 = c2.parentNode;
            c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
            for (b2 = 0; b2 < c2.length; b2++) {
              var d2 = c2[b2];
              if (d2 !== a && d2.form === a.form) {
                var e2 = Db(d2);
                if (!e2)
                  throw Error(p$5(90));
                Wa(d2);
                bb(d2, e2);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c2);
          break;
        case "select":
          b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
      }
    };
    Gb = Rk;
    Hb = Sk;
    var tl = { usingClientEntryPoint: false, Events: [Cb, ue$1, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
    var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
      a = Zb(a);
      return null === a ? null : a.stateNode;
    }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!wl.isDisabled && wl.supportsFiber)
        try {
          kc = wl.inject(vl), lc = wl;
        } catch (a) {
        }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
    reactDom_production_min.createPortal = function(a, b2) {
      var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!ol(b2))
        throw Error(p$5(200));
      return dl(a, b2, null, c2);
    };
    reactDom_production_min.createRoot = function(a, b2) {
      if (!ol(a))
        throw Error(p$5(299));
      var c2 = false, d2 = "", e2 = ll;
      null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
      b2 = cl(a, 1, false, null, null, c2, false, d2, e2);
      a[uf$1] = b2.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      return new ml(b2);
    };
    reactDom_production_min.findDOMNode = function(a) {
      if (null == a)
        return null;
      if (1 === a.nodeType)
        return a;
      var b2 = a._reactInternals;
      if (void 0 === b2) {
        if ("function" === typeof a.render)
          throw Error(p$5(188));
        a = Object.keys(a).join(",");
        throw Error(p$5(268, a));
      }
      a = Zb(b2);
      a = null === a ? null : a.stateNode;
      return a;
    };
    reactDom_production_min.flushSync = function(a) {
      return Sk(a);
    };
    reactDom_production_min.hydrate = function(a, b2, c2) {
      if (!pl(b2))
        throw Error(p$5(200));
      return sl(null, a, b2, true, c2);
    };
    reactDom_production_min.hydrateRoot = function(a, b2, c2) {
      if (!ol(a))
        throw Error(p$5(405));
      var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
      null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
      b2 = fl(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
      a[uf$1] = b2.current;
      sf(a);
      if (d2)
        for (a = 0; a < d2.length; a++)
          c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
            c2,
            e2
          );
      return new nl(b2);
    };
    reactDom_production_min.render = function(a, b2, c2) {
      if (!pl(b2))
        throw Error(p$5(200));
      return sl(null, a, b2, false, c2);
    };
    reactDom_production_min.unmountComponentAtNode = function(a) {
      if (!pl(a))
        throw Error(p$5(40));
      return a._reactRootContainer ? (Sk(function() {
        sl(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[uf$1] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Rk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
      if (!pl(c2))
        throw Error(p$5(200));
      if (null == a || void 0 === a._reactInternals)
        throw Error(p$5(38));
      return sl(a, b2, c2, false, d2);
    };
    reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
    (function(module2) {
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        module2.exports = reactDom_production_min;
      }
    })(reactDom);
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
    const ReactDOM$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: ReactDOM
    }, [reactDomExports]);
    var createRoot$1;
    var m$4 = reactDomExports;
    {
      createRoot$1 = m$4.createRoot;
      m$4.hydrateRoot;
    }
    function bind$5(fn, thisArg) {
      return function wrap2() {
        return fn.apply(thisArg, arguments);
      };
    }
    const { toString: toString$6 } = Object.prototype;
    const { getPrototypeOf } = Object;
    const kindOf = ((cache2) => (thing) => {
      const str = toString$6.call(thing);
      return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    const kindOfTest = (type2) => {
      type2 = type2.toLowerCase();
      return (thing) => kindOf(thing) === type2;
    };
    const typeOfTest = (type2) => (thing) => typeof thing === type2;
    const { isArray: isArray$j } = Array;
    const isUndefined$3 = typeOfTest("undefined");
    function isBuffer$8(val) {
      return val !== null && !isUndefined$3(val) && val.constructor !== null && !isUndefined$3(val.constructor) && isFunction$7(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    const isArrayBuffer$1 = kindOfTest("ArrayBuffer");
    function isArrayBufferView$1(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer$1(val.buffer);
      }
      return result;
    }
    const isString$4 = typeOfTest("string");
    const isFunction$7 = typeOfTest("function");
    const isNumber$3 = typeOfTest("number");
    const isObject$a = (thing) => thing !== null && typeof thing === "object";
    const isBoolean$1 = (thing) => thing === true || thing === false;
    const isPlainObject$4 = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    const isDate$2 = kindOfTest("Date");
    const isFile$1 = kindOfTest("File");
    const isBlob$1 = kindOfTest("Blob");
    const isFileList = kindOfTest("FileList");
    const isStream$1 = (val) => isObject$a(val) && isFunction$7(val.pipe);
    const isFormData$1 = (thing) => {
      const pattern2 = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString$6.call(thing) === pattern2 || isFunction$7(thing.toString) && thing.toString() === pattern2);
    };
    const isURLSearchParams$1 = kindOfTest("URLSearchParams");
    const trim$2 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach$1(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i2;
      let l2;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray$j(obj)) {
        for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          fn.call(null, obj[i2], i2, obj);
        }
      } else {
        const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys2.length;
        let key;
        for (i2 = 0; i2 < len; i2++) {
          key = keys2[i2];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys2 = Object.keys(obj);
      let i2 = keys2.length;
      let _key;
      while (i2-- > 0) {
        _key = keys2[i2];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    const _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    const isContextDefined = (context) => !isUndefined$3(context) && context !== _global;
    function merge$6() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject$4(result[targetKey]) && isPlainObject$4(val)) {
          result[targetKey] = merge$6(result[targetKey], val);
        } else if (isPlainObject$4(val)) {
          result[targetKey] = merge$6({}, val);
        } else if (isArray$j(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
        arguments[i2] && forEach$1(arguments[i2], assignValue);
      }
      return result;
    }
    const extend$4 = (a, b2, thisArg, { allOwnKeys } = {}) => {
      forEach$1(b2, (val, key) => {
        if (thisArg && isFunction$7(val)) {
          a[key] = bind$5(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    const stripBOM$1 = (content2) => {
      if (content2.charCodeAt(0) === 65279) {
        content2 = content2.slice(1);
      }
      return content2;
    };
    const inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
      let props;
      let i2;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i2 = props.length;
        while (i2-- > 0) {
          prop = props[i2];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    const endsWith = (str, searchString, position2) => {
      str = String(str);
      if (position2 === void 0 || position2 > str.length) {
        position2 = str.length;
      }
      position2 -= searchString.length;
      const lastIndex = str.indexOf(searchString, position2);
      return lastIndex !== -1 && lastIndex === position2;
    };
    const toArray$9 = (thing) => {
      if (!thing)
        return null;
      if (isArray$j(thing))
        return thing;
      let i2 = thing.length;
      if (!isNumber$3(i2))
        return null;
      const arr = new Array(i2);
      while (i2-- > 0) {
        arr[i2] = thing[i2];
      }
      return arr;
    };
    const isTypedArray$5 = ((TypedArray2) => {
      return (thing) => {
        return TypedArray2 && thing instanceof TypedArray2;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    const forEachEntry = (obj, fn) => {
      const generator2 = obj && obj[Symbol.iterator];
      const iterator = generator2.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    const matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    const isHTMLForm = kindOfTest("HTMLFormElement");
    const toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m2, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    const hasOwnProperty$o = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    const isRegExp$2 = kindOfTest("RegExp");
    const reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach$1(descriptors2, (descriptor, name) => {
        if (reducer(descriptor, name, obj) !== false) {
          reducedDescriptors[name] = descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    const freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction$7(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction$7(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    const toObjectSet = (arrayOrString, delimiter2) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray$j(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
      return obj;
    };
    const noop$9 = () => {
    };
    const toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    const ALPHA = "abcdefghijklmnopqrstuvwxyz";
    const DIGIT = "0123456789";
    const ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length: length2 } = alphabet;
      while (size--) {
        str += alphabet[Math.random() * length2 | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$7(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    const toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit2 = (source, i2) => {
        if (isObject$a(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i2] = source;
            const target = isArray$j(source) ? [] : {};
            forEach$1(source, (value, key) => {
              const reducedValue = visit2(value, i2 + 1);
              !isUndefined$3(reducedValue) && (target[key] = reducedValue);
            });
            stack[i2] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit2(obj, 0);
    };
    const utils$g = {
      isArray: isArray$j,
      isArrayBuffer: isArrayBuffer$1,
      isBuffer: isBuffer$8,
      isFormData: isFormData$1,
      isArrayBufferView: isArrayBufferView$1,
      isString: isString$4,
      isNumber: isNumber$3,
      isBoolean: isBoolean$1,
      isObject: isObject$a,
      isPlainObject: isPlainObject$4,
      isUndefined: isUndefined$3,
      isDate: isDate$2,
      isFile: isFile$1,
      isBlob: isBlob$1,
      isRegExp: isRegExp$2,
      isFunction: isFunction$7,
      isStream: isStream$1,
      isURLSearchParams: isURLSearchParams$1,
      isTypedArray: isTypedArray$5,
      isFileList,
      forEach: forEach$1,
      merge: merge$6,
      extend: extend$4,
      trim: trim$2,
      stripBOM: stripBOM$1,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray: toArray$9,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty: hasOwnProperty$o,
      hasOwnProp: hasOwnProperty$o,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop: noop$9,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject
    };
    function AxiosError(message2, code2, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message2;
      this.name = "AxiosError";
      code2 && (this.code = code2);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$g.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$g.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    const prototype$1 = AxiosError.prototype;
    const descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code2) => {
      descriptors[code2] = { value: code2 };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code2, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$g.toFlatObject(error, axiosError, function filter2(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code2, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    const httpAdapter = null;
    function isVisitable(thing) {
      return utils$g.isPlainObject(thing) || utils$g.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$g.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path2, key, dots) {
      if (!path2)
        return key;
      return path2.concat(key).map(function each2(token2, i2) {
        token2 = removeBrackets(token2);
        return !dots && i2 ? "[" + token2 + "]" : token2;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$g.isArray(arr) && !arr.some(isVisitable);
    }
    const predicates = utils$g.toFlatObject(utils$g, {}, null, function filter2(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$g.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$g.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$g.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$g.isSpecCompliantForm(formData);
      if (!utils$g.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$g.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$g.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$g.isArrayBuffer(value) || utils$g.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path2) {
        let arr = value;
        if (value && !path2 && typeof value === "object") {
          if (utils$g.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$g.isArray(value) && isFlatArray(value) || (utils$g.isFileList(value) || utils$g.endsWith(key, "[]")) && (arr = utils$g.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each2(el2, index2) {
              !(utils$g.isUndefined(el2) || el2 === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
                convertValue(el2)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path2, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build2(value, path2) {
        if (utils$g.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path2.join("."));
        }
        stack.push(value);
        utils$g.forEach(value, function each2(el2, key) {
          const result = !(utils$g.isUndefined(el2) || el2 === null) && visitor.call(
            formData,
            el2,
            utils$g.isString(key) ? key.trim() : key,
            path2,
            exposedHelpers
          );
          if (result === true) {
            build2(el2, path2 ? path2.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$g.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build2(obj);
      return formData;
    }
    function encode$4(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
        return charMap[match2];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    const prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append2(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$4);
      } : encode$4;
      return this._pairs.map(function each2(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode$3(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL$2(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode$3;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$g.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    let InterceptorManager$2 = class InterceptorManager {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id2) {
        if (this.handlers[id2]) {
          this.handlers[id2] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$g.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn(h2);
          }
        });
      }
    };
    const InterceptorManager$3 = InterceptorManager$2;
    const transitionalDefaults$1 = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    const isStandardBrowserEnv$1 = (() => {
      let product;
      if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    })();
    const isStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    const platform = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      isStandardBrowserEnv: isStandardBrowserEnv$1,
      isStandardBrowserWebWorkerEnv,
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    function toURLEncodedForm(data2, options) {
      return toFormData(data2, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path2, helpers) {
          if (platform.isNode && utils$g.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$g.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
        return match2[0] === "[]" ? "" : match2[1] || match2[0];
      });
    }
    function arrayToObject$1(arr) {
      const obj = {};
      const keys2 = Object.keys(arr);
      let i2;
      const len = keys2.length;
      let key;
      for (i2 = 0; i2 < len; i2++) {
        key = keys2[i2];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path2, value, target, index2) {
        let name = path2[index2++];
        const isNumericKey = Number.isFinite(+name);
        const isLast = index2 >= path2.length;
        name = !name && utils$g.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$g.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$g.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path2, value, target[name], index2);
        if (result && utils$g.isArray(target[name])) {
          target[name] = arrayToObject$1(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$g.isFormData(formData) && utils$g.isFunction(formData.entries)) {
        const obj = {};
        utils$g.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    const DEFAULT_CONTENT_TYPE$1 = {
      "Content-Type": void 0
    };
    function stringifySafely$1(rawValue, parser2, encoder) {
      if (utils$g.isString(rawValue)) {
        try {
          (parser2 || JSON.parse)(rawValue);
          return utils$g.trim(rawValue);
        } catch (e2) {
          if (e2.name !== "SyntaxError") {
            throw e2;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    const defaults$6 = {
      transitional: transitionalDefaults$1,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data2, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$g.isObject(data2);
        if (isObjectPayload && utils$g.isHTMLForm(data2)) {
          data2 = new FormData(data2);
        }
        const isFormData2 = utils$g.isFormData(data2);
        if (isFormData2) {
          if (!hasJSONContentType) {
            return data2;
          }
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data2)) : data2;
        }
        if (utils$g.isArrayBuffer(data2) || utils$g.isBuffer(data2) || utils$g.isStream(data2) || utils$g.isFile(data2) || utils$g.isBlob(data2)) {
          return data2;
        }
        if (utils$g.isArrayBufferView(data2)) {
          return data2.buffer;
        }
        if (utils$g.isURLSearchParams(data2)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data2.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data2, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$g.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data2 } : data2,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely$1(data2);
        }
        return data2;
      }],
      transformResponse: [function transformResponse(data2) {
        const transitional2 = this.transitional || defaults$6.transitional;
        const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data2 && utils$g.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data2);
          } catch (e2) {
            if (strictJSONParsing) {
              if (e2.name === "SyntaxError") {
                throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e2;
            }
          }
        }
        return data2;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils$g.forEach(["delete", "get", "head"], function forEachMethodNoData(method2) {
      defaults$6.headers[method2] = {};
    });
    utils$g.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
      defaults$6.headers[method2] = utils$g.merge(DEFAULT_CONTENT_TYPE$1);
    });
    const defaults$7 = defaults$6;
    const ignoreDuplicateOf = utils$g.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    const parseHeaders$1 = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i2;
      rawHeaders && rawHeaders.split("\n").forEach(function parser2(line2) {
        i2 = line2.indexOf(":");
        key = line2.substring(0, i2).trim().toLowerCase();
        val = line2.substring(i2 + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    const $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$g.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match2;
      while (match2 = tokensRE.exec(str)) {
        tokens[match2[1]] = match2[2];
      }
      return tokens;
    }
    function isValidHeaderName(str) {
      return /^[-_a-zA-Z]+$/.test(str.trim());
    }
    function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
      if (utils$g.isFunction(filter2)) {
        return filter2.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$g.isString(value))
        return;
      if (utils$g.isString(filter2)) {
        return value.indexOf(filter2) !== -1;
      }
      if (utils$g.isRegExp(filter2)) {
        return filter2.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
        return char2.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$g.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$g.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$g.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$g.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$g.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders$1(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser2) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$g.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser2) {
              return value;
            }
            if (parser2 === true) {
              return parseTokens(value);
            }
            if (utils$g.isFunction(parser2)) {
              return parser2.call(this, value, key);
            }
            if (utils$g.isRegExp(parser2)) {
              return parser2.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$g.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$g.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$g.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys2 = Object.keys(this);
        let i2 = keys2.length;
        let deleted = false;
        while (i2--) {
          const key = keys2[i2];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format2) {
        const self2 = this;
        const headers = {};
        utils$g.forEach(this, (value, header) => {
          const key = utils$g.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format2 ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$g.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$g.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$g.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    }
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$g.freezeMethods(AxiosHeaders.prototype);
    utils$g.freezeMethods(AxiosHeaders);
    const AxiosHeaders$1 = AxiosHeaders;
    function transformData$2(fns, response) {
      const config = this || defaults$7;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data2 = context.data;
      utils$g.forEach(fns, function transform(fn) {
        data2 = fn.call(config, data2, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data2;
    }
    function isCancel$2(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message2, config, request) {
      AxiosError.call(this, message2 == null ? "canceled" : message2, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$g.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle$1(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    const cookies$1 = platform.isStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path2, domain2, secure) {
            const cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils$g.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils$g.isString(path2)) {
              cookie.push("path=" + path2);
            }
            if (utils$g.isString(domain2)) {
              cookie.push("domain=" + domain2);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match2 ? decodeURIComponent(match2[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
    function isAbsoluteURL$1(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs$1(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath$1(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL$1(requestedURL)) {
        return combineURLs$1(baseURL, requestedURL);
      }
      return requestedURL;
    }
    const isURLSameOrigin$1 = platform.isStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$g.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match2 && match2[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push2(chunkLength) {
        const now2 = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now2;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now2;
        let i2 = tail;
        let bytesCount = 0;
        while (i2 !== head) {
          bytesCount += bytes[i2++];
          i2 = i2 % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now2 - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now2 - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e2) => {
        const loaded = e2.loaded;
        const total = e2.lengthComputable ? e2.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data2 = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e2
        };
        data2[isDownloadStream ? "download" : "upload"] = true;
        listener(data2);
      };
    }
    const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    const xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        const responseType = config.responseType;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils$g.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
          requestHeaders.setContentType(false);
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath$1(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL$2(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle$1(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional2 = config.transitional || transitionalDefaults$1;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform.isStandardBrowserEnv) {
          const xsrfValue = (config.withCredentials || isURLSameOrigin$1(fullPath)) && config.xsrfCookieName && cookies$1.read(config.xsrfCookieName);
          if (xsrfValue) {
            requestHeaders.set(config.xsrfHeaderName, xsrfValue);
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$g.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$g.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    const knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils$g.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e2) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    const adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$g.isArray(adapters2) ? adapters2 : [adapters2];
        const { length: length2 } = adapters2;
        let nameOrAdapter;
        let adapter;
        for (let i2 = 0; i2 < length2; i2++) {
          nameOrAdapter = adapters2[i2];
          if (adapter = utils$g.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
            break;
          }
        }
        if (!adapter) {
          if (adapter === false) {
            throw new AxiosError(
              `Adapter ${nameOrAdapter} is not supported by the environment`,
              "ERR_NOT_SUPPORT"
            );
          }
          throw new Error(
            utils$g.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
          );
        }
        if (!utils$g.isFunction(adapter)) {
          throw new TypeError("adapter is not a function");
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested$1(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest$2(config) {
      throwIfCancellationRequested$1(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData$2.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$7.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested$1(config);
        response.data = transformData$2.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel$2(reason)) {
          throwIfCancellationRequested$1(config);
          if (reason && reason.response) {
            reason.response.data = transformData$2.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig$4(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils$g.isPlainObject(target) && utils$g.isPlainObject(source)) {
          return utils$g.merge.call({ caseless }, target, source);
        } else if (utils$g.isPlainObject(source)) {
          return utils$g.merge({}, source);
        } else if (utils$g.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b2, caseless) {
        if (!utils$g.isUndefined(b2)) {
          return getMergedValue(a, b2, caseless);
        } else if (!utils$g.isUndefined(a)) {
          return getMergedValue(void 0, a, caseless);
        }
      }
      function valueFromConfig2(a, b2) {
        if (!utils$g.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        }
      }
      function defaultToConfig2(a, b2) {
        if (!utils$g.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        } else if (!utils$g.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b2, prop) {
        if (prop in config2) {
          return getMergedValue(a, b2);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b2) => mergeDeepProperties(headersToObject(a), headersToObject(b2), true)
      };
      utils$g.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$g.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    const VERSION$1 = "1.3.4";
    const validators$4 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i2) => {
      validators$4[type2] = function validator2(thing) {
        return typeof thing === type2 || "a" + (i2 < 1 ? "n " : " ") + type2;
      };
    });
    const deprecatedWarnings$1 = {};
    validators$4.transitional = function transitional2(validator2, version2, message2) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings$1[opt]) {
          deprecatedWarnings$1[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions$1(options, schema2, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys2 = Object.keys(options);
      let i2 = keys2.length;
      while (i2-- > 0) {
        const opt = keys2[i2];
        const validator2 = schema2[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    const validator$2 = {
      assertOptions: assertOptions$1,
      validators: validators$4
    };
    const validators$3 = validator$2.validators;
    let Axios$2 = class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$3(),
          response: new InterceptorManager$3()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig$4(this.defaults, config);
        const { transitional: transitional2, paramsSerializer, headers } = config;
        if (transitional2 !== void 0) {
          validator$2.assertOptions(transitional2, {
            silentJSONParsing: validators$3.transitional(validators$3.boolean),
            forcedJSONParsing: validators$3.transitional(validators$3.boolean),
            clarifyTimeoutError: validators$3.transitional(validators$3.boolean)
          }, false);
        }
        if (paramsSerializer !== void 0) {
          validator$2.assertOptions(paramsSerializer, {
            encode: validators$3.function,
            serialize: validators$3.function
          }, true);
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders;
        contextHeaders = headers && utils$g.merge(
          headers.common,
          headers[config.method]
        );
        contextHeaders && utils$g.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method2) => {
            delete headers[method2];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i2 = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest$2.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i2 < len) {
            promise = promise.then(chain[i2++], chain[i2++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i2 = 0;
        while (i2 < len) {
          const onFulfilled = requestInterceptorChain[i2++];
          const onRejected = requestInterceptorChain[i2++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest$2.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i2 = 0;
        len = responseInterceptorChain.length;
        while (i2 < len) {
          promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig$4(this.defaults, config);
        const fullPath = buildFullPath$1(config.baseURL, config.url);
        return buildURL$2(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$g.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method2) {
      Axios$2.prototype[method2] = function(url, config) {
        return this.request(mergeConfig$4(config || {}, {
          method: method2,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$g.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data2, config) {
          return this.request(mergeConfig$4(config || {}, {
            method: method2,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data: data2
          }));
        };
      }
      Axios$2.prototype[method2] = generateHTTPMethod();
      Axios$2.prototype[method2 + "Form"] = generateHTTPMethod(true);
    });
    const Axios$3 = Axios$2;
    class CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token2 = this;
        this.promise.then((cancel) => {
          if (!token2._listeners)
            return;
          let i2 = token2._listeners.length;
          while (i2-- > 0) {
            token2._listeners[i2](cancel);
          }
          token2._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token2.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token2.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message2, config, request) {
          if (token2.reason) {
            return;
          }
          token2.reason = new CanceledError(message2, config, request);
          resolvePromise(token2.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token2 = new CancelToken(function executor(c2) {
          cancel = c2;
        });
        return {
          token: token2,
          cancel
        };
      }
    }
    const CancelToken$1 = CancelToken;
    function spread$1(callback) {
      return function wrap2(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError$1(payload) {
      return utils$g.isObject(payload) && payload.isAxiosError === true;
    }
    const HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    const HttpStatusCode$1 = HttpStatusCode;
    function createInstance$1(defaultConfig2) {
      const context = new Axios$3(defaultConfig2);
      const instance = bind$5(Axios$3.prototype.request, context);
      utils$g.extend(instance, Axios$3.prototype, context, { allOwnKeys: true });
      utils$g.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create2(instanceConfig) {
        return createInstance$1(mergeConfig$4(defaultConfig2, instanceConfig));
      };
      return instance;
    }
    const axios$3 = createInstance$1(defaults$7);
    axios$3.Axios = Axios$3;
    axios$3.CanceledError = CanceledError;
    axios$3.CancelToken = CancelToken$1;
    axios$3.isCancel = isCancel$2;
    axios$3.VERSION = VERSION$1;
    axios$3.toFormData = toFormData;
    axios$3.AxiosError = AxiosError;
    axios$3.Cancel = axios$3.CanceledError;
    axios$3.all = function all2(promises) {
      return Promise.all(promises);
    };
    axios$3.spread = spread$1;
    axios$3.isAxiosError = isAxiosError$1;
    axios$3.mergeConfig = mergeConfig$4;
    axios$3.AxiosHeaders = AxiosHeaders$1;
    axios$3.formToJSON = (thing) => formDataToJSON(utils$g.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios$3.HttpStatusCode = HttpStatusCode$1;
    axios$3.default = axios$3;
    const axios$4 = axios$3;
    class Subscribable {
      constructor() {
        this.listeners = [];
        this.subscribe = this.subscribe.bind(this);
      }
      subscribe(listener) {
        this.listeners.push(listener);
        this.onSubscribe();
        return () => {
          this.listeners = this.listeners.filter((x2) => x2 !== listener);
          this.onUnsubscribe();
        };
      }
      hasListeners() {
        return this.listeners.length > 0;
      }
      onSubscribe() {
      }
      onUnsubscribe() {
      }
    }
    const isServer = typeof window === "undefined" || "Deno" in window;
    function noop$8() {
      return void 0;
    }
    function functionalUpdate(updater, input) {
      return typeof updater === "function" ? updater(input) : updater;
    }
    function isValidTimeout(value) {
      return typeof value === "number" && value >= 0 && value !== Infinity;
    }
    function timeUntilStale(updatedAt, staleTime) {
      return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
    }
    function parseQueryArgs(arg1, arg2, arg3) {
      if (!isQueryKey(arg1)) {
        return arg1;
      }
      if (typeof arg2 === "function") {
        return {
          ...arg3,
          queryKey: arg1,
          queryFn: arg2
        };
      }
      return {
        ...arg2,
        queryKey: arg1
      };
    }
    function parseMutationArgs(arg1, arg2, arg3) {
      if (isQueryKey(arg1)) {
        if (typeof arg2 === "function") {
          return {
            ...arg3,
            mutationKey: arg1,
            mutationFn: arg2
          };
        }
        return {
          ...arg2,
          mutationKey: arg1
        };
      }
      if (typeof arg1 === "function") {
        return {
          ...arg2,
          mutationFn: arg1
        };
      }
      return {
        ...arg1
      };
    }
    function parseFilterArgs(arg1, arg2, arg3) {
      return isQueryKey(arg1) ? [{
        ...arg2,
        queryKey: arg1
      }, arg3] : [arg1 || {}, arg2];
    }
    function matchQuery(filters, query) {
      const {
        type: type2 = "all",
        exact,
        fetchStatus,
        predicate,
        queryKey,
        stale
      } = filters;
      if (isQueryKey(queryKey)) {
        if (exact) {
          if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
            return false;
          }
        } else if (!partialMatchKey(query.queryKey, queryKey)) {
          return false;
        }
      }
      if (type2 !== "all") {
        const isActive2 = query.isActive();
        if (type2 === "active" && !isActive2) {
          return false;
        }
        if (type2 === "inactive" && isActive2) {
          return false;
        }
      }
      if (typeof stale === "boolean" && query.isStale() !== stale) {
        return false;
      }
      if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) {
        return false;
      }
      if (predicate && !predicate(query)) {
        return false;
      }
      return true;
    }
    function matchMutation(filters, mutation) {
      const {
        exact,
        fetching,
        predicate,
        mutationKey
      } = filters;
      if (isQueryKey(mutationKey)) {
        if (!mutation.options.mutationKey) {
          return false;
        }
        if (exact) {
          if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
            return false;
          }
        } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
          return false;
        }
      }
      if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
        return false;
      }
      if (predicate && !predicate(mutation)) {
        return false;
      }
      return true;
    }
    function hashQueryKeyByOptions(queryKey, options) {
      const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
      return hashFn(queryKey);
    }
    function hashQueryKey(queryKey) {
      return JSON.stringify(queryKey, (_, val) => isPlainObject$3(val) ? Object.keys(val).sort().reduce((result, key) => {
        result[key] = val[key];
        return result;
      }, {}) : val);
    }
    function partialMatchKey(a, b2) {
      return partialDeepEqual(a, b2);
    }
    function partialDeepEqual(a, b2) {
      if (a === b2) {
        return true;
      }
      if (typeof a !== typeof b2) {
        return false;
      }
      if (a && b2 && typeof a === "object" && typeof b2 === "object") {
        return !Object.keys(b2).some((key) => !partialDeepEqual(a[key], b2[key]));
      }
      return false;
    }
    function replaceEqualDeep(a, b2) {
      if (a === b2) {
        return a;
      }
      const array2 = isPlainArray(a) && isPlainArray(b2);
      if (array2 || isPlainObject$3(a) && isPlainObject$3(b2)) {
        const aSize = array2 ? a.length : Object.keys(a).length;
        const bItems = array2 ? b2 : Object.keys(b2);
        const bSize = bItems.length;
        const copy2 = array2 ? [] : {};
        let equalItems = 0;
        for (let i2 = 0; i2 < bSize; i2++) {
          const key = array2 ? i2 : bItems[i2];
          copy2[key] = replaceEqualDeep(a[key], b2[key]);
          if (copy2[key] === a[key]) {
            equalItems++;
          }
        }
        return aSize === bSize && equalItems === aSize ? a : copy2;
      }
      return b2;
    }
    function shallowEqualObjects(a, b2) {
      if (a && !b2 || b2 && !a) {
        return false;
      }
      for (const key in a) {
        if (a[key] !== b2[key]) {
          return false;
        }
      }
      return true;
    }
    function isPlainArray(value) {
      return Array.isArray(value) && value.length === Object.keys(value).length;
    }
    function isPlainObject$3(o2) {
      if (!hasObjectPrototype(o2)) {
        return false;
      }
      const ctor = o2.constructor;
      if (typeof ctor === "undefined") {
        return true;
      }
      const prot = ctor.prototype;
      if (!hasObjectPrototype(prot)) {
        return false;
      }
      if (!prot.hasOwnProperty("isPrototypeOf")) {
        return false;
      }
      return true;
    }
    function hasObjectPrototype(o2) {
      return Object.prototype.toString.call(o2) === "[object Object]";
    }
    function isQueryKey(value) {
      return Array.isArray(value);
    }
    function sleep(timeout) {
      return new Promise((resolve) => {
        setTimeout(resolve, timeout);
      });
    }
    function scheduleMicrotask(callback) {
      sleep(0).then(callback);
    }
    function getAbortController() {
      if (typeof AbortController === "function") {
        return new AbortController();
      }
      return;
    }
    function replaceData(prevData, data2, options) {
      if (options.isDataEqual != null && options.isDataEqual(prevData, data2)) {
        return prevData;
      } else if (typeof options.structuralSharing === "function") {
        return options.structuralSharing(prevData, data2);
      } else if (options.structuralSharing !== false) {
        return replaceEqualDeep(prevData, data2);
      }
      return data2;
    }
    class FocusManager extends Subscribable {
      constructor() {
        super();
        this.setup = (onFocus) => {
          if (!isServer && window.addEventListener) {
            const listener = () => onFocus();
            window.addEventListener("visibilitychange", listener, false);
            window.addEventListener("focus", listener, false);
            return () => {
              window.removeEventListener("visibilitychange", listener);
              window.removeEventListener("focus", listener);
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.cleanup) {
          this.setEventListener(this.setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          var _this$cleanup;
          (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
          this.cleanup = void 0;
        }
      }
      setEventListener(setup) {
        var _this$cleanup2;
        this.setup = setup;
        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
        this.cleanup = setup((focused) => {
          if (typeof focused === "boolean") {
            this.setFocused(focused);
          } else {
            this.onFocus();
          }
        });
      }
      setFocused(focused) {
        this.focused = focused;
        if (focused) {
          this.onFocus();
        }
      }
      onFocus() {
        this.listeners.forEach((listener) => {
          listener();
        });
      }
      isFocused() {
        if (typeof this.focused === "boolean") {
          return this.focused;
        }
        if (typeof document === "undefined") {
          return true;
        }
        return [void 0, "visible", "prerender"].includes(document.visibilityState);
      }
    }
    const focusManager = new FocusManager();
    class OnlineManager extends Subscribable {
      constructor() {
        super();
        this.setup = (onOnline) => {
          if (!isServer && window.addEventListener) {
            const listener = () => onOnline();
            window.addEventListener("online", listener, false);
            window.addEventListener("offline", listener, false);
            return () => {
              window.removeEventListener("online", listener);
              window.removeEventListener("offline", listener);
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.cleanup) {
          this.setEventListener(this.setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          var _this$cleanup;
          (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
          this.cleanup = void 0;
        }
      }
      setEventListener(setup) {
        var _this$cleanup2;
        this.setup = setup;
        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
        this.cleanup = setup((online2) => {
          if (typeof online2 === "boolean") {
            this.setOnline(online2);
          } else {
            this.onOnline();
          }
        });
      }
      setOnline(online2) {
        this.online = online2;
        if (online2) {
          this.onOnline();
        }
      }
      onOnline() {
        this.listeners.forEach((listener) => {
          listener();
        });
      }
      isOnline() {
        if (typeof this.online === "boolean") {
          return this.online;
        }
        if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
          return true;
        }
        return navigator.onLine;
      }
    }
    const onlineManager = new OnlineManager();
    function defaultRetryDelay(failureCount) {
      return Math.min(1e3 * 2 ** failureCount, 3e4);
    }
    function canFetch(networkMode) {
      return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
    }
    class CancelledError {
      constructor(options) {
        this.revert = options == null ? void 0 : options.revert;
        this.silent = options == null ? void 0 : options.silent;
      }
    }
    function isCancelledError(value) {
      return value instanceof CancelledError;
    }
    function createRetryer(config) {
      let isRetryCancelled = false;
      let failureCount = 0;
      let isResolved = false;
      let continueFn;
      let promiseResolve;
      let promiseReject;
      const promise = new Promise((outerResolve, outerReject) => {
        promiseResolve = outerResolve;
        promiseReject = outerReject;
      });
      const cancel = (cancelOptions) => {
        if (!isResolved) {
          reject(new CancelledError(cancelOptions));
          config.abort == null ? void 0 : config.abort();
        }
      };
      const cancelRetry = () => {
        isRetryCancelled = true;
      };
      const continueRetry = () => {
        isRetryCancelled = false;
      };
      const shouldPause = () => !focusManager.isFocused() || config.networkMode !== "always" && !onlineManager.isOnline();
      const resolve = (value) => {
        if (!isResolved) {
          isResolved = true;
          config.onSuccess == null ? void 0 : config.onSuccess(value);
          continueFn == null ? void 0 : continueFn();
          promiseResolve(value);
        }
      };
      const reject = (value) => {
        if (!isResolved) {
          isResolved = true;
          config.onError == null ? void 0 : config.onError(value);
          continueFn == null ? void 0 : continueFn();
          promiseReject(value);
        }
      };
      const pause = () => {
        return new Promise((continueResolve) => {
          continueFn = (value) => {
            const canContinue = isResolved || !shouldPause();
            if (canContinue) {
              continueResolve(value);
            }
            return canContinue;
          };
          config.onPause == null ? void 0 : config.onPause();
        }).then(() => {
          continueFn = void 0;
          if (!isResolved) {
            config.onContinue == null ? void 0 : config.onContinue();
          }
        });
      };
      const run = () => {
        if (isResolved) {
          return;
        }
        let promiseOrValue;
        try {
          promiseOrValue = config.fn();
        } catch (error) {
          promiseOrValue = Promise.reject(error);
        }
        Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
          var _config$retry, _config$retryDelay;
          if (isResolved) {
            return;
          }
          const retry = (_config$retry = config.retry) != null ? _config$retry : 3;
          const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
          const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
          const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
          if (isRetryCancelled || !shouldRetry) {
            reject(error);
            return;
          }
          failureCount++;
          config.onFail == null ? void 0 : config.onFail(failureCount, error);
          sleep(delay).then(() => {
            if (shouldPause()) {
              return pause();
            }
            return;
          }).then(() => {
            if (isRetryCancelled) {
              reject(error);
            } else {
              run();
            }
          });
        });
      };
      if (canFetch(config.networkMode)) {
        run();
      } else {
        pause().then(run);
      }
      return {
        promise,
        cancel,
        continue: () => {
          const didContinue = continueFn == null ? void 0 : continueFn();
          return didContinue ? promise : Promise.resolve();
        },
        cancelRetry,
        continueRetry
      };
    }
    const defaultLogger = console;
    function createNotifyManager() {
      let queue = [];
      let transactions = 0;
      let notifyFn = (callback) => {
        callback();
      };
      let batchNotifyFn = (callback) => {
        callback();
      };
      const batch = (callback) => {
        let result;
        transactions++;
        try {
          result = callback();
        } finally {
          transactions--;
          if (!transactions) {
            flush();
          }
        }
        return result;
      };
      const schedule = (callback) => {
        if (transactions) {
          queue.push(callback);
        } else {
          scheduleMicrotask(() => {
            notifyFn(callback);
          });
        }
      };
      const batchCalls = (callback) => {
        return (...args) => {
          schedule(() => {
            callback(...args);
          });
        };
      };
      const flush = () => {
        const originalQueue = queue;
        queue = [];
        if (originalQueue.length) {
          scheduleMicrotask(() => {
            batchNotifyFn(() => {
              originalQueue.forEach((callback) => {
                notifyFn(callback);
              });
            });
          });
        }
      };
      const setNotifyFunction = (fn) => {
        notifyFn = fn;
      };
      const setBatchNotifyFunction = (fn) => {
        batchNotifyFn = fn;
      };
      return {
        batch,
        batchCalls,
        schedule,
        setNotifyFunction,
        setBatchNotifyFunction
      };
    }
    const notifyManager = createNotifyManager();
    class Removable {
      destroy() {
        this.clearGcTimeout();
      }
      scheduleGc() {
        this.clearGcTimeout();
        if (isValidTimeout(this.cacheTime)) {
          this.gcTimeout = setTimeout(() => {
            this.optionalRemove();
          }, this.cacheTime);
        }
      }
      updateCacheTime(newCacheTime) {
        this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1e3);
      }
      clearGcTimeout() {
        if (this.gcTimeout) {
          clearTimeout(this.gcTimeout);
          this.gcTimeout = void 0;
        }
      }
    }
    class Query extends Removable {
      constructor(config) {
        super();
        this.abortSignalConsumed = false;
        this.defaultOptions = config.defaultOptions;
        this.setOptions(config.options);
        this.observers = [];
        this.cache = config.cache;
        this.logger = config.logger || defaultLogger;
        this.queryKey = config.queryKey;
        this.queryHash = config.queryHash;
        this.initialState = config.state || getDefaultState$1(this.options);
        this.state = this.initialState;
        this.scheduleGc();
      }
      get meta() {
        return this.options.meta;
      }
      setOptions(options) {
        this.options = {
          ...this.defaultOptions,
          ...options
        };
        this.updateCacheTime(this.options.cacheTime);
      }
      optionalRemove() {
        if (!this.observers.length && this.state.fetchStatus === "idle") {
          this.cache.remove(this);
        }
      }
      setData(newData, options) {
        const data2 = replaceData(this.state.data, newData, this.options);
        this.dispatch({
          data: data2,
          type: "success",
          dataUpdatedAt: options == null ? void 0 : options.updatedAt,
          manual: options == null ? void 0 : options.manual
        });
        return data2;
      }
      setState(state, setStateOptions) {
        this.dispatch({
          type: "setState",
          state,
          setStateOptions
        });
      }
      cancel(options) {
        var _this$retryer;
        const promise = this.promise;
        (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);
        return promise ? promise.then(noop$8).catch(noop$8) : Promise.resolve();
      }
      destroy() {
        super.destroy();
        this.cancel({
          silent: true
        });
      }
      reset() {
        this.destroy();
        this.setState(this.initialState);
      }
      isActive() {
        return this.observers.some((observer) => observer.options.enabled !== false);
      }
      isDisabled() {
        return this.getObserversCount() > 0 && !this.isActive();
      }
      isStale() {
        return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer) => observer.getCurrentResult().isStale);
      }
      isStaleByTime(staleTime = 0) {
        return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
      }
      onFocus() {
        var _this$retryer2;
        const observer = this.observers.find((x2) => x2.shouldFetchOnWindowFocus());
        if (observer) {
          observer.refetch({
            cancelRefetch: false
          });
        }
        (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
      }
      onOnline() {
        var _this$retryer3;
        const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
        if (observer) {
          observer.refetch({
            cancelRefetch: false
          });
        }
        (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
      }
      addObserver(observer) {
        if (this.observers.indexOf(observer) === -1) {
          this.observers.push(observer);
          this.clearGcTimeout();
          this.cache.notify({
            type: "observerAdded",
            query: this,
            observer
          });
        }
      }
      removeObserver(observer) {
        if (this.observers.indexOf(observer) !== -1) {
          this.observers = this.observers.filter((x2) => x2 !== observer);
          if (!this.observers.length) {
            if (this.retryer) {
              if (this.abortSignalConsumed) {
                this.retryer.cancel({
                  revert: true
                });
              } else {
                this.retryer.cancelRetry();
              }
            }
            this.scheduleGc();
          }
          this.cache.notify({
            type: "observerRemoved",
            query: this,
            observer
          });
        }
      }
      getObserversCount() {
        return this.observers.length;
      }
      invalidate() {
        if (!this.state.isInvalidated) {
          this.dispatch({
            type: "invalidate"
          });
        }
      }
      fetch(options, fetchOptions) {
        var _this$options$behavio, _context$fetchOptions;
        if (this.state.fetchStatus !== "idle") {
          if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
            this.cancel({
              silent: true
            });
          } else if (this.promise) {
            var _this$retryer4;
            (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
            return this.promise;
          }
        }
        if (options) {
          this.setOptions(options);
        }
        if (!this.options.queryFn) {
          const observer = this.observers.find((x2) => x2.options.queryFn);
          if (observer) {
            this.setOptions(observer.options);
          }
        }
        if (!Array.isArray(this.options.queryKey))
          ;
        const abortController = getAbortController();
        const queryFnContext = {
          queryKey: this.queryKey,
          pageParam: void 0,
          meta: this.meta
        };
        const addSignalProperty = (object2) => {
          Object.defineProperty(object2, "signal", {
            enumerable: true,
            get: () => {
              if (abortController) {
                this.abortSignalConsumed = true;
                return abortController.signal;
              }
              return void 0;
            }
          });
        };
        addSignalProperty(queryFnContext);
        const fetchFn = () => {
          if (!this.options.queryFn) {
            return Promise.reject("Missing queryFn");
          }
          this.abortSignalConsumed = false;
          return this.options.queryFn(queryFnContext);
        };
        const context = {
          fetchOptions,
          options: this.options,
          queryKey: this.queryKey,
          state: this.state,
          fetchFn
        };
        addSignalProperty(context);
        (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context);
        this.revertState = this.state;
        if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
          var _context$fetchOptions2;
          this.dispatch({
            type: "fetch",
            meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
          });
        }
        const onError = (error) => {
          if (!(isCancelledError(error) && error.silent)) {
            this.dispatch({
              type: "error",
              error
            });
          }
          if (!isCancelledError(error)) {
            var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;
            (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);
            (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);
          }
          if (!this.isFetchingOptimistic) {
            this.scheduleGc();
          }
          this.isFetchingOptimistic = false;
        };
        this.retryer = createRetryer({
          fn: context.fetchFn,
          abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
          onSuccess: (data2) => {
            var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;
            if (typeof data2 === "undefined") {
              onError(new Error("undefined"));
              return;
            }
            this.setData(data2);
            (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data2, this);
            (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data2, this.state.error, this);
            if (!this.isFetchingOptimistic) {
              this.scheduleGc();
            }
            this.isFetchingOptimistic = false;
          },
          onError,
          onFail: (failureCount, error) => {
            this.dispatch({
              type: "failed",
              failureCount,
              error
            });
          },
          onPause: () => {
            this.dispatch({
              type: "pause"
            });
          },
          onContinue: () => {
            this.dispatch({
              type: "continue"
            });
          },
          retry: context.options.retry,
          retryDelay: context.options.retryDelay,
          networkMode: context.options.networkMode
        });
        this.promise = this.retryer.promise;
        return this.promise;
      }
      dispatch(action) {
        const reducer = (state) => {
          var _action$meta, _action$dataUpdatedAt;
          switch (action.type) {
            case "failed":
              return {
                ...state,
                fetchFailureCount: action.failureCount,
                fetchFailureReason: action.error
              };
            case "pause":
              return {
                ...state,
                fetchStatus: "paused"
              };
            case "continue":
              return {
                ...state,
                fetchStatus: "fetching"
              };
            case "fetch":
              return {
                ...state,
                fetchFailureCount: 0,
                fetchFailureReason: null,
                fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
                fetchStatus: canFetch(this.options.networkMode) ? "fetching" : "paused",
                ...!state.dataUpdatedAt && {
                  error: null,
                  status: "loading"
                }
              };
            case "success":
              return {
                ...state,
                data: action.data,
                dataUpdateCount: state.dataUpdateCount + 1,
                dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
                error: null,
                isInvalidated: false,
                status: "success",
                ...!action.manual && {
                  fetchStatus: "idle",
                  fetchFailureCount: 0,
                  fetchFailureReason: null
                }
              };
            case "error":
              const error = action.error;
              if (isCancelledError(error) && error.revert && this.revertState) {
                return {
                  ...this.revertState
                };
              }
              return {
                ...state,
                error,
                errorUpdateCount: state.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: state.fetchFailureCount + 1,
                fetchFailureReason: error,
                fetchStatus: "idle",
                status: "error"
              };
            case "invalidate":
              return {
                ...state,
                isInvalidated: true
              };
            case "setState":
              return {
                ...state,
                ...action.state
              };
          }
        };
        this.state = reducer(this.state);
        notifyManager.batch(() => {
          this.observers.forEach((observer) => {
            observer.onQueryUpdate(action);
          });
          this.cache.notify({
            query: this,
            type: "updated",
            action
          });
        });
      }
    }
    function getDefaultState$1(options) {
      const data2 = typeof options.initialData === "function" ? options.initialData() : options.initialData;
      const hasData = typeof data2 !== "undefined";
      const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
      return {
        data: data2,
        dataUpdateCount: 0,
        dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: false,
        status: hasData ? "success" : "loading",
        fetchStatus: "idle"
      };
    }
    class QueryCache extends Subscribable {
      constructor(config) {
        super();
        this.config = config || {};
        this.queries = [];
        this.queriesMap = {};
      }
      build(client, options, state) {
        var _options$queryHash;
        const queryKey = options.queryKey;
        const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);
        let query = this.get(queryHash);
        if (!query) {
          query = new Query({
            cache: this,
            logger: client.getLogger(),
            queryKey,
            queryHash,
            options: client.defaultQueryOptions(options),
            state,
            defaultOptions: client.getQueryDefaults(queryKey)
          });
          this.add(query);
        }
        return query;
      }
      add(query) {
        if (!this.queriesMap[query.queryHash]) {
          this.queriesMap[query.queryHash] = query;
          this.queries.push(query);
          this.notify({
            type: "added",
            query
          });
        }
      }
      remove(query) {
        const queryInMap = this.queriesMap[query.queryHash];
        if (queryInMap) {
          query.destroy();
          this.queries = this.queries.filter((x2) => x2 !== query);
          if (queryInMap === query) {
            delete this.queriesMap[query.queryHash];
          }
          this.notify({
            type: "removed",
            query
          });
        }
      }
      clear() {
        notifyManager.batch(() => {
          this.queries.forEach((query) => {
            this.remove(query);
          });
        });
      }
      get(queryHash) {
        return this.queriesMap[queryHash];
      }
      getAll() {
        return this.queries;
      }
      find(arg1, arg2) {
        const [filters] = parseFilterArgs(arg1, arg2);
        if (typeof filters.exact === "undefined") {
          filters.exact = true;
        }
        return this.queries.find((query) => matchQuery(filters, query));
      }
      findAll(arg1, arg2) {
        const [filters] = parseFilterArgs(arg1, arg2);
        return Object.keys(filters).length > 0 ? this.queries.filter((query) => matchQuery(filters, query)) : this.queries;
      }
      notify(event) {
        notifyManager.batch(() => {
          this.listeners.forEach((listener) => {
            listener(event);
          });
        });
      }
      onFocus() {
        notifyManager.batch(() => {
          this.queries.forEach((query) => {
            query.onFocus();
          });
        });
      }
      onOnline() {
        notifyManager.batch(() => {
          this.queries.forEach((query) => {
            query.onOnline();
          });
        });
      }
    }
    class Mutation extends Removable {
      constructor(config) {
        super();
        this.defaultOptions = config.defaultOptions;
        this.mutationId = config.mutationId;
        this.mutationCache = config.mutationCache;
        this.logger = config.logger || defaultLogger;
        this.observers = [];
        this.state = config.state || getDefaultState();
        this.setOptions(config.options);
        this.scheduleGc();
      }
      setOptions(options) {
        this.options = {
          ...this.defaultOptions,
          ...options
        };
        this.updateCacheTime(this.options.cacheTime);
      }
      get meta() {
        return this.options.meta;
      }
      setState(state) {
        this.dispatch({
          type: "setState",
          state
        });
      }
      addObserver(observer) {
        if (this.observers.indexOf(observer) === -1) {
          this.observers.push(observer);
          this.clearGcTimeout();
          this.mutationCache.notify({
            type: "observerAdded",
            mutation: this,
            observer
          });
        }
      }
      removeObserver(observer) {
        this.observers = this.observers.filter((x2) => x2 !== observer);
        this.scheduleGc();
        this.mutationCache.notify({
          type: "observerRemoved",
          mutation: this,
          observer
        });
      }
      optionalRemove() {
        if (!this.observers.length) {
          if (this.state.status === "loading") {
            this.scheduleGc();
          } else {
            this.mutationCache.remove(this);
          }
        }
      }
      continue() {
        var _this$retryer$continu, _this$retryer;
        return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();
      }
      async execute() {
        const executeMutation = () => {
          var _this$options$retry;
          this.retryer = createRetryer({
            fn: () => {
              if (!this.options.mutationFn) {
                return Promise.reject("No mutationFn found");
              }
              return this.options.mutationFn(this.state.variables);
            },
            onFail: (failureCount, error) => {
              this.dispatch({
                type: "failed",
                failureCount,
                error
              });
            },
            onPause: () => {
              this.dispatch({
                type: "pause"
              });
            },
            onContinue: () => {
              this.dispatch({
                type: "continue"
              });
            },
            retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode
          });
          return this.retryer.promise;
        };
        const restored = this.state.status === "loading";
        try {
          var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;
          if (!restored) {
            var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;
            this.dispatch({
              type: "loading",
              variables: this.options.variables
            });
            await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));
            const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));
            if (context !== this.state.context) {
              this.dispatch({
                type: "loading",
                context,
                variables: this.state.variables
              });
            }
          }
          const data2 = await executeMutation();
          await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data2, this.state.variables, this.state.context, this));
          await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data2, this.state.variables, this.state.context));
          await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data2, null, this.state.variables, this.state.context, this));
          await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data2, null, this.state.variables, this.state.context));
          this.dispatch({
            type: "success",
            data: data2
          });
          return data2;
        } catch (error) {
          try {
            var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;
            await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));
            if (false)
              ;
            await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));
            await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, void 0, error, this.state.variables, this.state.context, this));
            await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, void 0, error, this.state.variables, this.state.context));
            throw error;
          } finally {
            this.dispatch({
              type: "error",
              error
            });
          }
        }
      }
      dispatch(action) {
        const reducer = (state) => {
          switch (action.type) {
            case "failed":
              return {
                ...state,
                failureCount: action.failureCount,
                failureReason: action.error
              };
            case "pause":
              return {
                ...state,
                isPaused: true
              };
            case "continue":
              return {
                ...state,
                isPaused: false
              };
            case "loading":
              return {
                ...state,
                context: action.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: !canFetch(this.options.networkMode),
                status: "loading",
                variables: action.variables
              };
            case "success":
              return {
                ...state,
                data: action.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: false
              };
            case "error":
              return {
                ...state,
                data: void 0,
                error: action.error,
                failureCount: state.failureCount + 1,
                failureReason: action.error,
                isPaused: false,
                status: "error"
              };
            case "setState":
              return {
                ...state,
                ...action.state
              };
          }
        };
        this.state = reducer(this.state);
        notifyManager.batch(() => {
          this.observers.forEach((observer) => {
            observer.onMutationUpdate(action);
          });
          this.mutationCache.notify({
            mutation: this,
            type: "updated",
            action
          });
        });
      }
    }
    function getDefaultState() {
      return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: false,
        status: "idle",
        variables: void 0
      };
    }
    class MutationCache extends Subscribable {
      constructor(config) {
        super();
        this.config = config || {};
        this.mutations = [];
        this.mutationId = 0;
      }
      build(client, options, state) {
        const mutation = new Mutation({
          mutationCache: this,
          logger: client.getLogger(),
          mutationId: ++this.mutationId,
          options: client.defaultMutationOptions(options),
          state,
          defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : void 0
        });
        this.add(mutation);
        return mutation;
      }
      add(mutation) {
        this.mutations.push(mutation);
        this.notify({
          type: "added",
          mutation
        });
      }
      remove(mutation) {
        this.mutations = this.mutations.filter((x2) => x2 !== mutation);
        this.notify({
          type: "removed",
          mutation
        });
      }
      clear() {
        notifyManager.batch(() => {
          this.mutations.forEach((mutation) => {
            this.remove(mutation);
          });
        });
      }
      getAll() {
        return this.mutations;
      }
      find(filters) {
        if (typeof filters.exact === "undefined") {
          filters.exact = true;
        }
        return this.mutations.find((mutation) => matchMutation(filters, mutation));
      }
      findAll(filters) {
        return this.mutations.filter((mutation) => matchMutation(filters, mutation));
      }
      notify(event) {
        notifyManager.batch(() => {
          this.listeners.forEach((listener) => {
            listener(event);
          });
        });
      }
      resumePausedMutations() {
        var _this$resuming;
        this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {
          const pausedMutations = this.mutations.filter((x2) => x2.state.isPaused);
          return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop$8)), Promise.resolve()));
        }).then(() => {
          this.resuming = void 0;
        });
        return this.resuming;
      }
    }
    function infiniteQueryBehavior() {
      return {
        onFetch: (context) => {
          context.fetchFn = () => {
            var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
            const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
            const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
            const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
            const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
            const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
            const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
            const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
            let newPageParams = oldPageParams;
            let cancelled = false;
            const addSignalProperty = (object2) => {
              Object.defineProperty(object2, "signal", {
                enumerable: true,
                get: () => {
                  var _context$signal;
                  if ((_context$signal = context.signal) != null && _context$signal.aborted) {
                    cancelled = true;
                  } else {
                    var _context$signal2;
                    (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener("abort", () => {
                      cancelled = true;
                    });
                  }
                  return context.signal;
                }
              });
            };
            const queryFn = context.options.queryFn || (() => Promise.reject("Missing queryFn"));
            const buildNewPages = (pages, param, page, previous2) => {
              newPageParams = previous2 ? [param, ...newPageParams] : [...newPageParams, param];
              return previous2 ? [page, ...pages] : [...pages, page];
            };
            const fetchPage = (pages, manual, param, previous2) => {
              if (cancelled) {
                return Promise.reject("Cancelled");
              }
              if (typeof param === "undefined" && !manual && pages.length) {
                return Promise.resolve(pages);
              }
              const queryFnContext = {
                queryKey: context.queryKey,
                pageParam: param,
                meta: context.options.meta
              };
              addSignalProperty(queryFnContext);
              const queryFnResult = queryFn(queryFnContext);
              const promise2 = Promise.resolve(queryFnResult).then((page) => buildNewPages(pages, param, page, previous2));
              return promise2;
            };
            let promise;
            if (!oldPages.length) {
              promise = fetchPage([]);
            } else if (isFetchingNextPage) {
              const manual = typeof pageParam !== "undefined";
              const param = manual ? pageParam : getNextPageParam(context.options, oldPages);
              promise = fetchPage(oldPages, manual, param);
            } else if (isFetchingPreviousPage) {
              const manual = typeof pageParam !== "undefined";
              const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);
              promise = fetchPage(oldPages, manual, param, true);
            } else {
              newPageParams = [];
              const manual = typeof context.options.getNextPageParam === "undefined";
              const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
              promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
              for (let i2 = 1; i2 < oldPages.length; i2++) {
                promise = promise.then((pages) => {
                  const shouldFetchNextPage = refetchPage && oldPages[i2] ? refetchPage(oldPages[i2], i2, oldPages) : true;
                  if (shouldFetchNextPage) {
                    const param = manual ? oldPageParams[i2] : getNextPageParam(context.options, pages);
                    return fetchPage(pages, manual, param);
                  }
                  return Promise.resolve(buildNewPages(pages, oldPageParams[i2], oldPages[i2]));
                });
              }
            }
            const finalPromise = promise.then((pages) => ({
              pages,
              pageParams: newPageParams
            }));
            return finalPromise;
          };
        }
      };
    }
    function getNextPageParam(options, pages) {
      return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
    }
    function getPreviousPageParam(options, pages) {
      return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
    }
    class QueryClient {
      constructor(config = {}) {
        this.queryCache = config.queryCache || new QueryCache();
        this.mutationCache = config.mutationCache || new MutationCache();
        this.logger = config.logger || defaultLogger;
        this.defaultOptions = config.defaultOptions || {};
        this.queryDefaults = [];
        this.mutationDefaults = [];
        this.mountCount = 0;
      }
      mount() {
        this.mountCount++;
        if (this.mountCount !== 1)
          return;
        this.unsubscribeFocus = focusManager.subscribe(() => {
          if (focusManager.isFocused()) {
            this.resumePausedMutations();
            this.queryCache.onFocus();
          }
        });
        this.unsubscribeOnline = onlineManager.subscribe(() => {
          if (onlineManager.isOnline()) {
            this.resumePausedMutations();
            this.queryCache.onOnline();
          }
        });
      }
      unmount() {
        var _this$unsubscribeFocu, _this$unsubscribeOnli;
        this.mountCount--;
        if (this.mountCount !== 0)
          return;
        (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
        this.unsubscribeFocus = void 0;
        (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
        this.unsubscribeOnline = void 0;
      }
      isFetching(arg1, arg2) {
        const [filters] = parseFilterArgs(arg1, arg2);
        filters.fetchStatus = "fetching";
        return this.queryCache.findAll(filters).length;
      }
      isMutating(filters) {
        return this.mutationCache.findAll({
          ...filters,
          fetching: true
        }).length;
      }
      getQueryData(queryKey, filters) {
        var _this$queryCache$find;
        return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
      }
      ensureQueryData(arg1, arg2, arg3) {
        const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
        const cachedData = this.getQueryData(parsedOptions.queryKey);
        return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);
      }
      getQueriesData(queryKeyOrFilters) {
        return this.getQueryCache().findAll(queryKeyOrFilters).map(({
          queryKey,
          state
        }) => {
          const data2 = state.data;
          return [queryKey, data2];
        });
      }
      setQueryData(queryKey, updater, options) {
        const query = this.queryCache.find(queryKey);
        const prevData = query == null ? void 0 : query.state.data;
        const data2 = functionalUpdate(updater, prevData);
        if (typeof data2 === "undefined") {
          return void 0;
        }
        const parsedOptions = parseQueryArgs(queryKey);
        const defaultedOptions = this.defaultQueryOptions(parsedOptions);
        return this.queryCache.build(this, defaultedOptions).setData(data2, {
          ...options,
          manual: true
        });
      }
      setQueriesData(queryKeyOrFilters, updater, options) {
        return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({
          queryKey
        }) => [queryKey, this.setQueryData(queryKey, updater, options)]));
      }
      getQueryState(queryKey, filters) {
        var _this$queryCache$find2;
        return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
      }
      removeQueries(arg1, arg2) {
        const [filters] = parseFilterArgs(arg1, arg2);
        const queryCache = this.queryCache;
        notifyManager.batch(() => {
          queryCache.findAll(filters).forEach((query) => {
            queryCache.remove(query);
          });
        });
      }
      resetQueries(arg1, arg2, arg3) {
        const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
        const queryCache = this.queryCache;
        const refetchFilters = {
          type: "active",
          ...filters
        };
        return notifyManager.batch(() => {
          queryCache.findAll(filters).forEach((query) => {
            query.reset();
          });
          return this.refetchQueries(refetchFilters, options);
        });
      }
      cancelQueries(arg1, arg2, arg3) {
        const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);
        if (typeof cancelOptions.revert === "undefined") {
          cancelOptions.revert = true;
        }
        const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map((query) => query.cancel(cancelOptions)));
        return Promise.all(promises).then(noop$8).catch(noop$8);
      }
      invalidateQueries(arg1, arg2, arg3) {
        const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
        return notifyManager.batch(() => {
          var _ref, _filters$refetchType;
          this.queryCache.findAll(filters).forEach((query) => {
            query.invalidate();
          });
          if (filters.refetchType === "none") {
            return Promise.resolve();
          }
          const refetchFilters = {
            ...filters,
            type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : "active"
          };
          return this.refetchQueries(refetchFilters, options);
        });
      }
      refetchQueries(arg1, arg2, arg3) {
        const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
        const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
          var _options$cancelRefetc;
          return query.fetch(void 0, {
            ...options,
            cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,
            meta: {
              refetchPage: filters.refetchPage
            }
          });
        }));
        let promise = Promise.all(promises).then(noop$8);
        if (!(options != null && options.throwOnError)) {
          promise = promise.catch(noop$8);
        }
        return promise;
      }
      fetchQuery(arg1, arg2, arg3) {
        const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
        const defaultedOptions = this.defaultQueryOptions(parsedOptions);
        if (typeof defaultedOptions.retry === "undefined") {
          defaultedOptions.retry = false;
        }
        const query = this.queryCache.build(this, defaultedOptions);
        return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
      }
      prefetchQuery(arg1, arg2, arg3) {
        return this.fetchQuery(arg1, arg2, arg3).then(noop$8).catch(noop$8);
      }
      fetchInfiniteQuery(arg1, arg2, arg3) {
        const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
        parsedOptions.behavior = infiniteQueryBehavior();
        return this.fetchQuery(parsedOptions);
      }
      prefetchInfiniteQuery(arg1, arg2, arg3) {
        return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop$8).catch(noop$8);
      }
      resumePausedMutations() {
        return this.mutationCache.resumePausedMutations();
      }
      getQueryCache() {
        return this.queryCache;
      }
      getMutationCache() {
        return this.mutationCache;
      }
      getLogger() {
        return this.logger;
      }
      getDefaultOptions() {
        return this.defaultOptions;
      }
      setDefaultOptions(options) {
        this.defaultOptions = options;
      }
      setQueryDefaults(queryKey, options) {
        const result = this.queryDefaults.find((x2) => hashQueryKey(queryKey) === hashQueryKey(x2.queryKey));
        if (result) {
          result.defaultOptions = options;
        } else {
          this.queryDefaults.push({
            queryKey,
            defaultOptions: options
          });
        }
      }
      getQueryDefaults(queryKey) {
        if (!queryKey) {
          return void 0;
        }
        const firstMatchingDefaults = this.queryDefaults.find((x2) => partialMatchKey(queryKey, x2.queryKey));
        return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
      }
      setMutationDefaults(mutationKey, options) {
        const result = this.mutationDefaults.find((x2) => hashQueryKey(mutationKey) === hashQueryKey(x2.mutationKey));
        if (result) {
          result.defaultOptions = options;
        } else {
          this.mutationDefaults.push({
            mutationKey,
            defaultOptions: options
          });
        }
      }
      getMutationDefaults(mutationKey) {
        if (!mutationKey) {
          return void 0;
        }
        const firstMatchingDefaults = this.mutationDefaults.find((x2) => partialMatchKey(mutationKey, x2.mutationKey));
        return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
      }
      defaultQueryOptions(options) {
        if (options != null && options._defaulted) {
          return options;
        }
        const defaultedOptions = {
          ...this.defaultOptions.queries,
          ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),
          ...options,
          _defaulted: true
        };
        if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
          defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
        }
        if (typeof defaultedOptions.refetchOnReconnect === "undefined") {
          defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
        }
        if (typeof defaultedOptions.useErrorBoundary === "undefined") {
          defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
        }
        return defaultedOptions;
      }
      defaultMutationOptions(options) {
        if (options != null && options._defaulted) {
          return options;
        }
        return {
          ...this.defaultOptions.mutations,
          ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),
          ...options,
          _defaulted: true
        };
      }
      clear() {
        this.queryCache.clear();
        this.mutationCache.clear();
      }
    }
    class QueryObserver extends Subscribable {
      constructor(client, options) {
        super();
        this.client = client;
        this.options = options;
        this.trackedProps = /* @__PURE__ */ new Set();
        this.selectError = null;
        this.bindMethods();
        this.setOptions(options);
      }
      bindMethods() {
        this.remove = this.remove.bind(this);
        this.refetch = this.refetch.bind(this);
      }
      onSubscribe() {
        if (this.listeners.length === 1) {
          this.currentQuery.addObserver(this);
          if (shouldFetchOnMount(this.currentQuery, this.options)) {
            this.executeFetch();
          }
          this.updateTimers();
        }
      }
      onUnsubscribe() {
        if (!this.listeners.length) {
          this.destroy();
        }
      }
      shouldFetchOnReconnect() {
        return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
      }
      shouldFetchOnWindowFocus() {
        return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
      }
      destroy() {
        this.listeners = [];
        this.clearStaleTimeout();
        this.clearRefetchInterval();
        this.currentQuery.removeObserver(this);
      }
      setOptions(options, notifyOptions) {
        const prevOptions = this.options;
        const prevQuery = this.currentQuery;
        this.options = this.client.defaultQueryOptions(options);
        if (!shallowEqualObjects(prevOptions, this.options)) {
          this.client.getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: this.currentQuery,
            observer: this
          });
        }
        if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
          throw new Error("Expected enabled to be a boolean");
        }
        if (!this.options.queryKey) {
          this.options.queryKey = prevOptions.queryKey;
        }
        this.updateQuery();
        const mounted = this.hasListeners();
        if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
          this.executeFetch();
        }
        this.updateResult(notifyOptions);
        if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
          this.updateStaleTimeout();
        }
        const nextRefetchInterval = this.computeRefetchInterval();
        if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
          this.updateRefetchInterval(nextRefetchInterval);
        }
      }
      getOptimisticResult(options) {
        const query = this.client.getQueryCache().build(this.client, options);
        return this.createResult(query, options);
      }
      getCurrentResult() {
        return this.currentResult;
      }
      trackResult(result) {
        const trackedResult = {};
        Object.keys(result).forEach((key) => {
          Object.defineProperty(trackedResult, key, {
            configurable: false,
            enumerable: true,
            get: () => {
              this.trackedProps.add(key);
              return result[key];
            }
          });
        });
        return trackedResult;
      }
      getCurrentQuery() {
        return this.currentQuery;
      }
      remove() {
        this.client.getQueryCache().remove(this.currentQuery);
      }
      refetch({
        refetchPage,
        ...options
      } = {}) {
        return this.fetch({
          ...options,
          meta: {
            refetchPage
          }
        });
      }
      fetchOptimistic(options) {
        const defaultedOptions = this.client.defaultQueryOptions(options);
        const query = this.client.getQueryCache().build(this.client, defaultedOptions);
        query.isFetchingOptimistic = true;
        return query.fetch().then(() => this.createResult(query, defaultedOptions));
      }
      fetch(fetchOptions) {
        var _fetchOptions$cancelR;
        return this.executeFetch({
          ...fetchOptions,
          cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true
        }).then(() => {
          this.updateResult();
          return this.currentResult;
        });
      }
      executeFetch(fetchOptions) {
        this.updateQuery();
        let promise = this.currentQuery.fetch(this.options, fetchOptions);
        if (!(fetchOptions != null && fetchOptions.throwOnError)) {
          promise = promise.catch(noop$8);
        }
        return promise;
      }
      updateStaleTimeout() {
        this.clearStaleTimeout();
        if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
          return;
        }
        const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
        const timeout = time + 1;
        this.staleTimeoutId = setTimeout(() => {
          if (!this.currentResult.isStale) {
            this.updateResult();
          }
        }, timeout);
      }
      computeRefetchInterval() {
        var _this$options$refetch;
        return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
      }
      updateRefetchInterval(nextInterval) {
        this.clearRefetchInterval();
        this.currentRefetchInterval = nextInterval;
        if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
          return;
        }
        this.refetchIntervalId = setInterval(() => {
          if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
            this.executeFetch();
          }
        }, this.currentRefetchInterval);
      }
      updateTimers() {
        this.updateStaleTimeout();
        this.updateRefetchInterval(this.computeRefetchInterval());
      }
      clearStaleTimeout() {
        if (this.staleTimeoutId) {
          clearTimeout(this.staleTimeoutId);
          this.staleTimeoutId = void 0;
        }
      }
      clearRefetchInterval() {
        if (this.refetchIntervalId) {
          clearInterval(this.refetchIntervalId);
          this.refetchIntervalId = void 0;
        }
      }
      createResult(query, options) {
        const prevQuery = this.currentQuery;
        const prevOptions = this.options;
        const prevResult = this.currentResult;
        const prevResultState = this.currentResultState;
        const prevResultOptions = this.currentResultOptions;
        const queryChange = query !== prevQuery;
        const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
        const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
        const {
          state
        } = query;
        let {
          dataUpdatedAt,
          error,
          errorUpdatedAt,
          fetchStatus,
          status
        } = state;
        let isPreviousData = false;
        let isPlaceholderData = false;
        let data2;
        if (options._optimisticResults) {
          const mounted = this.hasListeners();
          const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
          const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
          if (fetchOnMount || fetchOptionally) {
            fetchStatus = canFetch(query.options.networkMode) ? "fetching" : "paused";
            if (!dataUpdatedAt) {
              status = "loading";
            }
          }
          if (options._optimisticResults === "isRestoring") {
            fetchStatus = "idle";
          }
        }
        if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== "error") {
          data2 = prevQueryResult.data;
          dataUpdatedAt = prevQueryResult.dataUpdatedAt;
          status = prevQueryResult.status;
          isPreviousData = true;
        } else if (options.select && typeof state.data !== "undefined") {
          if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
            data2 = this.selectResult;
          } else {
            try {
              this.selectFn = options.select;
              data2 = options.select(state.data);
              data2 = replaceData(prevResult == null ? void 0 : prevResult.data, data2, options);
              this.selectResult = data2;
              this.selectError = null;
            } catch (selectError) {
              this.selectError = selectError;
            }
          }
        } else {
          data2 = state.data;
        }
        if (typeof options.placeholderData !== "undefined" && typeof data2 === "undefined" && status === "loading") {
          let placeholderData;
          if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
            placeholderData = prevResult.data;
          } else {
            placeholderData = typeof options.placeholderData === "function" ? options.placeholderData() : options.placeholderData;
            if (options.select && typeof placeholderData !== "undefined") {
              try {
                placeholderData = options.select(placeholderData);
                this.selectError = null;
              } catch (selectError) {
                this.selectError = selectError;
              }
            }
          }
          if (typeof placeholderData !== "undefined") {
            status = "success";
            data2 = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);
            isPlaceholderData = true;
          }
        }
        if (this.selectError) {
          error = this.selectError;
          data2 = this.selectResult;
          errorUpdatedAt = Date.now();
          status = "error";
        }
        const isFetching = fetchStatus === "fetching";
        const isLoading = status === "loading";
        const isError2 = status === "error";
        const result = {
          status,
          fetchStatus,
          isLoading,
          isSuccess: status === "success",
          isError: isError2,
          isInitialLoading: isLoading && isFetching,
          data: data2,
          dataUpdatedAt,
          error,
          errorUpdatedAt,
          failureCount: state.fetchFailureCount,
          failureReason: state.fetchFailureReason,
          errorUpdateCount: state.errorUpdateCount,
          isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
          isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
          isFetching,
          isRefetching: isFetching && !isLoading,
          isLoadingError: isError2 && state.dataUpdatedAt === 0,
          isPaused: fetchStatus === "paused",
          isPlaceholderData,
          isPreviousData,
          isRefetchError: isError2 && state.dataUpdatedAt !== 0,
          isStale: isStale(query, options),
          refetch: this.refetch,
          remove: this.remove
        };
        return result;
      }
      updateResult(notifyOptions) {
        const prevResult = this.currentResult;
        const nextResult = this.createResult(this.currentQuery, this.options);
        this.currentResultState = this.currentQuery.state;
        this.currentResultOptions = this.options;
        if (shallowEqualObjects(nextResult, prevResult)) {
          return;
        }
        this.currentResult = nextResult;
        const defaultNotifyOptions = {
          cache: true
        };
        const shouldNotifyListeners = () => {
          if (!prevResult) {
            return true;
          }
          const {
            notifyOnChangeProps
          } = this.options;
          if (notifyOnChangeProps === "all" || !notifyOnChangeProps && !this.trackedProps.size) {
            return true;
          }
          const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);
          if (this.options.useErrorBoundary) {
            includedProps.add("error");
          }
          return Object.keys(this.currentResult).some((key) => {
            const typedKey = key;
            const changed = this.currentResult[typedKey] !== prevResult[typedKey];
            return changed && includedProps.has(typedKey);
          });
        };
        if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
          defaultNotifyOptions.listeners = true;
        }
        this.notify({
          ...defaultNotifyOptions,
          ...notifyOptions
        });
      }
      updateQuery() {
        const query = this.client.getQueryCache().build(this.client, this.options);
        if (query === this.currentQuery) {
          return;
        }
        const prevQuery = this.currentQuery;
        this.currentQuery = query;
        this.currentQueryInitialState = query.state;
        this.previousQueryResult = this.currentResult;
        if (this.hasListeners()) {
          prevQuery == null ? void 0 : prevQuery.removeObserver(this);
          query.addObserver(this);
        }
      }
      onQueryUpdate(action) {
        const notifyOptions = {};
        if (action.type === "success") {
          notifyOptions.onSuccess = !action.manual;
        } else if (action.type === "error" && !isCancelledError(action.error)) {
          notifyOptions.onError = true;
        }
        this.updateResult(notifyOptions);
        if (this.hasListeners()) {
          this.updateTimers();
        }
      }
      notify(notifyOptions) {
        notifyManager.batch(() => {
          if (notifyOptions.onSuccess) {
            var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;
            (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);
            (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);
          } else if (notifyOptions.onError) {
            var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;
            (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);
            (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, void 0, this.currentResult.error);
          }
          if (notifyOptions.listeners) {
            this.listeners.forEach((listener) => {
              listener(this.currentResult);
            });
          }
          if (notifyOptions.cache) {
            this.client.getQueryCache().notify({
              query: this.currentQuery,
              type: "observerResultsUpdated"
            });
          }
        });
      }
    }
    function shouldLoadOnMount(query, options) {
      return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
    }
    function shouldFetchOnMount(query, options) {
      return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
    }
    function shouldFetchOn(query, options, field) {
      if (options.enabled !== false) {
        const value = typeof field === "function" ? field(query) : field;
        return value === "always" || value !== false && isStale(query, options);
      }
      return false;
    }
    function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
      return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
    }
    function isStale(query, options) {
      return query.isStaleByTime(options.staleTime);
    }
    let MutationObserver$1 = class MutationObserver extends Subscribable {
      constructor(client, options) {
        super();
        this.client = client;
        this.setOptions(options);
        this.bindMethods();
        this.updateResult();
      }
      bindMethods() {
        this.mutate = this.mutate.bind(this);
        this.reset = this.reset.bind(this);
      }
      setOptions(options) {
        var _this$currentMutation;
        const prevOptions = this.options;
        this.options = this.client.defaultMutationOptions(options);
        if (!shallowEqualObjects(prevOptions, this.options)) {
          this.client.getMutationCache().notify({
            type: "observerOptionsUpdated",
            mutation: this.currentMutation,
            observer: this
          });
        }
        (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);
      }
      onUnsubscribe() {
        if (!this.listeners.length) {
          var _this$currentMutation2;
          (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);
        }
      }
      onMutationUpdate(action) {
        this.updateResult();
        const notifyOptions = {
          listeners: true
        };
        if (action.type === "success") {
          notifyOptions.onSuccess = true;
        } else if (action.type === "error") {
          notifyOptions.onError = true;
        }
        this.notify(notifyOptions);
      }
      getCurrentResult() {
        return this.currentResult;
      }
      reset() {
        this.currentMutation = void 0;
        this.updateResult();
        this.notify({
          listeners: true
        });
      }
      mutate(variables, options) {
        this.mutateOptions = options;
        if (this.currentMutation) {
          this.currentMutation.removeObserver(this);
        }
        this.currentMutation = this.client.getMutationCache().build(this.client, {
          ...this.options,
          variables: typeof variables !== "undefined" ? variables : this.options.variables
        });
        this.currentMutation.addObserver(this);
        return this.currentMutation.execute();
      }
      updateResult() {
        const state = this.currentMutation ? this.currentMutation.state : getDefaultState();
        const result = {
          ...state,
          isLoading: state.status === "loading",
          isSuccess: state.status === "success",
          isError: state.status === "error",
          isIdle: state.status === "idle",
          mutate: this.mutate,
          reset: this.reset
        };
        this.currentResult = result;
      }
      notify(options) {
        notifyManager.batch(() => {
          if (this.mutateOptions && this.hasListeners()) {
            if (options.onSuccess) {
              var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;
              (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
              (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
            } else if (options.onError) {
              var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;
              (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
              (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
            }
          }
          if (options.listeners) {
            this.listeners.forEach((listener) => {
              listener(this.currentResult);
            });
          }
        });
      }
    };
    var shimExports = {};
    var shim = {
      get exports() {
        return shimExports;
      },
      set exports(v2) {
        shimExports = v2;
      }
    };
    var useSyncExternalStoreShim_production_min = {};
    /**
     * @license React
     * use-sync-external-store-shim.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var e$3 = reactExports;
    function h$2(a, b2) {
      return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
    }
    var k$4 = "function" === typeof Object.is ? Object.is : h$2, l$3 = e$3.useState, m$3 = e$3.useEffect, n$4 = e$3.useLayoutEffect, p$4 = e$3.useDebugValue;
    function q$3(a, b2) {
      var d2 = b2(), f2 = l$3({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
      n$4(function() {
        c2.value = d2;
        c2.getSnapshot = b2;
        r$2(c2) && g2({ inst: c2 });
      }, [a, d2, b2]);
      m$3(function() {
        r$2(c2) && g2({ inst: c2 });
        return a(function() {
          r$2(c2) && g2({ inst: c2 });
        });
      }, [a]);
      p$4(d2);
      return d2;
    }
    function r$2(a) {
      var b2 = a.getSnapshot;
      a = a.value;
      try {
        var d2 = b2();
        return !k$4(a, d2);
      } catch (f2) {
        return true;
      }
    }
    function t$3(a, b2) {
      return b2();
    }
    var u$d = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$3 : q$3;
    useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$3.useSyncExternalStore ? e$3.useSyncExternalStore : u$d;
    (function(module2) {
      {
        module2.exports = useSyncExternalStoreShim_production_min;
      }
    })(shim);
    const useSyncExternalStore = shimExports.useSyncExternalStore;
    const defaultContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const QueryClientSharingContext = /* @__PURE__ */ reactExports.createContext(false);
    function getQueryClientContext(context, contextSharing) {
      if (context) {
        return context;
      }
      if (contextSharing && typeof window !== "undefined") {
        if (!window.ReactQueryClientContext) {
          window.ReactQueryClientContext = defaultContext;
        }
        return window.ReactQueryClientContext;
      }
      return defaultContext;
    }
    const useQueryClient = ({
      context
    } = {}) => {
      const queryClient = reactExports.useContext(getQueryClientContext(context, reactExports.useContext(QueryClientSharingContext)));
      if (!queryClient) {
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
      }
      return queryClient;
    };
    const QueryClientProvider = ({
      client,
      children,
      context,
      contextSharing = false
    }) => {
      reactExports.useEffect(() => {
        client.mount();
        return () => {
          client.unmount();
        };
      }, [client]);
      const Context2 = getQueryClientContext(context, contextSharing);
      return /* @__PURE__ */ reactExports.createElement(QueryClientSharingContext.Provider, {
        value: !context && contextSharing
      }, /* @__PURE__ */ reactExports.createElement(Context2.Provider, {
        value: client
      }, children));
    };
    const IsRestoringContext = /* @__PURE__ */ reactExports.createContext(false);
    const useIsRestoring = () => reactExports.useContext(IsRestoringContext);
    IsRestoringContext.Provider;
    function createValue() {
      let isReset = false;
      return {
        clearReset: () => {
          isReset = false;
        },
        reset: () => {
          isReset = true;
        },
        isReset: () => {
          return isReset;
        }
      };
    }
    const QueryErrorResetBoundaryContext = /* @__PURE__ */ reactExports.createContext(createValue());
    const useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
    function shouldThrowError(_useErrorBoundary, params) {
      if (typeof _useErrorBoundary === "function") {
        return _useErrorBoundary(...params);
      }
      return !!_useErrorBoundary;
    }
    const ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
      if (options.suspense || options.useErrorBoundary) {
        if (!errorResetBoundary.isReset()) {
          options.retryOnMount = false;
        }
      }
    };
    const useClearResetErrorBoundary = (errorResetBoundary) => {
      reactExports.useEffect(() => {
        errorResetBoundary.clearReset();
      }, [errorResetBoundary]);
    };
    const getHasError = ({
      result,
      errorResetBoundary,
      useErrorBoundary,
      query
    }) => {
      return result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(useErrorBoundary, [result.error, query]);
    };
    const ensureStaleTime = (defaultedOptions) => {
      if (defaultedOptions.suspense) {
        if (typeof defaultedOptions.staleTime !== "number") {
          defaultedOptions.staleTime = 1e3;
        }
      }
    };
    const willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
    const shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);
    const fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({
      data: data2
    }) => {
      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data2);
      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data2, null);
    }).catch((error) => {
      errorResetBoundary.clearReset();
      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(void 0, error);
    });
    function useBaseQuery(options, Observer) {
      const queryClient = useQueryClient({
        context: options.context
      });
      const isRestoring = useIsRestoring();
      const errorResetBoundary = useQueryErrorResetBoundary();
      const defaultedOptions = queryClient.defaultQueryOptions(options);
      defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
      if (defaultedOptions.onError) {
        defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);
      }
      if (defaultedOptions.onSuccess) {
        defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);
      }
      if (defaultedOptions.onSettled) {
        defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);
      }
      ensureStaleTime(defaultedOptions);
      ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
      useClearResetErrorBoundary(errorResetBoundary);
      const [observer] = reactExports.useState(() => new Observer(queryClient, defaultedOptions));
      const result = observer.getOptimisticResult(defaultedOptions);
      useSyncExternalStore(reactExports.useCallback((onStoreChange) => isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
      reactExports.useEffect(() => {
        observer.setOptions(defaultedOptions, {
          listeners: false
        });
      }, [defaultedOptions, observer]);
      if (shouldSuspend(defaultedOptions, result, isRestoring)) {
        throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
      }
      if (getHasError({
        result,
        errorResetBoundary,
        useErrorBoundary: defaultedOptions.useErrorBoundary,
        query: observer.getCurrentQuery()
      })) {
        throw result.error;
      }
      return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
    }
    function useQuery(arg1, arg2, arg3) {
      const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
      return useBaseQuery(parsedOptions, QueryObserver);
    }
    function useMutation(arg1, arg2, arg3) {
      const options = parseMutationArgs(arg1, arg2, arg3);
      const queryClient = useQueryClient({
        context: options.context
      });
      const [observer] = reactExports.useState(() => new MutationObserver$1(queryClient, options));
      reactExports.useEffect(() => {
        observer.setOptions(options);
      }, [observer, options]);
      const result = useSyncExternalStore(reactExports.useCallback((onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
      const mutate2 = reactExports.useCallback((variables, mutateOptions) => {
        observer.mutate(variables, mutateOptions).catch(noop$7);
      }, [observer]);
      if (result.error && shouldThrowError(observer.options.useErrorBoundary, [result.error])) {
        throw result.error;
      }
      return {
        ...result,
        mutate: mutate2,
        mutateAsync: result.mutate
      };
    }
    function noop$7() {
    }
    var shams = function hasSymbols2() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = shams;
    var hasSymbols$1 = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice$4 = Array.prototype.slice;
    var toStr$2 = Object.prototype.toString;
    var funcType = "[object Function]";
    var implementation$1 = function bind2(that) {
      var target = this;
      if (typeof target !== "function" || toStr$2.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice$4.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice$4.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice$4.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i2 = 0; i2 < boundLength; i2++) {
        boundArgs.push("$" + i2);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty2 = function Empty3() {
        };
        Empty2.prototype = target.prototype;
        bound.prototype = new Empty2();
        Empty2.prototype = null;
      }
      return bound;
    };
    var implementation = implementation$1;
    var functionBind = Function.prototype.bind || implementation;
    var bind$4 = functionBind;
    var src = bind$4.call(Function.call, Object.prototype.hasOwnProperty);
    var undefined$1;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError$1 = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e2) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e2) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError$1();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = hasSymbols$1();
    var getProto = Object.getPrototypeOf || function(x2) {
      return x2.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined$1,
      "%AsyncFromSyncIteratorPrototype%": undefined$1,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
      "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
      "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined$1,
      "%Symbol%": hasSymbols ? Symbol : undefined$1,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError$1,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
    };
    try {
      null.error;
    } catch (e2) {
      var errorProto = getProto(getProto(e2));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind$3 = functionBind;
    var hasOwn$2 = src;
    var $concat$1 = bind$3.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind$3.call(Function.apply, Array.prototype.splice);
    var $replace$1 = bind$3.call(Function.call, String.prototype.replace);
    var $strSlice = bind$3.call(Function.call, String.prototype.slice);
    var $exec = bind$3.call(Function.call, RegExp.prototype.exec);
    var rePropName$1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar$1 = /\\(\\)?/g;
    var stringToPath$2 = function stringToPath2(string2) {
      var first = $strSlice(string2, 0, 1);
      var last2 = $strSlice(string2, -1);
      if (first === "%" && last2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last2 === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace$1(string2, rePropName$1, function(match2, number2, quote2, subString) {
        result[result.length] = quote2 ? $replace$1(subString, reEscapeChar$1, "$1") : number2 || match2;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn$2(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn$2(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError$1("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    var getIntrinsic = function GetIntrinsic2(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError$1("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError$1('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath$2(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat$1([0, 1], alias));
      }
      for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
        var part = parts[i2];
        var first = $strSlice(part, 0, 1);
        var last2 = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first !== last2) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn$2(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError$1("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i2 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn$2(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
    var callBindExports = {};
    var callBind$1 = {
      get exports() {
        return callBindExports;
      },
      set exports(v2) {
        callBindExports = v2;
      }
    };
    (function(module2) {
      var bind2 = functionBind;
      var GetIntrinsic2 = getIntrinsic;
      var $apply = GetIntrinsic2("%Function.prototype.apply%");
      var $call = GetIntrinsic2("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic2("%Reflect.apply%", true) || bind2.call($call, $apply);
      var $gOPD2 = GetIntrinsic2("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic2("%Object.defineProperty%", true);
      var $max = GetIntrinsic2("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e2) {
          $defineProperty = null;
        }
      }
      module2.exports = function callBind2(originalFunction) {
        var func = $reflectApply(bind2, $call, arguments);
        if ($gOPD2 && $defineProperty) {
          var desc = $gOPD2(func, "length");
          if (desc.configurable) {
            $defineProperty(
              func,
              "length",
              { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
            );
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind2, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module2.exports, "apply", { value: applyBind });
      } else {
        module2.exports.apply = applyBind;
      }
    })(callBind$1);
    var GetIntrinsic$1 = getIntrinsic;
    var callBind = callBindExports;
    var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
    var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic$1(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
    const __viteBrowserExternal = {};
    const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: __viteBrowserExternal
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString$3 = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
      return O2.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require$$0;
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol$5(inspectCustom) ? inspectCustom : null;
    var objectInspect = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has$3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray$i(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect2(value, from2, noIndent) {
        if (from2) {
          seen = $arrSlice.call(seen);
          seen.push(from2);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has$3(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp$1(obj)) {
        var name = nameOf(obj);
        var keys2 = arrObjKeys(obj, inspect2);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
      }
      if (isSymbol$5(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i2 = 0; i2 < attrs.length; i2++) {
          s += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray$i(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect2);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect2);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect2(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber$2(obj)) {
        return markBoxed(inspect2(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect2(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString$3(obj)) {
        return markBoxed(inspect2(String(obj)));
      }
      if (!isDate$1(obj) && !isRegExp$1(obj)) {
        var ys = arrObjKeys(obj, inspect2);
        var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag2 = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr$1(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag2 || protoTag ? "[" + $join.call($concat.call([], stringTag2 || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray$i(obj) {
      return toStr$1(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate$1(obj) {
      return toStr$1(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp$1(obj) {
      return toStr$1(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr$1(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString$3(obj) {
      return toStr$1(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber$2(obj) {
      return toStr$1(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr$1(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol$5(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e2) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e2) {
      }
      return false;
    }
    var hasOwn$1 = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has$3(obj, key) {
      return hasOwn$1.call(obj, key);
    }
    function toStr$1(obj) {
      return objectToString$3.call(obj);
    }
    function nameOf(f2) {
      if (f2.name) {
        return f2.name;
      }
      var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
      if (m2) {
        return m2[1];
      }
      return null;
    }
    function indexOf(xs, x2) {
      if (xs.indexOf) {
        return xs.indexOf(x2);
      }
      for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
        if (xs[i2] === x2) {
          return i2;
        }
      }
      return -1;
    }
    function isMap(x2) {
      if (!mapSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        mapSize.call(x2);
        try {
          setSize.call(x2);
        } catch (s) {
          return true;
        }
        return x2 instanceof Map;
      } catch (e2) {
      }
      return false;
    }
    function isWeakMap(x2) {
      if (!weakMapHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x2, weakMapHas);
        try {
          weakSetHas.call(x2, weakSetHas);
        } catch (s) {
          return true;
        }
        return x2 instanceof WeakMap;
      } catch (e2) {
      }
      return false;
    }
    function isWeakRef(x2) {
      if (!weakRefDeref || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x2);
        return true;
      } catch (e2) {
      }
      return false;
    }
    function isSet(x2) {
      if (!setSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        setSize.call(x2);
        try {
          mapSize.call(x2);
        } catch (m2) {
          return true;
        }
        return x2 instanceof Set;
      } catch (e2) {
      }
      return false;
    }
    function isWeakSet(x2) {
      if (!weakSetHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x2, weakSetHas);
        try {
          weakMapHas.call(x2, weakMapHas);
        } catch (s) {
          return true;
        }
        return x2 instanceof WeakSet;
      } catch (e2) {
      }
      return false;
    }
    function isElement(x2) {
      if (!x2 || typeof x2 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
        return true;
      }
      return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c2) {
      var n2 = c2.charCodeAt(0);
      var x2 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n2];
      if (x2) {
        return "\\" + x2;
      }
      return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type2) {
      return type2 + " { ? }";
    }
    function collectionOf(type2, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type2 + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i2 = 0; i2 < xs.length; i2++) {
        if (indexOf(xs[i2], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect2) {
      var isArr = isArray$i(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i2 = 0; i2 < obj.length; i2++) {
          xs[i2] = has$3(obj, i2) ? inspect2(obj[i2], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k2 = 0; k2 < syms.length; k2++) {
          symMap["$" + syms[k2]] = syms[k2];
        }
      }
      for (var key in obj) {
        if (!has$3(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect2(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
    var GetIntrinsic = getIntrinsic;
    var callBound = callBound$1;
    var inspect = objectInspect;
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list2, key) {
      for (var prev2 = list2, curr; (curr = prev2.next) !== null; prev2 = curr) {
        if (curr.key === key) {
          prev2.next = curr.next;
          curr.next = list2.next;
          list2.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node2 = listGetNode(objects, key);
      return node2 && node2.value;
    };
    var listSet = function(objects, key, value) {
      var node2 = listGetNode(objects, key);
      if (node2) {
        node2.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    var sideChannel = function getSideChannel2() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
    var replace$2 = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    var formats$3 = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace$2.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
    var formats$2 = formats$3;
    var has$2 = Object.prototype.hasOwnProperty;
    var isArray$h = Array.isArray;
    var hexTable = function() {
      var array2 = [];
      for (var i2 = 0; i2 < 256; ++i2) {
        array2.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
      }
      return array2;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray$h(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i2 = 0; i2 < source.length; ++i2) {
        if (typeof source[i2] !== "undefined") {
          obj[i2] = source[i2];
        }
      }
      return obj;
    };
    var merge$5 = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray$h(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray$h(target) && !isArray$h(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray$h(target) && isArray$h(source)) {
        source.forEach(function(item, i2) {
          if (has$2.call(target, i2)) {
            var targetItem = target[i2];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i2] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i2] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has$2.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign$6 = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode$2 = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e2) {
        return strWithoutPlus;
      }
    };
    var encode$2 = function encode2(str, defaultEncoder, charset, kind, format2) {
      if (str.length === 0) {
        return str;
      }
      var string2 = str;
      if (typeof str === "symbol") {
        string2 = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string2 = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i2 = 0; i2 < string2.length; ++i2) {
        var c2 = string2.charCodeAt(i2);
        if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format2 === formats$2.RFC1738 && (c2 === 40 || c2 === 41)) {
          out += string2.charAt(i2);
          continue;
        }
        if (c2 < 128) {
          out = out + hexTable[c2];
          continue;
        }
        if (c2 < 2048) {
          out = out + (hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63]);
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          out = out + (hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63]);
          continue;
        }
        i2 += 1;
        c2 = 65536 + ((c2 & 1023) << 10 | string2.charCodeAt(i2) & 1023);
        out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i2 = 0; i2 < queue.length; ++i2) {
        var item = queue[i2];
        var obj = item.obj[item.prop];
        var keys2 = Object.keys(obj);
        for (var j = 0; j < keys2.length; ++j) {
          var key = keys2[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer$7 = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine$1 = function combine2(a, b2) {
      return [].concat(a, b2);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray$h(val)) {
        var mapped = [];
        for (var i2 = 0; i2 < val.length; i2 += 1) {
          mapped.push(fn(val[i2]));
        }
        return mapped;
      }
      return fn(val);
    };
    var utils$f = {
      arrayToObject,
      assign: assign$6,
      combine: combine$1,
      compact,
      decode: decode$2,
      encode: encode$2,
      isBuffer: isBuffer$7,
      isRegExp,
      maybeMap,
      merge: merge$5
    };
    var getSideChannel = sideChannel;
    var utils$e = utils$f;
    var formats$1 = formats$3;
    var has$1 = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray$g = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray$g(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats$1["default"];
    var defaults$5 = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils$e.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats$1.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date2) {
        return toISO.call(date2);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
      return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
    };
    var sentinel = {};
    var stringify$6 = function stringify2(object2, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter2, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
      var obj = object2;
      var tmpSc = sideChannel2;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object2);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter2 === "function") {
        obj = filter2(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray$g(obj)) {
        obj = utils$e.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults$5.encoder, charset, "key", format2) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils$e.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$5.encoder, charset, "key", format2);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$5.encoder, charset, "value", format2))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray$g(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils$e.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray$g(filter2)) {
        objKeys = filter2;
      } else {
        var keys2 = Object.keys(obj);
        objKeys = sort ? keys2.sort(sort) : keys2;
      }
      var adjustedPrefix = commaRoundTrip && isArray$g(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray$g(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel2.set(object2, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel2);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray$g(obj) ? null : encoder,
          filter2,
          sort,
          allowDots,
          serializeDate,
          format2,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults$5;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults$5.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format2 = formats$1["default"];
      if (typeof opts.format !== "undefined") {
        if (!has$1.call(formats$1.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format2 = opts.format;
      }
      var formatter = formats$1.formatters[format2];
      var filter2 = defaults$5.filter;
      if (typeof opts.filter === "function" || isArray$g(opts.filter)) {
        filter2 = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$5.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults$5.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$5.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults$5.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults$5.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$5.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$5.encodeValuesOnly,
        filter: filter2,
        format: format2,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$5.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$5.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$5.strictNullHandling
      };
    };
    var stringify_1 = function(object2, opts) {
      var obj = object2;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter2;
      if (typeof options.filter === "function") {
        filter2 = options.filter;
        obj = filter2("", obj);
      } else if (isArray$g(options.filter)) {
        filter2 = options.filter;
        objKeys = filter2;
      }
      var keys2 = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel2 = getSideChannel();
      for (var i2 = 0; i2 < objKeys.length; ++i2) {
        var key = objKeys[i2];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys2, stringify$6(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel2
        ));
      }
      var joined = keys2.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
    var utils$d = utils$f;
    var has = Object.prototype.hasOwnProperty;
    var isArray$f = Array.isArray;
    var defaults$4 = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils$d.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i2;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i2 = 0; i2 < parts.length; ++i2) {
          if (parts[i2].indexOf("utf8=") === 0) {
            if (parts[i2] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i2] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i2;
            i2 = parts.length;
          }
        }
      }
      for (i2 = 0; i2 < parts.length; ++i2) {
        if (i2 === skipIndex) {
          continue;
        }
        var part = parts[i2];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults$4.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults$4.decoder, charset, "key");
          val = utils$d.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults$4.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray$f(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils$d.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i2 = chain.length - 1; i2 >= 0; --i2) {
        var obj;
        var root2 = chain[i2];
        if (root2 === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
          var index2 = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index2) && root2 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
            obj = [];
            obj[index2] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys$1 = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys2 = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys2.push(parent);
      }
      var i2 = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
        i2 += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys2.push(segment[1]);
      }
      if (segment) {
        keys2.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys2, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults$4;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults$4.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults$4.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults$4.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults$4.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults$4.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$4.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults$4.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults$4.decoder,
        delimiter: typeof opts.delimiter === "string" || utils$d.isRegExp(opts.delimiter) ? opts.delimiter : defaults$4.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults$4.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults$4.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults$4.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults$4.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$4.strictNullHandling
      };
    };
    var parse$3 = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys2 = Object.keys(tempObj);
      for (var i2 = 0; i2 < keys2.length; ++i2) {
        var key = keys2[i2];
        var newObj = parseKeys$1(key, tempObj[key], options, typeof str === "string");
        obj = utils$d.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils$d.compact(obj);
    };
    var stringify$5 = stringify_1;
    var parse$2 = parse$3;
    var formats = formats$3;
    var lib$4 = {
      formats,
      parse: parse$2,
      stringify: stringify$5
    };
    function identity$4(value) {
      return value;
    }
    var identity_1 = identity$4;
    function apply$1(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    var _apply = apply$1;
    var apply = _apply;
    var nativeMax$2 = Math.max;
    function overRest$1(func, start2, transform) {
      start2 = nativeMax$2(start2 === void 0 ? func.length - 1 : start2, 0);
      return function() {
        var args = arguments, index2 = -1, length2 = nativeMax$2(args.length - start2, 0), array2 = Array(length2);
        while (++index2 < length2) {
          array2[index2] = args[start2 + index2];
        }
        index2 = -1;
        var otherArgs = Array(start2 + 1);
        while (++index2 < start2) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start2] = transform(array2);
        return apply(func, this, otherArgs);
      };
    }
    var _overRest = overRest$1;
    function constant$1(value) {
      return function() {
        return value;
      };
    }
    var constant_1 = constant$1;
    var freeGlobal$3 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var _freeGlobal = freeGlobal$3;
    var freeGlobal$2 = _freeGlobal;
    var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
    var root$d = freeGlobal$2 || freeSelf$1 || Function("return this")();
    var _root = root$d;
    var root$c = _root;
    var Symbol$8 = root$c.Symbol;
    var _Symbol = Symbol$8;
    var Symbol$7 = _Symbol;
    var objectProto$n = Object.prototype;
    var hasOwnProperty$n = objectProto$n.hasOwnProperty;
    var nativeObjectToString$3 = objectProto$n.toString;
    var symToStringTag$3 = Symbol$7 ? Symbol$7.toStringTag : void 0;
    function getRawTag$2(value) {
      var isOwn = hasOwnProperty$n.call(value, symToStringTag$3), tag = value[symToStringTag$3];
      try {
        value[symToStringTag$3] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString$3.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$3] = tag;
        } else {
          delete value[symToStringTag$3];
        }
      }
      return result;
    }
    var _getRawTag = getRawTag$2;
    var objectProto$m = Object.prototype;
    var nativeObjectToString$2 = objectProto$m.toString;
    function objectToString$2(value) {
      return nativeObjectToString$2.call(value);
    }
    var _objectToString = objectToString$2;
    var Symbol$6 = _Symbol, getRawTag$1 = _getRawTag, objectToString$1 = _objectToString;
    var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
    var symToStringTag$2 = Symbol$6 ? Symbol$6.toStringTag : void 0;
    function baseGetTag$6(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag$1 : nullTag$1;
      }
      return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$1(value) : objectToString$1(value);
    }
    var _baseGetTag = baseGetTag$6;
    function isObject$9(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    var isObject_1 = isObject$9;
    var baseGetTag$5 = _baseGetTag, isObject$8 = isObject_1;
    var asyncTag$1 = "[object AsyncFunction]", funcTag$3 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
    function isFunction$6(value) {
      if (!isObject$8(value)) {
        return false;
      }
      var tag = baseGetTag$5(value);
      return tag == funcTag$3 || tag == genTag$1 || tag == asyncTag$1 || tag == proxyTag$1;
    }
    var isFunction_1 = isFunction$6;
    var root$b = _root;
    var coreJsData$3 = root$b["__core-js_shared__"];
    var _coreJsData = coreJsData$3;
    var coreJsData$2 = _coreJsData;
    var maskSrcKey$1 = function() {
      var uid2 = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked$2(func) {
      return !!maskSrcKey$1 && maskSrcKey$1 in func;
    }
    var _isMasked = isMasked$2;
    var funcProto$3 = Function.prototype;
    var funcToString$3 = funcProto$3.toString;
    function toSource$3(func) {
      if (func != null) {
        try {
          return funcToString$3.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    var _toSource = toSource$3;
    var isFunction$5 = isFunction_1, isMasked$1 = _isMasked, isObject$7 = isObject_1, toSource$2 = _toSource;
    var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
    var funcProto$2 = Function.prototype, objectProto$l = Object.prototype;
    var funcToString$2 = funcProto$2.toString;
    var hasOwnProperty$m = objectProto$l.hasOwnProperty;
    var reIsNative$1 = RegExp(
      "^" + funcToString$2.call(hasOwnProperty$m).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative$2(value) {
      if (!isObject$7(value) || isMasked$1(value)) {
        return false;
      }
      var pattern2 = isFunction$5(value) ? reIsNative$1 : reIsHostCtor$1;
      return pattern2.test(toSource$2(value));
    }
    var _baseIsNative = baseIsNative$2;
    function getValue$7(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    var _getValue = getValue$7;
    var baseIsNative$1 = _baseIsNative, getValue$6 = _getValue;
    function getNative$8(object2, key) {
      var value = getValue$6(object2, key);
      return baseIsNative$1(value) ? value : void 0;
    }
    var _getNative = getNative$8;
    var getNative$7 = _getNative;
    var defineProperty$4 = function() {
      try {
        var func = getNative$7(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    var _defineProperty$8 = defineProperty$4;
    var constant = constant_1, defineProperty$3 = _defineProperty$8, identity$3 = identity_1;
    var baseSetToString$1 = !defineProperty$3 ? identity$3 : function(func, string2) {
      return defineProperty$3(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    var _baseSetToString = baseSetToString$1;
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut$1(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    var _shortOut = shortOut$1;
    var baseSetToString = _baseSetToString, shortOut = _shortOut;
    var setToString$1 = shortOut(baseSetToString);
    var _setToString = setToString$1;
    var identity$2 = identity_1, overRest = _overRest, setToString = _setToString;
    function baseRest$3(func, start2) {
      return setToString(overRest(func, start2, identity$2), func + "");
    }
    var _baseRest = baseRest$3;
    function arrayFilter$3(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    var _arrayFilter = arrayFilter$3;
    function arrayMap$3(array2, iteratee) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
      while (++index2 < length2) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    var _arrayMap = arrayMap$3;
    function baseProperty$2(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    var _baseProperty = baseProperty$2;
    function baseTimes$3(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    var _baseTimes = baseTimes$3;
    var MAX_SAFE_INTEGER$3 = 9007199254740991;
    function isLength$4(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$3;
    }
    var isLength_1 = isLength$4;
    var isFunction$4 = isFunction_1, isLength$3 = isLength_1;
    function isArrayLike$3(value) {
      return value != null && isLength$3(value.length) && !isFunction$4(value);
    }
    var isArrayLike_1 = isArrayLike$3;
    function isObjectLike$7(value) {
      return value != null && typeof value == "object";
    }
    var isObjectLike_1 = isObjectLike$7;
    var isArrayLike$2 = isArrayLike_1, isObjectLike$6 = isObjectLike_1;
    function isArrayLikeObject$3(value) {
      return isObjectLike$6(value) && isArrayLike$2(value);
    }
    var isArrayLikeObject_1 = isArrayLikeObject$3;
    var arrayFilter$2 = _arrayFilter, arrayMap$2 = _arrayMap, baseProperty$1 = _baseProperty, baseTimes$2 = _baseTimes, isArrayLikeObject$2 = isArrayLikeObject_1;
    var nativeMax$1 = Math.max;
    function unzip$1(array2) {
      if (!(array2 && array2.length)) {
        return [];
      }
      var length2 = 0;
      array2 = arrayFilter$2(array2, function(group) {
        if (isArrayLikeObject$2(group)) {
          length2 = nativeMax$1(group.length, length2);
          return true;
        }
      });
      return baseTimes$2(length2, function(index2) {
        return arrayMap$2(array2, baseProperty$1(index2));
      });
    }
    var unzip_1 = unzip$1;
    var baseRest$2 = _baseRest, unzip = unzip_1;
    baseRest$2(unzip);
    function commonjsRequire(path2) {
      throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }
    var pluralizeExports = {};
    var pluralize = {
      get exports() {
        return pluralizeExports;
      },
      set exports(v2) {
        pluralizeExports = v2;
      }
    };
    (function(module2, exports2) {
      (function(root2, pluralize2) {
        if (typeof commonjsRequire === "function" && true && true) {
          module2.exports = pluralize2();
        } else {
          root2.pluralize = pluralize2();
        }
      })(commonjsGlobal, function() {
        var pluralRules = [];
        var singularRules = [];
        var uncountables = {};
        var irregularPlurals = {};
        var irregularSingles = {};
        function sanitizeRule(rule) {
          if (typeof rule === "string") {
            return new RegExp("^" + rule + "$", "i");
          }
          return rule;
        }
        function restoreCase(word, token2) {
          if (word === token2)
            return token2;
          if (word === word.toLowerCase())
            return token2.toLowerCase();
          if (word === word.toUpperCase())
            return token2.toUpperCase();
          if (word[0] === word[0].toUpperCase()) {
            return token2.charAt(0).toUpperCase() + token2.substr(1).toLowerCase();
          }
          return token2.toLowerCase();
        }
        function interpolate(str, args) {
          return str.replace(/\$(\d{1,2})/g, function(match2, index2) {
            return args[index2] || "";
          });
        }
        function replace2(word, rule) {
          return word.replace(rule[0], function(match2, index2) {
            var result = interpolate(rule[1], arguments);
            if (match2 === "") {
              return restoreCase(word[index2 - 1], result);
            }
            return restoreCase(match2, result);
          });
        }
        function sanitizeWord(token2, word, rules2) {
          if (!token2.length || uncountables.hasOwnProperty(token2)) {
            return word;
          }
          var len = rules2.length;
          while (len--) {
            var rule = rules2[len];
            if (rule[0].test(word))
              return replace2(word, rule);
          }
          return word;
        }
        function replaceWord(replaceMap, keepMap, rules2) {
          return function(word) {
            var token2 = word.toLowerCase();
            if (keepMap.hasOwnProperty(token2)) {
              return restoreCase(word, token2);
            }
            if (replaceMap.hasOwnProperty(token2)) {
              return restoreCase(word, replaceMap[token2]);
            }
            return sanitizeWord(token2, word, rules2);
          };
        }
        function checkWord(replaceMap, keepMap, rules2, bool) {
          return function(word) {
            var token2 = word.toLowerCase();
            if (keepMap.hasOwnProperty(token2))
              return true;
            if (replaceMap.hasOwnProperty(token2))
              return false;
            return sanitizeWord(token2, token2, rules2) === token2;
          };
        }
        function pluralize2(word, count, inclusive) {
          var pluralized = count === 1 ? pluralize2.singular(word) : pluralize2.plural(word);
          return (inclusive ? count + " " : "") + pluralized;
        }
        pluralize2.plural = replaceWord(
          irregularSingles,
          irregularPlurals,
          pluralRules
        );
        pluralize2.isPlural = checkWord(
          irregularSingles,
          irregularPlurals,
          pluralRules
        );
        pluralize2.singular = replaceWord(
          irregularPlurals,
          irregularSingles,
          singularRules
        );
        pluralize2.isSingular = checkWord(
          irregularPlurals,
          irregularSingles,
          singularRules
        );
        pluralize2.addPluralRule = function(rule, replacement) {
          pluralRules.push([sanitizeRule(rule), replacement]);
        };
        pluralize2.addSingularRule = function(rule, replacement) {
          singularRules.push([sanitizeRule(rule), replacement]);
        };
        pluralize2.addUncountableRule = function(word) {
          if (typeof word === "string") {
            uncountables[word.toLowerCase()] = true;
            return;
          }
          pluralize2.addPluralRule(word, "$0");
          pluralize2.addSingularRule(word, "$0");
        };
        pluralize2.addIrregularRule = function(single, plural) {
          plural = plural.toLowerCase();
          single = single.toLowerCase();
          irregularSingles[single] = plural;
          irregularPlurals[plural] = single;
        };
        [
          // Pronouns.
          ["I", "we"],
          ["me", "us"],
          ["he", "they"],
          ["she", "they"],
          ["them", "them"],
          ["myself", "ourselves"],
          ["yourself", "yourselves"],
          ["itself", "themselves"],
          ["herself", "themselves"],
          ["himself", "themselves"],
          ["themself", "themselves"],
          ["is", "are"],
          ["was", "were"],
          ["has", "have"],
          ["this", "these"],
          ["that", "those"],
          // Words ending in with a consonant and `o`.
          ["echo", "echoes"],
          ["dingo", "dingoes"],
          ["volcano", "volcanoes"],
          ["tornado", "tornadoes"],
          ["torpedo", "torpedoes"],
          // Ends with `us`.
          ["genus", "genera"],
          ["viscus", "viscera"],
          // Ends with `ma`.
          ["stigma", "stigmata"],
          ["stoma", "stomata"],
          ["dogma", "dogmata"],
          ["lemma", "lemmata"],
          ["schema", "schemata"],
          ["anathema", "anathemata"],
          // Other irregular rules.
          ["ox", "oxen"],
          ["axe", "axes"],
          ["die", "dice"],
          ["yes", "yeses"],
          ["foot", "feet"],
          ["eave", "eaves"],
          ["goose", "geese"],
          ["tooth", "teeth"],
          ["quiz", "quizzes"],
          ["human", "humans"],
          ["proof", "proofs"],
          ["carve", "carves"],
          ["valve", "valves"],
          ["looey", "looies"],
          ["thief", "thieves"],
          ["groove", "grooves"],
          ["pickaxe", "pickaxes"],
          ["passerby", "passersby"]
        ].forEach(function(rule) {
          return pluralize2.addIrregularRule(rule[0], rule[1]);
        });
        [
          [/s?$/i, "s"],
          [/[^\u0000-\u007F]$/i, "$0"],
          [/([^aeiou]ese)$/i, "$1"],
          [/(ax|test)is$/i, "$1es"],
          [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
          [/(e[mn]u)s?$/i, "$1s"],
          [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
          [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
          [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
          [/(seraph|cherub)(?:im)?$/i, "$1im"],
          [/(her|at|gr)o$/i, "$1oes"],
          [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
          [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
          [/sis$/i, "ses"],
          [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
          [/([^aeiouy]|qu)y$/i, "$1ies"],
          [/([^ch][ieo][ln])ey$/i, "$1ies"],
          [/(x|ch|ss|sh|zz)$/i, "$1es"],
          [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
          [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
          [/(pe)(?:rson|ople)$/i, "$1ople"],
          [/(child)(?:ren)?$/i, "$1ren"],
          [/eaux$/i, "$0"],
          [/m[ae]n$/i, "men"],
          ["thou", "you"]
        ].forEach(function(rule) {
          return pluralize2.addPluralRule(rule[0], rule[1]);
        });
        [
          [/s$/i, ""],
          [/(ss)$/i, "$1"],
          [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
          [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
          [/ies$/i, "y"],
          [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
          [/\b(mon|smil)ies$/i, "$1ey"],
          [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
          [/(seraph|cherub)im$/i, "$1"],
          [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
          [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
          [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
          [/(test)(?:is|es)$/i, "$1is"],
          [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
          [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
          [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
          [/(alumn|alg|vertebr)ae$/i, "$1a"],
          [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
          [/(matr|append)ices$/i, "$1ix"],
          [/(pe)(rson|ople)$/i, "$1rson"],
          [/(child)ren$/i, "$1"],
          [/(eau)x?$/i, "$1"],
          [/men$/i, "man"]
        ].forEach(function(rule) {
          return pluralize2.addSingularRule(rule[0], rule[1]);
        });
        [
          // Singular words with no plurals.
          "adulthood",
          "advice",
          "agenda",
          "aid",
          "aircraft",
          "alcohol",
          "ammo",
          "analytics",
          "anime",
          "athletics",
          "audio",
          "bison",
          "blood",
          "bream",
          "buffalo",
          "butter",
          "carp",
          "cash",
          "chassis",
          "chess",
          "clothing",
          "cod",
          "commerce",
          "cooperation",
          "corps",
          "debris",
          "diabetes",
          "digestion",
          "elk",
          "energy",
          "equipment",
          "excretion",
          "expertise",
          "firmware",
          "flounder",
          "fun",
          "gallows",
          "garbage",
          "graffiti",
          "hardware",
          "headquarters",
          "health",
          "herpes",
          "highjinks",
          "homework",
          "housework",
          "information",
          "jeans",
          "justice",
          "kudos",
          "labour",
          "literature",
          "machinery",
          "mackerel",
          "mail",
          "media",
          "mews",
          "moose",
          "music",
          "mud",
          "manga",
          "news",
          "only",
          "personnel",
          "pike",
          "plankton",
          "pliers",
          "police",
          "pollution",
          "premises",
          "rain",
          "research",
          "rice",
          "salmon",
          "scissors",
          "series",
          "sewage",
          "shambles",
          "shrimp",
          "software",
          "species",
          "staff",
          "swine",
          "tennis",
          "traffic",
          "transportation",
          "trout",
          "tuna",
          "wealth",
          "welfare",
          "whiting",
          "wildebeest",
          "wildlife",
          "you",
          /pok[eé]mon$/i,
          // Regexes.
          /[^aeiou]ese$/i,
          // "chinese", "japanese"
          /deer$/i,
          // "deer", "reindeer"
          /fish$/i,
          // "fish", "blowfish", "angelfish"
          /measles$/i,
          /o[iu]s$/i,
          // "carnivorous"
          /pox$/i,
          // "chickpox", "smallpox"
          /sheep$/i
        ].forEach(pluralize2.addUncountableRule);
        return pluralize2;
      });
    })(pluralize);
    const Xo$1 = pluralizeExports;
    function arrayPush$3(array2, values) {
      var index2 = -1, length2 = values.length, offset2 = array2.length;
      while (++index2 < length2) {
        array2[offset2 + index2] = values[index2];
      }
      return array2;
    }
    var _arrayPush = arrayPush$3;
    var baseGetTag$4 = _baseGetTag, isObjectLike$5 = isObjectLike_1;
    var argsTag$5 = "[object Arguments]";
    function baseIsArguments$2(value) {
      return isObjectLike$5(value) && baseGetTag$4(value) == argsTag$5;
    }
    var _baseIsArguments = baseIsArguments$2;
    var baseIsArguments$1 = _baseIsArguments, isObjectLike$4 = isObjectLike_1;
    var objectProto$k = Object.prototype;
    var hasOwnProperty$l = objectProto$k.hasOwnProperty;
    var propertyIsEnumerable$3 = objectProto$k.propertyIsEnumerable;
    var isArguments$5 = baseIsArguments$1(function() {
      return arguments;
    }()) ? baseIsArguments$1 : function(value) {
      return isObjectLike$4(value) && hasOwnProperty$l.call(value, "callee") && !propertyIsEnumerable$3.call(value, "callee");
    };
    var isArguments_1 = isArguments$5;
    var isArray$e = Array.isArray;
    var isArray_1 = isArray$e;
    var Symbol$5 = _Symbol, isArguments$4 = isArguments_1, isArray$d = isArray_1;
    var spreadableSymbol = Symbol$5 ? Symbol$5.isConcatSpreadable : void 0;
    function isFlattenable$1(value) {
      return isArray$d(value) || isArguments$4(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    var _isFlattenable = isFlattenable$1;
    var arrayPush$2 = _arrayPush, isFlattenable = _isFlattenable;
    function baseFlatten$2(array2, depth, predicate, isStrict, result) {
      var index2 = -1, length2 = array2.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index2 < length2) {
        var value = array2[index2];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten$2(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush$2(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    var _baseFlatten = baseFlatten$2;
    var getNative$6 = _getNative;
    var nativeCreate$6 = getNative$6(Object, "create");
    var _nativeCreate = nativeCreate$6;
    var nativeCreate$5 = _nativeCreate;
    function hashClear$2() {
      this.__data__ = nativeCreate$5 ? nativeCreate$5(null) : {};
      this.size = 0;
    }
    var _hashClear = hashClear$2;
    function hashDelete$2(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var _hashDelete = hashDelete$2;
    var nativeCreate$4 = _nativeCreate;
    var HASH_UNDEFINED$5 = "__lodash_hash_undefined__";
    var objectProto$j = Object.prototype;
    var hasOwnProperty$k = objectProto$j.hasOwnProperty;
    function hashGet$2(key) {
      var data2 = this.__data__;
      if (nativeCreate$4) {
        var result = data2[key];
        return result === HASH_UNDEFINED$5 ? void 0 : result;
      }
      return hasOwnProperty$k.call(data2, key) ? data2[key] : void 0;
    }
    var _hashGet = hashGet$2;
    var nativeCreate$3 = _nativeCreate;
    var objectProto$i = Object.prototype;
    var hasOwnProperty$j = objectProto$i.hasOwnProperty;
    function hashHas$2(key) {
      var data2 = this.__data__;
      return nativeCreate$3 ? data2[key] !== void 0 : hasOwnProperty$j.call(data2, key);
    }
    var _hashHas = hashHas$2;
    var nativeCreate$2 = _nativeCreate;
    var HASH_UNDEFINED$4 = "__lodash_hash_undefined__";
    function hashSet$2(key, value) {
      var data2 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data2[key] = nativeCreate$2 && value === void 0 ? HASH_UNDEFINED$4 : value;
      return this;
    }
    var _hashSet = hashSet$2;
    var hashClear$1 = _hashClear, hashDelete$1 = _hashDelete, hashGet$1 = _hashGet, hashHas$1 = _hashHas, hashSet$1 = _hashSet;
    function Hash$2(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash$2.prototype.clear = hashClear$1;
    Hash$2.prototype["delete"] = hashDelete$1;
    Hash$2.prototype.get = hashGet$1;
    Hash$2.prototype.has = hashHas$1;
    Hash$2.prototype.set = hashSet$1;
    var _Hash = Hash$2;
    function listCacheClear$2() {
      this.__data__ = [];
      this.size = 0;
    }
    var _listCacheClear = listCacheClear$2;
    function eq$3(value, other) {
      return value === other || value !== value && other !== other;
    }
    var eq_1 = eq$3;
    var eq$2 = eq_1;
    function assocIndexOf$5(array2, key) {
      var length2 = array2.length;
      while (length2--) {
        if (eq$2(array2[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    var _assocIndexOf = assocIndexOf$5;
    var assocIndexOf$4 = _assocIndexOf;
    var arrayProto$1 = Array.prototype;
    var splice$4 = arrayProto$1.splice;
    function listCacheDelete$2(key) {
      var data2 = this.__data__, index2 = assocIndexOf$4(data2, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index2 == lastIndex) {
        data2.pop();
      } else {
        splice$4.call(data2, index2, 1);
      }
      --this.size;
      return true;
    }
    var _listCacheDelete = listCacheDelete$2;
    var assocIndexOf$3 = _assocIndexOf;
    function listCacheGet$2(key) {
      var data2 = this.__data__, index2 = assocIndexOf$3(data2, key);
      return index2 < 0 ? void 0 : data2[index2][1];
    }
    var _listCacheGet = listCacheGet$2;
    var assocIndexOf$2 = _assocIndexOf;
    function listCacheHas$2(key) {
      return assocIndexOf$2(this.__data__, key) > -1;
    }
    var _listCacheHas = listCacheHas$2;
    var assocIndexOf$1 = _assocIndexOf;
    function listCacheSet$2(key, value) {
      var data2 = this.__data__, index2 = assocIndexOf$1(data2, key);
      if (index2 < 0) {
        ++this.size;
        data2.push([key, value]);
      } else {
        data2[index2][1] = value;
      }
      return this;
    }
    var _listCacheSet = listCacheSet$2;
    var listCacheClear$1 = _listCacheClear, listCacheDelete$1 = _listCacheDelete, listCacheGet$1 = _listCacheGet, listCacheHas$1 = _listCacheHas, listCacheSet$1 = _listCacheSet;
    function ListCache$5(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache$5.prototype.clear = listCacheClear$1;
    ListCache$5.prototype["delete"] = listCacheDelete$1;
    ListCache$5.prototype.get = listCacheGet$1;
    ListCache$5.prototype.has = listCacheHas$1;
    ListCache$5.prototype.set = listCacheSet$1;
    var _ListCache = ListCache$5;
    var getNative$5 = _getNative, root$a = _root;
    var Map$6 = getNative$5(root$a, "Map");
    var _Map = Map$6;
    var Hash$1 = _Hash, ListCache$4 = _ListCache, Map$5 = _Map;
    function mapCacheClear$2() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash$1(),
        "map": new (Map$5 || ListCache$4)(),
        "string": new Hash$1()
      };
    }
    var _mapCacheClear = mapCacheClear$2;
    function isKeyable$2(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    var _isKeyable = isKeyable$2;
    var isKeyable$1 = _isKeyable;
    function getMapData$5(map, key) {
      var data2 = map.__data__;
      return isKeyable$1(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    var _getMapData = getMapData$5;
    var getMapData$4 = _getMapData;
    function mapCacheDelete$2(key) {
      var result = getMapData$4(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    var _mapCacheDelete = mapCacheDelete$2;
    var getMapData$3 = _getMapData;
    function mapCacheGet$2(key) {
      return getMapData$3(this, key).get(key);
    }
    var _mapCacheGet = mapCacheGet$2;
    var getMapData$2 = _getMapData;
    function mapCacheHas$2(key) {
      return getMapData$2(this, key).has(key);
    }
    var _mapCacheHas = mapCacheHas$2;
    var getMapData$1 = _getMapData;
    function mapCacheSet$2(key, value) {
      var data2 = getMapData$1(this, key), size = data2.size;
      data2.set(key, value);
      this.size += data2.size == size ? 0 : 1;
      return this;
    }
    var _mapCacheSet = mapCacheSet$2;
    var mapCacheClear$1 = _mapCacheClear, mapCacheDelete$1 = _mapCacheDelete, mapCacheGet$1 = _mapCacheGet, mapCacheHas$1 = _mapCacheHas, mapCacheSet$1 = _mapCacheSet;
    function MapCache$4(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache$4.prototype.clear = mapCacheClear$1;
    MapCache$4.prototype["delete"] = mapCacheDelete$1;
    MapCache$4.prototype.get = mapCacheGet$1;
    MapCache$4.prototype.has = mapCacheHas$1;
    MapCache$4.prototype.set = mapCacheSet$1;
    var _MapCache = MapCache$4;
    var HASH_UNDEFINED$3 = "__lodash_hash_undefined__";
    function setCacheAdd$2(value) {
      this.__data__.set(value, HASH_UNDEFINED$3);
      return this;
    }
    var _setCacheAdd = setCacheAdd$2;
    function setCacheHas$2(value) {
      return this.__data__.has(value);
    }
    var _setCacheHas = setCacheHas$2;
    var MapCache$3 = _MapCache, setCacheAdd$1 = _setCacheAdd, setCacheHas$1 = _setCacheHas;
    function SetCache$4(values) {
      var index2 = -1, length2 = values == null ? 0 : values.length;
      this.__data__ = new MapCache$3();
      while (++index2 < length2) {
        this.add(values[index2]);
      }
    }
    SetCache$4.prototype.add = SetCache$4.prototype.push = setCacheAdd$1;
    SetCache$4.prototype.has = setCacheHas$1;
    var _SetCache = SetCache$4;
    function baseFindIndex$1(array2, predicate, fromIndex, fromRight) {
      var length2 = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length2) {
        if (predicate(array2[index2], index2, array2)) {
          return index2;
        }
      }
      return -1;
    }
    var _baseFindIndex = baseFindIndex$1;
    function baseIsNaN$1(value) {
      return value !== value;
    }
    var _baseIsNaN = baseIsNaN$1;
    function strictIndexOf$1(array2, value, fromIndex) {
      var index2 = fromIndex - 1, length2 = array2.length;
      while (++index2 < length2) {
        if (array2[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    var _strictIndexOf = strictIndexOf$1;
    var baseFindIndex = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
    function baseIndexOf$1(array2, value, fromIndex) {
      return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    var _baseIndexOf = baseIndexOf$1;
    var baseIndexOf = _baseIndexOf;
    function arrayIncludes$2(array2, value) {
      var length2 = array2 == null ? 0 : array2.length;
      return !!length2 && baseIndexOf(array2, value, 0) > -1;
    }
    var _arrayIncludes = arrayIncludes$2;
    function arrayIncludesWith$2(array2, value, comparator) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (comparator(value, array2[index2])) {
          return true;
        }
      }
      return false;
    }
    var _arrayIncludesWith = arrayIncludesWith$2;
    function cacheHas$4(cache2, key) {
      return cache2.has(key);
    }
    var _cacheHas = cacheHas$4;
    var getNative$4 = _getNative, root$9 = _root;
    var Set$5 = getNative$4(root$9, "Set");
    var _Set = Set$5;
    function noop$6() {
    }
    var noop_1 = noop$6;
    function setToArray$4(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var _setToArray = setToArray$4;
    var Set$4 = _Set, noop$5 = noop_1, setToArray$3 = _setToArray;
    var INFINITY$2 = 1 / 0;
    var createSet$1 = !(Set$4 && 1 / setToArray$3(new Set$4([, -0]))[1] == INFINITY$2) ? noop$5 : function(values) {
      return new Set$4(values);
    };
    var _createSet = createSet$1;
    var SetCache$3 = _SetCache, arrayIncludes$1 = _arrayIncludes, arrayIncludesWith$1 = _arrayIncludesWith, cacheHas$3 = _cacheHas, createSet = _createSet, setToArray$2 = _setToArray;
    var LARGE_ARRAY_SIZE$3 = 200;
    function baseUniq$2(array2, iteratee, comparator) {
      var index2 = -1, includes2 = arrayIncludes$1, length2 = array2.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes2 = arrayIncludesWith$1;
      } else if (length2 >= LARGE_ARRAY_SIZE$3) {
        var set2 = iteratee ? null : createSet(array2);
        if (set2) {
          return setToArray$2(set2);
        }
        isCommon = false;
        includes2 = cacheHas$3;
        seen = new SetCache$3();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index2 < length2) {
          var value = array2[index2], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes2(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    var _baseUniq = baseUniq$2;
    function last$2(array2) {
      var length2 = array2 == null ? 0 : array2.length;
      return length2 ? array2[length2 - 1] : void 0;
    }
    var last_1 = last$2;
    var baseFlatten$1 = _baseFlatten, baseRest$1 = _baseRest, baseUniq$1 = _baseUniq, isArrayLikeObject$1 = isArrayLikeObject_1, last$1 = last_1;
    var unionWith = baseRest$1(function(arrays) {
      var comparator = last$1(arrays);
      comparator = typeof comparator == "function" ? comparator : void 0;
      return baseUniq$1(baseFlatten$1(arrays, 1, isArrayLikeObject$1, true), void 0, comparator);
    });
    var unionWith_1 = unionWith;
    function baseUnary$3(func) {
      return function(value) {
        return func(value);
      };
    }
    var _baseUnary = baseUnary$3;
    var SetCache$2 = _SetCache, arrayIncludes = _arrayIncludes, arrayIncludesWith = _arrayIncludesWith, arrayMap$1 = _arrayMap, baseUnary$2 = _baseUnary, cacheHas$2 = _cacheHas;
    var LARGE_ARRAY_SIZE$2 = 200;
    function baseDifference$1(array2, values, iteratee, comparator) {
      var index2 = -1, includes2 = arrayIncludes, isCommon = true, length2 = array2.length, result = [], valuesLength = values.length;
      if (!length2) {
        return result;
      }
      if (iteratee) {
        values = arrayMap$1(values, baseUnary$2(iteratee));
      }
      if (comparator) {
        includes2 = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE$2) {
        includes2 = cacheHas$2;
        isCommon = false;
        values = new SetCache$2(values);
      }
      outer:
        while (++index2 < length2) {
          var value = array2[index2], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes2(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    var _baseDifference = baseDifference$1;
    var baseDifference = _baseDifference, baseFlatten = _baseFlatten, baseRest = _baseRest, isArrayLikeObject = isArrayLikeObject_1, last = last_1;
    var differenceWith = baseRest(function(array2, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = void 0;
      }
      return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values, 1, isArrayLikeObject, true), void 0, comparator) : [];
    });
    var differenceWith_1 = differenceWith;
    function warnOnce(condition, ...rest) {
    }
    var warnOnce_1 = warnOnce;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function eq$1(value, other) {
      return value === other || value !== value && other !== other;
    }
    function assocIndexOf(array2, key) {
      var length2 = array2.length;
      while (length2--) {
        if (eq$1(array2[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice$3 = arrayProto.splice;
    function listCacheDelete(key) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index2 == lastIndex) {
        data2.pop();
      } else {
        splice$3.call(data2, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      return index2 < 0 ? void 0 : data2[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      if (index2 < 0) {
        ++this.size;
        data2.push([key, value]);
      } else {
        data2[index2][1] = value;
      }
      return this;
    }
    function ListCache$3(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache$3.prototype.clear = listCacheClear;
    ListCache$3.prototype["delete"] = listCacheDelete;
    ListCache$3.prototype.get = listCacheGet;
    ListCache$3.prototype.has = listCacheHas;
    ListCache$3.prototype.set = listCacheSet;
    function stackClear$2() {
      this.__data__ = new ListCache$3();
      this.size = 0;
    }
    function stackDelete$2(key) {
      var data2 = this.__data__, result = data2["delete"](key);
      this.size = data2.size;
      return result;
    }
    function stackGet$2(key) {
      return this.__data__.get(key);
    }
    function stackHas$2(key) {
      return this.__data__.has(key);
    }
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    const freeGlobal$1 = freeGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root$7 = freeGlobal$1 || freeSelf || Function("return this")();
    const root$8 = root$7;
    var Symbol$3 = root$8.Symbol;
    const Symbol$4 = Symbol$3;
    var objectProto$h = Object.prototype;
    var hasOwnProperty$i = objectProto$h.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$h.toString;
    var symToStringTag$1 = Symbol$4 ? Symbol$4.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$i.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$g = Object.prototype;
    var nativeObjectToString = objectProto$g.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : void 0;
    function baseGetTag$3(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObject$6(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction$3(value) {
      if (!isObject$6(value)) {
        return false;
      }
      var tag = baseGetTag$3(value);
      return tag == funcTag$2 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root$8["__core-js_shared__"];
    const coreJsData$1 = coreJsData;
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$1 = Function.prototype;
    var funcToString$1 = funcProto$1.toString;
    function toSource$1(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype, objectProto$f = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$h = objectProto$f.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty$h).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject$6(value) || isMasked(value)) {
        return false;
      }
      var pattern2 = isFunction$3(value) ? reIsNative : reIsHostCtor;
      return pattern2.test(toSource$1(value));
    }
    function getValue$5(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function getNative$3(object2, key) {
      var value = getValue$5(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var Map$3 = getNative$3(root$8, "Map");
    const Map$4 = Map$3;
    var nativeCreate = getNative$3(Object, "create");
    const nativeCreate$1 = nativeCreate;
    function hashClear() {
      this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$e = Object.prototype;
    var hasOwnProperty$g = objectProto$e.hasOwnProperty;
    function hashGet(key) {
      var data2 = this.__data__;
      if (nativeCreate$1) {
        var result = data2[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$g.call(data2, key) ? data2[key] : void 0;
    }
    var objectProto$d = Object.prototype;
    var hasOwnProperty$f = objectProto$d.hasOwnProperty;
    function hashHas(key) {
      var data2 = this.__data__;
      return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$f.call(data2, key);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data2 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data2[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
      return this;
    }
    function Hash(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$4 || ListCache$3)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map, key) {
      var data2 = map.__data__;
      return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data2 = getMapData(this, key), size = data2.size;
      data2.set(key, value);
      this.size += data2.size == size ? 0 : 1;
      return this;
    }
    function MapCache$2(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache$2.prototype.clear = mapCacheClear;
    MapCache$2.prototype["delete"] = mapCacheDelete;
    MapCache$2.prototype.get = mapCacheGet;
    MapCache$2.prototype.has = mapCacheHas;
    MapCache$2.prototype.set = mapCacheSet;
    var LARGE_ARRAY_SIZE$1 = 200;
    function stackSet$2(key, value) {
      var data2 = this.__data__;
      if (data2 instanceof ListCache$3) {
        var pairs = data2.__data__;
        if (!Map$4 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
          pairs.push([key, value]);
          this.size = ++data2.size;
          return this;
        }
        data2 = this.__data__ = new MapCache$2(pairs);
      }
      data2.set(key, value);
      this.size = data2.size;
      return this;
    }
    function Stack$3(entries) {
      var data2 = this.__data__ = new ListCache$3(entries);
      this.size = data2.size;
    }
    Stack$3.prototype.clear = stackClear$2;
    Stack$3.prototype["delete"] = stackDelete$2;
    Stack$3.prototype.get = stackGet$2;
    Stack$3.prototype.has = stackHas$2;
    Stack$3.prototype.set = stackSet$2;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    function SetCache$1(values) {
      var index2 = -1, length2 = values == null ? 0 : values.length;
      this.__data__ = new MapCache$2();
      while (++index2 < length2) {
        this.add(values[index2]);
      }
    }
    SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
    SetCache$1.prototype.has = setCacheHas;
    function arraySome$2(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas$1(cache2, key) {
      return cache2.has(key);
    }
    var COMPARE_PARTIAL_FLAG$9 = 1, COMPARE_UNORDERED_FLAG$5 = 2;
    function equalArrays$3(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$9, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$5 ? new SetCache$1() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome$2(other, function(othValue2, othIndex) {
            if (!cacheHas$1(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    var Uint8Array$3 = root$8.Uint8Array;
    const Uint8Array$4 = Uint8Array$3;
    function mapToArray$2(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function setToArray$1(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var COMPARE_PARTIAL_FLAG$8 = 1, COMPARE_UNORDERED_FLAG$4 = 2;
    var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$3 = "[object Error]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$2 = "[object Symbol]";
    var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$5 = "[object DataView]";
    var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
    function equalByTag$2(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$5:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag$3:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$4(object2), new Uint8Array$4(other))) {
            return false;
          }
          return true;
        case boolTag$3:
        case dateTag$3:
        case numberTag$3:
          return eq$1(+object2, +other);
        case errorTag$3:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag$3:
        case stringTag$3:
          return object2 == other + "";
        case mapTag$5:
          var convert2 = mapToArray$2;
        case setTag$5:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$8;
          convert2 || (convert2 = setToArray$1);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$4;
          stack.set(object2, other);
          var result = equalArrays$3(convert2(object2), convert2(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag$2:
          if (symbolValueOf$1) {
            return symbolValueOf$1.call(object2) == symbolValueOf$1.call(other);
          }
      }
      return false;
    }
    function arrayPush$1(array2, values) {
      var index2 = -1, length2 = values.length, offset2 = array2.length;
      while (++index2 < length2) {
        array2[offset2 + index2] = values[index2];
      }
      return array2;
    }
    var isArray$b = Array.isArray;
    const isArray$c = isArray$b;
    function baseGetAllKeys$2(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray$c(object2) ? result : arrayPush$1(result, symbolsFunc(object2));
    }
    function arrayFilter$1(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray$2() {
      return [];
    }
    var objectProto$c = Object.prototype;
    var propertyIsEnumerable$2 = objectProto$c.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols$2 = !nativeGetSymbols$1 ? stubArray$2 : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter$1(nativeGetSymbols$1(object2), function(symbol) {
        return propertyIsEnumerable$2.call(object2, symbol);
      });
    };
    const getSymbols$3 = getSymbols$2;
    function baseTimes$1(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function isObjectLike$3(value) {
      return value != null && typeof value == "object";
    }
    var argsTag$4 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike$3(value) && baseGetTag$3(value) == argsTag$4;
    }
    var objectProto$b = Object.prototype;
    var hasOwnProperty$e = objectProto$b.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;
    var isArguments$2 = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike$3(value) && hasOwnProperty$e.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    const isArguments$3 = isArguments$2;
    function stubFalse$1() {
      return false;
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var Buffer$1 = moduleExports$1 ? root$8.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer$5 = nativeIsBuffer || stubFalse$1;
    const isBuffer$6 = isBuffer$5;
    var MAX_SAFE_INTEGER$2 = 9007199254740991;
    var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
    function isIndex$3(value, length2) {
      var type2 = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER$2 : length2;
      return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint$1.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    function isLength$2(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
    }
    var argsTag$3 = "[object Arguments]", arrayTag$3 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$5 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$3 = "[object WeakMap]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    var typedArrayTags$1 = {};
    typedArrayTags$1[float32Tag$1] = typedArrayTags$1[float64Tag$1] = typedArrayTags$1[int8Tag$1] = typedArrayTags$1[int16Tag$1] = typedArrayTags$1[int32Tag$1] = typedArrayTags$1[uint8Tag$1] = typedArrayTags$1[uint8ClampedTag$1] = typedArrayTags$1[uint16Tag$1] = typedArrayTags$1[uint32Tag$1] = true;
    typedArrayTags$1[argsTag$3] = typedArrayTags$1[arrayTag$3] = typedArrayTags$1[arrayBufferTag$2] = typedArrayTags$1[boolTag$2] = typedArrayTags$1[dataViewTag$4] = typedArrayTags$1[dateTag$2] = typedArrayTags$1[errorTag$2] = typedArrayTags$1[funcTag$1] = typedArrayTags$1[mapTag$4] = typedArrayTags$1[numberTag$2] = typedArrayTags$1[objectTag$5] = typedArrayTags$1[regexpTag$2] = typedArrayTags$1[setTag$4] = typedArrayTags$1[stringTag$2] = typedArrayTags$1[weakMapTag$3] = false;
    function baseIsTypedArray$2(value) {
      return isObjectLike$3(value) && isLength$2(value.length) && !!typedArrayTags$1[baseGetTag$3(value)];
    }
    function baseUnary$1(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal$1.process;
    var nodeUtil$1 = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    const nodeUtil$2 = nodeUtil$1;
    var nodeIsTypedArray$1 = nodeUtil$2 && nodeUtil$2.isTypedArray;
    var isTypedArray$3 = nodeIsTypedArray$1 ? baseUnary$1(nodeIsTypedArray$1) : baseIsTypedArray$2;
    const isTypedArray$4 = isTypedArray$3;
    var objectProto$a = Object.prototype;
    var hasOwnProperty$d = objectProto$a.hasOwnProperty;
    function arrayLikeKeys$2(value, inherited) {
      var isArr = isArray$c(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$6(value), isType = !isArr && !isArg && !isBuff && isTypedArray$4(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes$1(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$d.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex$3(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$9 = Object.prototype;
    function isPrototype$2(value) {
      var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$9;
      return value === proto2;
    }
    function overArg$2(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var nativeKeys$2 = overArg$2(Object.keys, Object);
    const nativeKeys$3 = nativeKeys$2;
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$c = objectProto$8.hasOwnProperty;
    function baseKeys$2(object2) {
      if (!isPrototype$2(object2)) {
        return nativeKeys$3(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty$c.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isArrayLike$1(value) {
      return value != null && isLength$2(value.length) && !isFunction$3(value);
    }
    function keys$4(object2) {
      return isArrayLike$1(object2) ? arrayLikeKeys$2(object2) : baseKeys$2(object2);
    }
    function getAllKeys$2(object2) {
      return baseGetAllKeys$2(object2, keys$4, getSymbols$3);
    }
    var COMPARE_PARTIAL_FLAG$7 = 1;
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$b = objectProto$7.hasOwnProperty;
    function equalObjects$2(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$7, objProps = getAllKeys$2(object2), objLength = objProps.length, othProps = getAllKeys$2(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty$b.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    var DataView$3 = getNative$3(root$8, "DataView");
    const DataView$4 = DataView$3;
    var Promise$3 = getNative$3(root$8, "Promise");
    const Promise$4 = Promise$3;
    var Set$2 = getNative$3(root$8, "Set");
    const Set$3 = Set$2;
    var WeakMap$3 = getNative$3(root$8, "WeakMap");
    const WeakMap$4 = WeakMap$3;
    var mapTag$3 = "[object Map]", objectTag$4 = "[object Object]", promiseTag$1 = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$2 = "[object WeakMap]";
    var dataViewTag$3 = "[object DataView]";
    var dataViewCtorString$1 = toSource$1(DataView$4), mapCtorString$1 = toSource$1(Map$4), promiseCtorString$1 = toSource$1(Promise$4), setCtorString$1 = toSource$1(Set$3), weakMapCtorString$1 = toSource$1(WeakMap$4);
    var getTag$2 = baseGetTag$3;
    if (DataView$4 && getTag$2(new DataView$4(new ArrayBuffer(1))) != dataViewTag$3 || Map$4 && getTag$2(new Map$4()) != mapTag$3 || Promise$4 && getTag$2(Promise$4.resolve()) != promiseTag$1 || Set$3 && getTag$2(new Set$3()) != setTag$3 || WeakMap$4 && getTag$2(new WeakMap$4()) != weakMapTag$2) {
      getTag$2 = function(value) {
        var result = baseGetTag$3(value), Ctor = result == objectTag$4 ? value.constructor : void 0, ctorString = Ctor ? toSource$1(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString$1:
              return dataViewTag$3;
            case mapCtorString$1:
              return mapTag$3;
            case promiseCtorString$1:
              return promiseTag$1;
            case setCtorString$1:
              return setTag$3;
            case weakMapCtorString$1:
              return weakMapTag$2;
          }
        }
        return result;
      };
    }
    const getTag$3 = getTag$2;
    var COMPARE_PARTIAL_FLAG$6 = 1;
    var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", objectTag$3 = "[object Object]";
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$a = objectProto$6.hasOwnProperty;
    function baseIsEqualDeep$2(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray$c(object2), othIsArr = isArray$c(other), objTag = objIsArr ? arrayTag$2 : getTag$3(object2), othTag = othIsArr ? arrayTag$2 : getTag$3(other);
      objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
      othTag = othTag == argsTag$2 ? objectTag$3 : othTag;
      var objIsObj = objTag == objectTag$3, othIsObj = othTag == objectTag$3, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer$6(object2)) {
        if (!isBuffer$6(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack$3());
        return objIsArr || isTypedArray$4(object2) ? equalArrays$3(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag$2(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$6)) {
        var objIsWrapped = objIsObj && hasOwnProperty$a.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$a.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack$3());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack$3());
      return equalObjects$2(object2, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsEqual$4(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike$3(value) && !isObjectLike$3(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep$2(value, other, bitmask, customizer, baseIsEqual$4, stack);
    }
    function isEqual$3(value, other) {
      return baseIsEqual$4(value, other);
    }
    var build = {};
    var exportToCsv = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      var CsvConfigConsts = function() {
        function CsvConfigConsts2() {
        }
        CsvConfigConsts2.EOL = "\r\n";
        CsvConfigConsts2.BOM = "\uFEFF";
        CsvConfigConsts2.DEFAULT_FIELD_SEPARATOR = ",";
        CsvConfigConsts2.DEFAULT_DECIMAL_SEPARATOR = ".";
        CsvConfigConsts2.DEFAULT_QUOTE = '"';
        CsvConfigConsts2.DEFAULT_SHOW_TITLE = false;
        CsvConfigConsts2.DEFAULT_TITLE = "My Generated Report";
        CsvConfigConsts2.DEFAULT_FILENAME = "generated";
        CsvConfigConsts2.DEFAULT_SHOW_LABELS = false;
        CsvConfigConsts2.DEFAULT_USE_TEXT_FILE = false;
        CsvConfigConsts2.DEFAULT_USE_BOM = true;
        CsvConfigConsts2.DEFAULT_HEADER = [];
        CsvConfigConsts2.DEFAULT_KEYS_AS_HEADERS = false;
        return CsvConfigConsts2;
      }();
      exports2.CsvConfigConsts = CsvConfigConsts;
      exports2.ConfigDefaults = {
        filename: CsvConfigConsts.DEFAULT_FILENAME,
        fieldSeparator: CsvConfigConsts.DEFAULT_FIELD_SEPARATOR,
        quoteStrings: CsvConfigConsts.DEFAULT_QUOTE,
        decimalSeparator: CsvConfigConsts.DEFAULT_DECIMAL_SEPARATOR,
        showLabels: CsvConfigConsts.DEFAULT_SHOW_LABELS,
        showTitle: CsvConfigConsts.DEFAULT_SHOW_TITLE,
        title: CsvConfigConsts.DEFAULT_TITLE,
        useTextFile: CsvConfigConsts.DEFAULT_USE_TEXT_FILE,
        useBom: CsvConfigConsts.DEFAULT_USE_BOM,
        headers: CsvConfigConsts.DEFAULT_HEADER,
        useKeysAsHeaders: CsvConfigConsts.DEFAULT_KEYS_AS_HEADERS
      };
      var ExportToCsv = function() {
        function ExportToCsv2(options) {
          this._csv = "";
          var config = options || {};
          this._options = objectAssign2({}, exports2.ConfigDefaults, config);
          if (this._options.useKeysAsHeaders && this._options.headers && this._options.headers.length > 0) {
            console.warn("Option to use object keys as headers was set, but headers were still passed!");
          }
        }
        Object.defineProperty(ExportToCsv2.prototype, "options", {
          get: function() {
            return this._options;
          },
          set: function(options) {
            this._options = objectAssign2({}, exports2.ConfigDefaults, options);
          },
          enumerable: true,
          configurable: true
        });
        ExportToCsv2.prototype.generateCsv = function(jsonData, shouldReturnCsv) {
          if (shouldReturnCsv === void 0) {
            shouldReturnCsv = false;
          }
          this._csv = "";
          this._parseData(jsonData);
          if (this._options.useBom) {
            this._csv += CsvConfigConsts.BOM;
          }
          if (this._options.showTitle) {
            this._csv += this._options.title + "\r\n\n";
          }
          this._getHeaders();
          this._getBody();
          if (this._csv == "") {
            console.log("Invalid data");
            return;
          }
          if (shouldReturnCsv) {
            return this._csv;
          }
          var FileType = this._options.useTextFile ? "plain" : "csv";
          var fileExtension = this._options.useTextFile ? ".txt" : ".csv";
          var blob = new Blob([this._csv], { "type": "text/" + FileType + ";charset=utf8;" });
          if (navigator.msSaveBlob) {
            var filename = this._options.filename.replace(/ /g, "_") + fileExtension;
            navigator.msSaveBlob(blob, filename);
          } else {
            var attachmentType = this._options.useTextFile ? "text" : "csv";
            "data:attachment/" + attachmentType + ";charset=utf-8," + encodeURI(this._csv);
            var link2 = document.createElement("a");
            link2.href = URL.createObjectURL(blob);
            link2.setAttribute("visibility", "hidden");
            link2.download = this._options.filename.replace(/ /g, "_") + fileExtension;
            document.body.appendChild(link2);
            link2.click();
            document.body.removeChild(link2);
          }
        };
        ExportToCsv2.prototype._getHeaders = function() {
          if (!this._options.showLabels && !this._options.useKeysAsHeaders) {
            return;
          }
          var useKeysAsHeaders = this._options.useKeysAsHeaders;
          var headers = useKeysAsHeaders ? Object.keys(this._data[0]) : this._options.headers;
          if (headers.length > 0) {
            var row = "";
            for (var keyPos = 0; keyPos < headers.length; keyPos++) {
              row += headers[keyPos] + this._options.fieldSeparator;
            }
            row = row.slice(0, -1);
            this._csv += row + CsvConfigConsts.EOL;
          }
        };
        ExportToCsv2.prototype._getBody = function() {
          var keys2 = Object.keys(this._data[0]);
          for (var i2 = 0; i2 < this._data.length; i2++) {
            var row = "";
            for (var keyPos = 0; keyPos < keys2.length; keyPos++) {
              var key = keys2[keyPos];
              row += this._formatData(this._data[i2][key]) + this._options.fieldSeparator;
            }
            row = row.slice(0, -1);
            this._csv += row + CsvConfigConsts.EOL;
          }
        };
        ExportToCsv2.prototype._formatData = function(data2) {
          if (this._options.decimalSeparator === "locale" && this._isFloat(data2)) {
            return data2.toLocaleString();
          }
          if (this._options.decimalSeparator !== "." && this._isFloat(data2)) {
            return data2.toString().replace(".", this._options.decimalSeparator);
          }
          if (typeof data2 === "string") {
            data2 = data2.replace(/"/g, '""');
            if (this._options.quoteStrings || data2.indexOf(",") > -1 || data2.indexOf("\n") > -1 || data2.indexOf("\r") > -1) {
              data2 = this._options.quoteStrings + data2 + this._options.quoteStrings;
            }
            return data2;
          }
          if (typeof data2 === "boolean") {
            return data2 ? "TRUE" : "FALSE";
          }
          return data2;
        };
        ExportToCsv2.prototype._isFloat = function(input) {
          return +input === input && (!isFinite(input) || Boolean(input % 1));
        };
        ExportToCsv2.prototype._parseData = function(jsonData) {
          this._data = typeof jsonData != "object" ? JSON.parse(jsonData) : jsonData;
          return this._data;
        };
        return ExportToCsv2;
      }();
      exports2.ExportToCsv = ExportToCsv;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var propIsEnumerable2 = Object.prototype.propertyIsEnumerable;
      function toObject2(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function objectAssign2(target) {
        var from2;
        var to = toObject2(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from2 = Object(arguments[s]);
          for (var key in from2) {
            if (hasOwnProperty2.call(from2, key)) {
              to[key] = from2[key];
            }
          }
          if (Object.getOwnPropertySymbols) {
            symbols = Object.getOwnPropertySymbols(from2);
            for (var i2 = 0; i2 < symbols.length; i2++) {
              if (propIsEnumerable2.call(from2, symbols[i2])) {
                to[symbols[i2]] = from2[symbols[i2]];
              }
            }
          }
        }
        return to;
      }
    })(exportToCsv);
    (function(exports2) {
      function __export(m2) {
        for (var p2 in m2)
          if (!exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      __export(exportToCsv);
    })(build);
    var papaparse_minExports = {};
    var papaparse_min = {
      get exports() {
        return papaparse_minExports;
      },
      set exports(v2) {
        papaparse_minExports = v2;
      }
    };
    /* @license
    Papa Parse
    v5.4.0
    https://github.com/mholt/PapaParse
    License: MIT
    */
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function s() {
        var f2 = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== f2 ? f2 : {};
        var n2 = !f2.document && !!f2.postMessage, o2 = f2.IS_PAPA_WORKER || false, a = {}, u2 = 0, b2 = { parse: function(e2, t2) {
          var r3 = (t2 = t2 || {}).dynamicTyping || false;
          J2(r3) && (t2.dynamicTypingFunction = r3, r3 = {});
          if (t2.dynamicTyping = r3, t2.transform = !!J2(t2.transform) && t2.transform, t2.worker && b2.WORKERS_SUPPORTED) {
            var i2 = function() {
              if (!b2.WORKERS_SUPPORTED)
                return false;
              var e3 = (r4 = f2.URL || f2.webkitURL || null, i3 = s.toString(), b2.BLOB_URL || (b2.BLOB_URL = r4.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", i3, ")();"], { type: "text/javascript" })))), t3 = new f2.Worker(e3);
              var r4, i3;
              return t3.onmessage = _, t3.id = u2++, a[t3.id] = t3;
            }();
            return i2.userStep = t2.step, i2.userChunk = t2.chunk, i2.userComplete = t2.complete, i2.userError = t2.error, t2.step = J2(t2.step), t2.chunk = J2(t2.chunk), t2.complete = J2(t2.complete), t2.error = J2(t2.error), delete t2.worker, void i2.postMessage({ input: e2, config: t2, workerId: i2.id });
          }
          var n3 = null;
          b2.NODE_STREAM_INPUT, "string" == typeof e2 ? (e2 = function(e3) {
            if (65279 === e3.charCodeAt(0))
              return e3.slice(1);
            return e3;
          }(e2), n3 = t2.download ? new l2(t2) : new p2(t2)) : true === e2.readable && J2(e2.read) && J2(e2.on) ? n3 = new g2(t2) : (f2.File && e2 instanceof File || e2 instanceof Object) && (n3 = new c2(t2));
          return n3.stream(e2);
        }, unparse: function(e2, t2) {
          var n3 = false, _2 = true, m3 = ",", y3 = "\r\n", s2 = '"', a2 = s2 + s2, r3 = false, i2 = null, o3 = false;
          !function() {
            if ("object" != typeof t2)
              return;
            "string" != typeof t2.delimiter || b2.BAD_DELIMITERS.filter(function(e3) {
              return -1 !== t2.delimiter.indexOf(e3);
            }).length || (m3 = t2.delimiter);
            ("boolean" == typeof t2.quotes || "function" == typeof t2.quotes || Array.isArray(t2.quotes)) && (n3 = t2.quotes);
            "boolean" != typeof t2.skipEmptyLines && "string" != typeof t2.skipEmptyLines || (r3 = t2.skipEmptyLines);
            "string" == typeof t2.newline && (y3 = t2.newline);
            "string" == typeof t2.quoteChar && (s2 = t2.quoteChar);
            "boolean" == typeof t2.header && (_2 = t2.header);
            if (Array.isArray(t2.columns)) {
              if (0 === t2.columns.length)
                throw new Error("Option columns is empty");
              i2 = t2.columns;
            }
            void 0 !== t2.escapeChar && (a2 = t2.escapeChar + s2);
            ("boolean" == typeof t2.escapeFormulae || t2.escapeFormulae instanceof RegExp) && (o3 = t2.escapeFormulae instanceof RegExp ? t2.escapeFormulae : /^[=+\-@\t\r].*$/);
          }();
          var u3 = new RegExp(Q2(s2), "g");
          "string" == typeof e2 && (e2 = JSON.parse(e2));
          if (Array.isArray(e2)) {
            if (!e2.length || Array.isArray(e2[0]))
              return h3(null, e2, r3);
            if ("object" == typeof e2[0])
              return h3(i2 || Object.keys(e2[0]), e2, r3);
          } else if ("object" == typeof e2)
            return "string" == typeof e2.data && (e2.data = JSON.parse(e2.data)), Array.isArray(e2.data) && (e2.fields || (e2.fields = e2.meta && e2.meta.fields || i2), e2.fields || (e2.fields = Array.isArray(e2.data[0]) ? e2.fields : "object" == typeof e2.data[0] ? Object.keys(e2.data[0]) : []), Array.isArray(e2.data[0]) || "object" == typeof e2.data[0] || (e2.data = [e2.data])), h3(e2.fields || [], e2.data || [], r3);
          throw new Error("Unable to serialize unrecognized input");
          function h3(e3, t3, r4) {
            var i3 = "";
            "string" == typeof e3 && (e3 = JSON.parse(e3)), "string" == typeof t3 && (t3 = JSON.parse(t3));
            var n4 = Array.isArray(e3) && 0 < e3.length, s3 = !Array.isArray(t3[0]);
            if (n4 && _2) {
              for (var a3 = 0; a3 < e3.length; a3++)
                0 < a3 && (i3 += m3), i3 += v3(e3[a3], a3);
              0 < t3.length && (i3 += y3);
            }
            for (var o4 = 0; o4 < t3.length; o4++) {
              var u4 = n4 ? e3.length : t3[o4].length, h4 = false, f3 = n4 ? 0 === Object.keys(t3[o4]).length : 0 === t3[o4].length;
              if (r4 && !n4 && (h4 = "greedy" === r4 ? "" === t3[o4].join("").trim() : 1 === t3[o4].length && 0 === t3[o4][0].length), "greedy" === r4 && n4) {
                for (var d3 = [], l3 = 0; l3 < u4; l3++) {
                  var c3 = s3 ? e3[l3] : l3;
                  d3.push(t3[o4][c3]);
                }
                h4 = "" === d3.join("").trim();
              }
              if (!h4) {
                for (var p3 = 0; p3 < u4; p3++) {
                  0 < p3 && !f3 && (i3 += m3);
                  var g3 = n4 && s3 ? e3[p3] : p3;
                  i3 += v3(t3[o4][g3], p3);
                }
                o4 < t3.length - 1 && (!r4 || 0 < u4 && !f3) && (i3 += y3);
              }
            }
            return i3;
          }
          function v3(e3, t3) {
            if (null == e3)
              return "";
            if (e3.constructor === Date)
              return JSON.stringify(e3).slice(1, 25);
            var r4 = false;
            o3 && "string" == typeof e3 && o3.test(e3) && (e3 = "'" + e3, r4 = true);
            var i3 = e3.toString().replace(u3, a2);
            return (r4 = r4 || true === n3 || "function" == typeof n3 && n3(e3, t3) || Array.isArray(n3) && n3[t3] || function(e4, t4) {
              for (var r5 = 0; r5 < t4.length; r5++)
                if (-1 < e4.indexOf(t4[r5]))
                  return true;
              return false;
            }(i3, b2.BAD_DELIMITERS) || -1 < i3.indexOf(m3) || " " === i3.charAt(0) || " " === i3.charAt(i3.length - 1)) ? s2 + i3 + s2 : i3;
          }
        } };
        if (b2.RECORD_SEP = String.fromCharCode(30), b2.UNIT_SEP = String.fromCharCode(31), b2.BYTE_ORDER_MARK = "\uFEFF", b2.BAD_DELIMITERS = ["\r", "\n", '"', b2.BYTE_ORDER_MARK], b2.WORKERS_SUPPORTED = !n2 && !!f2.Worker, b2.NODE_STREAM_INPUT = 1, b2.LocalChunkSize = 10485760, b2.RemoteChunkSize = 5242880, b2.DefaultDelimiter = ",", b2.Parser = E2, b2.ParserHandle = r2, b2.NetworkStreamer = l2, b2.FileStreamer = c2, b2.StringStreamer = p2, b2.ReadableStreamStreamer = g2, f2.jQuery) {
          var d2 = f2.jQuery;
          d2.fn.parse = function(o3) {
            var r3 = o3.config || {}, u3 = [];
            return this.each(function(e3) {
              if (!("INPUT" === d2(this).prop("tagName").toUpperCase() && "file" === d2(this).attr("type").toLowerCase() && f2.FileReader) || !this.files || 0 === this.files.length)
                return true;
              for (var t2 = 0; t2 < this.files.length; t2++)
                u3.push({ file: this.files[t2], inputElem: this, instanceConfig: d2.extend({}, r3) });
            }), e2(), this;
            function e2() {
              if (0 !== u3.length) {
                var e3, t2, r4, i2, n3 = u3[0];
                if (J2(o3.before)) {
                  var s2 = o3.before(n3.file, n3.inputElem);
                  if ("object" == typeof s2) {
                    if ("abort" === s2.action)
                      return e3 = "AbortError", t2 = n3.file, r4 = n3.inputElem, i2 = s2.reason, void (J2(o3.error) && o3.error({ name: e3 }, t2, r4, i2));
                    if ("skip" === s2.action)
                      return void h3();
                    "object" == typeof s2.config && (n3.instanceConfig = d2.extend(n3.instanceConfig, s2.config));
                  } else if ("skip" === s2)
                    return void h3();
                }
                var a2 = n3.instanceConfig.complete;
                n3.instanceConfig.complete = function(e4) {
                  J2(a2) && a2(e4, n3.file, n3.inputElem), h3();
                }, b2.parse(n3.file, n3.instanceConfig);
              } else
                J2(o3.complete) && o3.complete();
            }
            function h3() {
              u3.splice(0, 1), e2();
            }
          };
        }
        function h2(e2) {
          this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = { data: [], errors: [], meta: {} }, function(e3) {
            var t2 = w2(e3);
            t2.chunkSize = parseInt(t2.chunkSize), e3.step || e3.chunk || (t2.chunkSize = null);
            this._handle = new r2(t2), (this._handle.streamer = this)._config = t2;
          }.call(this, e2), this.parseChunk = function(e3, t2) {
            if (this.isFirstChunk && J2(this._config.beforeFirstChunk)) {
              var r3 = this._config.beforeFirstChunk(e3);
              void 0 !== r3 && (e3 = r3);
            }
            this.isFirstChunk = false, this._halted = false;
            var i2 = this._partialLine + e3;
            this._partialLine = "";
            var n3 = this._handle.parse(i2, this._baseIndex, !this._finished);
            if (!this._handle.paused() && !this._handle.aborted()) {
              var s2 = n3.meta.cursor;
              this._finished || (this._partialLine = i2.substring(s2 - this._baseIndex), this._baseIndex = s2), n3 && n3.data && (this._rowCount += n3.data.length);
              var a2 = this._finished || this._config.preview && this._rowCount >= this._config.preview;
              if (o2)
                f2.postMessage({ results: n3, workerId: b2.WORKER_ID, finished: a2 });
              else if (J2(this._config.chunk) && !t2) {
                if (this._config.chunk(n3, this._handle), this._handle.paused() || this._handle.aborted())
                  return void (this._halted = true);
                n3 = void 0, this._completeResults = void 0;
              }
              return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(n3.data), this._completeResults.errors = this._completeResults.errors.concat(n3.errors), this._completeResults.meta = n3.meta), this._completed || !a2 || !J2(this._config.complete) || n3 && n3.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), a2 || n3 && n3.meta.paused || this._nextChunk(), n3;
            }
            this._halted = true;
          }, this._sendError = function(e3) {
            J2(this._config.error) ? this._config.error(e3) : o2 && this._config.error && f2.postMessage({ workerId: b2.WORKER_ID, error: e3, finished: false });
          };
        }
        function l2(e2) {
          var i2;
          (e2 = e2 || {}).chunkSize || (e2.chunkSize = b2.RemoteChunkSize), h2.call(this, e2), this._nextChunk = n2 ? function() {
            this._readChunk(), this._chunkLoaded();
          } : function() {
            this._readChunk();
          }, this.stream = function(e3) {
            this._input = e3, this._nextChunk();
          }, this._readChunk = function() {
            if (this._finished)
              this._chunkLoaded();
            else {
              if (i2 = new XMLHttpRequest(), this._config.withCredentials && (i2.withCredentials = this._config.withCredentials), n2 || (i2.onload = v2(this._chunkLoaded, this), i2.onerror = v2(this._chunkError, this)), i2.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !n2), this._config.downloadRequestHeaders) {
                var e3 = this._config.downloadRequestHeaders;
                for (var t2 in e3)
                  i2.setRequestHeader(t2, e3[t2]);
              }
              if (this._config.chunkSize) {
                var r3 = this._start + this._config.chunkSize - 1;
                i2.setRequestHeader("Range", "bytes=" + this._start + "-" + r3);
              }
              try {
                i2.send(this._config.downloadRequestBody);
              } catch (e4) {
                this._chunkError(e4.message);
              }
              n2 && 0 === i2.status && this._chunkError();
            }
          }, this._chunkLoaded = function() {
            4 === i2.readyState && (i2.status < 200 || 400 <= i2.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : i2.responseText.length, this._finished = !this._config.chunkSize || this._start >= function(e3) {
              var t2 = e3.getResponseHeader("Content-Range");
              if (null === t2)
                return -1;
              return parseInt(t2.substring(t2.lastIndexOf("/") + 1));
            }(i2), this.parseChunk(i2.responseText)));
          }, this._chunkError = function(e3) {
            var t2 = i2.statusText || e3;
            this._sendError(new Error(t2));
          };
        }
        function c2(e2) {
          var i2, n3;
          (e2 = e2 || {}).chunkSize || (e2.chunkSize = b2.LocalChunkSize), h2.call(this, e2);
          var s2 = "undefined" != typeof FileReader;
          this.stream = function(e3) {
            this._input = e3, n3 = e3.slice || e3.webkitSlice || e3.mozSlice, s2 ? ((i2 = new FileReader()).onload = v2(this._chunkLoaded, this), i2.onerror = v2(this._chunkError, this)) : i2 = new FileReaderSync(), this._nextChunk();
          }, this._nextChunk = function() {
            this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
          }, this._readChunk = function() {
            var e3 = this._input;
            if (this._config.chunkSize) {
              var t2 = Math.min(this._start + this._config.chunkSize, this._input.size);
              e3 = n3.call(e3, this._start, t2);
            }
            var r3 = i2.readAsText(e3, this._config.encoding);
            s2 || this._chunkLoaded({ target: { result: r3 } });
          }, this._chunkLoaded = function(e3) {
            this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e3.target.result);
          }, this._chunkError = function() {
            this._sendError(i2.error);
          };
        }
        function p2(e2) {
          var r3;
          h2.call(this, e2 = e2 || {}), this.stream = function(e3) {
            return r3 = e3, this._nextChunk();
          }, this._nextChunk = function() {
            if (!this._finished) {
              var e3, t2 = this._config.chunkSize;
              return t2 ? (e3 = r3.substring(0, t2), r3 = r3.substring(t2)) : (e3 = r3, r3 = ""), this._finished = !r3, this.parseChunk(e3);
            }
          };
        }
        function g2(e2) {
          h2.call(this, e2 = e2 || {});
          var t2 = [], r3 = true, i2 = false;
          this.pause = function() {
            h2.prototype.pause.apply(this, arguments), this._input.pause();
          }, this.resume = function() {
            h2.prototype.resume.apply(this, arguments), this._input.resume();
          }, this.stream = function(e3) {
            this._input = e3, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
          }, this._checkIsFinished = function() {
            i2 && 1 === t2.length && (this._finished = true);
          }, this._nextChunk = function() {
            this._checkIsFinished(), t2.length ? this.parseChunk(t2.shift()) : r3 = true;
          }, this._streamData = v2(function(e3) {
            try {
              t2.push("string" == typeof e3 ? e3 : e3.toString(this._config.encoding)), r3 && (r3 = false, this._checkIsFinished(), this.parseChunk(t2.shift()));
            } catch (e4) {
              this._streamError(e4);
            }
          }, this), this._streamError = v2(function(e3) {
            this._streamCleanUp(), this._sendError(e3);
          }, this), this._streamEnd = v2(function() {
            this._streamCleanUp(), i2 = true, this._streamData("");
          }, this), this._streamCleanUp = v2(function() {
            this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
          }, this);
        }
        function r2(m3) {
          var a2, o3, u3, i2 = Math.pow(2, 53), n3 = -i2, s2 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, h3 = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, t2 = this, r3 = 0, f3 = 0, d3 = false, e2 = false, l3 = [], c3 = { data: [], errors: [], meta: {} };
          if (J2(m3.step)) {
            var p3 = m3.step;
            m3.step = function(e3) {
              if (c3 = e3, _2())
                g3();
              else {
                if (g3(), 0 === c3.data.length)
                  return;
                r3 += e3.data.length, m3.preview && r3 > m3.preview ? o3.abort() : (c3.data = c3.data[0], p3(c3, t2));
              }
            };
          }
          function y3(e3) {
            return "greedy" === m3.skipEmptyLines ? "" === e3.join("").trim() : 1 === e3.length && 0 === e3[0].length;
          }
          function g3() {
            return c3 && u3 && (k2("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + b2.DefaultDelimiter + "'"), u3 = false), m3.skipEmptyLines && (c3.data = c3.data.filter(function(e3) {
              return !y3(e3);
            })), _2() && function() {
              if (!c3)
                return;
              function e3(e4, t4) {
                J2(m3.transformHeader) && (e4 = m3.transformHeader(e4, t4)), l3.push(e4);
              }
              if (Array.isArray(c3.data[0])) {
                for (var t3 = 0; _2() && t3 < c3.data.length; t3++)
                  c3.data[t3].forEach(e3);
                c3.data.splice(0, 1);
              } else
                c3.data.forEach(e3);
            }(), function() {
              if (!c3 || !m3.header && !m3.dynamicTyping && !m3.transform)
                return c3;
              function e3(e4, t4) {
                var r4, i3 = m3.header ? {} : [];
                for (r4 = 0; r4 < e4.length; r4++) {
                  var n4 = r4, s3 = e4[r4];
                  m3.header && (n4 = r4 >= l3.length ? "__parsed_extra" : l3[r4]), m3.transform && (s3 = m3.transform(s3, n4)), s3 = v3(n4, s3), "__parsed_extra" === n4 ? (i3[n4] = i3[n4] || [], i3[n4].push(s3)) : i3[n4] = s3;
                }
                return m3.header && (r4 > l3.length ? k2("FieldMismatch", "TooManyFields", "Too many fields: expected " + l3.length + " fields but parsed " + r4, f3 + t4) : r4 < l3.length && k2("FieldMismatch", "TooFewFields", "Too few fields: expected " + l3.length + " fields but parsed " + r4, f3 + t4)), i3;
              }
              var t3 = 1;
              !c3.data.length || Array.isArray(c3.data[0]) ? (c3.data = c3.data.map(e3), t3 = c3.data.length) : c3.data = e3(c3.data, 0);
              m3.header && c3.meta && (c3.meta.fields = l3);
              return f3 += t3, c3;
            }();
          }
          function _2() {
            return m3.header && 0 === l3.length;
          }
          function v3(e3, t3) {
            return r4 = e3, m3.dynamicTypingFunction && void 0 === m3.dynamicTyping[r4] && (m3.dynamicTyping[r4] = m3.dynamicTypingFunction(r4)), true === (m3.dynamicTyping[r4] || m3.dynamicTyping) ? "true" === t3 || "TRUE" === t3 || "false" !== t3 && "FALSE" !== t3 && (function(e4) {
              if (s2.test(e4)) {
                var t4 = parseFloat(e4);
                if (n3 < t4 && t4 < i2)
                  return true;
              }
              return false;
            }(t3) ? parseFloat(t3) : h3.test(t3) ? new Date(t3) : "" === t3 ? null : t3) : t3;
            var r4;
          }
          function k2(e3, t3, r4, i3) {
            var n4 = { type: e3, code: t3, message: r4 };
            void 0 !== i3 && (n4.row = i3), c3.errors.push(n4);
          }
          this.parse = function(e3, t3, r4) {
            var i3 = m3.quoteChar || '"';
            if (m3.newline || (m3.newline = function(e4, t4) {
              e4 = e4.substring(0, 1048576);
              var r5 = new RegExp(Q2(t4) + "([^]*?)" + Q2(t4), "gm"), i4 = (e4 = e4.replace(r5, "")).split("\r"), n5 = e4.split("\n"), s4 = 1 < n5.length && n5[0].length < i4[0].length;
              if (1 === i4.length || s4)
                return "\n";
              for (var a3 = 0, o4 = 0; o4 < i4.length; o4++)
                "\n" === i4[o4][0] && a3++;
              return a3 >= i4.length / 2 ? "\r\n" : "\r";
            }(e3, i3)), u3 = false, m3.delimiter)
              J2(m3.delimiter) && (m3.delimiter = m3.delimiter(e3), c3.meta.delimiter = m3.delimiter);
            else {
              var n4 = function(e4, t4, r5, i4, n5) {
                var s4, a3, o4, u4;
                n5 = n5 || [",", "	", "|", ";", b2.RECORD_SEP, b2.UNIT_SEP];
                for (var h4 = 0; h4 < n5.length; h4++) {
                  var f4 = n5[h4], d4 = 0, l4 = 0, c4 = 0;
                  o4 = void 0;
                  for (var p4 = new E2({ comments: i4, delimiter: f4, newline: t4, preview: 10 }).parse(e4), g4 = 0; g4 < p4.data.length; g4++)
                    if (r5 && y3(p4.data[g4]))
                      c4++;
                    else {
                      var _3 = p4.data[g4].length;
                      l4 += _3, void 0 !== o4 ? 0 < _3 && (d4 += Math.abs(_3 - o4), o4 = _3) : o4 = _3;
                    }
                  0 < p4.data.length && (l4 /= p4.data.length - c4), (void 0 === a3 || d4 <= a3) && (void 0 === u4 || u4 < l4) && 1.99 < l4 && (a3 = d4, s4 = f4, u4 = l4);
                }
                return { successful: !!(m3.delimiter = s4), bestDelimiter: s4 };
              }(e3, m3.newline, m3.skipEmptyLines, m3.comments, m3.delimitersToGuess);
              n4.successful ? m3.delimiter = n4.bestDelimiter : (u3 = true, m3.delimiter = b2.DefaultDelimiter), c3.meta.delimiter = m3.delimiter;
            }
            var s3 = w2(m3);
            return m3.preview && m3.header && s3.preview++, a2 = e3, o3 = new E2(s3), c3 = o3.parse(a2, t3, r4), g3(), d3 ? { meta: { paused: true } } : c3 || { meta: { paused: false } };
          }, this.paused = function() {
            return d3;
          }, this.pause = function() {
            d3 = true, o3.abort(), a2 = J2(m3.chunk) ? "" : a2.substring(o3.getCharIndex());
          }, this.resume = function() {
            t2.streamer._halted ? (d3 = false, t2.streamer.parseChunk(a2, true)) : setTimeout(t2.resume, 3);
          }, this.aborted = function() {
            return e2;
          }, this.abort = function() {
            e2 = true, o3.abort(), c3.meta.aborted = true, J2(m3.complete) && m3.complete(c3), a2 = "";
          };
        }
        function Q2(e2) {
          return e2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        function E2(j) {
          var z2, M2 = (j = j || {}).delimiter, P2 = j.newline, U2 = j.comments, q2 = j.step, N2 = j.preview, B2 = j.fastMode, K2 = z2 = void 0 === j.quoteChar || null === j.quoteChar ? '"' : j.quoteChar;
          if (void 0 !== j.escapeChar && (K2 = j.escapeChar), ("string" != typeof M2 || -1 < b2.BAD_DELIMITERS.indexOf(M2)) && (M2 = ","), U2 === M2)
            throw new Error("Comment character same as delimiter");
          true === U2 ? U2 = "#" : ("string" != typeof U2 || -1 < b2.BAD_DELIMITERS.indexOf(U2)) && (U2 = false), "\n" !== P2 && "\r" !== P2 && "\r\n" !== P2 && (P2 = "\n");
          var W2 = 0, H2 = false;
          this.parse = function(i2, t2, r3) {
            if ("string" != typeof i2)
              throw new Error("Input must be a string");
            var n3 = i2.length, e2 = M2.length, s2 = P2.length, a2 = U2.length, o3 = J2(q2), u3 = [], h3 = [], f3 = [], d3 = W2 = 0;
            if (!i2)
              return L2();
            if (j.header) {
              var l3 = i2.split(P2)[0].split(M2), c3 = [], p3 = {}, g3 = false;
              for (var _2 in l3) {
                var m3 = l3[_2];
                J2(j.transformHeader) && (m3 = j.transformHeader(m3, _2));
                var y3 = m3, v3 = p3[m3] || 0;
                0 < v3 && (g3 = true, y3 = m3 + "_" + v3), p3[m3] = v3 + 1, c3.push(y3);
              }
              if (g3) {
                var k2 = i2.split(P2);
                k2[0] = c3.join(M2), i2 = k2.join(P2);
              }
            }
            if (B2 || false !== B2 && -1 === i2.indexOf(z2)) {
              for (var b3 = i2.split(P2), E3 = 0; E3 < b3.length; E3++) {
                if (f3 = b3[E3], W2 += f3.length, E3 !== b3.length - 1)
                  W2 += P2.length;
                else if (r3)
                  return L2();
                if (!U2 || f3.substring(0, a2) !== U2) {
                  if (o3) {
                    if (u3 = [], I2(f3.split(M2)), F2(), H2)
                      return L2();
                  } else
                    I2(f3.split(M2));
                  if (N2 && N2 <= E3)
                    return u3 = u3.slice(0, N2), L2(true);
                }
              }
              return L2();
            }
            for (var w3 = i2.indexOf(M2, W2), R2 = i2.indexOf(P2, W2), C2 = new RegExp(Q2(K2) + Q2(z2), "g"), S2 = i2.indexOf(z2, W2); ; )
              if (i2[W2] !== z2)
                if (U2 && 0 === f3.length && i2.substring(W2, W2 + a2) === U2) {
                  if (-1 === R2)
                    return L2();
                  W2 = R2 + s2, R2 = i2.indexOf(P2, W2), w3 = i2.indexOf(M2, W2);
                } else if (-1 !== w3 && (w3 < R2 || -1 === R2))
                  f3.push(i2.substring(W2, w3)), W2 = w3 + e2, w3 = i2.indexOf(M2, W2);
                else {
                  if (-1 === R2)
                    break;
                  if (f3.push(i2.substring(W2, R2)), D2(R2 + s2), o3 && (F2(), H2))
                    return L2();
                  if (N2 && u3.length >= N2)
                    return L2(true);
                }
              else
                for (S2 = W2, W2++; ; ) {
                  if (-1 === (S2 = i2.indexOf(z2, S2 + 1)))
                    return r3 || h3.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: u3.length, index: W2 }), T2();
                  if (S2 === n3 - 1)
                    return T2(i2.substring(W2, S2).replace(C2, z2));
                  if (z2 !== K2 || i2[S2 + 1] !== K2) {
                    if (z2 === K2 || 0 === S2 || i2[S2 - 1] !== K2) {
                      -1 !== w3 && w3 < S2 + 1 && (w3 = i2.indexOf(M2, S2 + 1)), -1 !== R2 && R2 < S2 + 1 && (R2 = i2.indexOf(P2, S2 + 1));
                      var O2 = A2(-1 === R2 ? w3 : Math.min(w3, R2));
                      if (i2.substr(S2 + 1 + O2, e2) === M2) {
                        f3.push(i2.substring(W2, S2).replace(C2, z2)), i2[W2 = S2 + 1 + O2 + e2] !== z2 && (S2 = i2.indexOf(z2, W2)), w3 = i2.indexOf(M2, W2), R2 = i2.indexOf(P2, W2);
                        break;
                      }
                      var x2 = A2(R2);
                      if (i2.substring(S2 + 1 + x2, S2 + 1 + x2 + s2) === P2) {
                        if (f3.push(i2.substring(W2, S2).replace(C2, z2)), D2(S2 + 1 + x2 + s2), w3 = i2.indexOf(M2, W2), S2 = i2.indexOf(z2, W2), o3 && (F2(), H2))
                          return L2();
                        if (N2 && u3.length >= N2)
                          return L2(true);
                        break;
                      }
                      h3.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: u3.length, index: W2 }), S2++;
                    }
                  } else
                    S2++;
                }
            return T2();
            function I2(e3) {
              u3.push(e3), d3 = W2;
            }
            function A2(e3) {
              var t3 = 0;
              if (-1 !== e3) {
                var r4 = i2.substring(S2 + 1, e3);
                r4 && "" === r4.trim() && (t3 = r4.length);
              }
              return t3;
            }
            function T2(e3) {
              return r3 || (void 0 === e3 && (e3 = i2.substring(W2)), f3.push(e3), W2 = n3, I2(f3), o3 && F2()), L2();
            }
            function D2(e3) {
              W2 = e3, I2(f3), f3 = [], R2 = i2.indexOf(P2, W2);
            }
            function L2(e3) {
              return { data: u3, errors: h3, meta: { delimiter: M2, linebreak: P2, aborted: H2, truncated: !!e3, cursor: d3 + (t2 || 0) } };
            }
            function F2() {
              q2(L2()), u3 = [], h3 = [];
            }
          }, this.abort = function() {
            H2 = true;
          }, this.getCharIndex = function() {
            return W2;
          };
        }
        function _(e2) {
          var t2 = e2.data, r3 = a[t2.workerId], i2 = false;
          if (t2.error)
            r3.userError(t2.error, t2.file);
          else if (t2.results && t2.results.data) {
            var n3 = { abort: function() {
              i2 = true, m2(t2.workerId, { data: [], errors: [], meta: { aborted: true } });
            }, pause: y2, resume: y2 };
            if (J2(r3.userStep)) {
              for (var s2 = 0; s2 < t2.results.data.length && (r3.userStep({ data: t2.results.data[s2], errors: t2.results.errors, meta: t2.results.meta }, n3), !i2); s2++)
                ;
              delete t2.results;
            } else
              J2(r3.userChunk) && (r3.userChunk(t2.results, n3, t2.file), delete t2.results);
          }
          t2.finished && !i2 && m2(t2.workerId, t2.results);
        }
        function m2(e2, t2) {
          var r3 = a[e2];
          J2(r3.userComplete) && r3.userComplete(t2), r3.terminate(), delete a[e2];
        }
        function y2() {
          throw new Error("Not implemented.");
        }
        function w2(e2) {
          if ("object" != typeof e2 || null === e2)
            return e2;
          var t2 = Array.isArray(e2) ? [] : {};
          for (var r3 in e2)
            t2[r3] = w2(e2[r3]);
          return t2;
        }
        function v2(e2, t2) {
          return function() {
            e2.apply(t2, arguments);
          };
        }
        function J2(e2) {
          return "function" == typeof e2;
        }
        return o2 && (f2.onmessage = function(e2) {
          var t2 = e2.data;
          void 0 === b2.WORKER_ID && t2 && (b2.WORKER_ID = t2.workerId);
          if ("string" == typeof t2.input)
            f2.postMessage({ workerId: b2.WORKER_ID, results: b2.parse(t2.input, t2.config), finished: true });
          else if (f2.File && t2.input instanceof File || t2.input instanceof Object) {
            var r3 = b2.parse(t2.input, t2.config);
            r3 && f2.postMessage({ workerId: b2.WORKER_ID, results: r3, finished: true });
          }
        }), (l2.prototype = Object.create(h2.prototype)).constructor = l2, (c2.prototype = Object.create(h2.prototype)).constructor = c2, (p2.prototype = Object.create(p2.prototype)).constructor = p2, (g2.prototype = Object.create(h2.prototype)).constructor = g2, b2;
      });
    })(papaparse_min);
    var ListCache$2 = _ListCache;
    function stackClear$1() {
      this.__data__ = new ListCache$2();
      this.size = 0;
    }
    var _stackClear = stackClear$1;
    function stackDelete$1(key) {
      var data2 = this.__data__, result = data2["delete"](key);
      this.size = data2.size;
      return result;
    }
    var _stackDelete = stackDelete$1;
    function stackGet$1(key) {
      return this.__data__.get(key);
    }
    var _stackGet = stackGet$1;
    function stackHas$1(key) {
      return this.__data__.has(key);
    }
    var _stackHas = stackHas$1;
    var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$1 = _MapCache;
    var LARGE_ARRAY_SIZE = 200;
    function stackSet$1(key, value) {
      var data2 = this.__data__;
      if (data2 instanceof ListCache$1) {
        var pairs = data2.__data__;
        if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data2.size;
          return this;
        }
        data2 = this.__data__ = new MapCache$1(pairs);
      }
      data2.set(key, value);
      this.size = data2.size;
      return this;
    }
    var _stackSet = stackSet$1;
    var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
    function Stack$2(entries) {
      var data2 = this.__data__ = new ListCache(entries);
      this.size = data2.size;
    }
    Stack$2.prototype.clear = stackClear;
    Stack$2.prototype["delete"] = stackDelete;
    Stack$2.prototype.get = stackGet;
    Stack$2.prototype.has = stackHas;
    Stack$2.prototype.set = stackSet;
    var _Stack = Stack$2;
    function arraySome$1(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    var _arraySome = arraySome$1;
    var SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;
    var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
    function equalArrays$2(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    var _equalArrays = equalArrays$2;
    var root$6 = _root;
    var Uint8Array$2 = root$6.Uint8Array;
    var _Uint8Array = Uint8Array$2;
    function mapToArray$1(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    var _mapToArray = mapToArray$1;
    var Symbol$2 = _Symbol, Uint8Array$1 = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
    var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
    var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
    var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    function equalByTag$1(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$2:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag$1:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object2), new Uint8Array$1(other))) {
            return false;
          }
          return true;
        case boolTag$1:
        case dateTag$1:
        case numberTag$1:
          return eq(+object2, +other);
        case errorTag$1:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag$1:
        case stringTag$1:
          return object2 == other + "";
        case mapTag$2:
          var convert2 = mapToArray;
        case setTag$2:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert2 || (convert2 = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;
          stack.set(object2, other);
          var result = equalArrays$1(convert2(object2), convert2(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag$1:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    var _equalByTag = equalByTag$1;
    var arrayPush = _arrayPush, isArray$a = isArray_1;
    function baseGetAllKeys$1(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray$a(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    var _baseGetAllKeys = baseGetAllKeys$1;
    function stubArray$1() {
      return [];
    }
    var stubArray_1 = stubArray$1;
    var arrayFilter = _arrayFilter, stubArray = stubArray_1;
    var objectProto$5 = Object.prototype;
    var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    var _getSymbols = getSymbols$1;
    var isBufferExports = {};
    var isBuffer$4 = {
      get exports() {
        return isBufferExports;
      },
      set exports(v2) {
        isBufferExports = v2;
      }
    };
    function stubFalse() {
      return false;
    }
    var stubFalse_1 = stubFalse;
    (function(module2, exports2) {
      var root2 = _root, stubFalse2 = stubFalse_1;
      var freeExports2 = exports2 && !exports2.nodeType && exports2;
      var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
      var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
      var Buffer2 = moduleExports2 ? root2.Buffer : void 0;
      var nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer2 = nativeIsBuffer2 || stubFalse2;
      module2.exports = isBuffer2;
    })(isBuffer$4, isBufferExports);
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex$2(value, length2) {
      var type2 = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    var _isIndex = isIndex$2;
    var baseGetTag$2 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$2 = isObjectLike_1;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$2 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
    function baseIsTypedArray$1(value) {
      return isObjectLike$2(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$2(value)];
    }
    var _baseIsTypedArray = baseIsTypedArray$1;
    var _nodeUtilExports = {};
    var _nodeUtil = {
      get exports() {
        return _nodeUtilExports;
      },
      set exports(v2) {
        _nodeUtilExports = v2;
      }
    };
    (function(module2, exports2) {
      var freeGlobal2 = _freeGlobal;
      var freeExports2 = exports2 && !exports2.nodeType && exports2;
      var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
      var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
      var freeProcess2 = moduleExports2 && freeGlobal2.process;
      var nodeUtil2 = function() {
        try {
          var types2 = freeModule2 && freeModule2.require && freeModule2.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
        } catch (e2) {
        }
      }();
      module2.exports = nodeUtil2;
    })(_nodeUtil, _nodeUtilExports);
    var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports;
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    var isTypedArray_1 = isTypedArray$2;
    var baseTimes = _baseTimes, isArguments$1 = isArguments_1, isArray$9 = isArray_1, isBuffer$3 = isBufferExports, isIndex$1 = _isIndex, isTypedArray$1 = isTypedArray_1;
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$9 = objectProto$4.hasOwnProperty;
    function arrayLikeKeys$1(value, inherited) {
      var isArr = isArray$9(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$3(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$9.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex$1(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    var _arrayLikeKeys = arrayLikeKeys$1;
    var objectProto$3 = Object.prototype;
    function isPrototype$1(value) {
      var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$3;
      return value === proto2;
    }
    var _isPrototype = isPrototype$1;
    function overArg$1(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var _overArg = overArg$1;
    var overArg = _overArg;
    var nativeKeys$1 = overArg(Object.keys, Object);
    var _nativeKeys = nativeKeys$1;
    var isPrototype = _isPrototype, nativeKeys = _nativeKeys;
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$8 = objectProto$2.hasOwnProperty;
    function baseKeys$1(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty$8.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    var _baseKeys = baseKeys$1;
    var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike = isArrayLike_1;
    function keys$3(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    var keys_1 = keys$3;
    var baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys$2 = keys_1;
    function getAllKeys$1(object2) {
      return baseGetAllKeys(object2, keys$2, getSymbols);
    }
    var _getAllKeys = getAllKeys$1;
    var getAllKeys = _getAllKeys;
    var COMPARE_PARTIAL_FLAG$3 = 1;
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$7 = objectProto$1.hasOwnProperty;
    function equalObjects$1(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty$7.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    var _equalObjects = equalObjects$1;
    var getNative$2 = _getNative, root$5 = _root;
    var DataView$2 = getNative$2(root$5, "DataView");
    var _DataView = DataView$2;
    var getNative$1 = _getNative, root$4 = _root;
    var Promise$2 = getNative$1(root$4, "Promise");
    var _Promise = Promise$2;
    var getNative = _getNative, root$3 = _root;
    var WeakMap$2 = getNative(root$3, "WeakMap");
    var _WeakMap = WeakMap$2;
    var DataView$1 = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag$1 = _baseGetTag, toSource = _toSource;
    var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
    var getTag$1 = baseGetTag$1;
    if (DataView$1 && getTag$1(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag) {
      getTag$1 = function(value) {
        var result = baseGetTag$1(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    var _getTag = getTag$1;
    var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray$8 = isArray_1, isBuffer$2 = isBufferExports, isTypedArray = isTypedArray_1;
    var COMPARE_PARTIAL_FLAG$2 = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty$6 = objectProto.hasOwnProperty;
    function baseIsEqualDeep$1(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray$8(object2), othIsArr = isArray$8(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer$2(object2)) {
        if (!isBuffer$2(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack$1());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty$6.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$6.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack$1());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack$1());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    var _baseIsEqualDeep = baseIsEqualDeep$1;
    var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$1 = isObjectLike_1;
    function baseIsEqual$3(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike$1(value) && !isObjectLike$1(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);
    }
    var _baseIsEqual = baseIsEqual$3;
    var Stack = _Stack, baseIsEqual$2 = _baseIsEqual;
    var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function baseIsMatch$1(object2, source, matchData, customizer) {
      var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
      if (object2 == null) {
        return !length2;
      }
      object2 = Object(object2);
      while (index2--) {
        var data2 = matchData[index2];
        if (noCustomizer && data2[2] ? data2[1] !== object2[data2[0]] : !(data2[0] in object2)) {
          return false;
        }
      }
      while (++index2 < length2) {
        data2 = matchData[index2];
        var key = data2[0], objValue = object2[key], srcValue = data2[1];
        if (noCustomizer && data2[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object2, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    var _baseIsMatch = baseIsMatch$1;
    var isObject$5 = isObject_1;
    function isStrictComparable$2(value) {
      return value === value && !isObject$5(value);
    }
    var _isStrictComparable = isStrictComparable$2;
    var isStrictComparable$1 = _isStrictComparable, keys$1 = keys_1;
    function getMatchData$1(object2) {
      var result = keys$1(object2), length2 = result.length;
      while (length2--) {
        var key = result[length2], value = object2[key];
        result[length2] = [key, value, isStrictComparable$1(value)];
      }
      return result;
    }
    var _getMatchData = getMatchData$1;
    function matchesStrictComparable$2(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    var _matchesStrictComparable = matchesStrictComparable$2;
    var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
    function baseMatches$1(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    var _baseMatches = baseMatches$1;
    var baseGetTag = _baseGetTag, isObjectLike = isObjectLike_1;
    var symbolTag = "[object Symbol]";
    function isSymbol$4(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    var isSymbol_1 = isSymbol$4;
    var isArray$7 = isArray_1, isSymbol$3 = isSymbol_1;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey$3(value, object2) {
      if (isArray$7(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol$3(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    var _isKey = isKey$3;
    var MapCache = _MapCache;
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    function memoize$2(func, resolver2) {
      if (typeof func != "function" || resolver2 != null && typeof resolver2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      var memoized = function() {
        var args = arguments, key = resolver2 ? resolver2.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize$2.Cache || MapCache)();
      return memoized;
    }
    memoize$2.Cache = MapCache;
    var memoize_1 = memoize$2;
    var memoize$1 = memoize_1;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped$1(func) {
      var result = memoize$1(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result.cache;
      return result;
    }
    var _memoizeCapped = memoizeCapped$1;
    var memoizeCapped = _memoizeCapped;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath$1 = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match2, number2, quote2, subString) {
        result.push(quote2 ? subString.replace(reEscapeChar, "$1") : number2 || match2);
      });
      return result;
    });
    var _stringToPath = stringToPath$1;
    var Symbol$1 = _Symbol, arrayMap = _arrayMap, isArray$6 = isArray_1, isSymbol$2 = isSymbol_1;
    var INFINITY$1 = 1 / 0;
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString$1(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray$6(value)) {
        return arrayMap(value, baseToString$1) + "";
      }
      if (isSymbol$2(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
    }
    var _baseToString = baseToString$1;
    var baseToString = _baseToString;
    function toString$5(value) {
      return value == null ? "" : baseToString(value);
    }
    var toString_1 = toString$5;
    var isArray$5 = isArray_1, isKey$2 = _isKey, stringToPath = _stringToPath, toString$4 = toString_1;
    function castPath$2(value, object2) {
      if (isArray$5(value)) {
        return value;
      }
      return isKey$2(value, object2) ? [value] : stringToPath(toString$4(value));
    }
    var _castPath = castPath$2;
    var isSymbol$1 = isSymbol_1;
    var INFINITY = 1 / 0;
    function toKey$4(value) {
      if (typeof value == "string" || isSymbol$1(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    var _toKey = toKey$4;
    var castPath$1 = _castPath, toKey$3 = _toKey;
    function baseGet$2(object2, path2) {
      path2 = castPath$1(path2, object2);
      var index2 = 0, length2 = path2.length;
      while (object2 != null && index2 < length2) {
        object2 = object2[toKey$3(path2[index2++])];
      }
      return index2 && index2 == length2 ? object2 : void 0;
    }
    var _baseGet = baseGet$2;
    var baseGet$1 = _baseGet;
    function get$4(object2, path2, defaultValue) {
      var result = object2 == null ? void 0 : baseGet$1(object2, path2);
      return result === void 0 ? defaultValue : result;
    }
    var get_1 = get$4;
    function baseHasIn$1(object2, key) {
      return object2 != null && key in Object(object2);
    }
    var _baseHasIn = baseHasIn$1;
    var castPath = _castPath, isArguments = isArguments_1, isArray$4 = isArray_1, isIndex = _isIndex, isLength = isLength_1, toKey$2 = _toKey;
    function hasPath$1(object2, path2, hasFunc) {
      path2 = castPath(path2, object2);
      var index2 = -1, length2 = path2.length, result = false;
      while (++index2 < length2) {
        var key = toKey$2(path2[index2]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result || ++index2 != length2) {
        return result;
      }
      length2 = object2 == null ? 0 : object2.length;
      return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray$4(object2) || isArguments(object2));
    }
    var _hasPath = hasPath$1;
    var baseHasIn = _baseHasIn, hasPath = _hasPath;
    function hasIn$1(object2, path2) {
      return object2 != null && hasPath(object2, path2, baseHasIn);
    }
    var hasIn_1 = hasIn$1;
    var baseIsEqual$1 = _baseIsEqual, get$3 = get_1, hasIn = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$1 = _toKey;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty$1(path2, srcValue) {
      if (isKey$1(path2) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey$1(path2), srcValue);
      }
      return function(object2) {
        var objValue = get$3(object2, path2);
        return objValue === void 0 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    var _baseMatchesProperty = baseMatchesProperty$1;
    var baseGet = _baseGet;
    function basePropertyDeep$1(path2) {
      return function(object2) {
        return baseGet(object2, path2);
      };
    }
    var _basePropertyDeep = basePropertyDeep$1;
    var baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey = _toKey;
    function property$1(path2) {
      return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
    }
    var property_1 = property$1;
    var baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity$1 = identity_1, isArray$3 = isArray_1, property = property_1;
    function baseIteratee$1(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity$1;
      }
      if (typeof value == "object") {
        return isArray$3(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    var _baseIteratee = baseIteratee$1;
    var baseIteratee = _baseIteratee, baseUniq = _baseUniq;
    function uniqBy(array2, iteratee) {
      return array2 && array2.length ? baseUniq(array2, baseIteratee(iteratee)) : [];
    }
    var uniqBy_1 = uniqBy;
    var root$2 = _root;
    var now$2 = function() {
      return root$2.Date.now();
    };
    var now_1 = now$2;
    var reWhitespace = /\s/;
    function trimmedEndIndex$1(string2) {
      var index2 = string2.length;
      while (index2-- && reWhitespace.test(string2.charAt(index2))) {
      }
      return index2;
    }
    var _trimmedEndIndex = trimmedEndIndex$1;
    var trimmedEndIndex = _trimmedEndIndex;
    var reTrimStart = /^\s+/;
    function baseTrim$1(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    var _baseTrim = baseTrim$1;
    var baseTrim = _baseTrim, isObject$4 = isObject_1, isSymbol = isSymbol_1;
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber$1(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject$4(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject$4(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    var toNumber_1 = toNumber$1;
    var isObject$3 = isObject_1, now$1 = now_1, toNumber = toNumber_1;
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max, nativeMin = Math.min;
    function debounce$1(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject$3(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now$1();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now$1());
      }
      function debounced() {
        var time = now$1(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    var debounce_1 = debounce$1;
    var baseIsEqual = _baseIsEqual;
    function isEqual$2(value, other) {
      return baseIsEqual(value, other);
    }
    var isEqual_1 = isEqual$2;
    const ReactQueryDevtools = function() {
      return null;
    };
    var H$2 = React$3.createContext({}), Zt = ({ children: e2, isProvided: t2, ...r2 }) => {
      let { replace: o2 } = q$2(), s = useQueryClient(), a = () => {
        s.invalidateQueries(["useAuthenticated"]), s.invalidateQueries(["getUserIdentity"]), s.invalidateQueries(["usePermissions"]);
      }, n2 = async (l2) => {
        var y2;
        try {
          let R2 = await ((y2 = r2.login) == null ? void 0 : y2.call(r2, l2));
          return a(), Promise.resolve(R2);
        } catch (R2) {
          return Promise.reject(R2);
        }
      }, m2 = async (l2) => {
        var y2;
        try {
          let R2 = await ((y2 = r2.register) == null ? void 0 : y2.call(r2, l2));
          return a(), Promise.resolve(R2);
        } catch (R2) {
          return Promise.reject(R2);
        }
      }, C2 = async (l2) => {
        var y2;
        try {
          let R2 = await ((y2 = r2.logout) == null ? void 0 : y2.call(r2, l2));
          return a(), Promise.resolve(R2);
        } catch (R2) {
          return Promise.reject(R2);
        }
      }, u2 = async (l2) => {
        var y2;
        try {
          return await ((y2 = r2.checkAuth) == null ? void 0 : y2.call(r2, l2)), Promise.resolve();
        } catch (R2) {
          return R2 != null && R2.redirectPath && o2(R2.redirectPath), Promise.reject(R2);
        }
      };
      return React$3.createElement(H$2.Provider, { value: { ...r2, login: n2, logout: C2, checkAuth: u2, register: m2, isProvided: t2 } }, e2);
    };
    var gt$1 = ({ queryOptions: e2 } = {}) => {
      let { getUserIdentity: t2 } = React$3.useContext(H$2);
      return useQuery(["getUserIdentity"], t2 != null ? t2 : () => Promise.resolve({}), { enabled: !!t2, retry: false, ...e2 });
    };
    var Ct = ({ mutationOptions: e2 } = {}) => {
      let { push: t2 } = q$2(), { logout: r2 } = React$3.useContext(H$2), { open: o2 } = te();
      return useMutation(["useLogout"], r2, { onSuccess: (a, n2) => {
        var C2;
        let m2 = (C2 = n2 == null ? void 0 : n2.redirectPath) != null ? C2 : a;
        if (m2 !== false) {
          if (m2) {
            t2(m2);
            return;
          }
          t2("/login");
        }
      }, onError: (a) => {
        o2 == null || o2({ key: "useLogout-error", type: "error", message: (a == null ? void 0 : a.name) || "Logout Error", description: (a == null ? void 0 : a.message) || "Something went wrong during logout" });
      }, ...e2 });
    };
    var $e = ({ mutationOptions: e2 } = {}) => {
      let { replace: t2 } = q$2(), { login: r2 } = React$3.useContext(H$2), { useLocation: o2 } = w$3(), { search: s } = o2(), { close: a, open: n2 } = te(), { to: m2 } = lib$4.parse(s, { ignoreQueryPrefix: true });
      return useMutation(["useLogin"], r2, { onSuccess: (u2) => {
        if (m2)
          return t2(m2);
        u2 !== false && t2(typeof u2 == "string" ? u2 : "/"), a == null || a("login-error");
      }, onError: (u2) => {
        n2 == null || n2({ message: (u2 == null ? void 0 : u2.name) || "Login Error", description: (u2 == null ? void 0 : u2.message) || "Invalid credentials", key: "login-error", type: "error" });
      }, ...e2 });
    };
    var xt = ({ mutationOptions: e2 } = {}) => {
      let { replace: t2 } = q$2(), { register: r2 } = React$3.useContext(H$2), { close: o2, open: s } = te();
      return useMutation(["useRegister"], r2, { onSuccess: (n2) => {
        n2 !== false && t2(n2 || "/"), o2 == null || o2("register-error");
      }, onError: (n2) => {
        s == null || s({ message: (n2 == null ? void 0 : n2.name) || "Register Error", description: (n2 == null ? void 0 : n2.message) || "Error while registering", key: "register-error", type: "error" });
      }, ...e2 });
    };
    var Rt = ({ mutationOptions: e2 } = {}) => {
      let { replace: t2 } = q$2(), { forgotPassword: r2 } = React$3.useContext(H$2), { close: o2, open: s } = te();
      return useMutation(["useForgotPassword"], r2, { onSuccess: (n2) => {
        n2 !== false && n2 && t2(n2), o2 == null || o2("forgot-password-error");
      }, onError: (n2) => {
        s == null || s({ message: (n2 == null ? void 0 : n2.name) || "Forgot Password Error", description: (n2 == null ? void 0 : n2.message) || "Error while resetting password", key: "forgot-password-error", type: "error" });
      }, ...e2 });
    };
    var Pt = ({ mutationOptions: e2 } = {}) => {
      let { replace: t2 } = q$2(), { updatePassword: r2 } = React$3.useContext(H$2), { close: o2, open: s } = te(), { useLocation: a } = w$3(), { search: n2 } = a(), m2 = lib$4.parse(n2, { ignoreQueryPrefix: true });
      return useMutation(["useUpdatePassword"], async (u2) => r2 == null ? void 0 : r2({ ...m2, ...u2 }), { onSuccess: (u2) => {
        u2 !== false && u2 && t2(u2), o2 == null || o2("update-password-error");
      }, onError: (u2) => {
        s == null || s({ message: (u2 == null ? void 0 : u2.name) || "Update Password Error", description: (u2 == null ? void 0 : u2.message) || "Error while updating password", key: "update-password-error", type: "error" });
      }, ...e2 });
    };
    var bt = (e2) => {
      let { checkAuth: t2 } = reactExports.useContext(H$2);
      return useQuery(["useAuthenticated", e2], async () => {
        var o2;
        return (o2 = await (t2 == null ? void 0 : t2(e2))) != null ? o2 : {};
      }, { retry: false });
    };
    var W$1 = () => {
      let { checkError: e2 } = React$3.useContext(H$2), { mutate: t2 } = Ct();
      return useMutation(["useCheckError"], e2, { onError: (o2) => {
        t2({ redirectPath: o2 });
      } });
    };
    var vo = () => {
      let { isProvided: e2 } = reactExports.useContext(H$2);
      return e2 || false;
    };
    var Oe = (e2) => e2 / 1e3;
    var st = (e2) => {
      let { current: t2, pageSize: r2, sorter: o2, filters: s } = lib$4.parse(e2.substring(1));
      return { parsedCurrent: t2 && Number(t2), parsedPageSize: r2 && Number(r2), parsedSorter: o2 != null ? o2 : [], parsedFilters: s != null ? s : [] };
    }, at = (e2) => {
      let t2 = { skipNulls: true, arrayFormat: "indices", encode: false }, { pagination: r2, sorter: o2, filters: s, ...a } = e2;
      return lib$4.stringify({ ...a, ...r2 || {}, sorter: o2, filters: s }, t2);
    }, er = (e2, t2) => e2.operator !== "and" && e2.operator !== "or" && t2.operator !== "and" && t2.operator !== "or" ? ("field" in e2 ? e2.field : void 0) == ("field" in t2 ? t2.field : void 0) && e2.operator == t2.operator : ("key" in e2 ? e2.key : void 0) == ("key" in t2 ? t2.key : void 0) && e2.operator == t2.operator, tr$1 = (e2, t2) => e2.field == t2.field, we = (e2, t2, r2 = []) => (t2.filter((s) => (s.operator === "or" || s.operator === "and") && !s.key).length > 1 && warnOnce_1(true, `[conditionalFilters]: You have created multiple Conditional Filters at the top level, this requires the key parameter. 
For more information, see https://refine.dev/docs/advanced-tutorials/data-provider/handling-filters/#top-level-multiple-conditional-filters-usage`), unionWith_1(e2, t2, r2, er).filter((s) => s.value !== void 0 && s.value !== null && (s.operator !== "or" || s.operator === "or" && s.value.length !== 0) && (s.operator !== "and" || s.operator === "and" && s.value.length !== 0))), nt = (e2, t2) => unionWith_1(e2, t2, tr$1).filter((r2) => r2.order !== void 0 && r2.order !== null), it$1 = (e2, t2) => [...differenceWith_1(t2, e2, er), ...e2], ut = (e2, t2) => [...differenceWith_1(t2, e2, tr$1), ...e2], So = (e2, t2) => {
      if (!t2)
        return;
      let r2 = t2.find((o2) => o2.field === e2);
      if (r2)
        return r2.order;
    };
    var Qe = (e2 = "", t2) => {
      let r2 = Pe$1(e2);
      return t2 === "singular" ? Xo$1.singular(r2) : Xo$1.plural(r2);
    };
    var or$1 = (e2 = {}) => e2 != null && e2.id ? { ...e2, id: decodeURIComponent(e2.id) } : e2;
    var F$1 = (e2, t2, r2) => {
      let o2 = t2 || "default", s = { all: [o2], resourceAll: [o2, e2 || ""], list: (a) => [...s.resourceAll, "list", { ...a, ...r2 }], many: (a) => [...s.resourceAll, "getMany", a && a.map(String), { ...r2 }].filter((n2) => n2 !== void 0), detail: (a) => [...s.resourceAll, "detail", a == null ? void 0 : a.toString(), { ...r2 }], logList: (a) => ["logList", e2, a, r2].filter((n2) => n2 !== void 0) };
      return s;
    };
    var vt$1 = (e2, t2) => !e2 || !t2 ? false : !!e2.find((r2) => r2 === t2);
    var wo = (e2) => (t2) => e2.parentName ? t2.name === e2.parentName : false, We = (e2, t2) => {
      var s, a, n2, m2, C2;
      let r2, o2 = (a = (s = e2.options) == null ? void 0 : s.route) != null ? a : e2.name;
      if (e2.parentName) {
        let u2 = t2.find(wo(e2));
        u2 != null && u2.parentName ? r2 = `${We(u2, t2)}/${o2}` : e2.parentName && (r2 = `${(C2 = (m2 = (n2 = u2 == null ? void 0 : u2.options) == null ? void 0 : n2.route) != null ? m2 : u2 == null ? void 0 : u2.name) != null ? C2 : e2.parentName}/${o2}`);
      } else
        r2 = o2;
      return r2;
    };
    var ct = (e2) => {
      var n2, m2, C2;
      let t2 = [], r2 = {}, o2 = {}, s, a;
      for (let u2 = 0; u2 < e2.length; u2++) {
        s = e2[u2];
        let l2 = (C2 = (m2 = s.route) != null ? m2 : (n2 = s.options) == null ? void 0 : n2.route) != null ? C2 : "";
        r2[l2] = s, r2[l2].children = [], o2[s.name] = s, o2[s.name].children = [];
      }
      for (let u2 in r2)
        r2.hasOwnProperty(u2) && (a = r2[u2], a.parentName && o2[a.parentName] ? o2[a.parentName].children.push(a) : t2.push(a));
      return t2;
    };
    var Pe$1 = (e2) => (e2 = e2.replace(/([a-z]{1})([A-Z]{1})/g, "$1-$2"), e2 = e2.replace(/([A-Z]{1})([A-Z]{1})([a-z]{1})/g, "$1-$2$3"), e2 = e2.toLowerCase().replace(/[_-]+/g, " ").replace(/\s{2,}/g, " ").trim(), e2 = e2.charAt(0).toUpperCase() + e2.slice(1), e2);
    var ht = ({ children: e2 }) => React$3.createElement("div", null, e2);
    var ge = { mutationMode: "pessimistic", syncWithLocation: false, undoableTimeout: 5e3, warnWhenUnsavedChanges: false, liveMode: "off", redirect: { afterCreate: "list", afterClone: "list", afterEdit: "list" } }, ee$1 = React$3.createContext({ hasDashboard: false, mutationMode: "pessimistic", warnWhenUnsavedChanges: false, syncWithLocation: false, undoableTimeout: 5e3, Title: void 0, Sider: void 0, Header: void 0, Footer: void 0, Layout: ht, OffLayoutArea: void 0, liveMode: "off", onLiveEvent: void 0, options: ge }), ar = ({ hasDashboard: e2, mutationMode: t2, warnWhenUnsavedChanges: r2, syncWithLocation: o2, undoableTimeout: s, children: a, DashboardPage: n2, Title: m2, Layout: C2 = ht, Header: u2, Sider: l2, Footer: y2, OffLayoutArea: R2, LoginPage: f2 = Et, catchAll: d2, liveMode: p2 = "off", onLiveEvent: c2, options: i2 }) => React$3.createElement(ee$1.Provider, { value: { hasDashboard: e2, mutationMode: t2, warnWhenUnsavedChanges: r2, syncWithLocation: o2, Title: m2, undoableTimeout: s, Layout: C2, Header: u2, Sider: l2, Footer: y2, OffLayoutArea: R2, DashboardPage: n2, LoginPage: f2, catchAll: d2, liveMode: p2, onLiveEvent: c2, options: i2 } }, a);
    var Mt = ({ options: e2, disableTelemetry: t2, liveMode: r2, mutationMode: o2, reactQueryClientConfig: s, reactQueryDevtoolConfig: a, syncWithLocation: n2, undoableTimeout: m2, warnWhenUnsavedChanges: C2 } = {}) => {
      var R2, f2, d2, p2, c2, i2, g2, T2, x2, P2, b2, v2, D2, h2, S2, V2, Q2, L2, U2, A2, I2, Z2, oe2, ce2;
      let u2 = { breadcrumb: e2 == null ? void 0 : e2.breadcrumb, mutationMode: (f2 = (R2 = e2 == null ? void 0 : e2.mutationMode) != null ? R2 : o2) != null ? f2 : ge.mutationMode, undoableTimeout: (p2 = (d2 = e2 == null ? void 0 : e2.undoableTimeout) != null ? d2 : m2) != null ? p2 : ge.undoableTimeout, syncWithLocation: (i2 = (c2 = e2 == null ? void 0 : e2.syncWithLocation) != null ? c2 : n2) != null ? i2 : ge.syncWithLocation, warnWhenUnsavedChanges: (T2 = (g2 = e2 == null ? void 0 : e2.warnWhenUnsavedChanges) != null ? g2 : C2) != null ? T2 : ge.warnWhenUnsavedChanges, liveMode: (P2 = (x2 = e2 == null ? void 0 : e2.liveMode) != null ? x2 : r2) != null ? P2 : ge.liveMode, redirect: { afterCreate: (v2 = (b2 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : b2.afterCreate) != null ? v2 : ge.redirect.afterCreate, afterClone: (h2 = (D2 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : D2.afterClone) != null ? h2 : ge.redirect.afterClone, afterEdit: (V2 = (S2 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : S2.afterEdit) != null ? V2 : ge.redirect.afterEdit } }, l2 = (L2 = (Q2 = e2 == null ? void 0 : e2.disableTelemetry) != null ? Q2 : t2) != null ? L2 : false, y2 = { clientConfig: (I2 = (A2 = (U2 = e2 == null ? void 0 : e2.reactQuery) == null ? void 0 : U2.clientConfig) != null ? A2 : s) != null ? I2 : {}, devtoolConfig: (ce2 = (oe2 = (Z2 = e2 == null ? void 0 : e2.reactQuery) == null ? void 0 : Z2.devtoolConfig) != null ? oe2 : a) != null ? ce2 : {} };
      return { optionsWithDefaults: u2, disableTelemetryWithDefault: l2, reactQueryWithDefaults: y2 };
    };
    var Ut = ({ redirectFromProps: e2, action: t2, redirectOptions: r2 }) => {
      if (e2 || e2 === false)
        return e2;
      switch (t2) {
        case "clone":
          return r2.afterClone;
        case "create":
          return r2.afterCreate;
        case "edit":
          return r2.afterEdit;
      }
    };
    var E$2 = (e2, t2, r2) => {
      var s;
      if (t2)
        return t2;
      let o2 = r2 == null ? void 0 : r2.find((a) => a.name === e2);
      return (s = o2 == null ? void 0 : o2.options) != null && s.dataProviderName ? o2.options.dataProviderName : "default";
    };
    var xe = async (e2) => ({ data: (await Promise.all(e2)).map((t2) => t2.data) });
    var Ke = ({ resource: e2, config: t2, queryOptions: r2, successNotification: o2, errorNotification: s, metaData: a, liveMode: n2, onLiveEvent: m2, liveParams: C2, dataProviderName: u2 }) => {
      let { resources: l2 } = B$1(), y2 = k$3(), R2 = F$1(e2, E$2(e2, u2, l2), a), { getList: f2 } = y2(E$2(e2, u2, l2)), d2 = M(), { mutate: p2 } = W$1(), c2 = $$1(), i2 = (r2 == null ? void 0 : r2.enabled) === void 0 || (r2 == null ? void 0 : r2.enabled) === true;
      return be$1({ resource: e2, types: ["*"], params: { metaData: a, pagination: t2 == null ? void 0 : t2.pagination, hasPagination: t2 == null ? void 0 : t2.hasPagination, sort: t2 == null ? void 0 : t2.sort, filters: t2 == null ? void 0 : t2.filters, subscriptionType: "useList", ...C2 }, channel: `resources/${e2}`, enabled: i2, liveMode: n2, onLiveEvent: m2 }), useQuery(R2.list(t2), ({ queryKey: T2, pageParam: x2, signal: P2 }) => {
        let { hasPagination: b2, ...v2 } = t2 || {};
        return f2({ resource: e2, ...v2, hasPagination: b2, metaData: { ...a, queryContext: { queryKey: T2, pageParam: x2, signal: P2 } } });
      }, { ...r2, onSuccess: (T2) => {
        var P2;
        (P2 = r2 == null ? void 0 : r2.onSuccess) == null || P2.call(r2, T2);
        let x2 = typeof o2 == "function" ? o2(T2, { metaData: a, config: t2 }, e2) : o2;
        c2(x2);
      }, onError: (T2) => {
        var P2;
        p2(T2), (P2 = r2 == null ? void 0 : r2.onError) == null || P2.call(r2, T2);
        let x2 = typeof s == "function" ? s(T2, { metaData: a, config: t2 }, e2) : s;
        c2(x2, { key: `${e2}-useList-notification`, message: d2("notifications.error", { statusCode: T2.statusCode }, `Error (status code: ${T2.statusCode})`), description: T2.message, type: "error" });
      } });
    };
    var Ge = ({ resource: e2, id: t2, queryOptions: r2, successNotification: o2, errorNotification: s, metaData: a, liveMode: n2, onLiveEvent: m2, liveParams: C2, dataProviderName: u2 }) => {
      let { resources: l2 } = B$1(), y2 = k$3(), R2 = F$1(e2, E$2(e2, u2, l2), a), { getOne: f2 } = y2(E$2(e2, u2, l2)), d2 = M(), { mutate: p2 } = W$1(), c2 = $$1();
      return be$1({ resource: e2, types: ["*"], channel: `resources/${e2}`, params: { ids: t2 ? [t2] : [], id: t2, metaData: a, subscriptionType: "useOne", ...C2 }, enabled: r2 == null ? void 0 : r2.enabled, liveMode: n2, onLiveEvent: m2 }), useQuery(R2.detail(t2), ({ queryKey: g2, pageParam: T2, signal: x2 }) => f2({ resource: e2, id: t2, metaData: { ...a, queryContext: { queryKey: g2, pageParam: T2, signal: x2 } } }), { ...r2, onSuccess: (g2) => {
        var x2;
        (x2 = r2 == null ? void 0 : r2.onSuccess) == null || x2.call(r2, g2);
        let T2 = typeof o2 == "function" ? o2(g2, { id: t2, metaData: a }, e2) : o2;
        c2(T2);
      }, onError: (g2) => {
        var x2;
        p2(g2), (x2 = r2 == null ? void 0 : r2.onError) == null || x2.call(r2, g2);
        let T2 = typeof s == "function" ? s(g2, { id: t2, metaData: a }, e2) : s;
        c2(T2, { key: `${t2}-${e2}-getOne-notification`, message: d2("notifications.error", { statusCode: g2.statusCode }, `Error (status code: ${g2.statusCode})`), description: g2.message, type: "error" });
      } });
    };
    var St = ({ resource: e2, ids: t2, queryOptions: r2, successNotification: o2, errorNotification: s, metaData: a, liveMode: n2, onLiveEvent: m2, liveParams: C2, dataProviderName: u2 }) => {
      let { resources: l2 } = B$1(), y2 = k$3(), R2 = F$1(e2, E$2(e2, u2, l2), a), { getMany: f2, getOne: d2 } = y2(E$2(e2, u2, l2)), p2 = M(), { mutate: c2 } = W$1(), i2 = $$1(), g2 = (r2 == null ? void 0 : r2.enabled) === void 0 || (r2 == null ? void 0 : r2.enabled) === true;
      return be$1({ resource: e2, types: ["*"], params: { ids: t2 != null ? t2 : [], metaData: a, subscriptionType: "useMany", ...C2 }, channel: `resources/${e2}`, enabled: g2, liveMode: n2, onLiveEvent: m2 }), useQuery(R2.many(t2), ({ queryKey: x2, pageParam: P2, signal: b2 }) => f2 ? f2({ resource: e2, ids: t2, metaData: { ...a, queryContext: { queryKey: x2, pageParam: P2, signal: b2 } } }) : xe(t2.map((v2) => d2({ resource: e2, id: v2, metaData: { ...a, queryContext: { queryKey: x2, pageParam: P2, signal: b2 } } }))), { ...r2, onSuccess: (x2) => {
        var b2;
        (b2 = r2 == null ? void 0 : r2.onSuccess) == null || b2.call(r2, x2);
        let P2 = typeof o2 == "function" ? o2(x2, t2, e2) : o2;
        i2(P2);
      }, onError: (x2) => {
        var b2;
        c2(x2), (b2 = r2 == null ? void 0 : r2.onError) == null || b2.call(r2, x2);
        let P2 = typeof s == "function" ? s(x2, t2, e2) : s;
        i2(P2, { key: `${t2[0]}-${e2}-getMany-notification`, message: p2("notifications.error", { statusCode: x2.statusCode }, `Error (status code: ${x2.statusCode})`), description: x2.message, type: "error" });
      } });
    };
    var mt = React$3.createContext({ notifications: [], notificationDispatch: () => false }), ko = [], Ho = (e2, t2) => {
      switch (t2.type) {
        case "ADD":
          return [...e2.filter((o2) => !(isEqual$3(o2.id, t2.payload.id) && o2.resource == t2.payload.resource)), { ...t2.payload, isRunning: true }];
        case "REMOVE":
          return e2.filter((o2) => !(isEqual$3(o2.id, t2.payload.id) && o2.resource == t2.payload.resource));
        case "DECREASE_NOTIFICATION_SECOND":
          return e2.map((o2) => isEqual$3(o2.id, t2.payload.id) && o2.resource == t2.payload.resource ? { ...o2, seconds: t2.payload.seconds - 1e3 } : o2);
        default:
          return e2;
      }
    }, wt = ({ children: e2 }) => {
      let [t2, r2] = reactExports.useReducer(Ho, ko), o2 = { notifications: t2, notificationDispatch: r2 };
      return React$3.createElement(mt.Provider, { value: o2 }, e2, typeof window < "u" && t2.map((s) => React$3.createElement(nr, { key: `${s.id}-${s.resource}-queue`, notification: s })));
    };
    var Qt = ({ mutationOptions: e2 } = {}) => {
      let { resources: t2 } = B$1(), r2 = useQueryClient(), o2 = k$3(), { mutationMode: s, undoableTimeout: a } = le$1(), n2 = M(), { mutate: m2 } = W$1(), C2 = ne$1(), { log: u2 } = Ve(), { notificationDispatch: l2 } = Ce(), y2 = $$1(), R2 = ie$1();
      return useMutation(({ id: d2, values: p2, resource: c2, mutationMode: i2, undoableTimeout: g2, onCancel: T2, metaData: x2, dataProviderName: P2 }) => {
        let b2 = i2 != null ? i2 : s, v2 = g2 != null ? g2 : a;
        return b2 !== "undoable" ? o2(E$2(c2, P2, t2)).update({ resource: c2, id: d2, variables: p2, metaData: x2 }) : new Promise((h2, S2) => {
          let V2 = () => {
            o2(E$2(c2, P2, t2)).update({ resource: c2, id: d2, variables: p2, metaData: x2 }).then((L2) => h2(L2)).catch((L2) => S2(L2));
          }, Q2 = () => {
            S2({ message: "mutationCancelled" });
          };
          T2 && T2(Q2), l2({ type: "ADD", payload: { id: d2, resource: c2, cancelMutation: Q2, doMutation: V2, seconds: v2, isSilent: !!T2 } });
        });
      }, { onMutate: async ({ resource: d2, id: p2, mutationMode: c2, values: i2, dataProviderName: g2 }) => {
        let T2 = F$1(d2, E$2(d2, g2, t2)), x2 = r2.getQueriesData(T2.resourceAll), P2 = c2 != null ? c2 : s;
        return await r2.cancelQueries(T2.resourceAll, void 0, { silent: true }), P2 !== "pessimistic" && (r2.setQueriesData(T2.list(), (b2) => {
          if (!b2)
            return null;
          let v2 = b2.data.map((D2) => {
            var h2;
            return ((h2 = D2.id) == null ? void 0 : h2.toString()) === (p2 == null ? void 0 : p2.toString()) ? { id: p2, ...D2, ...i2 } : D2;
          });
          return { ...b2, data: v2 };
        }), r2.setQueriesData(T2.many(), (b2) => {
          if (!b2)
            return null;
          let v2 = b2.data.map((D2) => {
            var h2;
            return ((h2 = D2.id) == null ? void 0 : h2.toString()) === (p2 == null ? void 0 : p2.toString()) && (D2 = { id: p2, ...D2, ...i2 }), D2;
          });
          return { ...b2, data: v2 };
        }), r2.setQueriesData(T2.detail(p2), (b2) => b2 ? { ...b2, data: { ...b2.data, ...i2 } } : null)), { previousQueries: x2, queryKey: T2 };
      }, onSettled: (d2, p2, { id: c2, resource: i2, dataProviderName: g2, invalidates: T2 = ["list", "many", "detail"] }) => {
        R2({ resource: i2, dataProviderName: E$2(i2, g2, t2), invalidates: T2, id: c2 }), l2({ type: "REMOVE", payload: { id: c2, resource: i2 } });
      }, onSuccess: (d2, { id: p2, resource: c2, successNotification: i2, dataProviderName: g2, values: T2, metaData: x2 }, P2) => {
        var L2;
        let b2 = Xo$1.singular(c2), v2 = typeof i2 == "function" ? i2(d2, { id: p2, values: T2 }, c2) : i2;
        y2(v2, { key: `${p2}-${c2}-notification`, description: n2("notifications.success", "Successful"), message: n2("notifications.editSuccess", { resource: n2(`${c2}.${c2}`, b2) }, `Successfully updated ${b2}`), type: "success" }), C2 == null || C2({ channel: `resources/${c2}`, type: "updated", payload: { ids: (L2 = d2.data) != null && L2.id ? [d2.data.id] : void 0 }, date: new Date() });
        let D2;
        if (P2) {
          let U2 = r2.getQueryData(P2.queryKey.detail(p2));
          D2 = Object.keys(T2).reduce((A2, I2) => {
            var Z2;
            return A2[I2] = (Z2 = U2 == null ? void 0 : U2.data) == null ? void 0 : Z2[I2], A2;
          }, {});
        }
        let { fields: h2, operation: S2, variables: V2, ...Q2 } = x2 || {};
        u2 == null || u2.mutate({ action: "update", resource: c2, data: T2, previousData: D2, meta: { id: p2, dataProviderName: E$2(c2, g2, t2), ...Q2 } });
      }, onError: (d2, { id: p2, resource: c2, errorNotification: i2, values: g2 }, T2) => {
        if (T2)
          for (let x2 of T2.previousQueries)
            r2.setQueryData(x2[0], x2[1]);
        if (d2.message !== "mutationCancelled") {
          m2 == null || m2(d2);
          let x2 = Xo$1.singular(c2), P2 = typeof i2 == "function" ? i2(d2, { id: p2, values: g2 }, c2) : i2;
          y2(P2, { key: `${p2}-${c2}-notification`, message: n2("notifications.editError", { resource: n2(`${c2}.${c2}`, x2), statusCode: d2.statusCode }, `Error when updating ${x2} (status code: ${d2.statusCode})`), description: d2.message, type: "error" });
        }
      }, ...e2 });
    };
    var ze$1 = ({ mutationOptions: e2 } = {}) => {
      let { mutate: t2 } = W$1(), r2 = k$3(), o2 = ie$1(), { resources: s } = B$1(), a = M(), n2 = ne$1(), { log: m2 } = Ve(), C2 = $$1();
      return useMutation(({ resource: l2, values: y2, metaData: R2, dataProviderName: f2 }) => r2(E$2(l2, f2, s)).create({ resource: l2, variables: y2, metaData: R2 }), { onSuccess: (l2, { resource: y2, successNotification: R2, dataProviderName: f2, invalidates: d2 = ["list", "many"], values: p2, metaData: c2 }) => {
        var v2, D2, h2;
        let i2 = Xo$1.singular(y2), g2 = typeof R2 == "function" ? R2(l2, p2, y2) : R2;
        C2(g2, { key: `create-${y2}-notification`, message: a("notifications.createSuccess", { resource: a(`${y2}.${y2}`, i2) }, `Successfully created ${i2}`), description: a("notifications.success", "Success"), type: "success" }), o2({ resource: y2, dataProviderName: E$2(y2, f2, s), invalidates: d2 }), n2 == null || n2({ channel: `resources/${y2}`, type: "created", payload: { ids: (v2 = l2 == null ? void 0 : l2.data) != null && v2.id ? [l2.data.id] : void 0 }, date: new Date() });
        let { fields: T2, operation: x2, variables: P2, ...b2 } = c2 || {};
        m2 == null || m2.mutate({ action: "create", resource: y2, data: p2, meta: { dataProviderName: E$2(y2, f2, s), id: (h2 = (D2 = l2 == null ? void 0 : l2.data) == null ? void 0 : D2.id) != null ? h2 : void 0, ...b2 } });
      }, onError: (l2, { resource: y2, errorNotification: R2, values: f2 }) => {
        t2(l2);
        let d2 = Xo$1.singular(y2), p2 = typeof R2 == "function" ? R2(l2, f2, y2) : R2;
        C2(p2, { key: `create-${y2}-notification`, description: l2.message, message: a("notifications.createError", { resource: a(`${y2}.${y2}`, d2), statusCode: l2.statusCode }, `There was an error creating ${d2} (status code: ${l2.statusCode})`), type: "error" });
      }, ...e2 });
    };
    var Go = ({ mutationOptions: e2 } = {}) => {
      let { mutate: t2 } = W$1(), r2 = k$3(), { resources: o2 } = B$1(), s = useQueryClient(), { mutationMode: a, undoableTimeout: n2 } = le$1(), { notificationDispatch: m2 } = Ce(), C2 = M(), u2 = ne$1(), { log: l2 } = Ve(), y2 = $$1(), R2 = ie$1();
      return useMutation(({ id: d2, mutationMode: p2, undoableTimeout: c2, resource: i2, onCancel: g2, metaData: T2, dataProviderName: x2, values: P2 }) => {
        let b2 = p2 != null ? p2 : a, v2 = c2 != null ? c2 : n2;
        return b2 !== "undoable" ? r2(E$2(i2, x2, o2)).deleteOne({ resource: i2, id: d2, metaData: T2, variables: P2 }) : new Promise((h2, S2) => {
          let V2 = () => {
            r2(E$2(i2, x2, o2)).deleteOne({ resource: i2, id: d2, metaData: T2, variables: P2 }).then((L2) => h2(L2)).catch((L2) => S2(L2));
          }, Q2 = () => {
            S2({ message: "mutationCancelled" });
          };
          g2 && g2(Q2), m2({ type: "ADD", payload: { id: d2, resource: i2, cancelMutation: Q2, doMutation: V2, seconds: v2, isSilent: !!g2 } });
        });
      }, { onMutate: async ({ id: d2, resource: p2, mutationMode: c2, dataProviderName: i2 }) => {
        let g2 = F$1(p2, E$2(p2, i2, o2)), T2 = c2 != null ? c2 : a;
        await s.cancelQueries(g2.resourceAll, void 0, { silent: true });
        let x2 = s.getQueriesData(g2.resourceAll);
        return T2 !== "pessimistic" && (s.setQueriesData(g2.list(), (P2) => P2 ? { data: P2.data.filter((v2) => {
          var D2;
          return ((D2 = v2.id) == null ? void 0 : D2.toString()) !== d2.toString();
        }), total: P2.total - 1 } : null), s.setQueriesData(g2.many(), (P2) => {
          if (!P2)
            return null;
          let b2 = P2.data.filter((v2) => {
            var D2;
            return ((D2 = v2.id) == null ? void 0 : D2.toString()) !== (d2 == null ? void 0 : d2.toString());
          });
          return { ...P2, data: b2 };
        })), { previousQueries: x2, queryKey: g2 };
      }, onSettled: (d2, p2, { id: c2, resource: i2, dataProviderName: g2, invalidates: T2 = ["list", "many"] }) => {
        R2({ resource: i2, dataProviderName: E$2(i2, g2, o2), invalidates: T2 }), m2({ type: "REMOVE", payload: { id: c2, resource: i2 } });
      }, onSuccess: (d2, { id: p2, resource: c2, successNotification: i2, dataProviderName: g2, metaData: T2 }, x2) => {
        let P2 = Xo$1.singular(c2 != null ? c2 : "");
        s.removeQueries(x2 == null ? void 0 : x2.queryKey.detail(p2));
        let b2 = typeof i2 == "function" ? i2(d2, p2, c2) : i2;
        y2(b2, { key: `${p2}-${c2}-notification`, description: C2("notifications.success", "Success"), message: C2("notifications.deleteSuccess", { resource: C2(`${c2}.${c2}`, P2) }, `Successfully deleted a ${P2}`), type: "success" }), u2 == null || u2({ channel: `resources/${c2}`, type: "deleted", payload: { ids: p2 ? [p2] : [] }, date: new Date() });
        let { fields: v2, operation: D2, variables: h2, ...S2 } = T2 || {};
        l2 == null || l2.mutate({ action: "delete", resource: c2, meta: { id: p2, dataProviderName: E$2(c2, g2, o2), ...S2 } }), s.removeQueries(x2 == null ? void 0 : x2.queryKey.detail(p2));
      }, onError: (d2, { id: p2, resource: c2, errorNotification: i2 }, g2) => {
        if (g2)
          for (let T2 of g2.previousQueries)
            s.setQueryData(T2[0], T2[1]);
        if (d2.message !== "mutationCancelled") {
          t2(d2);
          let T2 = Xo$1.singular(c2 != null ? c2 : ""), x2 = typeof i2 == "function" ? i2(d2, p2, c2) : i2;
          y2(x2, { key: `${p2}-${c2}-notification`, message: C2("notifications.deleteError", { resource: T2, statusCode: d2.statusCode }, `Error (status code: ${d2.statusCode})`), description: d2.message, type: "error" });
        }
      }, ...e2 });
    };
    var es$1 = ({ mutationOptions: e2 } = {}) => {
      let { mutate: t2 } = W$1(), { mutationMode: r2, undoableTimeout: o2 } = le$1(), s = k$3(), { notificationDispatch: a } = Ce(), n2 = M(), m2 = ne$1(), C2 = $$1(), u2 = ie$1(), { resources: l2 } = B$1(), y2 = useQueryClient();
      return useMutation(({ resource: f2, ids: d2, mutationMode: p2, undoableTimeout: c2, onCancel: i2, metaData: g2, dataProviderName: T2, values: x2 }) => {
        let P2 = p2 != null ? p2 : r2, b2 = c2 != null ? c2 : o2, v2 = s(E$2(f2, T2, l2)), D2 = () => v2.deleteMany ? v2.deleteMany({ resource: f2, ids: d2, metaData: g2, variables: x2 }) : xe(d2.map((S2) => v2.deleteOne({ resource: f2, id: S2, metaData: g2, variables: x2 })));
        return P2 !== "undoable" ? D2() : new Promise((S2, V2) => {
          let Q2 = () => {
            D2().then((U2) => S2(U2)).catch((U2) => V2(U2));
          }, L2 = () => {
            V2({ message: "mutationCancelled" });
          };
          i2 && i2(L2), a({ type: "ADD", payload: { id: d2, resource: f2, cancelMutation: L2, doMutation: Q2, seconds: b2, isSilent: !!i2 } });
        });
      }, { onMutate: async ({ ids: f2, resource: d2, mutationMode: p2, dataProviderName: c2 }) => {
        let i2 = F$1(d2, E$2(d2, c2, l2)), g2 = p2 != null ? p2 : r2;
        await y2.cancelQueries(i2.resourceAll, void 0, { silent: true });
        let T2 = y2.getQueriesData(i2.resourceAll);
        if (g2 !== "pessimistic") {
          y2.setQueriesData(i2.list(), (x2) => x2 ? { data: x2.data.filter((b2) => b2.id && !f2.map(String).includes(b2.id.toString())), total: x2.total - 1 } : null), y2.setQueriesData(i2.many(), (x2) => {
            if (!x2)
              return null;
            let P2 = x2.data.filter((b2) => b2.id ? !f2.map(String).includes(b2.id.toString()) : false);
            return { ...x2, data: P2 };
          });
          for (let x2 of f2)
            y2.setQueriesData(i2.detail(x2), (P2) => !P2 || P2.data.id == x2 ? null : { ...P2 });
        }
        return { previousQueries: T2, queryKey: i2 };
      }, onSettled: (f2, d2, { resource: p2, ids: c2, dataProviderName: i2, invalidates: g2 = ["list", "many"] }) => {
        u2({ resource: p2, dataProviderName: E$2(p2, i2, l2), invalidates: g2 }), a({ type: "REMOVE", payload: { id: c2, resource: p2 } });
      }, onSuccess: (f2, { ids: d2, resource: p2, successNotification: c2 }, i2) => {
        d2.forEach((T2) => y2.removeQueries(i2 == null ? void 0 : i2.queryKey.detail(T2)));
        let g2 = typeof c2 == "function" ? c2(f2, d2, p2) : c2;
        C2(g2, { key: `${d2}-${p2}-notification`, description: n2("notifications.success", "Success"), message: n2("notifications.deleteSuccess", { resource: n2(`${p2}.${p2}`, p2) }, `Successfully deleted ${p2}`), type: "success" }), m2 == null || m2({ channel: `resources/${p2}`, type: "deleted", payload: { ids: d2 }, date: new Date() }), d2.forEach((T2) => y2.removeQueries(i2 == null ? void 0 : i2.queryKey.detail(T2)));
      }, onError: (f2, { ids: d2, resource: p2, errorNotification: c2 }, i2) => {
        if (i2)
          for (let g2 of i2.previousQueries)
            y2.setQueryData(g2[0], g2[1]);
        if (f2.message !== "mutationCancelled") {
          t2(f2);
          let g2 = Xo$1.singular(p2), T2 = typeof c2 == "function" ? c2(f2, d2, p2) : c2;
          C2(T2, { key: `${d2}-${p2}-notification`, message: n2("notifications.deleteError", { resource: g2, statusCode: f2.statusCode }, `Error (status code: ${f2.statusCode})`), description: f2.message, type: "error" });
        }
      }, ...e2 });
    };
    var ts = (e2) => {
      let t2 = k$3(), { getApiUrl: r2 } = t2(e2);
      return r2();
    };
    var as = ({ mutationOptions: e2 } = {}) => {
      let { mutate: t2 } = W$1(), r2 = $$1(), o2 = k$3(), s = M();
      return useMutation(({ url: n2, method: m2, values: C2, metaData: u2, dataProviderName: l2, config: y2 }) => {
        let { custom: R2 } = o2(l2);
        if (R2)
          return R2({ url: n2, method: m2, payload: C2, metaData: u2, headers: { ...y2 == null ? void 0 : y2.headers } });
        throw Error("Not implemented custom on data provider.");
      }, { onSuccess: (n2, { successNotification: m2, config: C2, metaData: u2 }) => {
        let l2 = typeof m2 == "function" ? m2(n2, { ...C2, ...u2 }) : m2;
        r2(l2);
      }, onError: (n2, { errorNotification: m2, method: C2, config: u2, metaData: l2 }) => {
        t2(n2);
        let y2 = typeof m2 == "function" ? m2(n2, { ...u2, ...l2 }) : m2;
        r2(y2, { key: `${C2}-notification`, message: s("notifications.error", { statusCode: n2.statusCode }, `Error (status code: ${n2.statusCode})`), description: n2.message, type: "error" });
      }, ...e2 });
    };
    var ns = () => ({ default: { create: () => Promise.resolve({ data: { id: 1 } }), createMany: () => Promise.resolve({ data: [] }), deleteOne: () => Promise.resolve({ data: { id: 1 } }), deleteMany: () => Promise.resolve({ data: [] }), getList: () => Promise.resolve({ data: [], total: 0 }), getMany: () => Promise.resolve({ data: [] }), getOne: () => Promise.resolve({ data: { id: 1 } }), update: () => Promise.resolve({ data: { id: 1 } }), updateMany: () => Promise.resolve({ data: [] }), custom: () => Promise.resolve({ data: {} }), getApiUrl: () => "" } }), _e = React$3.createContext(ns()), dr = ({ children: e2, ...t2 }) => {
      let r2;
      return !t2.getList || !t2.getOne ? r2 = t2 : r2 = { default: t2 }, React$3.createElement(_e.Provider, { value: r2 }, e2);
    };
    var k$3 = () => {
      let e2 = reactExports.useContext(_e);
      return reactExports.useCallback((r2) => {
        if (r2) {
          if (!e2[r2])
            throw new Error(`"${r2}" Data provider not found`);
          return e2[r2];
        }
        if (e2.default)
          return e2.default;
        throw new Error('There is no "default" data provider. Please pass dataProviderName.');
      }, [e2]);
    };
    var Re = React$3.createContext(void 0), fr = ({ liveProvider: e2, children: t2 }) => React$3.createElement(Re.Provider, { value: e2 }, t2);
    var be$1 = ({ resource: e2, params: t2, channel: r2, types: o2, enabled: s = true, liveMode: a, onLiveEvent: n2 }) => {
      let m2 = useQueryClient(), C2 = F$1(e2), u2 = reactExports.useContext(Re), { liveMode: l2, onLiveEvent: y2 } = reactExports.useContext(ee$1), R2 = a != null ? a : l2;
      reactExports.useEffect(() => {
        let f2;
        return R2 && R2 !== "off" && s && (f2 = u2 == null ? void 0 : u2.subscribe({ channel: r2, params: { resource: e2, ...t2 }, types: o2, callback: (d2) => {
          R2 === "auto" && m2.invalidateQueries(C2.resourceAll), n2 == null || n2(d2), y2 == null || y2(d2);
        } })), () => {
          f2 && (u2 == null || u2.unsubscribe(f2));
        };
      }, [s]);
    };
    var Tr = (e2) => {
      let { liveMode: t2 } = reactExports.useContext(ee$1);
      return e2 != null ? e2 : t2;
    };
    var ne$1 = () => {
      let e2 = reactExports.useContext(Re);
      return e2 == null ? void 0 : e2.publish;
    };
    var Ue$1 = React$3.createContext({ resources: [] }), Cr = ({ resources: e2, children: t2 }) => React$3.createElement(Ue$1.Provider, { value: { resources: e2 } }, t2);
    var B$1 = ({ resourceName: e2, resourceNameOrRouteName: t2, recordItemId: r2 } = {}) => {
      let { resources: o2 } = reactExports.useContext(Ue$1), s = J(), { useParams: a } = w$3(), n2 = a(), m2 = s(t2 != null ? t2 : n2.resource), C2 = e2 != null ? e2 : m2.name, u2 = r2 != null ? r2 : n2.id;
      return { resources: o2, resource: m2, resourceName: C2, id: u2, action: n2.action };
    };
    var J = () => {
      let { resources: e2 } = reactExports.useContext(Ue$1);
      return reactExports.useCallback((r2) => {
        let o2 = e2.find((s) => s.route === r2);
        if (!o2) {
          let s = e2.find((a) => a.name === r2);
          return s != null ? s : { name: r2, route: r2 };
        }
        return o2;
      }, [e2]);
    };
    var Ce = () => {
      let { notifications: e2, notificationDispatch: t2 } = reactExports.useContext(mt);
      return { notifications: e2, notificationDispatch: t2 };
    };
    var je$1 = reactExports.createContext({}), xr = ({ open: e2, close: t2, children: r2 }) => React$3.createElement(je$1.Provider, { value: { open: e2, close: t2 } }, r2);
    var te = () => {
      let { open: e2, close: t2 } = reactExports.useContext(je$1);
      return { open: e2, close: t2 };
    };
    var $$1 = () => {
      let { open: e2 } = te();
      return reactExports.useCallback((r2, o2) => {
        r2 !== false && (r2 ? e2 == null || e2(r2) : o2 && (e2 == null || e2(o2)));
      }, []);
    };
    var de$1 = React$3.createContext({}), Pr = ({ children: e2, i18nProvider: t2 }) => React$3.createElement(de$1.Provider, { value: { i18nProvider: t2 } }, e2);
    var M = () => {
      let { i18nProvider: e2 } = reactExports.useContext(de$1);
      return reactExports.useMemo(() => {
        function r2(o2, s, a) {
          var n2, m2;
          return (m2 = (n2 = e2 == null ? void 0 : e2.translate(o2, s, a)) != null ? n2 : a) != null ? m2 : typeof s == "string" && typeof a > "u" ? s : o2;
        }
        return r2;
      }, [e2]);
    };
    var le$1 = () => {
      let { mutationMode: e2, undoableTimeout: t2 } = reactExports.useContext(ee$1);
      return { mutationMode: e2, undoableTimeout: t2 };
    };
    var Vt$1 = React$3.createContext({}), Dr = ({ children: e2 }) => {
      let [t2, r2] = reactExports.useState(false);
      return React$3.createElement(Vt$1.Provider, { value: { warnWhen: t2, setWarnWhen: r2 } }, e2);
    };
    var qe$1 = () => {
      let { warnWhenUnsavedChanges: e2 } = reactExports.useContext(ee$1), { warnWhen: t2, setWarnWhen: r2 } = reactExports.useContext(Vt$1);
      return { warnWhenUnsavedChanges: e2, warnWhen: Boolean(t2), setWarnWhen: r2 != null ? r2 : () => {
      } };
    };
    var Bt = () => {
      let { syncWithLocation: e2 } = reactExports.useContext(ee$1);
      return { syncWithLocation: e2 };
    };
    var Ns = () => {
      let { Title: e2 } = reactExports.useContext(ee$1);
      return e2;
    };
    var Se = () => {
      let { Footer: e2, Header: t2, Layout: r2, OffLayoutArea: o2, Sider: s, Title: a, hasDashboard: n2, mutationMode: m2, syncWithLocation: C2, undoableTimeout: u2, warnWhenUnsavedChanges: l2, DashboardPage: y2, LoginPage: R2, catchAll: f2, options: d2 } = reactExports.useContext(ee$1);
      return { Footer: e2, Header: t2, Layout: r2, OffLayoutArea: o2, Sider: s, Title: a, hasDashboard: n2, mutationMode: m2, syncWithLocation: C2, undoableTimeout: u2, warnWhenUnsavedChanges: l2, DashboardPage: y2, LoginPage: R2, catchAll: f2, options: d2 };
    };
    var Td = ({ resource: e2, action: t2, id: r2, onMutationSuccess: o2, onMutationError: s, redirect: a, successNotification: n2, errorNotification: m2, metaData: C2, mutationMode: u2, liveMode: l2, onLiveEvent: y2, liveParams: R2, undoableTimeout: f2, dataProviderName: d2, invalidates: p2, queryOptions: c2, createMutationOptions: i2, updateMutationOptions: g2 } = {}) => {
      var rt;
      let { options: T2 } = Se(), { useParams: x2 } = w$3(), { resource: P2, action: b2, id: v2 } = x2(), D2 = !e2 || e2 === P2 ? r2 != null ? r2 : v2 : r2, [h2, S2] = React$3.useState(D2);
      React$3.useEffect(() => {
        D2 !== h2 && S2(r2);
      }, [r2]);
      let V2 = e2 != null ? e2 : P2, Q2 = (rt = t2 != null ? t2 : b2 === "show" ? "create" : b2) != null ? rt : "create", U2 = J()(V2), { mutationMode: A2 } = le$1(), I2 = u2 != null ? u2 : A2, Z2 = Q2 === "create", oe2 = Q2 === "edit", ce2 = Q2 === "clone", K2 = Ut({ redirectFromProps: a, action: Q2, redirectOptions: T2.redirect }), j = h2 !== void 0 && (oe2 || ce2), pe2 = Ge({ resource: U2.name, id: h2 != null ? h2 : "", queryOptions: { enabled: j, ...c2 }, liveMode: l2, onLiveEvent: y2, liveParams: R2, metaData: C2, dataProviderName: d2 }), { isFetching: O2 } = pe2, fe2 = ze$1({ mutationOptions: i2 }), { mutate: ve2, isLoading: Xe2 } = fe2, ye2 = Qt({ mutationOptions: g2 }), { mutate: et, isLoading: Tt } = ye2, { setWarnWhen: tt } = qe$1(), he2 = Er();
      return { ...Z2 || ce2 ? { formLoading: O2 || Xe2, mutationResult: fe2, onFinish: async (se2) => {
        tt(false);
        let N2 = (G2) => {
          he2({ redirect: K2, resource: U2, id: G2 });
        };
        return I2 !== "pessimistic" && setTimeout(() => {
          N2();
        }), new Promise((G2, Ee2) => (I2 !== "pessimistic" && G2(), ve2({ values: se2, resource: U2.name, successNotification: n2, errorNotification: m2, metaData: C2, dataProviderName: d2, invalidates: p2 }, { onSuccess: (ae2, Te2, Me2) => {
          var qt;
          o2 && o2(ae2, se2, Me2);
          let Fe2 = (qt = ae2 == null ? void 0 : ae2.data) == null ? void 0 : qt.id;
          N2(Fe2), G2(ae2);
        }, onError: (ae2, Te2, Me2) => {
          if (s)
            return s(ae2, se2, Me2);
          Ee2();
        } })));
      } } : { formLoading: O2 || Tt, mutationResult: ye2, onFinish: async (se2) => {
        tt(false);
        let N2 = { id: h2 != null ? h2 : "", values: se2, resource: U2.name, mutationMode: I2, undoableTimeout: f2, successNotification: n2, errorNotification: m2, metaData: C2, dataProviderName: d2, invalidates: p2 }, G2 = () => {
          S2(D2), he2({ redirect: K2, resource: U2, id: h2 });
        };
        return I2 !== "pessimistic" && setTimeout(() => {
          G2();
        }), new Promise((Ee2, ae2) => (I2 !== "pessimistic" && Ee2(), setTimeout(() => {
          et(N2, { onSuccess: (Te2, Me2, Fe2) => {
            o2 && o2(Te2, se2, Fe2), I2 === "pessimistic" && G2(), Ee2(Te2);
          }, onError: (Te2, Me2, Fe2) => {
            if (s)
              return s(Te2, se2, Fe2);
            ae2();
          } });
        })));
      } }, queryResult: pe2, id: h2, setId: S2, redirect: (se2, N2) => {
        he2({ redirect: se2 !== void 0 ? se2 : oe2 ? "list" : "edit", resource: U2, id: N2 != null ? N2 : h2 });
      } };
    };
    var Er = () => {
      let { show: e2, edit: t2, list: r2, create: o2 } = q$2();
      return reactExports.useCallback(({ redirect: a, resource: n2, id: m2 }) => {
        if (a && n2.route)
          return n2.canShow && a === "show" && m2 ? e2(n2.route, m2) : n2.canEdit && a === "edit" && m2 ? t2(n2.route, m2) : n2.canCreate && a === "create" ? o2(n2.route) : r2(n2.route, "push");
      }, []);
    };
    var q$2 = () => {
      let { useHistory: e2 } = w$3(), t2 = e2(), r2 = J(), o2 = (i2, g2 = "push") => {
        g2 === "push" ? t2.push(i2) : t2.replace(i2);
      }, s = (i2) => `/${r2(i2).route}/create`, a = (i2, g2) => {
        let T2 = r2(i2), x2 = encodeURIComponent(g2);
        return `/${T2.route}/edit/${x2}`;
      }, n2 = (i2, g2) => {
        let T2 = r2(i2), x2 = encodeURIComponent(g2);
        return `/${T2.route}/clone/${x2}`;
      }, m2 = (i2, g2) => {
        let T2 = r2(i2), x2 = encodeURIComponent(g2);
        return `/${T2.route}/show/${x2}`;
      }, C2 = (i2) => `/${r2(i2).route}`;
      return { create: (i2, g2 = "push") => {
        o2(s(i2), g2);
      }, createUrl: s, edit: (i2, g2, T2 = "push") => {
        o2(a(i2, g2), T2);
      }, editUrl: a, clone: (i2, g2, T2 = "push") => {
        o2(n2(i2, g2), T2);
      }, cloneUrl: n2, show: (i2, g2, T2 = "push") => {
        o2(m2(i2, g2), T2);
      }, showUrl: m2, list: (i2, g2 = "push") => {
        o2(C2(i2), g2);
      }, listUrl: C2, push: (i2, ...g2) => {
        t2.push(i2, ...g2);
      }, replace: (i2, ...g2) => {
        t2.replace(i2, ...g2);
      }, goBack: () => {
        t2.goBack();
      } };
    };
    var Md = ({ resource: e2, id: t2, successNotification: r2, errorNotification: o2, metaData: s, liveMode: a, onLiveEvent: n2, dataProviderName: m2, queryOptions: C2 } = {}) => {
      let { useParams: u2 } = w$3(), { resource: l2, id: y2 } = u2(), R2 = !e2 || e2 === l2 ? t2 != null ? t2 : y2 : t2, [f2, d2] = reactExports.useState(R2);
      React$3.useEffect(() => {
        R2 !== f2 && d2(R2);
      }, [R2]);
      let c2 = J()(e2 != null ? e2 : l2);
      return { queryResult: Ge({ resource: c2.name, id: f2 != null ? f2 : "", queryOptions: { enabled: f2 !== void 0, ...C2 }, successNotification: r2, errorNotification: o2, metaData: s, liveMode: a, onLiveEvent: n2, dataProviderName: m2 }), showId: f2, setShowId: d2 };
    };
    var js = { useHistory: () => false, useLocation: () => false, useParams: () => ({}), Prompt: () => null, Link: () => null }, Ye = React$3.createContext(js), Sr = ({ children: e2, useHistory: t2, useLocation: r2, useParams: o2, Prompt: s, Link: a, routes: n2 }) => React$3.createElement(Ye.Provider, { value: { useHistory: t2, useLocation: r2, useParams: o2, Prompt: s, Link: a, routes: n2 } }, e2);
    var w$3 = () => {
      let { useHistory: e2, useLocation: t2, useParams: r2, Prompt: o2, Link: s, routes: a } = reactExports.useContext(Ye);
      return { useHistory: e2, useLocation: t2, useParams: r2, Prompt: o2, Link: s, routes: a };
    };
    var Ie$1 = React$3.createContext({}), Lr = ({ can: e2, children: t2 }) => React$3.createElement(Ie$1.Provider, { value: { can: e2 } }, t2);
    var wr = ({ action: e2, resource: t2, params: r2, queryOptions: o2 }) => {
      let { can: s } = reactExports.useContext(Ie$1), { resource: a, ...n2 } = r2 != null ? r2 : {}, { icon: m2, list: C2, edit: u2, create: l2, show: y2, children: R2, ...f2 } = a != null ? a : {}, d2 = useQuery(["useCan", { action: e2, resource: t2, params: { ...n2, resource: f2 }, enabled: o2 == null ? void 0 : o2.enabled }], () => {
        var p2;
        return (p2 = s == null ? void 0 : s({ action: e2, resource: t2, params: r2 })) != null ? p2 : Promise.resolve({ can: true });
      }, { enabled: typeof s < "u", ...o2, retry: false });
      return typeof s > "u" ? { data: { can: true } } : d2;
    };
    var gm = (e2) => {
      var oe2, ce2;
      let [t2, r2] = reactExports.useState([]), [o2, s] = reactExports.useState([]), [a, n2] = reactExports.useState([]), { resource: m2, sort: C2, filters: u2 = [], optionLabel: l2 = "title", optionValue: y2 = "id", debounce: R2 = 300, successNotification: f2, errorNotification: d2, defaultValueQueryOptions: p2, queryOptions: c2, fetchSize: i2, pagination: g2, hasPagination: T2, liveMode: x2, defaultValue: P2 = [], onLiveEvent: b2, onSearch: v2, liveParams: D2, metaData: h2, dataProviderName: S2 } = e2, V2 = Array.isArray(P2) ? P2 : [P2], Q2 = reactExports.useCallback((K2) => {
        n2(K2.data.map((j) => ({ label: get_1(j, l2), value: get_1(j, y2) })));
      }, [l2, y2]), L2 = p2 != null ? p2 : c2, U2 = St({ resource: m2, ids: V2, queryOptions: { ...L2, enabled: V2.length > 0 && ((oe2 = p2 == null ? void 0 : p2.enabled) != null ? oe2 : true), onSuccess: (K2) => {
        var j;
        Q2(K2), (j = L2 == null ? void 0 : L2.onSuccess) == null || j.call(L2, K2);
      } }, metaData: h2, liveMode: "off", dataProviderName: S2 }), A2 = reactExports.useCallback((K2) => {
        s(K2.data.map((j) => ({ label: get_1(j, l2), value: get_1(j, y2) })));
      }, [l2, y2]), I2 = Ke({ resource: m2, config: { sort: C2, filters: u2.concat(t2), pagination: { current: g2 == null ? void 0 : g2.current, pageSize: (ce2 = g2 == null ? void 0 : g2.pageSize) != null ? ce2 : i2 }, hasPagination: T2 }, queryOptions: { ...c2, onSuccess: (K2) => {
        var j;
        A2(K2), (j = c2 == null ? void 0 : c2.onSuccess) == null || j.call(c2, K2);
      } }, successNotification: f2, errorNotification: d2, metaData: h2, liveMode: x2, liveParams: D2, onLiveEvent: b2, dataProviderName: S2 }), Z2 = (K2) => {
        if (v2) {
          r2(v2(K2));
          return;
        }
        if (K2)
          r2([{ field: l2, operator: "contains", value: K2 }]);
        else {
          r2([]);
          return;
        }
      };
      return { queryResult: I2, defaultValueQueryResult: U2, options: reactExports.useMemo(() => uniqBy_1([...o2, ...a], "value"), [o2, a]), onSearch: debounce_1(Z2, R2) };
    };
    var oa = [], sa = [];
    function Em({ initialCurrent: e2 = 1, initialPageSize: t2 = 10, hasPagination: r2 = true, initialSorter: o2, permanentSorter: s = sa, defaultSetFilterBehavior: a = "merge", initialFilter: n2, permanentFilter: m2 = oa, syncWithLocation: C2, resource: u2, successNotification: l2, errorNotification: y2, queryOptions: R2, liveMode: f2, onLiveEvent: d2, liveParams: p2, metaData: c2, dataProviderName: i2 } = {}) {
      var se2;
      let { syncWithLocation: g2 } = Bt(), T2 = C2 != null ? C2 : g2, { useLocation: x2, useParams: P2 } = w$3(), { search: b2, pathname: v2 } = x2(), D2 = Tr(f2), { parsedCurrent: h2, parsedPageSize: S2, parsedSorter: V2, parsedFilters: Q2 } = st(b2), L2 = h2 || e2, U2 = S2 || t2, A2 = V2.length ? V2 : o2, I2 = Q2.length ? Q2 : n2, { resource: Z2 } = P2(), { replace: oe2 } = q$2(), K2 = J()(u2 != null ? u2 : Z2), [j, pe2] = reactExports.useState(ut(s, A2 != null ? A2 : [])), [O2, fe2] = reactExports.useState(it$1(m2, I2 != null ? I2 : [])), [ve2, Xe2] = reactExports.useState(L2), [ye2, et] = reactExports.useState(U2), Tt = ({ pagination: { current: N2, pageSize: G2 }, sorter: Ee2, filters: ae2 }) => {
        let Te2 = lib$4.parse(b2 == null ? void 0 : b2.substring(1)), Me2 = at({ pagination: { pageSize: G2, current: N2 }, sorter: Ee2, filters: ae2, ...Te2 });
        return `${v2}?${Me2}`;
      };
      reactExports.useEffect(() => {
        b2 === "" && (Xe2(L2), et(U2), pe2(ut(s, A2 != null ? A2 : [])), fe2(it$1(m2, I2 != null ? I2 : [])));
      }, [b2]);
      let tt = () => {
        let { sorter: N2, filters: G2, pageSize: Ee2, current: ae2, ...Te2 } = lib$4.parse(b2, { ignoreQueryPrefix: true });
        return Te2;
      };
      reactExports.useEffect(() => {
        if (T2) {
          let N2 = tt(), G2 = at({ ...r2 ? { pagination: { pageSize: ye2, current: ve2 } } : {}, sorter: differenceWith_1(j, s, isEqual_1), filters: differenceWith_1(O2, m2, isEqual_1), ...N2 });
          return oe2(`${v2}?${G2}`, void 0, { shallow: true });
        }
      }, [T2, ve2, ye2, j, O2]);
      let he2 = Ke({ resource: K2.name, config: { hasPagination: r2, pagination: { current: ve2, pageSize: ye2 }, filters: we(m2, O2), sort: nt(s, j) }, queryOptions: R2, successNotification: l2, errorNotification: y2, metaData: c2, liveMode: D2, liveParams: p2, onLiveEvent: d2, dataProviderName: i2 }), Kt = (N2) => {
        fe2((G2) => we(m2, N2, G2));
      }, Gt2 = (N2) => {
        fe2(we(m2, N2));
      }, zt = (N2) => {
        fe2((G2) => we(m2, N2(G2)));
      }, _t = (N2, G2 = a) => {
        typeof N2 == "function" ? zt(N2) : G2 === "replace" ? Gt2(N2) : Kt(N2);
      }, jt = (N2) => {
        pe2(() => nt(s, N2));
      }, rt = reactExports.useMemo(() => {
        var N2, G2;
        return r2 ? { current: ve2, setCurrent: Xe2, pageSize: ye2, setPageSize: et, pageCount: ye2 ? Math.ceil(((G2 = (N2 = he2.data) == null ? void 0 : N2.total) != null ? G2 : 0) / ye2) : 1 } : { current: void 0, setCurrent: void 0, pageSize: void 0, setPageSize: void 0, pageCount: void 0 };
      }, [r2, ve2, ye2, (se2 = he2.data) == null ? void 0 : se2.total]);
      return { tableQueryResult: he2, sorter: j, setSorter: jt, filters: O2, setFilters: _t, ...rt, createLinkForSyncWithLocation: Tt };
    }
    var Le = React$3.createContext({}), Hr = ({ create: e2, get: t2, update: r2, children: o2 }) => React$3.createElement(Le.Provider, { value: { create: e2, get: t2, update: r2 } }, o2);
    var Ve = ({ logMutationOptions: e2, renameMutationOptions: t2 } = {}) => {
      let r2 = useQueryClient(), o2 = reactExports.useContext(Le), { resources: s } = reactExports.useContext(Ue$1), { data: a, refetch: n2, isLoading: m2 } = gt$1({ queryOptions: { enabled: !!o2 } }), C2 = useMutation(async (l2) => {
        var d2, p2, c2;
        let y2 = s.find((i2) => i2.name === l2.resource), R2 = (p2 = (d2 = y2 == null ? void 0 : y2.options) == null ? void 0 : d2.auditLog) == null ? void 0 : p2.permissions;
        if (R2 && !vt$1(R2, l2.action))
          return;
        let f2;
        return m2 && (f2 = await n2()), await ((c2 = o2.create) == null ? void 0 : c2.call(o2, { ...l2, author: a != null ? a : f2 == null ? void 0 : f2.data }));
      }, e2), u2 = useMutation(async (l2) => {
        var y2;
        return await ((y2 = o2.update) == null ? void 0 : y2.call(o2, l2));
      }, { onSuccess: (l2) => {
        if (l2 != null && l2.resource) {
          let y2 = F$1(l2 == null ? void 0 : l2.resource);
          r2.invalidateQueries(y2.logList());
        }
      }, ...t2 });
      return { log: C2, rename: u2 };
    };
    var ie$1 = () => {
      let { resources: e2 } = B$1(), t2 = useQueryClient();
      return reactExports.useCallback(({ resource: o2, dataProviderName: s, invalidates: a, id: n2 }) => {
        if (a === false)
          return;
        let m2 = F$1(o2, E$2(o2, s, e2));
        a.forEach((C2) => {
          switch (C2) {
            case "all":
              t2.invalidateQueries(m2.all);
              break;
            case "list":
              t2.invalidateQueries(m2.list());
              break;
            case "many":
              t2.invalidateQueries(m2.many());
              break;
            case "resourceAll":
              t2.invalidateQueries(m2.resourceAll);
              break;
            case "detail":
              t2.invalidateQueries(m2.detail(n2 || ""));
              break;
          }
        });
      }, []);
    };
    var uf = () => {
      var C2;
      let { useParams: e2 } = w$3(), { i18nProvider: t2 } = reactExports.useContext(de$1), r2 = M(), { resources: o2, resource: s } = B$1(), { action: a } = e2(), n2 = [];
      if (!(s != null && s.name))
        return { breadcrumbs: n2 };
      let m2 = (u2) => {
        var y2;
        let l2 = o2.find((R2) => R2.name === u2);
        l2 && (l2.parentName && m2(l2.parentName), n2.push({ label: (y2 = l2.label) != null ? y2 : r2(`${l2.name}.${l2.name}`, Pe$1(l2.name)), href: l2.list ? `/${l2.route}` : void 0, icon: l2.icon }));
      };
      if (s.parentName && m2(s.parentName), n2.push({ label: (C2 = s.label) != null ? C2 : r2(`${s.name}.${s.name}`, Pe$1(s.name)), href: s.list ? `/${s.route}` : void 0, icon: s.icon }), a) {
        let u2 = `actions.${a}`, l2 = r2(u2);
        typeof t2 < "u" && l2 === u2 ? n2.push({ label: r2(`buttons.${a}`, Pe$1(a)) }) : n2.push({ label: r2(u2, Pe$1(a)) });
      }
      return { breadcrumbs: n2 };
    };
    var da = () => {
      let { resources: e2 } = B$1(), t2 = M(), { useLocation: r2, useParams: o2 } = w$3(), s = r2(), a = o2(), { hasDashboard: n2 } = Se(), m2 = React$3.useMemo(() => {
        let f2 = e2.find((p2) => (s == null ? void 0 : s.pathname) === `/${p2.route}`);
        f2 || (f2 = e2.find((p2) => (a == null ? void 0 : a.resource) === p2.route));
        let d2;
        return f2 != null && f2.route ? d2 = `/${f2 == null ? void 0 : f2.route}` : s.pathname === "/" ? d2 = "/" : d2 = s == null ? void 0 : s.pathname, d2;
      }, [e2, s, a]), C2 = React$3.useMemo(() => e2.map((f2) => {
        var p2, c2;
        let d2 = `/${f2.route}`;
        return { ...f2, icon: f2.icon, route: d2, key: (p2 = f2.key) != null ? p2 : d2, label: (c2 = f2.label) != null ? c2 : t2(`${f2.name}.${f2.name}`, Qe(f2.name, "plural")) };
      }), [e2, n2, t2]), u2 = React$3.useMemo(() => ct(C2), [C2]), l2 = React$3.useCallback((f2, d2, p2 = false) => {
        let c2 = d2.find((i2) => p2 ? i2.name === f2 : i2.route === f2);
        if (c2) {
          let i2 = [];
          return p2 && c2.route && i2.unshift(c2.route), c2.parentName && i2.unshift(...l2(c2.parentName, d2, true)), i2;
        }
        return [];
      }, []), y2 = React$3.useMemo(() => l2(m2, C2), [m2, C2]);
      return React$3.useMemo(() => {
        let f2 = (d2) => d2.reduce((p2, c2) => {
          var i2, g2;
          return c2.children.length > 0 && ((i2 = c2.options) == null ? void 0 : i2.hide) !== true ? [...p2, { ...c2, children: f2(c2.children) }] : typeof c2.list < "u" && ((g2 = c2.options) == null ? void 0 : g2.hide) !== true ? [...p2, c2] : p2;
        }, []);
        return { defaultOpenKeys: y2, selectedKey: m2, menuItems: f2(u2) };
      }, [y2, m2, u2]);
    };
    var ya = () => {
      let [e2, t2] = reactExports.useState(), { push: r2 } = q$2(), o2 = M(), s = ["edit", "create", "show"], { useParams: a } = w$3(), n2 = a(), m2 = J();
      return reactExports.useEffect(() => {
        if (n2.resource) {
          let C2 = m2(n2.resource);
          n2.action && s.includes(n2.action) && !C2[n2.action] && t2(o2("pages.error.info", { action: n2.action, resource: n2.resource }, `You may have forgotten to add the "${n2.action}" component to "${n2.resource}" resource.`));
        }
      }, [n2]), React$3.createElement(React$3.Fragment, null, React$3.createElement("h1", null, o2("pages.error.404", void 0, "Sorry, the page you visited does not exist.")), e2 && React$3.createElement("p", null, e2), React$3.createElement("button", { onClick: () => r2("/") }, o2("pages.error.backHome", void 0, "Back Home")));
    };
    var Et = () => {
      let [e2, t2] = reactExports.useState(""), [r2, o2] = reactExports.useState(""), s = M(), { mutate: a } = $e();
      return React$3.createElement(React$3.Fragment, null, React$3.createElement("h1", null, s("pages.login.title", "Sign in your account")), React$3.createElement("form", { onSubmit: (n2) => {
        n2.preventDefault(), a({ username: e2, password: r2 });
      } }, React$3.createElement("table", null, React$3.createElement("tbody", null, React$3.createElement("tr", null, React$3.createElement("td", null, s("pages.login.username", void 0, "username"), ":"), React$3.createElement("td", null, React$3.createElement("input", { type: "text", size: 20, autoCorrect: "off", spellCheck: false, autoCapitalize: "off", autoFocus: true, required: true, value: e2, onChange: (n2) => t2(n2.target.value) }))), React$3.createElement("tr", null, React$3.createElement("td", null, s("pages.login.password", void 0, "password"), ":"), React$3.createElement("td", null, React$3.createElement("input", { type: "password", required: true, size: 20, value: r2, onChange: (n2) => o2(n2.target.value) }))))), React$3.createElement("br", null), React$3.createElement("input", { type: "submit", value: "login" })));
    };
    var Ft = () => React$3.createElement(React$3.Fragment, null, React$3.createElement("h1", null, "Welcome on board"), React$3.createElement("p", null, "Your configuration is completed."), React$3.createElement("p", null, "Now you can get started by adding your resources to the", " ", React$3.createElement("code", null, "`resources`"), " property of ", React$3.createElement("code", null, "`<Refine>`")), React$3.createElement("div", { style: { display: "flex", gap: 8 } }, React$3.createElement("a", { href: "https://refine.dev", target: "_blank", rel: "noreferrer" }, React$3.createElement("button", null, "Documentation")), React$3.createElement("a", { href: "https://refine.dev/examples", target: "_blank", rel: "noreferrer" }, React$3.createElement("button", null, "Examples")), React$3.createElement("a", { href: "https://discord.gg/refine", target: "_blank", rel: "noreferrer" }, React$3.createElement("button", null, "Community"))));
    var Ca$1 = "3.101.0", qr = () => {
      let e2 = reactExports.useContext(H$2), t2 = reactExports.useContext(Le), r2 = reactExports.useContext(Re), o2 = reactExports.useContext(Ye), s = reactExports.useContext(_e), { i18nProvider: a } = reactExports.useContext(de$1), n2 = reactExports.useContext(je$1), m2 = reactExports.useContext(Ie$1), { resources: C2 } = B$1(), u2 = e2.isProvided, l2 = !!t2.create || !!t2.get || !!t2.update, y2 = !!(r2 != null && r2.publish) || !!(r2 != null && r2.subscribe) || !!(r2 != null && r2.unsubscribe), R2 = !!o2.useHistory || !!o2.Link || !!o2.Prompt || !!o2.useLocation || !!o2.useParams, f2 = !!s, d2 = !!(a != null && a.changeLocale) || !!(a != null && a.getLocale) || !!(a != null && a.translate), p2 = !!n2.close || !!n2.open, c2 = !!m2.can;
      return { providers: { auth: u2, auditLog: l2, live: y2, router: R2, data: f2, i18n: d2, notification: p2, accessControl: c2 }, version: Ca$1, resourceCount: C2.length };
    };
    var Ra = (e2) => {
      let t2 = JSON.stringify(e2 || {});
      return typeof btoa < "u" ? btoa(t2) : Buffer.from(t2).toString("base64");
    }, Yr = () => {
      let e2 = qr();
      return reactExports.useEffect(() => {
        if (typeof window > "u" && !Image)
          return;
        let t2 = new Image();
        t2.src = `https://telemetry.refine.dev/telemetry?payload=${Ra(e2)}`;
      }, []), null;
    };
    var Zr = (e2) => {
      let t2 = reactExports.useRef(e2);
      return isEqual$3(t2.current, e2) || (t2.current = e2), t2.current;
    };
    var $t = (e2, t2) => {
      let r2 = Zr(t2);
      return reactExports.useMemo(e2, r2);
    };
    var Ea$1 = ({ authProvider: e2, dataProvider: t2, routerProvider: r2, notificationProvider: o2, accessControlProvider: s, auditLogProvider: a, resources: n2, DashboardPage: m2, ReadyPage: C2, LoginPage: u2, catchAll: l2, children: y2, liveProvider: R2, i18nProvider: f2, mutationMode: d2, syncWithLocation: p2, warnWhenUnsavedChanges: c2, undoableTimeout: i2, Title: g2, Layout: T2, Sider: x2, Header: P2, Footer: b2, OffLayoutArea: v2, reactQueryClientConfig: D2, reactQueryDevtoolConfig: h2, liveMode: S2, onLiveEvent: V2, disableTelemetry: Q2, options: L2 }) => {
      let { optionsWithDefaults: U2, disableTelemetryWithDefault: A2, reactQueryWithDefaults: I2 } = Mt({ options: L2, disableTelemetry: Q2, liveMode: S2, mutationMode: d2, reactQueryClientConfig: D2, reactQueryDevtoolConfig: h2, syncWithLocation: p2, warnWhenUnsavedChanges: c2, undoableTimeout: i2 }), Z2 = $t(() => {
        var pe2;
        return I2.clientConfig instanceof QueryClient ? I2.clientConfig : new QueryClient({ ...I2.clientConfig, defaultOptions: { ...I2.clientConfig.defaultOptions, queries: { refetchOnWindowFocus: false, keepPreviousData: true, ...(pe2 = I2.clientConfig.defaultOptions) == null ? void 0 : pe2.queries } } });
      }, [I2.clientConfig]), ce2 = React$3.useMemo(() => typeof o2 == "function" ? o2 : () => o2 != null ? o2 : {}, [o2])(), K2 = $t(() => {
        let pe2 = [];
        return n2 == null || n2.forEach((O2) => {
          var fe2;
          pe2.push({ key: O2.key, name: O2.name, label: (fe2 = O2.options) == null ? void 0 : fe2.label, icon: O2.icon, route: We(O2, n2), canCreate: !!O2.create, canEdit: !!O2.edit, canShow: !!O2.show, canDelete: O2.canDelete, create: O2.create, show: O2.show, list: O2.list, edit: O2.edit, options: O2.options, parentName: O2.parentName });
        }), pe2;
      }, [n2]);
      if (K2.length === 0)
        return C2 ? React$3.createElement(C2, null) : React$3.createElement(Ft, null);
      let { RouterComponent: j = React$3.Fragment } = r2;
      return React$3.createElement(QueryClientProvider, { client: Z2 }, React$3.createElement(xr, { ...ce2 }, React$3.createElement(Zt, { ...e2 != null ? e2 : {}, isProvided: Boolean(e2) }, React$3.createElement(dr, { ...t2 }, React$3.createElement(fr, { liveProvider: R2 }, React$3.createElement(Sr, { ...r2 }, React$3.createElement(Cr, { resources: K2 }, React$3.createElement(Pr, { i18nProvider: f2 }, React$3.createElement(Lr, { ...s != null ? s : {} }, React$3.createElement(Hr, { ...a != null ? a : {} }, React$3.createElement(wt, null, React$3.createElement(ar, { mutationMode: U2.mutationMode, warnWhenUnsavedChanges: U2.warnWhenUnsavedChanges, syncWithLocation: U2.syncWithLocation, Title: g2, undoableTimeout: U2.undoableTimeout, catchAll: l2, DashboardPage: m2, LoginPage: u2, Layout: T2, Sider: x2, Footer: b2, Header: P2, OffLayoutArea: v2, hasDashboard: !!m2, liveMode: U2.liveMode, onLiveEvent: V2, options: U2 }, React$3.createElement(Dr, null, React$3.createElement(j, null, y2, !A2 && React$3.createElement(Yr, null), React$3.createElement(Ot, null)))))))))))))), I2.devtoolConfig === false ? null : React$3.createElement(ReactQueryDevtools, { initialIsOpen: false, position: "bottom-right", ...I2.devtoolConfig }));
    };
    var nr = ({ notification: e2 }) => {
      let t2 = M(), { notificationDispatch: r2 } = Ce(), { open: o2 } = te(), [s, a] = reactExports.useState(), n2 = () => {
        if (e2.isRunning === true && (e2.seconds === 0 && e2.doMutation(), e2.isSilent || o2 == null || o2({ key: `${e2.id}-${e2.resource}-notification`, type: "progress", message: t2("notifications.undoable", { seconds: Oe(e2.seconds) }, `You have ${Oe(e2.seconds)} seconds to undo`), cancelMutation: e2.cancelMutation, undoableTimeout: Oe(e2.seconds) }), e2.seconds > 0)) {
          s && clearTimeout(s);
          let m2 = setTimeout(() => {
            r2({ type: "DECREASE_NOTIFICATION_SECOND", payload: { id: e2.id, seconds: e2.seconds, resource: e2.resource } });
          }, 1e3);
          a(m2);
        }
      };
      return reactExports.useEffect(() => {
        n2();
      }, [e2]), null;
    };
    var Ia = ({ children: e2, Layout: t2, Sider: r2, Header: o2, Title: s, Footer: a, OffLayoutArea: n2 }) => {
      let { Layout: m2, Footer: C2, Header: u2, Sider: l2, Title: y2, OffLayoutArea: R2 } = Se(), f2 = t2 != null ? t2 : m2;
      return React$3.createElement(f2, { Sider: r2 != null ? r2 : l2, Header: o2 != null ? o2 : u2, Footer: a != null ? a : C2, Title: s != null ? s : y2, OffLayoutArea: n2 != null ? n2 : R2 }, e2, React$3.createElement(La, null));
    }, La = () => {
      let { Prompt: e2 } = w$3(), t2 = M(), { warnWhen: r2, setWarnWhen: o2 } = qe$1(), s = (a) => (a.preventDefault(), a.returnValue = t2("warnWhenUnsavedChanges", "Are you sure you want to leave? You have unsaved changes."), a.returnValue);
      return reactExports.useEffect(() => (r2 && window.addEventListener("beforeunload", s), window.removeEventListener("beforeunload", s)), [r2]), React$3.createElement(e2, { when: r2, message: t2("warnWhenUnsavedChanges", "Are you sure you want to leave? You have unsaved changes."), setWarnWhen: o2 });
    };
    var Ot = () => {
      let { useLocation: e2 } = w$3(), { checkAuth: t2 } = reactExports.useContext(H$2), r2 = e2();
      return reactExports.useEffect(() => {
        t2 == null || t2().catch(() => false);
      }, [r2 == null ? void 0 : r2.pathname]), null;
    };
    var Va = ({ resource: e2, action: t2, params: r2, fallback: o2, children: s, ...a }) => {
      let { data: n2 } = wr({ resource: e2, action: t2, params: r2 });
      return n2 != null && n2.can ? React$3.isValidElement(s) ? React$3.cloneElement(s, a) : React$3.createElement(React$3.Fragment, null, s) : (n2 == null ? void 0 : n2.can) === false ? React$3.createElement(React$3.Fragment, null, o2 != null ? o2 : null) : null;
    };
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _typeof$4(obj) {
      "@babel/helpers - typeof";
      return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$4(obj);
    }
    function _toPrimitive(input, hint) {
      if (_typeof$4(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof$4(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof$4(key) === "symbol" ? key : String(key);
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _setPrototypeOf$1(o2, p2) {
      _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf$1(o2, p2);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass)
        _setPrototypeOf$1(subClass, superClass);
    }
    function _getPrototypeOf$1(o2) {
      _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf$1(o2);
    }
    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _possibleConstructorReturn(self2, call2) {
      if (call2 && (_typeof$4(call2) === "object" || typeof call2 === "function")) {
        return call2;
      } else if (call2 !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$1(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$1(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var classnamesExports = {};
    var classnames = {
      get exports() {
        return classnamesExports;
      },
      set exports(v2) {
        classnamesExports = v2;
      }
    };
    /*!
    	Copyright (c) 2018 Jed Watson.
    	Licensed under the MIT License (MIT), see
    	http://jedwatson.github.io/classnames
    */
    (function(module2) {
      (function() {
        var hasOwn2 = {}.hasOwnProperty;
        function classNames2() {
          var classes = [];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            var arg = arguments[i2];
            if (!arg)
              continue;
            var argType = typeof arg;
            if (argType === "string" || argType === "number") {
              classes.push(arg);
            } else if (Array.isArray(arg)) {
              if (arg.length) {
                var inner = classNames2.apply(null, arg);
                if (inner) {
                  classes.push(inner);
                }
              }
            } else if (argType === "object") {
              if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                classes.push(arg.toString());
                continue;
              }
              for (var key in arg) {
                if (hasOwn2.call(arg, key) && arg[key]) {
                  classes.push(key);
                }
              }
            }
          }
          return classes.join(" ");
        }
        if (module2.exports) {
          classNames2.default = classNames2;
          module2.exports = classNames2;
        } else {
          window.classNames = classNames2;
        }
      })();
    })(classnames);
    const classNames = classnamesExports;
    function _extends$2() {
      _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$2.apply(this, arguments);
    }
    var reactIsExports$1 = {};
    var reactIs$1 = {
      get exports() {
        return reactIsExports$1;
      },
      set exports(v2) {
        reactIsExports$1 = v2;
      }
    };
    var reactIs_production_min$1 = {};
    /** @license React v16.13.1
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$2 = b$1 ? Symbol.for("react.fragment") : 60107, f$2 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$1 = b$1 ? Symbol.for("react.provider") : 60109, k$2 = b$1 ? Symbol.for("react.context") : 60110, l$2 = b$1 ? Symbol.for("react.async_mode") : 60111, m$2 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$3 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$3 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t$2 = b$1 ? Symbol.for("react.lazy") : 60116, v$2 = b$1 ? Symbol.for("react.block") : 60121, w$2 = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y$1 = b$1 ? Symbol.for("react.scope") : 60119;
    function z$1(a) {
      if ("object" === typeof a && null !== a) {
        var u2 = a.$$typeof;
        switch (u2) {
          case c$1:
            switch (a = a.type, a) {
              case l$2:
              case m$2:
              case e$2:
              case g$1:
              case f$2:
              case p$3:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k$2:
                  case n$3:
                  case t$2:
                  case r$1:
                  case h$1:
                    return a;
                  default:
                    return u2;
                }
            }
          case d$1:
            return u2;
        }
      }
    }
    function A$2(a) {
      return z$1(a) === m$2;
    }
    reactIs_production_min$1.AsyncMode = l$2;
    reactIs_production_min$1.ConcurrentMode = m$2;
    reactIs_production_min$1.ContextConsumer = k$2;
    reactIs_production_min$1.ContextProvider = h$1;
    reactIs_production_min$1.Element = c$1;
    reactIs_production_min$1.ForwardRef = n$3;
    reactIs_production_min$1.Fragment = e$2;
    reactIs_production_min$1.Lazy = t$2;
    reactIs_production_min$1.Memo = r$1;
    reactIs_production_min$1.Portal = d$1;
    reactIs_production_min$1.Profiler = g$1;
    reactIs_production_min$1.StrictMode = f$2;
    reactIs_production_min$1.Suspense = p$3;
    reactIs_production_min$1.isAsyncMode = function(a) {
      return A$2(a) || z$1(a) === l$2;
    };
    reactIs_production_min$1.isConcurrentMode = A$2;
    reactIs_production_min$1.isContextConsumer = function(a) {
      return z$1(a) === k$2;
    };
    reactIs_production_min$1.isContextProvider = function(a) {
      return z$1(a) === h$1;
    };
    reactIs_production_min$1.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === c$1;
    };
    reactIs_production_min$1.isForwardRef = function(a) {
      return z$1(a) === n$3;
    };
    reactIs_production_min$1.isFragment = function(a) {
      return z$1(a) === e$2;
    };
    reactIs_production_min$1.isLazy = function(a) {
      return z$1(a) === t$2;
    };
    reactIs_production_min$1.isMemo = function(a) {
      return z$1(a) === r$1;
    };
    reactIs_production_min$1.isPortal = function(a) {
      return z$1(a) === d$1;
    };
    reactIs_production_min$1.isProfiler = function(a) {
      return z$1(a) === g$1;
    };
    reactIs_production_min$1.isStrictMode = function(a) {
      return z$1(a) === f$2;
    };
    reactIs_production_min$1.isSuspense = function(a) {
      return z$1(a) === p$3;
    };
    reactIs_production_min$1.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === e$2 || a === m$2 || a === g$1 || a === f$2 || a === p$3 || a === q$1 || "object" === typeof a && null !== a && (a.$$typeof === t$2 || a.$$typeof === r$1 || a.$$typeof === h$1 || a.$$typeof === k$2 || a.$$typeof === n$3 || a.$$typeof === w$2 || a.$$typeof === x$1 || a.$$typeof === y$1 || a.$$typeof === v$2);
    };
    reactIs_production_min$1.typeOf = z$1;
    (function(module2) {
      {
        module2.exports = reactIs_production_min$1;
      }
    })(reactIs$1);
    function toArray$8(children) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var ret = [];
      React$3.Children.forEach(children, function(child) {
        if ((child === void 0 || child === null) && !option.keepEmpty) {
          return;
        }
        if (Array.isArray(child)) {
          ret = ret.concat(toArray$8(child));
        } else if (reactIsExports$1.isFragment(child) && child.props) {
          ret = ret.concat(toArray$8(child.props.children, option));
        } else {
          ret.push(child);
        }
      });
      return ret;
    }
    var warned$1 = {};
    function warning$5(valid, message2) {
    }
    function note$1(valid, message2) {
    }
    function call$1(method2, valid, message2) {
      if (!valid && !warned$1[message2]) {
        method2(false, message2);
        warned$1[message2] = true;
      }
    }
    function warningOnce$1(valid, message2) {
      call$1(warning$5, valid, message2);
    }
    function noteOnce$1(valid, message2) {
      call$1(note$1, valid, message2);
    }
    function _defineProperty$7(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    const defineProperty$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: _defineProperty$7
    }, Symbol.toStringTag, { value: "Module" }));
    function ownKeys$2(object2, enumerableOnly) {
      var keys2 = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread2$3(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
          _defineProperty$7(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function useMemo(getValue2, condition, shouldUpdate) {
      var cacheRef = reactExports.useRef({});
      if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
        cacheRef.current.value = getValue2();
        cacheRef.current.condition = condition;
      }
      return cacheRef.current.value;
    }
    function fillRef(ref, node2) {
      if (typeof ref === "function") {
        ref(node2);
      } else if (_typeof$4(ref) === "object" && ref && "current" in ref) {
        ref.current = node2;
      }
    }
    function composeRef() {
      for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
        refs[_key] = arguments[_key];
      }
      var refList = refs.filter(function(ref) {
        return ref;
      });
      if (refList.length <= 1) {
        return refList[0];
      }
      return function(node2) {
        refs.forEach(function(ref) {
          fillRef(ref, node2);
        });
      };
    }
    function useComposeRef() {
      for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        refs[_key2] = arguments[_key2];
      }
      return useMemo(function() {
        return composeRef.apply(void 0, refs);
      }, refs, function(prev2, next2) {
        return prev2.length === next2.length && prev2.every(function(ref, i2) {
          return ref === next2[i2];
        });
      });
    }
    function supportRef(nodeOrComponent) {
      var _type$prototype, _nodeOrComponent$prot;
      var type2 = reactIsExports$1.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
      if (typeof type2 === "function" && !((_type$prototype = type2.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
        return false;
      }
      if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
        return false;
      }
      return true;
    }
    function findDOMNode(node2) {
      if (node2 instanceof HTMLElement) {
        return node2;
      }
      if (node2 instanceof React$3.Component) {
        return ReactDOM.findDOMNode(node2);
      }
      return null;
    }
    var MapShim = function() {
      if (typeof Map !== "undefined") {
        return Map;
      }
      function getIndex(arr, key) {
        var result = -1;
        arr.some(function(entry, index2) {
          if (entry[0] === key) {
            result = index2;
            return true;
          }
          return false;
        });
        return result;
      }
      return (
        /** @class */
        function() {
          function class_1() {
            this.__entries__ = [];
          }
          Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function() {
              return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
          });
          class_1.prototype.get = function(key) {
            var index2 = getIndex(this.__entries__, key);
            var entry = this.__entries__[index2];
            return entry && entry[1];
          };
          class_1.prototype.set = function(key, value) {
            var index2 = getIndex(this.__entries__, key);
            if (~index2) {
              this.__entries__[index2][1] = value;
            } else {
              this.__entries__.push([key, value]);
            }
          };
          class_1.prototype.delete = function(key) {
            var entries = this.__entries__;
            var index2 = getIndex(entries, key);
            if (~index2) {
              entries.splice(index2, 1);
            }
          };
          class_1.prototype.has = function(key) {
            return !!~getIndex(this.__entries__, key);
          };
          class_1.prototype.clear = function() {
            this.__entries__.splice(0);
          };
          class_1.prototype.forEach = function(callback, ctx) {
            if (ctx === void 0) {
              ctx = null;
            }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
              var entry = _a[_i];
              callback.call(ctx, entry[1], entry[0]);
            }
          };
          return class_1;
        }()
      );
    }();
    var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
    var global$1 = function() {
      if (typeof global !== "undefined" && global.Math === Math) {
        return global;
      }
      if (typeof self !== "undefined" && self.Math === Math) {
        return self;
      }
      if (typeof window !== "undefined" && window.Math === Math) {
        return window;
      }
      return Function("return this")();
    }();
    var requestAnimationFrame$1 = function() {
      if (typeof requestAnimationFrame === "function") {
        return requestAnimationFrame.bind(global$1);
      }
      return function(callback) {
        return setTimeout(function() {
          return callback(Date.now());
        }, 1e3 / 60);
      };
    }();
    var trailingTimeout = 2;
    function throttle$1(callback, delay) {
      var leadingCall = false, trailingCall = false, lastCallTime = 0;
      function resolvePending() {
        if (leadingCall) {
          leadingCall = false;
          callback();
        }
        if (trailingCall) {
          proxy();
        }
      }
      function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
      }
      function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
          if (timeStamp - lastCallTime < trailingTimeout) {
            return;
          }
          trailingCall = true;
        } else {
          leadingCall = true;
          trailingCall = false;
          setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
      }
      return proxy;
    }
    var REFRESH_DELAY = 20;
    var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
    var mutationObserverSupported = typeof MutationObserver !== "undefined";
    var ResizeObserverController = (
      /** @class */
      function() {
        function ResizeObserverController2() {
          this.connected_ = false;
          this.mutationEventsAdded_ = false;
          this.mutationsObserver_ = null;
          this.observers_ = [];
          this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
          this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
        }
        ResizeObserverController2.prototype.addObserver = function(observer) {
          if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
          }
          if (!this.connected_) {
            this.connect_();
          }
        };
        ResizeObserverController2.prototype.removeObserver = function(observer) {
          var observers2 = this.observers_;
          var index2 = observers2.indexOf(observer);
          if (~index2) {
            observers2.splice(index2, 1);
          }
          if (!observers2.length && this.connected_) {
            this.disconnect_();
          }
        };
        ResizeObserverController2.prototype.refresh = function() {
          var changesDetected = this.updateObservers_();
          if (changesDetected) {
            this.refresh();
          }
        };
        ResizeObserverController2.prototype.updateObservers_ = function() {
          var activeObservers = this.observers_.filter(function(observer) {
            return observer.gatherActive(), observer.hasActive();
          });
          activeObservers.forEach(function(observer) {
            return observer.broadcastActive();
          });
          return activeObservers.length > 0;
        };
        ResizeObserverController2.prototype.connect_ = function() {
          if (!isBrowser || this.connected_) {
            return;
          }
          document.addEventListener("transitionend", this.onTransitionEnd_);
          window.addEventListener("resize", this.refresh);
          if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });
          } else {
            document.addEventListener("DOMSubtreeModified", this.refresh);
            this.mutationEventsAdded_ = true;
          }
          this.connected_ = true;
        };
        ResizeObserverController2.prototype.disconnect_ = function() {
          if (!isBrowser || !this.connected_) {
            return;
          }
          document.removeEventListener("transitionend", this.onTransitionEnd_);
          window.removeEventListener("resize", this.refresh);
          if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
          }
          if (this.mutationEventsAdded_) {
            document.removeEventListener("DOMSubtreeModified", this.refresh);
          }
          this.mutationsObserver_ = null;
          this.mutationEventsAdded_ = false;
          this.connected_ = false;
        };
        ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
          var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
          var isReflowProperty = transitionKeys.some(function(key) {
            return !!~propertyName.indexOf(key);
          });
          if (isReflowProperty) {
            this.refresh();
          }
        };
        ResizeObserverController2.getInstance = function() {
          if (!this.instance_) {
            this.instance_ = new ResizeObserverController2();
          }
          return this.instance_;
        };
        ResizeObserverController2.instance_ = null;
        return ResizeObserverController2;
      }()
    );
    var defineConfigurable = function(target, props) {
      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
          value: props[key],
          enumerable: false,
          writable: false,
          configurable: true
        });
      }
      return target;
    };
    var getWindowOf = function(target) {
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
      return ownerGlobal || global$1;
    };
    var emptyRect = createRectInit(0, 0, 0, 0);
    function toFloat(value) {
      return parseFloat(value) || 0;
    }
    function getBordersSize(styles) {
      var positions = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
      }
      return positions.reduce(function(size, position2) {
        var value = styles["border-" + position2 + "-width"];
        return size + toFloat(value);
      }, 0);
    }
    function getPaddings(styles) {
      var positions = ["top", "right", "bottom", "left"];
      var paddings = {};
      for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position2 = positions_1[_i];
        var value = styles["padding-" + position2];
        paddings[position2] = toFloat(value);
      }
      return paddings;
    }
    function getSVGContentRect(target) {
      var bbox = target.getBBox();
      return createRectInit(0, 0, bbox.width, bbox.height);
    }
    function getHTMLElementContentRect(target) {
      var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
      if (!clientWidth && !clientHeight) {
        return emptyRect;
      }
      var styles = getWindowOf(target).getComputedStyle(target);
      var paddings = getPaddings(styles);
      var horizPad = paddings.left + paddings.right;
      var vertPad = paddings.top + paddings.bottom;
      var width = toFloat(styles.width), height = toFloat(styles.height);
      if (styles.boxSizing === "border-box") {
        if (Math.round(width + horizPad) !== clientWidth) {
          width -= getBordersSize(styles, "left", "right") + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
          height -= getBordersSize(styles, "top", "bottom") + vertPad;
        }
      }
      if (!isDocumentElement(target)) {
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        if (Math.abs(vertScrollbar) !== 1) {
          width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
          height -= horizScrollbar;
        }
      }
      return createRectInit(paddings.left, paddings.top, width, height);
    }
    var isSVGGraphicsElement = function() {
      if (typeof SVGGraphicsElement !== "undefined") {
        return function(target) {
          return target instanceof getWindowOf(target).SVGGraphicsElement;
        };
      }
      return function(target) {
        return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
      };
    }();
    function isDocumentElement(target) {
      return target === getWindowOf(target).document.documentElement;
    }
    function getContentRect(target) {
      if (!isBrowser) {
        return emptyRect;
      }
      if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
      }
      return getHTMLElementContentRect(target);
    }
    function createReadOnlyRect(_a) {
      var x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height;
      var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
      var rect = Object.create(Constr.prototype);
      defineConfigurable(rect, {
        x: x2,
        y: y2,
        width,
        height,
        top: y2,
        right: x2 + width,
        bottom: height + y2,
        left: x2
      });
      return rect;
    }
    function createRectInit(x2, y2, width, height) {
      return { x: x2, y: y2, width, height };
    }
    var ResizeObservation = (
      /** @class */
      function() {
        function ResizeObservation2(target) {
          this.broadcastWidth = 0;
          this.broadcastHeight = 0;
          this.contentRect_ = createRectInit(0, 0, 0, 0);
          this.target = target;
        }
        ResizeObservation2.prototype.isActive = function() {
          var rect = getContentRect(this.target);
          this.contentRect_ = rect;
          return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
        };
        ResizeObservation2.prototype.broadcastRect = function() {
          var rect = this.contentRect_;
          this.broadcastWidth = rect.width;
          this.broadcastHeight = rect.height;
          return rect;
        };
        return ResizeObservation2;
      }()
    );
    var ResizeObserverEntry = (
      /** @class */
      function() {
        function ResizeObserverEntry2(target, rectInit) {
          var contentRect = createReadOnlyRect(rectInit);
          defineConfigurable(this, { target, contentRect });
        }
        return ResizeObserverEntry2;
      }()
    );
    var ResizeObserverSPI = (
      /** @class */
      function() {
        function ResizeObserverSPI2(callback, controller, callbackCtx) {
          this.activeObservations_ = [];
          this.observations_ = new MapShim();
          if (typeof callback !== "function") {
            throw new TypeError("The callback provided as parameter 1 is not a function.");
          }
          this.callback_ = callback;
          this.controller_ = controller;
          this.callbackCtx_ = callbackCtx;
        }
        ResizeObserverSPI2.prototype.observe = function(target) {
          if (!arguments.length) {
            throw new TypeError("1 argument required, but only 0 present.");
          }
          if (typeof Element === "undefined" || !(Element instanceof Object)) {
            return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          if (observations.has(target)) {
            return;
          }
          observations.set(target, new ResizeObservation(target));
          this.controller_.addObserver(this);
          this.controller_.refresh();
        };
        ResizeObserverSPI2.prototype.unobserve = function(target) {
          if (!arguments.length) {
            throw new TypeError("1 argument required, but only 0 present.");
          }
          if (typeof Element === "undefined" || !(Element instanceof Object)) {
            return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          if (!observations.has(target)) {
            return;
          }
          observations.delete(target);
          if (!observations.size) {
            this.controller_.removeObserver(this);
          }
        };
        ResizeObserverSPI2.prototype.disconnect = function() {
          this.clearActive();
          this.observations_.clear();
          this.controller_.removeObserver(this);
        };
        ResizeObserverSPI2.prototype.gatherActive = function() {
          var _this = this;
          this.clearActive();
          this.observations_.forEach(function(observation) {
            if (observation.isActive()) {
              _this.activeObservations_.push(observation);
            }
          });
        };
        ResizeObserverSPI2.prototype.broadcastActive = function() {
          if (!this.hasActive()) {
            return;
          }
          var ctx = this.callbackCtx_;
          var entries = this.activeObservations_.map(function(observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
          });
          this.callback_.call(ctx, entries, ctx);
          this.clearActive();
        };
        ResizeObserverSPI2.prototype.clearActive = function() {
          this.activeObservations_.splice(0);
        };
        ResizeObserverSPI2.prototype.hasActive = function() {
          return this.activeObservations_.length > 0;
        };
        return ResizeObserverSPI2;
      }()
    );
    var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
    var ResizeObserver$2 = (
      /** @class */
      function() {
        function ResizeObserver2(callback) {
          if (!(this instanceof ResizeObserver2)) {
            throw new TypeError("Cannot call a class as a function.");
          }
          if (!arguments.length) {
            throw new TypeError("1 argument required, but only 0 present.");
          }
          var controller = ResizeObserverController.getInstance();
          var observer = new ResizeObserverSPI(callback, controller, this);
          observers.set(this, observer);
        }
        return ResizeObserver2;
      }()
    );
    [
      "observe",
      "unobserve",
      "disconnect"
    ].forEach(function(method2) {
      ResizeObserver$2.prototype[method2] = function() {
        var _a;
        return (_a = observers.get(this))[method2].apply(_a, arguments);
      };
    });
    var index$3 = function() {
      if (typeof global$1.ResizeObserver !== "undefined") {
        return global$1.ResizeObserver;
      }
      return ResizeObserver$2;
    }();
    var elementListeners = /* @__PURE__ */ new Map();
    function onResize(entities) {
      entities.forEach(function(entity) {
        var _elementListeners$get;
        var target = entity.target;
        (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 ? void 0 : _elementListeners$get.forEach(function(listener) {
          return listener(target);
        });
      });
    }
    var resizeObserver = new index$3(onResize);
    function observe(element, callback) {
      if (!elementListeners.has(element)) {
        elementListeners.set(element, /* @__PURE__ */ new Set());
        resizeObserver.observe(element);
      }
      elementListeners.get(element).add(callback);
    }
    function unobserve(element, callback) {
      if (elementListeners.has(element)) {
        elementListeners.get(element).delete(callback);
        if (!elementListeners.get(element).size) {
          resizeObserver.unobserve(element);
          elementListeners.delete(element);
        }
      }
    }
    var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
      _inherits(DomWrapper2, _React$Component);
      var _super = _createSuper(DomWrapper2);
      function DomWrapper2() {
        _classCallCheck(this, DomWrapper2);
        return _super.apply(this, arguments);
      }
      _createClass(DomWrapper2, [{
        key: "render",
        value: function render2() {
          return this.props.children;
        }
      }]);
      return DomWrapper2;
    }(reactExports.Component);
    var CollectionContext = /* @__PURE__ */ reactExports.createContext(null);
    function Collection(_ref) {
      var children = _ref.children, onBatchResize = _ref.onBatchResize;
      var resizeIdRef = reactExports.useRef(0);
      var resizeInfosRef = reactExports.useRef([]);
      var onCollectionResize = reactExports.useContext(CollectionContext);
      var onResize2 = reactExports.useCallback(function(size, element, data2) {
        resizeIdRef.current += 1;
        var currentId = resizeIdRef.current;
        resizeInfosRef.current.push({
          size,
          element,
          data: data2
        });
        Promise.resolve().then(function() {
          if (currentId === resizeIdRef.current) {
            onBatchResize === null || onBatchResize === void 0 ? void 0 : onBatchResize(resizeInfosRef.current);
            resizeInfosRef.current = [];
          }
        });
        onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(size, element, data2);
      }, [onBatchResize, onCollectionResize]);
      return /* @__PURE__ */ reactExports.createElement(CollectionContext.Provider, {
        value: onResize2
      }, children);
    }
    function SingleObserver(props, ref) {
      var children = props.children, disabled = props.disabled;
      var elementRef = reactExports.useRef(null);
      var wrapperRef = reactExports.useRef(null);
      var onCollectionResize = reactExports.useContext(CollectionContext);
      var isRenderProps = typeof children === "function";
      var mergedChildren = isRenderProps ? children(elementRef) : children;
      var sizeRef = reactExports.useRef({
        width: -1,
        height: -1,
        offsetWidth: -1,
        offsetHeight: -1
      });
      var canRef = !isRenderProps && /* @__PURE__ */ reactExports.isValidElement(mergedChildren) && supportRef(mergedChildren);
      var originRef = canRef ? mergedChildren.ref : null;
      var mergedRef = reactExports.useMemo(function() {
        return composeRef(originRef, elementRef);
      }, [originRef, elementRef]);
      var getDom = function getDom2() {
        return findDOMNode(elementRef.current) || findDOMNode(wrapperRef.current);
      };
      reactExports.useImperativeHandle(ref, function() {
        return getDom();
      });
      var propsRef = reactExports.useRef(props);
      propsRef.current = props;
      var onInternalResize = reactExports.useCallback(function(target) {
        var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data2 = _propsRef$current.data;
        var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
        var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
        var fixedWidth = Math.floor(width);
        var fixedHeight = Math.floor(height);
        if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
          var size = {
            width: fixedWidth,
            height: fixedHeight,
            offsetWidth,
            offsetHeight
          };
          sizeRef.current = size;
          var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
          var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
          var sizeInfo = _objectSpread2$3(_objectSpread2$3({}, size), {}, {
            offsetWidth: mergedOffsetWidth,
            offsetHeight: mergedOffsetHeight
          });
          onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data2);
          if (onResize2) {
            Promise.resolve().then(function() {
              onResize2(sizeInfo, target);
            });
          }
        }
      }, []);
      reactExports.useEffect(function() {
        var currentElement = getDom();
        if (currentElement && !disabled) {
          observe(currentElement, onInternalResize);
        }
        return function() {
          return unobserve(currentElement, onInternalResize);
        };
      }, [elementRef.current, disabled]);
      return /* @__PURE__ */ reactExports.createElement(DomWrapper$1, {
        ref: wrapperRef
      }, canRef ? /* @__PURE__ */ reactExports.cloneElement(mergedChildren, {
        ref: mergedRef
      }) : mergedChildren);
    }
    var RefSingleObserver = /* @__PURE__ */ reactExports.forwardRef(SingleObserver);
    var INTERNAL_PREFIX_KEY = "rc-observer-key";
    function ResizeObserver$1(props, ref) {
      var children = props.children;
      var childNodes = typeof children === "function" ? [children] : toArray$8(children);
      return childNodes.map(function(child, index2) {
        var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index2);
        return /* @__PURE__ */ reactExports.createElement(RefSingleObserver, _extends$2({}, props, {
          key,
          ref: index2 === 0 ? ref : void 0
        }), child);
      });
    }
    var RefResizeObserver = /* @__PURE__ */ reactExports.forwardRef(ResizeObserver$1);
    RefResizeObserver.Collection = Collection;
    function omit(obj, fields) {
      var clone = _objectSpread2$3({}, obj);
      if (Array.isArray(fields)) {
        fields.forEach(function(key) {
          delete clone[key];
        });
      }
      return clone;
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function murmur2(str) {
      var h2 = 0;
      var k2, i2 = 0, len = str.length;
      for (; len >= 4; ++i2, len -= 4) {
        k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
        k2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
        k2 ^= /* k >>> r: */
        k2 >>> 24;
        h2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i2) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    function _objectWithoutPropertiesLoose$2(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _objectWithoutProperties$1(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose$2(source, excluded);
      var key, i2;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
          key = sourceSymbolKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    const objectWithoutProperties = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: _objectWithoutProperties$1
    }, Symbol.toStringTag, { value: "Module" }));
    function isEqual$1(obj1, obj2) {
      var shallow2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var refSet = /* @__PURE__ */ new Set();
      function deepEqual(a, b2) {
        var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        var circular = refSet.has(a);
        warningOnce$1(!circular, "Warning: There may be circular references");
        if (circular) {
          return false;
        }
        if (a === b2) {
          return true;
        }
        if (shallow2 && level > 1) {
          return false;
        }
        refSet.add(a);
        var newLevel = level + 1;
        if (Array.isArray(a)) {
          if (!Array.isArray(b2) || a.length !== b2.length) {
            return false;
          }
          for (var i2 = 0; i2 < a.length; i2++) {
            if (!deepEqual(a[i2], b2[i2], newLevel)) {
              return false;
            }
          }
          return true;
        }
        if (a && b2 && _typeof$4(a) === "object" && _typeof$4(b2) === "object") {
          var keys2 = Object.keys(a);
          if (keys2.length !== Object.keys(b2).length) {
            return false;
          }
          return keys2.every(function(key) {
            return deepEqual(a[key], b2[key], newLevel);
          });
        }
        return false;
      }
      return deepEqual(obj1, obj2);
    }
    var Entity = /* @__PURE__ */ function() {
      function Entity2() {
        _classCallCheck(this, Entity2);
        _defineProperty$7(this, "cache", /* @__PURE__ */ new Map());
      }
      _createClass(Entity2, [{
        key: "get",
        value: function get2(keys2) {
          return this.cache.get(keys2.join("%")) || null;
        }
      }, {
        key: "update",
        value: function update2(keys2, valueFn) {
          var path2 = keys2.join("%");
          var prevValue = this.cache.get(path2);
          var nextValue = valueFn(prevValue);
          if (nextValue === null) {
            this.cache.delete(path2);
          } else {
            this.cache.set(path2, nextValue);
          }
        }
      }]);
      return Entity2;
    }();
    var ATTR_TOKEN = "data-token-hash";
    var ATTR_MARK = "data-css-hash";
    var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
    var CSS_IN_JS_INSTANCE_ID = Math.random().toString(12).slice(2);
    function createCache() {
      if (typeof document !== "undefined" && document.head && document.body) {
        var styles = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [];
        var firstChild = document.head.firstChild;
        Array.from(styles).forEach(function(style2) {
          style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || CSS_IN_JS_INSTANCE_ID;
          document.head.insertBefore(style2, firstChild);
        });
        var styleHash = {};
        Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function(style2) {
          var hash = style2.getAttribute(ATTR_MARK);
          if (styleHash[hash]) {
            if (style2[CSS_IN_JS_INSTANCE] === CSS_IN_JS_INSTANCE_ID) {
              var _style$parentNode;
              (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
            }
          } else {
            styleHash[hash] = true;
          }
        });
      }
      return new Entity();
    }
    var StyleContext = /* @__PURE__ */ reactExports.createContext({
      hashPriority: "low",
      cache: createCache(),
      defaultCache: true
    });
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
      if (null != _i) {
        var _s, _e2, _x, _r, _arr = [], _n = true, _d = false;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i2) {
            if (Object(_i) !== _i)
              return;
            _n = false;
          } else
            for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true)
              ;
        } catch (err) {
          _d = true, _e2 = err;
        } finally {
          try {
            if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
              return;
          } finally {
            if (_d)
              throw _e2;
          }
        }
        return _arr;
      }
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    const slicedToArray = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: _slicedToArray
    }, Symbol.toStringTag, { value: "Module" }));
    function useClientCache(prefix, keyPath, cacheFn, onCacheRemove) {
      var _React$useContext = reactExports.useContext(StyleContext), globalCache = _React$useContext.cache;
      var fullPath = [prefix].concat(_toConsumableArray(keyPath));
      reactExports.useMemo(
        function() {
          globalCache.update(fullPath, function(prevCache) {
            var _ref = prevCache || [], _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], times = _ref2$ === void 0 ? 0 : _ref2$, cache2 = _ref2[1];
            var tmpCache = cache2;
            var mergedCache = tmpCache || cacheFn();
            return [times + 1, mergedCache];
          });
        },
        /* eslint-disable react-hooks/exhaustive-deps */
        [fullPath.join("_")]
        /* eslint-enable */
      );
      reactExports.useEffect(function() {
        return function() {
          globalCache.update(fullPath, function(prevCache) {
            var _ref3 = prevCache || [], _ref4 = _slicedToArray(_ref3, 2), _ref4$ = _ref4[0], times = _ref4$ === void 0 ? 0 : _ref4$, cache2 = _ref4[1];
            var nextCount = times - 1;
            if (nextCount === 0) {
              onCacheRemove === null || onCacheRemove === void 0 ? void 0 : onCacheRemove(cache2, false);
              return null;
            }
            return [times - 1, cache2];
          });
        };
      }, fullPath);
      return globalCache.get(fullPath)[1];
    }
    function canUseDom$2() {
      return !!(typeof window !== "undefined" && window.document && window.document.createElement);
    }
    function contains$2(root2, n2) {
      if (!root2) {
        return false;
      }
      if (root2.contains) {
        return root2.contains(n2);
      }
      var node2 = n2;
      while (node2) {
        if (node2 === root2) {
          return true;
        }
        node2 = node2.parentNode;
      }
      return false;
    }
    var APPEND_ORDER$1 = "data-rc-order";
    var MARK_KEY$1 = "rc-util-key";
    var containerCache$1 = /* @__PURE__ */ new Map();
    function getMark$1() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark2 = _ref.mark;
      if (mark2) {
        return mark2.startsWith("data-") ? mark2 : "data-".concat(mark2);
      }
      return MARK_KEY$1;
    }
    function getContainer$1(option) {
      if (option.attachTo) {
        return option.attachTo;
      }
      var head = document.querySelector("head");
      return head || document.body;
    }
    function getOrder$1(prepend) {
      if (prepend === "queue") {
        return "prependQueue";
      }
      return prepend ? "prepend" : "append";
    }
    function findStyles$1(container2) {
      return Array.from((containerCache$1.get(container2) || container2).children).filter(function(node2) {
        return node2.tagName === "STYLE";
      });
    }
    function injectCSS$1(css2) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!canUseDom$2()) {
        return null;
      }
      var csp = option.csp, prepend = option.prepend;
      var styleNode = document.createElement("style");
      styleNode.setAttribute(APPEND_ORDER$1, getOrder$1(prepend));
      if (csp !== null && csp !== void 0 && csp.nonce) {
        styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
      }
      styleNode.innerHTML = css2;
      var container2 = getContainer$1(option);
      var firstChild = container2.firstChild;
      if (prepend) {
        if (prepend === "queue") {
          var existStyle = findStyles$1(container2).filter(function(node2) {
            return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER$1));
          });
          if (existStyle.length) {
            container2.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
            return styleNode;
          }
        }
        container2.insertBefore(styleNode, firstChild);
      } else {
        container2.appendChild(styleNode);
      }
      return styleNode;
    }
    function findExistNode$1(key) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var container2 = getContainer$1(option);
      return findStyles$1(container2).find(function(node2) {
        return node2.getAttribute(getMark$1(option)) === key;
      });
    }
    function removeCSS$1(key) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var existNode = findExistNode$1(key, option);
      if (existNode) {
        var container2 = getContainer$1(option);
        container2.removeChild(existNode);
      }
    }
    function syncRealContainer$1(container2, option) {
      var cachedRealContainer = containerCache$1.get(container2);
      if (!cachedRealContainer || !contains$2(document, cachedRealContainer)) {
        var placeholderStyle = injectCSS$1("", option);
        var parentNode = placeholderStyle.parentNode;
        containerCache$1.set(container2, parentNode);
        container2.removeChild(placeholderStyle);
      }
    }
    function updateCSS$1(css2, key) {
      var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var container2 = getContainer$1(option);
      syncRealContainer$1(container2, option);
      var existNode = findExistNode$1(key, option);
      if (existNode) {
        var _option$csp, _option$csp2;
        if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
          var _option$csp3;
          existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
        }
        if (existNode.innerHTML !== css2) {
          existNode.innerHTML = css2;
        }
        return existNode;
      }
      var newNode = injectCSS$1(css2, option);
      newNode.setAttribute(getMark$1(option), key);
      return newNode;
    }
    function flattenToken(token2) {
      var str = "";
      Object.keys(token2).forEach(function(key) {
        var value = token2[key];
        str += key;
        if (value && _typeof$4(value) === "object") {
          str += flattenToken(value);
        } else {
          str += value;
        }
      });
      return str;
    }
    function token2key(token2, salt) {
      return murmur2("".concat(salt, "_").concat(flattenToken(token2)));
    }
    var layerKey = "layer-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, "");
    var layerWidth = "903px";
    function supportSelector(styleStr, handleElement) {
      if (canUseDom$2()) {
        var _ele$parentNode;
        updateCSS$1(styleStr, layerKey);
        var _ele = document.createElement("div");
        _ele.style.position = "fixed";
        _ele.style.left = "0";
        _ele.style.top = "0";
        handleElement === null || handleElement === void 0 ? void 0 : handleElement(_ele);
        document.body.appendChild(_ele);
        var support = getComputedStyle(_ele).width === layerWidth;
        (_ele$parentNode = _ele.parentNode) === null || _ele$parentNode === void 0 ? void 0 : _ele$parentNode.removeChild(_ele);
        removeCSS$1(layerKey);
        return support;
      }
      return false;
    }
    var canLayer = void 0;
    function supportLayer() {
      if (canLayer === void 0) {
        canLayer = supportSelector("@layer ".concat(layerKey, " { .").concat(layerKey, " { width: ").concat(layerWidth, "!important; } }"), function(ele) {
          ele.className = layerKey;
        });
      }
      return canLayer;
    }
    var EMPTY_OVERRIDE = {};
    var hashPrefix = "css";
    var tokenKeys = /* @__PURE__ */ new Map();
    function recordCleanToken(tokenKey) {
      tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
    }
    function removeStyleTags(key) {
      if (typeof document !== "undefined") {
        var styles = document.querySelectorAll("style[".concat(ATTR_TOKEN, '="').concat(key, '"]'));
        styles.forEach(function(style2) {
          if (style2[CSS_IN_JS_INSTANCE] === CSS_IN_JS_INSTANCE_ID) {
            var _style$parentNode;
            (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
          }
        });
      }
    }
    function cleanTokenStyle(tokenKey) {
      tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
      var tokenKeyList = Array.from(tokenKeys.keys());
      var cleanableKeyList = tokenKeyList.filter(function(key) {
        var count = tokenKeys.get(key) || 0;
        return count <= 0;
      });
      if (cleanableKeyList.length < tokenKeyList.length) {
        cleanableKeyList.forEach(function(key) {
          removeStyleTags(key);
          tokenKeys.delete(key);
        });
      }
    }
    function useCacheToken(theme2, tokens) {
      var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var _option$salt = option.salt, salt = _option$salt === void 0 ? "" : _option$salt, _option$override = option.override, override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override, formatToken2 = option.formatToken;
      var mergedToken = reactExports.useMemo(function() {
        return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens)));
      }, [tokens]);
      var tokenStr = reactExports.useMemo(function() {
        return flattenToken(mergedToken);
      }, [mergedToken]);
      var overrideTokenStr = reactExports.useMemo(function() {
        return flattenToken(override);
      }, [override]);
      var cachedToken = useClientCache("token", [salt, theme2.id, tokenStr, overrideTokenStr], function() {
        var derivativeToken = theme2.getDerivativeToken(mergedToken);
        var mergedDerivativeToken = _objectSpread2$3(_objectSpread2$3({}, derivativeToken), override);
        if (formatToken2) {
          mergedDerivativeToken = formatToken2(mergedDerivativeToken);
        }
        var tokenKey = token2key(mergedDerivativeToken, salt);
        mergedDerivativeToken._tokenKey = tokenKey;
        recordCleanToken(tokenKey);
        var hashId = "".concat(hashPrefix, "-").concat(murmur2(tokenKey));
        mergedDerivativeToken._hashId = hashId;
        return [mergedDerivativeToken, hashId];
      }, function(cache2) {
        cleanTokenStyle(cache2[0]._tokenKey);
      });
      return cachedToken;
    }
    var unitlessKeys = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    var COMMENT = "comm";
    var RULESET = "rule";
    var DECLARATION = "decl";
    var IMPORT = "@import";
    var KEYFRAMES = "@keyframes";
    var abs = Math.abs;
    var from = String.fromCharCode;
    function trim$1(value) {
      return value.trim();
    }
    function replace$1(value, pattern2, replacement) {
      return value.replace(pattern2, replacement);
    }
    function indexof(value, search2) {
      return value.indexOf(search2);
    }
    function charat(value, index2) {
      return value.charCodeAt(index2) | 0;
    }
    function substr(value, begin, end2) {
      return value.slice(begin, end2);
    }
    function strlen(value) {
      return value.length;
    }
    function sizeof(value) {
      return value.length;
    }
    function append(value, array2) {
      return array2.push(value), value;
    }
    var line = 1;
    var column = 1;
    var length = 0;
    var position$4 = 0;
    var character = 0;
    var characters = "";
    function node(value, root2, parent, type2, props, children, length2) {
      return { value, root: root2, parent, type: type2, props, children, line, column, length: length2, return: "" };
    }
    function char() {
      return character;
    }
    function prev() {
      character = position$4 > 0 ? charat(characters, --position$4) : 0;
      if (column--, character === 10)
        column = 1, line--;
      return character;
    }
    function next() {
      character = position$4 < length ? charat(characters, position$4++) : 0;
      if (column++, character === 10)
        column = 1, line++;
      return character;
    }
    function peek() {
      return charat(characters, position$4);
    }
    function caret() {
      return position$4;
    }
    function slice$3(begin, end2) {
      return substr(characters, begin, end2);
    }
    function token$2(type2) {
      switch (type2) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
          return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
          return 4;
        case 58:
          return 3;
        case 34:
        case 39:
        case 40:
        case 91:
          return 2;
        case 41:
        case 93:
          return 1;
      }
      return 0;
    }
    function alloc(value) {
      return line = column = 1, length = strlen(characters = value), position$4 = 0, [];
    }
    function dealloc(value) {
      return characters = "", value;
    }
    function delimit(type2) {
      return trim$1(slice$3(position$4 - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
    }
    function whitespace$1(type2) {
      while (character = peek())
        if (character < 33)
          next();
        else
          break;
      return token$2(type2) > 2 || token$2(character) > 3 ? "" : " ";
    }
    function escaping(index2, count) {
      while (--count && next())
        if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
          break;
      return slice$3(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
    }
    function delimiter(type2) {
      while (next())
        switch (character) {
          case type2:
            return position$4;
          case 34:
          case 39:
            if (type2 !== 34 && type2 !== 39)
              delimiter(character);
            break;
          case 40:
            if (type2 === 41)
              delimiter(type2);
            break;
          case 92:
            next();
            break;
        }
      return position$4;
    }
    function commenter(type2, index2) {
      while (next())
        if (type2 + character === 47 + 10)
          break;
        else if (type2 + character === 42 + 42 && peek() === 47)
          break;
      return "/*" + slice$3(index2, position$4 - 1) + "*" + from(type2 === 47 ? type2 : next());
    }
    function identifier(index2) {
      while (!token$2(peek()))
        next();
      return slice$3(index2, position$4);
    }
    function compile(value) {
      return dealloc(parse$1("", null, null, null, [""], value = alloc(value), 0, [0], value));
    }
    function parse$1(value, root2, parent, rule, rules2, rulesets, pseudo, points, declarations) {
      var index2 = 0;
      var offset2 = 0;
      var length2 = pseudo;
      var atrule = 0;
      var property2 = 0;
      var previous2 = 0;
      var variable = 1;
      var scanning = 1;
      var ampersand = 1;
      var character2 = 0;
      var type2 = "";
      var props = rules2;
      var children = rulesets;
      var reference = rule;
      var characters2 = type2;
      while (scanning)
        switch (previous2 = character2, character2 = next()) {
          case 40:
            if (previous2 != 108 && charat(characters2, length2 - 1) == 58) {
              if (indexof(characters2 += replace$1(delimit(character2), "&", "&\f"), "&\f") != -1)
                ampersand = -1;
              break;
            }
          case 34:
          case 39:
          case 91:
            characters2 += delimit(character2);
            break;
          case 9:
          case 10:
          case 13:
          case 32:
            characters2 += whitespace$1(previous2);
            break;
          case 92:
            characters2 += escaping(caret() - 1, 7);
            continue;
          case 47:
            switch (peek()) {
              case 42:
              case 47:
                append(comment(commenter(next(), caret()), root2, parent), declarations);
                break;
              default:
                characters2 += "/";
            }
            break;
          case 123 * variable:
            points[index2++] = strlen(characters2) * ampersand;
          case 125 * variable:
          case 59:
          case 0:
            switch (character2) {
              case 0:
              case 125:
                scanning = 0;
              case 59 + offset2:
                if (property2 > 0 && strlen(characters2) - length2)
                  append(property2 > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
                break;
              case 59:
                characters2 += ";";
              default:
                append(reference = ruleset(characters2, root2, parent, index2, offset2, rules2, points, type2, props = [], children = [], length2), rulesets);
                if (character2 === 123)
                  if (offset2 === 0)
                    parse$1(characters2, root2, reference, reference, props, rulesets, length2, points, children);
                  else
                    switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                      case 100:
                      case 109:
                      case 115:
                        parse$1(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type2, rules2, props = [], length2), children), rules2, children, length2, points, rule ? props : children);
                        break;
                      default:
                        parse$1(characters2, reference, reference, reference, [""], children, 0, points, children);
                    }
            }
            index2 = offset2 = property2 = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
            break;
          case 58:
            length2 = 1 + strlen(characters2), property2 = previous2;
          default:
            if (variable < 1) {
              if (character2 == 123)
                --variable;
              else if (character2 == 125 && variable++ == 0 && prev() == 125)
                continue;
            }
            switch (characters2 += from(character2), character2 * variable) {
              case 38:
                ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
                break;
              case 44:
                points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
                break;
              case 64:
                if (peek() === 45)
                  characters2 += delimit(next());
                atrule = peek(), offset2 = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
                break;
              case 45:
                if (previous2 === 45 && strlen(characters2) == 2)
                  variable = 0;
            }
        }
      return rulesets;
    }
    function ruleset(value, root2, parent, index2, offset2, rules2, points, type2, props, children, length2) {
      var post = offset2 - 1;
      var rule = offset2 === 0 ? rules2 : [""];
      var size = sizeof(rule);
      for (var i2 = 0, j = 0, k2 = 0; i2 < index2; ++i2)
        for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i2])), z2 = value; x2 < size; ++x2)
          if (z2 = trim$1(j > 0 ? rule[x2] + " " + y2 : replace$1(y2, /&\f/g, rule[x2])))
            props[k2++] = z2;
      return node(value, root2, parent, offset2 === 0 ? RULESET : type2, props, children, length2);
    }
    function comment(value, root2, parent) {
      return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
    }
    function declaration(value, root2, parent, length2) {
      return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
    }
    function serialize$1(children, callback) {
      var output = "";
      var length2 = sizeof(children);
      for (var i2 = 0; i2 < length2; i2++)
        output += callback(children[i2], i2, children, callback) || "";
      return output;
    }
    function stringify$4(element, index2, children, callback) {
      switch (element.type) {
        case IMPORT:
        case DECLARATION:
          return element.return = element.return || element.value;
        case COMMENT:
          return "";
        case KEYFRAMES:
          return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
        case RULESET:
          element.value = element.props.join(",");
      }
      return strlen(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
    }
    var isClientSide = canUseDom$2();
    var SKIP_CHECK = "_skip_check_";
    function normalizeStyle(styleStr) {
      var serialized = serialize$1(compile(styleStr), stringify$4);
      return serialized.replace(/\{%%%\:[^;];}/g, ";");
    }
    function isCompoundCSSProperty(value) {
      return _typeof$4(value) === "object" && value && SKIP_CHECK in value;
    }
    function injectSelectorHash(key, hashId, hashPriority) {
      if (!hashId) {
        return key;
      }
      var hashClassName = ".".concat(hashId);
      var hashSelector = hashPriority === "low" ? ":where(".concat(hashClassName, ")") : hashClassName;
      var keys2 = key.split(",").map(function(k2) {
        var _firstPath$match;
        var fullPath = k2.trim().split(/\s+/);
        var firstPath = fullPath[0] || "";
        var htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || "";
        firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));
        return [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(" ");
      });
      return keys2.join(",");
    }
    var globalEffectStyleKeys = /* @__PURE__ */ new Set();
    var parseStyle = function parseStyle2(interpolation) {
      var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        root: true,
        parentSelectors: []
      }, root2 = _ref.root, injectHash = _ref.injectHash, parentSelectors = _ref.parentSelectors;
      var hashId = config.hashId, layer = config.layer;
      config.path;
      var hashPriority = config.hashPriority, _config$transformers = config.transformers, transformers = _config$transformers === void 0 ? [] : _config$transformers;
      config.linters;
      var styleStr = "";
      var effectStyle = {};
      function parseKeyframes(keyframes) {
        var animationName = keyframes.getName(hashId);
        if (!effectStyle[animationName]) {
          var _parseStyle = parseStyle2(keyframes.style, config, {
            root: false,
            parentSelectors
          }), _parseStyle2 = _slicedToArray(_parseStyle, 1), _parsedStr = _parseStyle2[0];
          effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
        }
      }
      function flattenList(list2) {
        var fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        list2.forEach(function(item) {
          if (Array.isArray(item)) {
            flattenList(item, fullList);
          } else if (item) {
            fullList.push(item);
          }
        });
        return fullList;
      }
      var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
      flattenStyleList.forEach(function(originStyle) {
        var style2 = typeof originStyle === "string" && !root2 ? {} : originStyle;
        if (typeof style2 === "string") {
          styleStr += "".concat(style2, "\n");
        } else if (style2._keyframe) {
          parseKeyframes(style2);
        } else {
          var mergedStyle = transformers.reduce(function(prev2, trans) {
            var _trans$visit;
            return (trans === null || trans === void 0 ? void 0 : (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev2)) || prev2;
          }, style2);
          Object.keys(mergedStyle).forEach(function(key) {
            var value = mergedStyle[key];
            if (_typeof$4(value) === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
              var subInjectHash = false;
              var mergedKey = key.trim();
              var nextRoot = false;
              if ((root2 || injectHash) && hashId) {
                if (mergedKey.startsWith("@")) {
                  subInjectHash = true;
                } else {
                  mergedKey = injectSelectorHash(key, hashId, hashPriority);
                }
              } else if (root2 && !hashId && (mergedKey === "&" || mergedKey === "")) {
                mergedKey = "";
                nextRoot = true;
              }
              var _parseStyle3 = parseStyle2(value, config, {
                root: nextRoot,
                injectHash: subInjectHash,
                parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])
              }), _parseStyle4 = _slicedToArray(_parseStyle3, 2), _parsedStr2 = _parseStyle4[0], childEffectStyle = _parseStyle4[1];
              effectStyle = _objectSpread2$3(_objectSpread2$3({}, effectStyle), childEffectStyle);
              styleStr += "".concat(mergedKey).concat(_parsedStr2);
            } else {
              var _value;
              var actualValue = (_value = value === null || value === void 0 ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
              var styleName = key.replace(/[A-Z]/g, function(match2) {
                return "-".concat(match2.toLowerCase());
              });
              var formatValue2 = actualValue;
              if (!unitlessKeys[key] && typeof formatValue2 === "number" && formatValue2 !== 0) {
                formatValue2 = "".concat(formatValue2, "px");
              }
              if (key === "animationName" && value !== null && value !== void 0 && value._keyframe) {
                parseKeyframes(value);
                formatValue2 = value.getName(hashId);
              }
              styleStr += "".concat(styleName, ":").concat(formatValue2, ";");
            }
          });
        }
      });
      if (!root2) {
        styleStr = "{".concat(styleStr, "}");
      } else if (layer && supportLayer()) {
        var layerCells = layer.split(",");
        var layerName = layerCells[layerCells.length - 1].trim();
        styleStr = "@layer ".concat(layerName, " {").concat(styleStr, "}");
        if (layerCells.length > 1) {
          styleStr = "@layer ".concat(layer, "{%%%:%}").concat(styleStr);
        }
      }
      return [styleStr, effectStyle];
    };
    function uniqueHash(path2, styleStr) {
      return murmur2("".concat(path2.join("%")).concat(styleStr));
    }
    function Empty$3() {
      return null;
    }
    function useStyleRegister(info2, styleFn) {
      var token2 = info2.token, path2 = info2.path, hashId = info2.hashId, layer = info2.layer;
      var _React$useContext = reactExports.useContext(StyleContext), autoClear = _React$useContext.autoClear;
      _React$useContext.mock;
      var defaultCache = _React$useContext.defaultCache, hashPriority = _React$useContext.hashPriority, container2 = _React$useContext.container, ssrInline = _React$useContext.ssrInline, transformers = _React$useContext.transformers, linters = _React$useContext.linters;
      var tokenKey = token2._tokenKey;
      var fullPath = [tokenKey].concat(_toConsumableArray(path2));
      var isMergedClientSide = isClientSide;
      var _useGlobalCache = useClientCache(
        "style",
        fullPath,
        // Create cache if needed
        function() {
          var styleObj = styleFn();
          var _parseStyle5 = parseStyle(styleObj, {
            hashId,
            hashPriority,
            layer,
            path: path2.join("-"),
            transformers,
            linters
          }), _parseStyle6 = _slicedToArray(_parseStyle5, 2), parsedStyle = _parseStyle6[0], effectStyle = _parseStyle6[1];
          var styleStr = normalizeStyle(parsedStyle);
          var styleId = uniqueHash(fullPath, styleStr);
          if (isMergedClientSide) {
            var style2 = updateCSS$1(styleStr, styleId, {
              mark: ATTR_MARK,
              prepend: "queue",
              attachTo: container2
            });
            style2[CSS_IN_JS_INSTANCE] = CSS_IN_JS_INSTANCE_ID;
            style2.setAttribute(ATTR_TOKEN, tokenKey);
            Object.keys(effectStyle).forEach(function(effectKey) {
              if (!globalEffectStyleKeys.has(effectKey)) {
                globalEffectStyleKeys.add(effectKey);
                updateCSS$1(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), {
                  mark: ATTR_MARK,
                  prepend: "queue",
                  attachTo: container2
                });
              }
            });
          }
          return [styleStr, tokenKey, styleId];
        },
        // Remove cache if no need
        function(_ref2, fromHMR) {
          var _ref3 = _slicedToArray(_ref2, 3), styleId = _ref3[2];
          if ((fromHMR || autoClear) && isClientSide) {
            removeCSS$1(styleId, {
              mark: ATTR_MARK
            });
          }
        }
      ), _useGlobalCache2 = _slicedToArray(_useGlobalCache, 3), cachedStyleStr = _useGlobalCache2[0], cachedTokenKey = _useGlobalCache2[1], cachedStyleId = _useGlobalCache2[2];
      return function(node2) {
        var styleNode;
        if (!ssrInline || isMergedClientSide || !defaultCache) {
          styleNode = /* @__PURE__ */ reactExports.createElement(Empty$3, null);
        } else {
          var _ref4;
          styleNode = /* @__PURE__ */ reactExports.createElement("style", _extends$2({}, (_ref4 = {}, _defineProperty$7(_ref4, ATTR_TOKEN, cachedTokenKey), _defineProperty$7(_ref4, ATTR_MARK, cachedStyleId), _ref4), {
            dangerouslySetInnerHTML: {
              __html: cachedStyleStr
            }
          }));
        }
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, styleNode, node2);
      };
    }
    var Keyframe = /* @__PURE__ */ function() {
      function Keyframe2(name, style2) {
        _classCallCheck(this, Keyframe2);
        _defineProperty$7(this, "name", void 0);
        _defineProperty$7(this, "style", void 0);
        _defineProperty$7(this, "_keyframe", true);
        this.name = name;
        this.style = style2;
      }
      _createClass(Keyframe2, [{
        key: "getName",
        value: function getName() {
          var hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
        }
      }]);
      return Keyframe2;
    }();
    function sameDerivativeOption(left, right) {
      if (left.length !== right.length) {
        return false;
      }
      for (var i2 = 0; i2 < left.length; i2++) {
        if (left[i2] !== right[i2]) {
          return false;
        }
      }
      return true;
    }
    var ThemeCache = /* @__PURE__ */ function() {
      function ThemeCache2() {
        _classCallCheck(this, ThemeCache2);
        _defineProperty$7(this, "cache", void 0);
        _defineProperty$7(this, "keys", void 0);
        _defineProperty$7(this, "cacheCallTimes", void 0);
        this.cache = /* @__PURE__ */ new Map();
        this.keys = [];
        this.cacheCallTimes = 0;
      }
      _createClass(ThemeCache2, [{
        key: "size",
        value: function size() {
          return this.keys.length;
        }
      }, {
        key: "internalGet",
        value: function internalGet(derivativeOption) {
          var _cache2, _cache3;
          var updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var cache2 = {
            map: this.cache
          };
          derivativeOption.forEach(function(derivative2) {
            if (!cache2) {
              cache2 = void 0;
            } else {
              var _cache, _cache$map;
              cache2 = (_cache = cache2) === null || _cache === void 0 ? void 0 : (_cache$map = _cache.map) === null || _cache$map === void 0 ? void 0 : _cache$map.get(derivative2);
            }
          });
          if ((_cache2 = cache2) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes) {
            cache2.value[1] = this.cacheCallTimes++;
          }
          return (_cache3 = cache2) === null || _cache3 === void 0 ? void 0 : _cache3.value;
        }
      }, {
        key: "get",
        value: function get2(derivativeOption) {
          var _this$internalGet;
          return (_this$internalGet = this.internalGet(derivativeOption, true)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
        }
      }, {
        key: "has",
        value: function has2(derivativeOption) {
          return !!this.internalGet(derivativeOption);
        }
      }, {
        key: "set",
        value: function set2(derivativeOption, value) {
          var _this = this;
          if (!this.has(derivativeOption)) {
            if (this.size() + 1 > ThemeCache2.MAX_CACHE_SIZE + ThemeCache2.MAX_CACHE_OFFSET) {
              var _this$keys$reduce = this.keys.reduce(function(result, key) {
                var _result = _slicedToArray(result, 2), callTimes = _result[1];
                if (_this.internalGet(key)[1] < callTimes) {
                  return [key, _this.internalGet(key)[1]];
                }
                return result;
              }, [this.keys[0], this.cacheCallTimes]), _this$keys$reduce2 = _slicedToArray(_this$keys$reduce, 1), targetKey = _this$keys$reduce2[0];
              this.delete(targetKey);
            }
            this.keys.push(derivativeOption);
          }
          var cache2 = this.cache;
          derivativeOption.forEach(function(derivative2, index2) {
            if (index2 === derivativeOption.length - 1) {
              cache2.set(derivative2, {
                value: [value, _this.cacheCallTimes++]
              });
            } else {
              var cacheValue = cache2.get(derivative2);
              if (!cacheValue) {
                cache2.set(derivative2, {
                  map: /* @__PURE__ */ new Map()
                });
              } else if (!cacheValue.map) {
                cacheValue.map = /* @__PURE__ */ new Map();
              }
              cache2 = cache2.get(derivative2).map;
            }
          });
        }
      }, {
        key: "deleteByPath",
        value: function deleteByPath(currentCache, derivatives) {
          var cache2 = currentCache.get(derivatives[0]);
          if (derivatives.length === 1) {
            var _cache$value;
            if (!cache2.map) {
              currentCache.delete(derivatives[0]);
            } else {
              currentCache.set(derivatives[0], {
                map: cache2.map
              });
            }
            return (_cache$value = cache2.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
          }
          var result = this.deleteByPath(cache2.map, derivatives.slice(1));
          if ((!cache2.map || cache2.map.size === 0) && !cache2.value) {
            currentCache.delete(derivatives[0]);
          }
          return result;
        }
      }, {
        key: "delete",
        value: function _delete2(derivativeOption) {
          if (this.has(derivativeOption)) {
            this.keys = this.keys.filter(function(item) {
              return !sameDerivativeOption(item, derivativeOption);
            });
            return this.deleteByPath(this.cache, derivativeOption);
          }
          return void 0;
        }
      }]);
      return ThemeCache2;
    }();
    _defineProperty$7(ThemeCache, "MAX_CACHE_SIZE", 20);
    _defineProperty$7(ThemeCache, "MAX_CACHE_OFFSET", 5);
    var uuid$6 = 0;
    var Theme = /* @__PURE__ */ function() {
      function Theme2(derivatives) {
        _classCallCheck(this, Theme2);
        _defineProperty$7(this, "derivatives", void 0);
        _defineProperty$7(this, "id", void 0);
        this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
        this.id = uuid$6;
        if (derivatives.length === 0) {
          warning$5(derivatives.length > 0);
        }
        uuid$6 += 1;
      }
      _createClass(Theme2, [{
        key: "getDerivativeToken",
        value: function getDerivativeToken(token2) {
          return this.derivatives.reduce(function(result, derivative2) {
            return derivative2(token2, result);
          }, void 0);
        }
      }]);
      return Theme2;
    }();
    var cacheThemes = new ThemeCache();
    function createTheme(derivatives) {
      var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
      if (!cacheThemes.has(derivativeArr)) {
        cacheThemes.set(derivativeArr, new Theme(derivativeArr));
      }
      return cacheThemes.get(derivativeArr);
    }
    function noSplit(list2) {
      list2.notSplit = true;
      return list2;
    }
    ({
      // Inset
      inset: ["top", "right", "bottom", "left"],
      insetBlock: ["top", "bottom"],
      insetBlockStart: ["top"],
      insetBlockEnd: ["bottom"],
      insetInline: ["left", "right"],
      insetInlineStart: ["left"],
      insetInlineEnd: ["right"],
      // Margin
      marginBlock: ["marginTop", "marginBottom"],
      marginBlockStart: ["marginTop"],
      marginBlockEnd: ["marginBottom"],
      marginInline: ["marginLeft", "marginRight"],
      marginInlineStart: ["marginLeft"],
      marginInlineEnd: ["marginRight"],
      // Padding
      paddingBlock: ["paddingTop", "paddingBottom"],
      paddingBlockStart: ["paddingTop"],
      paddingBlockEnd: ["paddingBottom"],
      paddingInline: ["paddingLeft", "paddingRight"],
      paddingInlineStart: ["paddingLeft"],
      paddingInlineEnd: ["paddingRight"],
      // Border
      borderBlock: noSplit(["borderTop", "borderBottom"]),
      borderBlockStart: noSplit(["borderTop"]),
      borderBlockEnd: noSplit(["borderBottom"]),
      borderInline: noSplit(["borderLeft", "borderRight"]),
      borderInlineStart: noSplit(["borderLeft"]),
      borderInlineEnd: noSplit(["borderRight"]),
      // Border width
      borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
      borderBlockStartWidth: ["borderTopWidth"],
      borderBlockEndWidth: ["borderBottomWidth"],
      borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
      borderInlineStartWidth: ["borderLeftWidth"],
      borderInlineEndWidth: ["borderRightWidth"],
      // Border style
      borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
      borderBlockStartStyle: ["borderTopStyle"],
      borderBlockEndStyle: ["borderBottomStyle"],
      borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
      borderInlineStartStyle: ["borderLeftStyle"],
      borderInlineEndStyle: ["borderRightStyle"],
      // Border color
      borderBlockColor: ["borderTopColor", "borderBottomColor"],
      borderBlockStartColor: ["borderTopColor"],
      borderBlockEndColor: ["borderBottomColor"],
      borderInlineColor: ["borderLeftColor", "borderRightColor"],
      borderInlineStartColor: ["borderLeftColor"],
      borderInlineEndColor: ["borderRightColor"],
      // Border radius
      borderStartStartRadius: ["borderTopLeftRadius"],
      borderStartEndRadius: ["borderTopRightRadius"],
      borderEndStartRadius: ["borderBottomLeftRadius"],
      borderEndEndRadius: ["borderBottomRightRadius"]
    });
    var IconContext$2 = /* @__PURE__ */ reactExports.createContext({});
    const Context$3 = IconContext$2;
    var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
    var warningFunc = function warningFunc2() {
      warningOnce$1(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
    };
    var Context$2 = /* @__PURE__ */ reactExports.createContext({
      getFieldValue: warningFunc,
      getFieldsValue: warningFunc,
      getFieldError: warningFunc,
      getFieldWarning: warningFunc,
      getFieldsError: warningFunc,
      isFieldsTouched: warningFunc,
      isFieldTouched: warningFunc,
      isFieldValidating: warningFunc,
      isFieldsValidating: warningFunc,
      resetFields: warningFunc,
      setFields: warningFunc,
      setFieldValue: warningFunc,
      setFieldsValue: warningFunc,
      validateFields: warningFunc,
      submit: warningFunc,
      getInternalHooks: function getInternalHooks() {
        warningFunc();
        return {
          dispatch: warningFunc,
          initEntityValue: warningFunc,
          registerField: warningFunc,
          useSubscribe: warningFunc,
          setInitialValues: warningFunc,
          destroyForm: warningFunc,
          setCallbacks: warningFunc,
          registerWatch: warningFunc,
          getFields: warningFunc,
          setValidateMessages: warningFunc,
          setPreserve: warningFunc,
          getInitialValue: warningFunc
        };
      }
    });
    function toArray$7(value) {
      if (value === void 0 || value === null) {
        return [];
      }
      return Array.isArray(value) ? value : [value];
    }
    function _regeneratorRuntime() {
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return exports2;
      };
      var exports2 = {}, Op = Object.prototype, hasOwn2 = Op.hasOwnProperty, defineProperty2 = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function define2(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap2(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator2 = Object.create(protoGenerator.prototype), context = new Context2(tryLocsList || []);
        return defineProperty2(generator2, "_invoke", {
          value: makeInvokeMethod(innerFn, self2, context)
        }), generator2;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports2.wrap = wrap2;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto2 = Object.getPrototypeOf, NativeIteratorPrototype = getProto2 && getProto2(getProto2(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn2.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype2) {
        ["next", "throw", "return"].forEach(function(method2) {
          define(prototype2, method2, function(arg) {
            return this._invoke(method2, arg);
          });
        });
      }
      function AsyncIterator(generator2, PromiseImpl) {
        function invoke(method2, arg, resolve, reject) {
          var record = tryCatch(generator2[method2], generator2, arg);
          if ("throw" !== record.type) {
            var result = record.arg, value = result.value;
            return value && "object" == _typeof$4(value) && hasOwn2.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty2(this, "_invoke", {
          value: function value(method2, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method2, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self2, context) {
        var state = "suspendedStart";
        return function(method2, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method2)
              throw arg;
            return doneResult();
          }
          for (context.method = method2, context.arg = arg; ; ) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context.method)
              context.sent = context._sent = context.arg;
            else if ("throw" === context.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else
              "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self2, context);
            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return {
                value: record.arg,
                done: context.done
              };
            }
            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method, method2 = delegate.iterator[methodName];
        if (void 0 === method2)
          return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch(method2, delegate.iterator, context.arg);
        if ("throw" === record.type)
          return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info2 = record.arg;
        return info2 ? info2.done ? (context[delegate.resultName] = info2.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info2 : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context2(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i2 = -1, next2 = function next3() {
              for (; ++i2 < iterable.length; )
                if (hasOwn2.call(iterable, i2))
                  return next3.value = iterable[i2], next3.done = false, next3;
              return next3.value = void 0, next3.done = true, next3;
            };
            return next2.next = next2;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: void 0,
          done: true
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty2(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), defineProperty2(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports2.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports2.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap2(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
        return this;
      }), define(Gp, "toString", function() {
        return "[object Generator]";
      }), exports2.keys = function(val) {
        var object2 = Object(val), keys2 = [];
        for (var key in object2)
          keys2.push(key);
        return keys2.reverse(), function next2() {
          for (; keys2.length; ) {
            var key2 = keys2.pop();
            if (key2 in object2)
              return next2.value = key2, next2.done = false, next2;
          }
          return next2.done = true, next2;
        };
      }, exports2.values = values, Context2.prototype = {
        constructor: Context2,
        reset: function reset2(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this)
              "t" === name.charAt(0) && hasOwn2.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        },
        stop: function stop() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done)
            throw exception;
          var context = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
          }
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2], record = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn2.call(entry, "catchLoc"), hasFinally = hasOwn2.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type2, arg) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc <= this.prev && hasOwn2.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type2 || "continue" === type2) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type2, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type)
            throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports2;
    }
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info2 = gen[key](arg);
        var value = info2.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info2.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function _extends$1() {
      _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$1.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    var formatRegExp = /%[sdj%]/g;
    var warning$4 = function warning2() {
    };
    if (typeof process !== "undefined" && process.env && false) {
      warning$4 = function warning2(type2, errors) {
        if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
          if (errors.every(function(e2) {
            return typeof e2 === "string";
          })) {
            console.warn(type2, errors);
          }
        }
      };
    }
    function convertFieldsError(errors) {
      if (!errors || !errors.length)
        return null;
      var fields = {};
      errors.forEach(function(error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }
    function format$1(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var i2 = 0;
      var len = args.length;
      if (typeof template === "function") {
        return template.apply(null, args);
      }
      if (typeof template === "string") {
        var str = template.replace(formatRegExp, function(x2) {
          if (x2 === "%%") {
            return "%";
          }
          if (i2 >= len) {
            return x2;
          }
          switch (x2) {
            case "%s":
              return String(args[i2++]);
            case "%d":
              return Number(args[i2++]);
            case "%j":
              try {
                return JSON.stringify(args[i2++]);
              } catch (_) {
                return "[Circular]";
              }
              break;
            default:
              return x2;
          }
        });
        return str;
      }
      return template;
    }
    function isNativeStringType(type2) {
      return type2 === "string" || type2 === "url" || type2 === "hex" || type2 === "email" || type2 === "date" || type2 === "pattern";
    }
    function isEmptyValue(value, type2) {
      if (value === void 0 || value === null) {
        return true;
      }
      if (type2 === "array" && Array.isArray(value) && !value.length) {
        return true;
      }
      if (isNativeStringType(type2) && typeof value === "string" && !value) {
        return true;
      }
      return false;
    }
    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total = 0;
      var arrLength = arr.length;
      function count(errors) {
        results.push.apply(results, errors || []);
        total++;
        if (total === arrLength) {
          callback(results);
        }
      }
      arr.forEach(function(a) {
        func(a, count);
      });
    }
    function asyncSerialArray(arr, func, callback) {
      var index2 = 0;
      var arrLength = arr.length;
      function next2(errors) {
        if (errors && errors.length) {
          callback(errors);
          return;
        }
        var original = index2;
        index2 = index2 + 1;
        if (original < arrLength) {
          func(arr[original], next2);
        } else {
          callback([]);
        }
      }
      next2([]);
    }
    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function(k2) {
        ret.push.apply(ret, objArr[k2] || []);
      });
      return ret;
    }
    var AsyncValidationError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(AsyncValidationError2, _Error);
      function AsyncValidationError2(errors, fields) {
        var _this;
        _this = _Error.call(this, "Async Validation Error") || this;
        _this.errors = errors;
        _this.fields = fields;
        return _this;
      }
      return AsyncValidationError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function(resolve, reject) {
          var next2 = function next3(errors) {
            callback(errors);
            return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
          };
          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next2);
        });
        _pending["catch"](function(e2) {
          return e2;
        });
        return _pending;
      }
      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total = 0;
      var results = [];
      var pending = new Promise(function(resolve, reject) {
        var next2 = function next3(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
          }
        };
        if (!objArrKeys.length) {
          callback(results);
          resolve(source);
        }
        objArrKeys.forEach(function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next2);
          } else {
            asyncParallelArray(arr, func, next2);
          }
        });
      });
      pending["catch"](function(e2) {
        return e2;
      });
      return pending;
    }
    function isErrorObj(obj) {
      return !!(obj && obj.message !== void 0);
    }
    function getValue$4(value, path2) {
      var v2 = value;
      for (var i2 = 0; i2 < path2.length; i2++) {
        if (v2 == void 0) {
          return v2;
        }
        v2 = v2[path2[i2]];
      }
      return v2;
    }
    function complementError(rule, source) {
      return function(oe2) {
        var fieldValue;
        if (rule.fullFields) {
          fieldValue = getValue$4(source, rule.fullFields);
        } else {
          fieldValue = source[oe2.field || rule.fullField];
        }
        if (isErrorObj(oe2)) {
          oe2.field = oe2.field || rule.fullField;
          oe2.fieldValue = fieldValue;
          return oe2;
        }
        return {
          message: typeof oe2 === "function" ? oe2() : oe2,
          fieldValue,
          field: oe2.field || rule.fullField
        };
      };
    }
    function deepMerge(target, source) {
      if (source) {
        for (var s in source) {
          if (source.hasOwnProperty(s)) {
            var value = source[s];
            if (typeof value === "object" && typeof target[s] === "object") {
              target[s] = _extends$1({}, target[s], value);
            } else {
              target[s] = value;
            }
          }
        }
      }
      return target;
    }
    var required$1 = function required2(rule, value, source, errors, options, type2) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type2 || rule.type))) {
        errors.push(format$1(options.messages.required, rule.fullField));
      }
    };
    var whitespace = function whitespace2(rule, value, source, errors, options) {
      if (/^\s+$/.test(value) || value === "") {
        errors.push(format$1(options.messages.whitespace, rule.fullField));
      }
    };
    var urlReg;
    var getUrlRegex = function() {
      if (urlReg) {
        return urlReg;
      }
      var word = "[a-fA-F\\d:]";
      var b2 = function b3(options) {
        return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
      };
      var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      var v6seg = "[a-fA-F\\d]{1,4}";
      var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
      var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
      var v4exact = new RegExp("^" + v4 + "$");
      var v6exact = new RegExp("^" + v6 + "$");
      var ip = function ip2(options) {
        return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
      };
      ip.v4 = function(options) {
        return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
      };
      ip.v6 = function(options) {
        return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
      };
      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = "(?:\\S+(?::\\S*)?@)?";
      var ipv4 = ip.v4().source;
      var ipv6 = ip.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain2 = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = "(?::\\d{2,5})?";
      var path2 = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain2 + tld + ")" + port + path2;
      urlReg = new RegExp("(?:^" + regex + "$)", "i");
      return urlReg;
    };
    var pattern$2 = {
      // http://emailregex.com/
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      // url: new RegExp(
      //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      //   'i',
      // ),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types$6 = {
      integer: function integer2(value) {
        return types$6.number(value) && parseInt(value, 10) === value;
      },
      "float": function float(value) {
        return types$6.number(value) && !types$6.integer(value);
      },
      array: function array2(value) {
        return Array.isArray(value);
      },
      regexp: function regexp2(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e2) {
          return false;
        }
      },
      date: function date2(value) {
        return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
      },
      number: function number2(value) {
        if (isNaN(value)) {
          return false;
        }
        return typeof value === "number";
      },
      object: function object2(value) {
        return typeof value === "object" && !types$6.array(value);
      },
      method: function method2(value) {
        return typeof value === "function";
      },
      email: function email(value) {
        return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
      },
      url: function url(value) {
        return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex(value) {
        return typeof value === "string" && !!value.match(pattern$2.hex);
      }
    };
    var type$1 = function type2(rule, value, source, errors, options) {
      if (rule.required && value === void 0) {
        required$1(rule, value, source, errors, options);
        return;
      }
      var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
      var ruleType = rule.type;
      if (custom.indexOf(ruleType) > -1) {
        if (!types$6[ruleType](value)) {
          errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      } else if (ruleType && typeof value !== rule.type) {
        errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    };
    var range = function range2(rule, value, source, errors, options) {
      var len = typeof rule.len === "number";
      var min = typeof rule.min === "number";
      var max = typeof rule.max === "number";
      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === "number";
      var str = typeof value === "string";
      var arr = Array.isArray(value);
      if (num) {
        key = "number";
      } else if (str) {
        key = "string";
      } else if (arr) {
        key = "array";
      }
      if (!key) {
        return false;
      }
      if (arr) {
        val = value.length;
      }
      if (str) {
        val = value.replace(spRegexp, "_").length;
      }
      if (len) {
        if (val !== rule.len) {
          errors.push(format$1(options.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min && !max && val < rule.min) {
        errors.push(format$1(options.messages[key].min, rule.fullField, rule.min));
      } else if (max && !min && val > rule.max) {
        errors.push(format$1(options.messages[key].max, rule.fullField, rule.max));
      } else if (min && max && (val < rule.min || val > rule.max)) {
        errors.push(format$1(options.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };
    var ENUM$1 = "enum";
    var enumerable$1 = function enumerable2(rule, value, source, errors, options) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
      if (rule[ENUM$1].indexOf(value) === -1) {
        errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
      }
    };
    var pattern$1 = function pattern2(rule, value, source, errors, options) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          rule.pattern.lastIndex = 0;
          if (!rule.pattern.test(value)) {
            errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === "string") {
          var _pattern = new RegExp(rule.pattern);
          if (!_pattern.test(value)) {
            errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };
    var rules = {
      required: required$1,
      whitespace,
      type: type$1,
      range,
      "enum": enumerable$1,
      pattern: pattern$1
    };
    var string$2 = function string2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "string");
        if (!isEmptyValue(value, "string")) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
          rules.pattern(rule, value, source, errors, options);
          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var method = function method2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var number$3 = function number2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (value === "") {
          value = void 0;
        }
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var _boolean = function _boolean2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var regexp = function regexp2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var integer = function integer2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var floatFn = function floatFn2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var array = function array2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if ((value === void 0 || value === null) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "array");
        if (value !== void 0 && value !== null) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var object = function object2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var ENUM = "enum";
    var enumerable = function enumerable2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules[ENUM](rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var pattern = function pattern2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "string")) {
          rules.pattern(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var date = function date2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "date") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "date")) {
          var dateObject;
          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }
          rules.type(rule, dateObject, source, errors, options);
          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var required = function required2(rule, value, callback, source, options) {
      var errors = [];
      var type2 = Array.isArray(value) ? "array" : typeof value;
      rules.required(rule, value, source, errors, options, type2);
      callback(errors);
    };
    var type = function type2(rule, value, callback, source, options) {
      var ruleType = rule.type;
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, ruleType);
        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var any = function any2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
      }
      callback(errors);
    };
    var validators$2 = {
      string: string$2,
      method,
      number: number$3,
      "boolean": _boolean,
      regexp,
      integer,
      "float": floatFn,
      array,
      object,
      "enum": enumerable,
      pattern,
      date,
      url: type,
      hex: type,
      email: type,
      required,
      any
    };
    function newMessages() {
      return {
        "default": "Validation error on field %s",
        required: "%s is required",
        "enum": "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
          format: "%s date %s is invalid for format %s",
          parse: "%s date could not be parsed, %s is invalid ",
          invalid: "%s date %s is invalid"
        },
        types: {
          string: "%s is not a %s",
          method: "%s is not a %s (function)",
          array: "%s is not an %s",
          object: "%s is not an %s",
          number: "%s is not a %s",
          date: "%s is not a %s",
          "boolean": "%s is not a %s",
          integer: "%s is not an %s",
          "float": "%s is not a %s",
          regexp: "%s is not a valid %s",
          email: "%s is not a valid %s",
          url: "%s is not a valid %s",
          hex: "%s is not a valid %s"
        },
        string: {
          len: "%s must be exactly %s characters",
          min: "%s must be at least %s characters",
          max: "%s cannot be longer than %s characters",
          range: "%s must be between %s and %s characters"
        },
        number: {
          len: "%s must equal %s",
          min: "%s cannot be less than %s",
          max: "%s cannot be greater than %s",
          range: "%s must be between %s and %s"
        },
        array: {
          len: "%s must be exactly %s in length",
          min: "%s cannot be less than %s in length",
          max: "%s cannot be greater than %s in length",
          range: "%s must be between %s and %s in length"
        },
        pattern: {
          mismatch: "%s value %s does not match pattern %s"
        },
        clone: function clone() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }
    var messages = newMessages();
    var Schema$3 = /* @__PURE__ */ function() {
      function Schema2(descriptor) {
        this.rules = null;
        this._messages = messages;
        this.define(descriptor);
      }
      var _proto = Schema2.prototype;
      _proto.define = function define(rules2) {
        var _this = this;
        if (!rules2) {
          throw new Error("Cannot configure a schema with no rules");
        }
        if (typeof rules2 !== "object" || Array.isArray(rules2)) {
          throw new Error("Rules must be an object");
        }
        this.rules = {};
        Object.keys(rules2).forEach(function(name) {
          var item = rules2[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      };
      _proto.messages = function messages2(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }
        return this._messages;
      };
      _proto.validate = function validate(source_, o2, oc2) {
        var _this2 = this;
        if (o2 === void 0) {
          o2 = {};
        }
        if (oc2 === void 0) {
          oc2 = function oc3() {
          };
        }
        var source = source_;
        var options = o2;
        var callback = oc2;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }
          return Promise.resolve(source);
        }
        function complete(results) {
          var errors = [];
          var fields = {};
          function add2(e2) {
            if (Array.isArray(e2)) {
              var _errors;
              errors = (_errors = errors).concat.apply(_errors, e2);
            } else {
              errors.push(e2);
            }
          }
          for (var i2 = 0; i2 < results.length; i2++) {
            add2(results[i2]);
          }
          if (!errors.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors);
            callback(errors, fields);
          }
        }
        if (options.messages) {
          var messages$1 = this.messages();
          if (messages$1 === messages) {
            messages$1 = newMessages();
          }
          deepMerge(messages$1, options.messages);
          options.messages = messages$1;
        } else {
          options.messages = this.messages();
        }
        var series = {};
        var keys2 = options.keys || Object.keys(this.rules);
        keys2.forEach(function(z2) {
          var arr = _this2.rules[z2];
          var value = source[z2];
          arr.forEach(function(r2) {
            var rule = r2;
            if (typeof rule.transform === "function") {
              if (source === source_) {
                source = _extends$1({}, source);
              }
              value = source[z2] = rule.transform(value);
            }
            if (typeof rule === "function") {
              rule = {
                validator: rule
              };
            } else {
              rule = _extends$1({}, rule);
            }
            rule.validator = _this2.getValidationMethod(rule);
            if (!rule.validator) {
              return;
            }
            rule.field = z2;
            rule.fullField = rule.fullField || z2;
            rule.type = _this2.getType(rule);
            series[z2] = series[z2] || [];
            series[z2].push({
              rule,
              value,
              source,
              field: z2
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function(data2, doIt) {
          var rule = data2.rule;
          var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
          deep = deep && (rule.required || !rule.required && data2.value);
          rule.field = data2.field;
          function addFullField(key, schema2) {
            return _extends$1({}, schema2, {
              fullField: rule.fullField + "." + key,
              fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
            });
          }
          function cb2(e2) {
            if (e2 === void 0) {
              e2 = [];
            }
            var errorList = Array.isArray(e2) ? e2 : [e2];
            if (!options.suppressWarning && errorList.length) {
              Schema2.warning("async-validator:", errorList);
            }
            if (errorList.length && rule.message !== void 0) {
              errorList = [].concat(rule.message);
            }
            var filledErrors = errorList.map(complementError(rule, source));
            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }
            if (!deep) {
              doIt(filledErrors);
            } else {
              if (rule.required && !data2.value) {
                if (rule.message !== void 0) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
                }
                return doIt(filledErrors);
              }
              var fieldsSchema = {};
              if (rule.defaultField) {
                Object.keys(data2.value).map(function(key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }
              fieldsSchema = _extends$1({}, fieldsSchema, data2.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function(field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema2 = new Schema2(paredFieldsSchema);
              schema2.messages(options.messages);
              if (data2.rule.options) {
                data2.rule.options.messages = options.messages;
                data2.rule.options.error = options.error;
              }
              schema2.validate(data2.value, data2.rule.options || options, function(errs) {
                var finalErrors = [];
                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, filledErrors);
                }
                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, errs);
                }
                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }
          var res;
          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data2.value, cb2, data2.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data2.value, cb2, data2.source, options);
            } catch (error) {
              console.error == null ? void 0 : console.error(error);
              if (!options.suppressValidatorError) {
                setTimeout(function() {
                  throw error;
                }, 0);
              }
              cb2(error.message);
            }
            if (res === true) {
              cb2();
            } else if (res === false) {
              cb2(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
            } else if (res instanceof Array) {
              cb2(res);
            } else if (res instanceof Error) {
              cb2(res.message);
            }
          }
          if (res && res.then) {
            res.then(function() {
              return cb2();
            }, function(e2) {
              return cb2(e2);
            });
          }
        }, function(results) {
          complete(results);
        }, source);
      };
      _proto.getType = function getType(rule) {
        if (rule.type === void 0 && rule.pattern instanceof RegExp) {
          rule.type = "pattern";
        }
        if (typeof rule.validator !== "function" && rule.type && !validators$2.hasOwnProperty(rule.type)) {
          throw new Error(format$1("Unknown rule type %s", rule.type));
        }
        return rule.type || "string";
      };
      _proto.getValidationMethod = function getValidationMethod(rule) {
        if (typeof rule.validator === "function") {
          return rule.validator;
        }
        var keys2 = Object.keys(rule);
        var messageIndex = keys2.indexOf("message");
        if (messageIndex !== -1) {
          keys2.splice(messageIndex, 1);
        }
        if (keys2.length === 1 && keys2[0] === "required") {
          return validators$2.required;
        }
        return validators$2[this.getType(rule)] || void 0;
      };
      return Schema2;
    }();
    Schema$3.register = function register(type2, validator2) {
      if (typeof validator2 !== "function") {
        throw new Error("Cannot register a validator by type, validator is not a function");
      }
      validators$2[type2] = validator2;
    };
    Schema$3.warning = warning$4;
    Schema$3.messages = messages;
    Schema$3.validators = validators$2;
    var typeTemplate$1 = "'${name}' is not a valid ${type}";
    var defaultValidateMessages = {
      default: "Validation error on field '${name}'",
      required: "'${name}' is required",
      enum: "'${name}' must be one of [${enum}]",
      whitespace: "'${name}' cannot be empty",
      date: {
        format: "'${name}' is invalid for format date",
        parse: "'${name}' could not be parsed as date",
        invalid: "'${name}' is invalid date"
      },
      types: {
        string: typeTemplate$1,
        method: typeTemplate$1,
        array: typeTemplate$1,
        object: typeTemplate$1,
        number: typeTemplate$1,
        date: typeTemplate$1,
        boolean: typeTemplate$1,
        integer: typeTemplate$1,
        float: typeTemplate$1,
        regexp: typeTemplate$1,
        email: typeTemplate$1,
        url: typeTemplate$1,
        hex: typeTemplate$1
      },
      string: {
        len: "'${name}' must be exactly ${len} characters",
        min: "'${name}' must be at least ${min} characters",
        max: "'${name}' cannot be longer than ${max} characters",
        range: "'${name}' must be between ${min} and ${max} characters"
      },
      number: {
        len: "'${name}' must equal ${len}",
        min: "'${name}' cannot be less than ${min}",
        max: "'${name}' cannot be greater than ${max}",
        range: "'${name}' must be between ${min} and ${max}"
      },
      array: {
        len: "'${name}' must be exactly ${len} in length",
        min: "'${name}' cannot be less than ${min} in length",
        max: "'${name}' cannot be greater than ${max} in length",
        range: "'${name}' must be between ${min} and ${max} in length"
      },
      pattern: {
        mismatch: "'${name}' does not match pattern ${pattern}"
      }
    };
    function get$2(entity, path2) {
      var current = entity;
      for (var i2 = 0; i2 < path2.length; i2 += 1) {
        if (current === null || current === void 0) {
          return void 0;
        }
        current = current[path2[i2]];
      }
      return current;
    }
    function _toArray(arr) {
      return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
    }
    function internalSet(entity, paths, value, removeIfUndefined) {
      if (!paths.length) {
        return value;
      }
      var _paths = _toArray(paths), path2 = _paths[0], restPath = _paths.slice(1);
      var clone;
      if (!entity && typeof path2 === "number") {
        clone = [];
      } else if (Array.isArray(entity)) {
        clone = _toConsumableArray(entity);
      } else {
        clone = _objectSpread2$3({}, entity);
      }
      if (removeIfUndefined && value === void 0 && restPath.length === 1) {
        delete clone[path2][restPath[0]];
      } else {
        clone[path2] = internalSet(clone[path2], restPath, value, removeIfUndefined);
      }
      return clone;
    }
    function set(entity, paths, value) {
      var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (paths.length && removeIfUndefined && value === void 0 && !get$2(entity, paths.slice(0, -1))) {
        return entity;
      }
      return internalSet(entity, paths, value, removeIfUndefined);
    }
    function cloneDeep(val) {
      if (Array.isArray(val)) {
        return cloneArrayDeep(val);
      } else if (_typeof$4(val) === "object" && val !== null) {
        return cloneObjectDeep(val);
      }
      return val;
    }
    function cloneObjectDeep(val) {
      if (Object.getPrototypeOf(val) === Object.prototype) {
        var res = {};
        for (var key in val) {
          res[key] = cloneDeep(val[key]);
        }
        return res;
      }
      return val;
    }
    function cloneArrayDeep(val) {
      return val.map(function(item) {
        return cloneDeep(item);
      });
    }
    function getNamePath(path2) {
      return toArray$7(path2);
    }
    function getValue$3(store, namePath) {
      var value = get$2(store, namePath);
      return value;
    }
    function setValue(store, namePath, value) {
      var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      var newStore = set(store, namePath, value, removeIfUndefined);
      return newStore;
    }
    function cloneByNamePathList(store, namePathList) {
      var newStore = {};
      namePathList.forEach(function(namePath) {
        var value = getValue$3(store, namePath);
        newStore = setValue(newStore, namePath, value);
      });
      return newStore;
    }
    function containsNamePath(namePathList, namePath) {
      return namePathList && namePathList.some(function(path2) {
        return matchNamePath(path2, namePath);
      });
    }
    function isObject$2(obj) {
      return _typeof$4(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
    }
    function internalSetValues(store, values) {
      var newStore = Array.isArray(store) ? _toConsumableArray(store) : _objectSpread2$3({}, store);
      if (!values) {
        return newStore;
      }
      Object.keys(values).forEach(function(key) {
        var prevValue = newStore[key];
        var value = values[key];
        var recursive = isObject$2(prevValue) && isObject$2(value);
        newStore[key] = recursive ? internalSetValues(prevValue, value || {}) : cloneDeep(value);
      });
      return newStore;
    }
    function setValues(store) {
      for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        restValues[_key - 1] = arguments[_key];
      }
      return restValues.reduce(function(current, newStore) {
        return internalSetValues(current, newStore);
      }, store);
    }
    function matchNamePath(namePath, changedNamePath) {
      if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
        return false;
      }
      return namePath.every(function(nameUnit, i2) {
        return changedNamePath[i2] === nameUnit;
      });
    }
    function isSimilar(source, target) {
      if (source === target) {
        return true;
      }
      if (!source && target || source && !target) {
        return false;
      }
      if (!source || !target || _typeof$4(source) !== "object" || _typeof$4(target) !== "object") {
        return false;
      }
      var sourceKeys = Object.keys(source);
      var targetKeys = Object.keys(target);
      var keys2 = new Set([].concat(sourceKeys, targetKeys));
      return _toConsumableArray(keys2).every(function(key) {
        var sourceValue = source[key];
        var targetValue = target[key];
        if (typeof sourceValue === "function" && typeof targetValue === "function") {
          return true;
        }
        return sourceValue === targetValue;
      });
    }
    function defaultGetValueFromEvent(valuePropName) {
      var event = arguments.length <= 1 ? void 0 : arguments[1];
      if (event && event.target && _typeof$4(event.target) === "object" && valuePropName in event.target) {
        return event.target[valuePropName];
      }
      return event;
    }
    function move(array2, moveIndex, toIndex) {
      var length2 = array2.length;
      if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
        return array2;
      }
      var item = array2[moveIndex];
      var diff = moveIndex - toIndex;
      if (diff > 0) {
        return [].concat(_toConsumableArray(array2.slice(0, toIndex)), [item], _toConsumableArray(array2.slice(toIndex, moveIndex)), _toConsumableArray(array2.slice(moveIndex + 1, length2)));
      }
      if (diff < 0) {
        return [].concat(_toConsumableArray(array2.slice(0, moveIndex)), _toConsumableArray(array2.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array2.slice(toIndex + 1, length2)));
      }
      return array2;
    }
    var AsyncValidator = Schema$3;
    function replaceMessage(template, kv) {
      return template.replace(/\$\{\w+\}/g, function(str) {
        var key = str.slice(2, -1);
        return kv[key];
      });
    }
    var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
    function validateRule(_x, _x2, _x3, _x4, _x5) {
      return _validateRule.apply(this, arguments);
    }
    function _validateRule() {
      _validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name, value, rule, options, messageVariables) {
        var cloneRule, originValidator, subRuleField, validator2, messages2, result, subResults, kv, fillVariableResult;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                cloneRule = _objectSpread2$3({}, rule);
                delete cloneRule.ruleIndex;
                if (cloneRule.validator) {
                  originValidator = cloneRule.validator;
                  cloneRule.validator = function() {
                    try {
                      return originValidator.apply(void 0, arguments);
                    } catch (error) {
                      console.error(error);
                      return Promise.reject(CODE_LOGIC_ERROR);
                    }
                  };
                }
                subRuleField = null;
                if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
                  subRuleField = cloneRule.defaultField;
                  delete cloneRule.defaultField;
                }
                validator2 = new AsyncValidator(_defineProperty$7({}, name, [cloneRule]));
                messages2 = setValues({}, defaultValidateMessages, options.validateMessages);
                validator2.messages(messages2);
                result = [];
                _context2.prev = 9;
                _context2.next = 12;
                return Promise.resolve(validator2.validate(_defineProperty$7({}, name, value), _objectSpread2$3({}, options)));
              case 12:
                _context2.next = 17;
                break;
              case 14:
                _context2.prev = 14;
                _context2.t0 = _context2["catch"](9);
                if (_context2.t0.errors) {
                  result = _context2.t0.errors.map(function(_ref4, index2) {
                    var message2 = _ref4.message;
                    var mergedMessage = message2 === CODE_LOGIC_ERROR ? messages2.default : message2;
                    return /* @__PURE__ */ reactExports.isValidElement(mergedMessage) ? (
                      // Wrap ReactNode with `key`
                      /* @__PURE__ */ reactExports.cloneElement(mergedMessage, {
                        key: "error_".concat(index2)
                      })
                    ) : mergedMessage;
                  });
                }
              case 17:
                if (!(!result.length && subRuleField)) {
                  _context2.next = 22;
                  break;
                }
                _context2.next = 20;
                return Promise.all(value.map(function(subValue, i2) {
                  return validateRule("".concat(name, ".").concat(i2), subValue, subRuleField, options, messageVariables);
                }));
              case 20:
                subResults = _context2.sent;
                return _context2.abrupt("return", subResults.reduce(function(prev2, errors) {
                  return [].concat(_toConsumableArray(prev2), _toConsumableArray(errors));
                }, []));
              case 22:
                kv = _objectSpread2$3(_objectSpread2$3({}, rule), {}, {
                  name,
                  enum: (rule.enum || []).join(", ")
                }, messageVariables);
                fillVariableResult = result.map(function(error) {
                  if (typeof error === "string") {
                    return replaceMessage(error, kv);
                  }
                  return error;
                });
                return _context2.abrupt("return", fillVariableResult);
              case 25:
              case "end":
                return _context2.stop();
            }
        }, _callee2, null, [[9, 14]]);
      }));
      return _validateRule.apply(this, arguments);
    }
    function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
      var name = namePath.join(".");
      var filledRules = rules2.map(function(currentRule, ruleIndex) {
        var originValidatorFunc = currentRule.validator;
        var cloneRule = _objectSpread2$3(_objectSpread2$3({}, currentRule), {}, {
          ruleIndex
        });
        if (originValidatorFunc) {
          cloneRule.validator = function(rule, val, callback) {
            var hasPromise = false;
            var wrappedCallback = function wrappedCallback2() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              Promise.resolve().then(function() {
                warningOnce$1(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
                if (!hasPromise) {
                  callback.apply(void 0, args);
                }
              });
            };
            var promise = originValidatorFunc(rule, val, wrappedCallback);
            hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
            warningOnce$1(hasPromise, "`callback` is deprecated. Please return a promise instead.");
            if (hasPromise) {
              promise.then(function() {
                callback();
              }).catch(function(err) {
                callback(err || " ");
              });
            }
          };
        }
        return cloneRule;
      }).sort(function(_ref, _ref2) {
        var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
        var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
        if (!!w1 === !!w2) {
          return i1 - i2;
        }
        if (w1) {
          return 1;
        }
        return -1;
      });
      var summaryPromise;
      if (validateFirst === true) {
        summaryPromise = new Promise(/* @__PURE__ */ function() {
          var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve, reject) {
            var i2, rule, errors;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    i2 = 0;
                  case 1:
                    if (!(i2 < filledRules.length)) {
                      _context.next = 12;
                      break;
                    }
                    rule = filledRules[i2];
                    _context.next = 5;
                    return validateRule(name, value, rule, options, messageVariables);
                  case 5:
                    errors = _context.sent;
                    if (!errors.length) {
                      _context.next = 9;
                      break;
                    }
                    reject([{
                      errors,
                      rule
                    }]);
                    return _context.abrupt("return");
                  case 9:
                    i2 += 1;
                    _context.next = 1;
                    break;
                  case 12:
                    resolve([]);
                  case 13:
                  case "end":
                    return _context.stop();
                }
            }, _callee);
          }));
          return function(_x6, _x7) {
            return _ref3.apply(this, arguments);
          };
        }());
      } else {
        var rulePromises = filledRules.map(function(rule) {
          return validateRule(name, value, rule, options, messageVariables).then(function(errors) {
            return {
              errors,
              rule
            };
          });
        });
        summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
          return Promise.reject(errors);
        });
      }
      summaryPromise.catch(function(e2) {
        return e2;
      });
      return summaryPromise;
    }
    function finishOnAllFailed(_x8) {
      return _finishOnAllFailed.apply(this, arguments);
    }
    function _finishOnAllFailed() {
      _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(rulePromises) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
                  var _ref5;
                  var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
                  return errors;
                }));
              case 1:
              case "end":
                return _context3.stop();
            }
        }, _callee3);
      }));
      return _finishOnAllFailed.apply(this, arguments);
    }
    function finishOnFirstFailed(_x9) {
      return _finishOnFirstFailed.apply(this, arguments);
    }
    function _finishOnFirstFailed() {
      _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(rulePromises) {
        var count;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1)
            switch (_context4.prev = _context4.next) {
              case 0:
                count = 0;
                return _context4.abrupt("return", new Promise(function(resolve) {
                  rulePromises.forEach(function(promise) {
                    promise.then(function(ruleError) {
                      if (ruleError.errors.length) {
                        resolve([ruleError]);
                      }
                      count += 1;
                      if (count === rulePromises.length) {
                        resolve([]);
                      }
                    });
                  });
                }));
              case 2:
              case "end":
                return _context4.stop();
            }
        }, _callee4);
      }));
      return _finishOnFirstFailed.apply(this, arguments);
    }
    var _excluded$O = ["name"];
    var EMPTY_ERRORS = [];
    function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info2) {
      if (typeof shouldUpdate === "function") {
        return shouldUpdate(prev2, next2, "source" in info2 ? {
          source: info2.source
        } : {});
      }
      return prevValue !== nextValue;
    }
    var Field = /* @__PURE__ */ function(_React$Component) {
      _inherits(Field2, _React$Component);
      var _super = _createSuper(Field2);
      function Field2(props) {
        var _this;
        _classCallCheck(this, Field2);
        _this = _super.call(this, props);
        _this.state = {
          resetCount: 0
        };
        _this.cancelRegisterFunc = null;
        _this.mounted = false;
        _this.touched = false;
        _this.dirty = false;
        _this.validatePromise = null;
        _this.prevValidating = void 0;
        _this.errors = EMPTY_ERRORS;
        _this.warnings = EMPTY_ERRORS;
        _this.cancelRegister = function() {
          var _this$props = _this.props, preserve = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
          if (_this.cancelRegisterFunc) {
            _this.cancelRegisterFunc(isListField, preserve, getNamePath(name));
          }
          _this.cancelRegisterFunc = null;
        };
        _this.getNamePath = function() {
          var _this$props2 = _this.props, name = _this$props2.name, fieldContext = _this$props2.fieldContext;
          var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
          return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
        };
        _this.getRules = function() {
          var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
          return rules2.map(function(rule) {
            if (typeof rule === "function") {
              return rule(fieldContext);
            }
            return rule;
          });
        };
        _this.refresh = function() {
          if (!_this.mounted)
            return;
          _this.setState(function(_ref) {
            var resetCount = _ref.resetCount;
            return {
              resetCount: resetCount + 1
            };
          });
        };
        _this.triggerMetaEvent = function(destroy2) {
          var onMetaChange = _this.props.onMetaChange;
          onMetaChange === null || onMetaChange === void 0 ? void 0 : onMetaChange(_objectSpread2$3(_objectSpread2$3({}, _this.getMeta()), {}, {
            destroy: destroy2
          }));
        };
        _this.onStoreChange = function(prevStore, namePathList, info2) {
          var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
          var store = info2.store;
          var namePath = _this.getNamePath();
          var prevValue = _this.getValue(prevStore);
          var curValue = _this.getValue(store);
          var namePathMatch = namePathList && containsNamePath(namePathList, namePath);
          if (info2.type === "valueUpdate" && info2.source === "external" && prevValue !== curValue) {
            _this.touched = true;
            _this.dirty = true;
            _this.validatePromise = null;
            _this.errors = EMPTY_ERRORS;
            _this.warnings = EMPTY_ERRORS;
            _this.triggerMetaEvent();
          }
          switch (info2.type) {
            case "reset":
              if (!namePathList || namePathMatch) {
                _this.touched = false;
                _this.dirty = false;
                _this.validatePromise = null;
                _this.errors = EMPTY_ERRORS;
                _this.warnings = EMPTY_ERRORS;
                _this.triggerMetaEvent();
                onReset === null || onReset === void 0 ? void 0 : onReset();
                _this.refresh();
                return;
              }
              break;
            case "remove": {
              if (shouldUpdate) {
                _this.reRender();
                return;
              }
              break;
            }
            case "setField": {
              if (namePathMatch) {
                var data2 = info2.data;
                if ("touched" in data2) {
                  _this.touched = data2.touched;
                }
                if ("validating" in data2 && !("originRCField" in data2)) {
                  _this.validatePromise = data2.validating ? Promise.resolve([]) : null;
                }
                if ("errors" in data2) {
                  _this.errors = data2.errors || EMPTY_ERRORS;
                }
                if ("warnings" in data2) {
                  _this.warnings = data2.warnings || EMPTY_ERRORS;
                }
                _this.dirty = true;
                _this.triggerMetaEvent();
                _this.reRender();
                return;
              }
              if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info2)) {
                _this.reRender();
                return;
              }
              break;
            }
            case "dependenciesUpdate": {
              var dependencyList = dependencies.map(getNamePath);
              if (dependencyList.some(function(dependency) {
                return containsNamePath(info2.relatedFields, dependency);
              })) {
                _this.reRender();
                return;
              }
              break;
            }
            default:
              if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info2)) {
                _this.reRender();
                return;
              }
              break;
          }
          if (shouldUpdate === true) {
            _this.reRender();
          }
        };
        _this.validateRules = function(options) {
          var namePath = _this.getNamePath();
          var currentValue = _this.getValue();
          var rootPromise = Promise.resolve().then(function() {
            if (!_this.mounted) {
              return [];
            }
            var _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables;
            var _ref2 = options || {}, triggerName = _ref2.triggerName;
            var filteredRules = _this.getRules();
            if (triggerName) {
              filteredRules = filteredRules.filter(function(rule) {
                return rule;
              }).filter(function(rule) {
                var validateTrigger = rule.validateTrigger;
                if (!validateTrigger) {
                  return true;
                }
                var triggerList = toArray$7(validateTrigger);
                return triggerList.includes(triggerName);
              });
            }
            var promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
            promise.catch(function(e2) {
              return e2;
            }).then(function() {
              var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
              if (_this.validatePromise === rootPromise) {
                var _ruleErrors$forEach;
                _this.validatePromise = null;
                var nextErrors = [];
                var nextWarnings = [];
                (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref3) {
                  var warningOnly = _ref3.rule.warningOnly, _ref3$errors = _ref3.errors, errors = _ref3$errors === void 0 ? EMPTY_ERRORS : _ref3$errors;
                  if (warningOnly) {
                    nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
                  } else {
                    nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
                  }
                });
                _this.errors = nextErrors;
                _this.warnings = nextWarnings;
                _this.triggerMetaEvent();
                _this.reRender();
              }
            });
            return promise;
          });
          _this.validatePromise = rootPromise;
          _this.dirty = true;
          _this.errors = EMPTY_ERRORS;
          _this.warnings = EMPTY_ERRORS;
          _this.triggerMetaEvent();
          _this.reRender();
          return rootPromise;
        };
        _this.isFieldValidating = function() {
          return !!_this.validatePromise;
        };
        _this.isFieldTouched = function() {
          return _this.touched;
        };
        _this.isFieldDirty = function() {
          if (_this.dirty || _this.props.initialValue !== void 0) {
            return true;
          }
          var fieldContext = _this.props.fieldContext;
          var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
          if (getInitialValue(_this.getNamePath()) !== void 0) {
            return true;
          }
          return false;
        };
        _this.getErrors = function() {
          return _this.errors;
        };
        _this.getWarnings = function() {
          return _this.warnings;
        };
        _this.isListField = function() {
          return _this.props.isListField;
        };
        _this.isList = function() {
          return _this.props.isList;
        };
        _this.isPreserve = function() {
          return _this.props.preserve;
        };
        _this.getMeta = function() {
          _this.prevValidating = _this.isFieldValidating();
          var meta = {
            touched: _this.isFieldTouched(),
            validating: _this.prevValidating,
            errors: _this.errors,
            warnings: _this.warnings,
            name: _this.getNamePath()
          };
          return meta;
        };
        _this.getOnlyChild = function(children) {
          if (typeof children === "function") {
            var meta = _this.getMeta();
            return _objectSpread2$3(_objectSpread2$3({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.props.fieldContext))), {}, {
              isFunction: true
            });
          }
          var childList = toArray$8(children);
          if (childList.length !== 1 || !/* @__PURE__ */ reactExports.isValidElement(childList[0])) {
            return {
              child: childList,
              isFunction: false
            };
          }
          return {
            child: childList[0],
            isFunction: false
          };
        };
        _this.getValue = function(store) {
          var getFieldsValue = _this.props.fieldContext.getFieldsValue;
          var namePath = _this.getNamePath();
          return getValue$3(store || getFieldsValue(true), namePath);
        };
        _this.getControlled = function() {
          var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var _this$props6 = _this.props, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
          var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
          var namePath = _this.getNamePath();
          var getInternalHooks2 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
          var _getInternalHooks = getInternalHooks2(HOOK_MARK), dispatch = _getInternalHooks.dispatch;
          var value = _this.getValue();
          var mergedGetValueProps = getValueProps || function(val) {
            return _defineProperty$7({}, valuePropName, val);
          };
          var originTriggerFunc = childProps[trigger];
          var control = _objectSpread2$3(_objectSpread2$3({}, childProps), mergedGetValueProps(value));
          control[trigger] = function() {
            _this.touched = true;
            _this.dirty = true;
            _this.triggerMetaEvent();
            var newValue;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (getValueFromEvent) {
              newValue = getValueFromEvent.apply(void 0, args);
            } else {
              newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
            }
            if (normalize2) {
              newValue = normalize2(newValue, value, getFieldsValue(true));
            }
            dispatch({
              type: "updateValue",
              namePath,
              value: newValue
            });
            if (originTriggerFunc) {
              originTriggerFunc.apply(void 0, args);
            }
          };
          var validateTriggerList = toArray$7(mergedValidateTrigger || []);
          validateTriggerList.forEach(function(triggerName) {
            var originTrigger = control[triggerName];
            control[triggerName] = function() {
              if (originTrigger) {
                originTrigger.apply(void 0, arguments);
              }
              var rules2 = _this.props.rules;
              if (rules2 && rules2.length) {
                dispatch({
                  type: "validateField",
                  namePath,
                  triggerName
                });
              }
            };
          });
          return control;
        };
        if (props.fieldContext) {
          var getInternalHooks = props.fieldContext.getInternalHooks;
          var _getInternalHooks2 = getInternalHooks(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
          initEntityValue(_assertThisInitialized(_this));
        }
        return _this;
      }
      _createClass(Field2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
          this.mounted = true;
          if (fieldContext) {
            var getInternalHooks = fieldContext.getInternalHooks;
            var _getInternalHooks3 = getInternalHooks(HOOK_MARK), registerField = _getInternalHooks3.registerField;
            this.cancelRegisterFunc = registerField(this);
          }
          if (shouldUpdate === true) {
            this.reRender();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.cancelRegister();
          this.triggerMetaEvent(true);
          this.mounted = false;
        }
      }, {
        key: "reRender",
        value: function reRender() {
          if (!this.mounted)
            return;
          this.forceUpdate();
        }
      }, {
        key: "render",
        value: function render2() {
          var resetCount = this.state.resetCount;
          var children = this.props.children;
          var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction2 = _this$getOnlyChild.isFunction;
          var returnChildNode;
          if (isFunction2) {
            returnChildNode = child;
          } else if (/* @__PURE__ */ reactExports.isValidElement(child)) {
            returnChildNode = /* @__PURE__ */ reactExports.cloneElement(child, this.getControlled(child.props));
          } else {
            warningOnce$1(!child, "`children` of Field is not validate ReactElement.");
            returnChildNode = child;
          }
          return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, {
            key: resetCount
          }, returnChildNode);
        }
      }]);
      return Field2;
    }(reactExports.Component);
    Field.contextType = Context$2;
    Field.defaultProps = {
      trigger: "onChange",
      valuePropName: "value"
    };
    function WrapperField(_ref5) {
      var name = _ref5.name, restProps = _objectWithoutProperties$1(_ref5, _excluded$O);
      var fieldContext = reactExports.useContext(Context$2);
      var namePath = name !== void 0 ? getNamePath(name) : void 0;
      var key = "keep";
      if (!restProps.isListField) {
        key = "_".concat((namePath || []).join("_"));
      }
      return /* @__PURE__ */ reactExports.createElement(Field, _extends$2({
        key,
        name: namePath
      }, restProps, {
        fieldContext
      }));
    }
    var ListContext = /* @__PURE__ */ reactExports.createContext(null);
    var List$2 = function List2(_ref) {
      var name = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules2 = _ref.rules, validateTrigger = _ref.validateTrigger;
      var context = reactExports.useContext(Context$2);
      var keyRef = reactExports.useRef({
        keys: [],
        id: 0
      });
      var keyManager = keyRef.current;
      var prefixName = reactExports.useMemo(function() {
        var parentPrefixName = getNamePath(context.prefixName) || [];
        return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
      }, [context.prefixName, name]);
      var fieldContext = reactExports.useMemo(function() {
        return _objectSpread2$3(_objectSpread2$3({}, context), {}, {
          prefixName
        });
      }, [context, prefixName]);
      var listContext = reactExports.useMemo(function() {
        return {
          getKey: function getKey2(namePath) {
            var len = prefixName.length;
            var pathName = namePath[len];
            return [keyManager.keys[pathName], namePath.slice(len + 1)];
          }
        };
      }, [prefixName]);
      if (typeof children !== "function") {
        warningOnce$1(false, "Form.List only accepts function as children.");
        return null;
      }
      var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref2) {
        var source = _ref2.source;
        if (source === "internal") {
          return false;
        }
        return prevValue !== nextValue;
      };
      return /* @__PURE__ */ reactExports.createElement(ListContext.Provider, {
        value: listContext
      }, /* @__PURE__ */ reactExports.createElement(Context$2.Provider, {
        value: fieldContext
      }, /* @__PURE__ */ reactExports.createElement(WrapperField, {
        name: [],
        shouldUpdate,
        rules: rules2,
        validateTrigger,
        initialValue,
        isList: true
      }, function(_ref3, meta) {
        var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange = _ref3.onChange;
        var getFieldValue = context.getFieldValue;
        var getNewValue = function getNewValue2() {
          var values = getFieldValue(prefixName || []);
          return values || [];
        };
        var operations = {
          add: function add2(defaultValue, index2) {
            var newValue = getNewValue();
            if (index2 >= 0 && index2 <= newValue.length) {
              keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2)));
              onChange([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))));
            } else {
              keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
              onChange([].concat(_toConsumableArray(newValue), [defaultValue]));
            }
            keyManager.id += 1;
          },
          remove: function remove(index2) {
            var newValue = getNewValue();
            var indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
            if (indexSet.size <= 0) {
              return;
            }
            keyManager.keys = keyManager.keys.filter(function(_, keysIndex) {
              return !indexSet.has(keysIndex);
            });
            onChange(newValue.filter(function(_, valueIndex) {
              return !indexSet.has(valueIndex);
            }));
          },
          move: function move$1(from2, to) {
            if (from2 === to) {
              return;
            }
            var newValue = getNewValue();
            if (from2 < 0 || from2 >= newValue.length || to < 0 || to >= newValue.length) {
              return;
            }
            keyManager.keys = move(keyManager.keys, from2, to);
            onChange(move(newValue, from2, to));
          }
        };
        var listValue = value || [];
        if (!Array.isArray(listValue)) {
          listValue = [];
        }
        return children(listValue.map(function(__, index2) {
          var key = keyManager.keys[index2];
          if (key === void 0) {
            keyManager.keys[index2] = keyManager.id;
            key = keyManager.keys[index2];
            keyManager.id += 1;
          }
          return {
            name: index2,
            key,
            isListField: true
          };
        }), operations, meta);
      })));
    };
    function allPromiseFinish(promiseList) {
      var hasError = false;
      var count = promiseList.length;
      var results = [];
      if (!promiseList.length) {
        return Promise.resolve([]);
      }
      return new Promise(function(resolve, reject) {
        promiseList.forEach(function(promise, index2) {
          promise.catch(function(e2) {
            hasError = true;
            return e2;
          }).then(function(result) {
            count -= 1;
            results[index2] = result;
            if (count > 0) {
              return;
            }
            if (hasError) {
              reject(results);
            }
            resolve(results);
          });
        });
      });
    }
    var SPLIT = "__@field_split__";
    function normalize$7(namePath) {
      return namePath.map(function(cell) {
        return "".concat(_typeof$4(cell), ":").concat(cell);
      }).join(SPLIT);
    }
    var NameMap = /* @__PURE__ */ function() {
      function NameMap2() {
        _classCallCheck(this, NameMap2);
        this.kvs = /* @__PURE__ */ new Map();
      }
      _createClass(NameMap2, [{
        key: "set",
        value: function set2(key, value) {
          this.kvs.set(normalize$7(key), value);
        }
      }, {
        key: "get",
        value: function get2(key) {
          return this.kvs.get(normalize$7(key));
        }
      }, {
        key: "update",
        value: function update2(key, updater) {
          var origin = this.get(key);
          var next2 = updater(origin);
          if (!next2) {
            this.delete(key);
          } else {
            this.set(key, next2);
          }
        }
      }, {
        key: "delete",
        value: function _delete2(key) {
          this.kvs.delete(normalize$7(key));
        }
        // Since we only use this in test, let simply realize this
      }, {
        key: "map",
        value: function map(callback) {
          return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
            var cells = key.split(SPLIT);
            return callback({
              key: cells.map(function(cell) {
                var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray(_cell$match, 3), type2 = _cell$match2[1], unit = _cell$match2[2];
                return type2 === "number" ? Number(unit) : unit;
              }),
              value
            });
          });
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var json = {};
          this.map(function(_ref3) {
            var key = _ref3.key, value = _ref3.value;
            json[key.join(".")] = value;
            return null;
          });
          return json;
        }
      }]);
      return NameMap2;
    }();
    var _excluded$N = ["name", "errors"];
    var FormStore = /* @__PURE__ */ _createClass(function FormStore2(forceRootUpdate) {
      var _this = this;
      _classCallCheck(this, FormStore2);
      this.formHooked = false;
      this.forceRootUpdate = void 0;
      this.subscribable = true;
      this.store = {};
      this.fieldEntities = [];
      this.initialValues = {};
      this.callbacks = {};
      this.validateMessages = null;
      this.preserve = null;
      this.lastValidatePromise = null;
      this.getForm = function() {
        return {
          getFieldValue: _this.getFieldValue,
          getFieldsValue: _this.getFieldsValue,
          getFieldError: _this.getFieldError,
          getFieldWarning: _this.getFieldWarning,
          getFieldsError: _this.getFieldsError,
          isFieldsTouched: _this.isFieldsTouched,
          isFieldTouched: _this.isFieldTouched,
          isFieldValidating: _this.isFieldValidating,
          isFieldsValidating: _this.isFieldsValidating,
          resetFields: _this.resetFields,
          setFields: _this.setFields,
          setFieldValue: _this.setFieldValue,
          setFieldsValue: _this.setFieldsValue,
          validateFields: _this.validateFields,
          submit: _this.submit,
          _init: true,
          getInternalHooks: _this.getInternalHooks
        };
      };
      this.getInternalHooks = function(key) {
        if (key === HOOK_MARK) {
          _this.formHooked = true;
          return {
            dispatch: _this.dispatch,
            initEntityValue: _this.initEntityValue,
            registerField: _this.registerField,
            useSubscribe: _this.useSubscribe,
            setInitialValues: _this.setInitialValues,
            destroyForm: _this.destroyForm,
            setCallbacks: _this.setCallbacks,
            setValidateMessages: _this.setValidateMessages,
            getFields: _this.getFields,
            setPreserve: _this.setPreserve,
            getInitialValue: _this.getInitialValue,
            registerWatch: _this.registerWatch
          };
        }
        warningOnce$1(false, "`getInternalHooks` is internal usage. Should not call directly.");
        return null;
      };
      this.useSubscribe = function(subscribable) {
        _this.subscribable = subscribable;
      };
      this.prevWithoutPreserves = null;
      this.setInitialValues = function(initialValues, init) {
        _this.initialValues = initialValues || {};
        if (init) {
          var _this$prevWithoutPres;
          var nextStore = setValues({}, initialValues, _this.store);
          (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function(_ref) {
            var namePath = _ref.key;
            nextStore = setValue(nextStore, namePath, getValue$3(initialValues, namePath));
          });
          _this.prevWithoutPreserves = null;
          _this.updateStore(nextStore);
        }
      };
      this.destroyForm = function() {
        var prevWithoutPreserves = new NameMap();
        _this.getFieldEntities(true).forEach(function(entity) {
          if (!_this.isMergedPreserve(entity.isPreserve())) {
            prevWithoutPreserves.set(entity.getNamePath(), true);
          }
        });
        _this.prevWithoutPreserves = prevWithoutPreserves;
      };
      this.getInitialValue = function(namePath) {
        var initValue = getValue$3(_this.initialValues, namePath);
        return namePath.length ? cloneDeep(initValue) : initValue;
      };
      this.setCallbacks = function(callbacks) {
        _this.callbacks = callbacks;
      };
      this.setValidateMessages = function(validateMessages) {
        _this.validateMessages = validateMessages;
      };
      this.setPreserve = function(preserve) {
        _this.preserve = preserve;
      };
      this.watchList = [];
      this.registerWatch = function(callback) {
        _this.watchList.push(callback);
        return function() {
          _this.watchList = _this.watchList.filter(function(fn) {
            return fn !== callback;
          });
        };
      };
      this.notifyWatch = function() {
        var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (_this.watchList.length) {
          var values = _this.getFieldsValue();
          _this.watchList.forEach(function(callback) {
            callback(values, namePath);
          });
        }
      };
      this.timeoutId = null;
      this.warningUnhooked = function() {
      };
      this.updateStore = function(nextStore) {
        _this.store = nextStore;
      };
      this.getFieldEntities = function() {
        var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (!pure) {
          return _this.fieldEntities;
        }
        return _this.fieldEntities.filter(function(field) {
          return field.getNamePath().length;
        });
      };
      this.getFieldsMap = function() {
        var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var cache2 = new NameMap();
        _this.getFieldEntities(pure).forEach(function(field) {
          var namePath = field.getNamePath();
          cache2.set(namePath, field);
        });
        return cache2;
      };
      this.getFieldEntitiesForNamePathList = function(nameList) {
        if (!nameList) {
          return _this.getFieldEntities(true);
        }
        var cache2 = _this.getFieldsMap(true);
        return nameList.map(function(name) {
          var namePath = getNamePath(name);
          return cache2.get(namePath) || {
            INVALIDATE_NAME_PATH: getNamePath(name)
          };
        });
      };
      this.getFieldsValue = function(nameList, filterFunc) {
        _this.warningUnhooked();
        if (nameList === true && !filterFunc) {
          return _this.store;
        }
        var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(nameList) ? nameList : null);
        var filteredNameList = [];
        fieldEntities.forEach(function(entity) {
          var _entity$isListField;
          var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
          if (!nameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {
            return;
          }
          if (!filterFunc) {
            filteredNameList.push(namePath);
          } else {
            var meta = "getMeta" in entity ? entity.getMeta() : null;
            if (filterFunc(meta)) {
              filteredNameList.push(namePath);
            }
          }
        });
        return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
      };
      this.getFieldValue = function(name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        return getValue$3(_this.store, namePath);
      };
      this.getFieldsError = function(nameList) {
        _this.warningUnhooked();
        var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
        return fieldEntities.map(function(entity, index2) {
          if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
            return {
              name: entity.getNamePath(),
              errors: entity.getErrors(),
              warnings: entity.getWarnings()
            };
          }
          return {
            name: getNamePath(nameList[index2]),
            errors: [],
            warnings: []
          };
        });
      };
      this.getFieldError = function(name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        var fieldError = _this.getFieldsError([namePath])[0];
        return fieldError.errors;
      };
      this.getFieldWarning = function(name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        var fieldError = _this.getFieldsError([namePath])[0];
        return fieldError.warnings;
      };
      this.isFieldsTouched = function() {
        _this.warningUnhooked();
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var arg0 = args[0], arg1 = args[1];
        var namePathList;
        var isAllFieldsTouched = false;
        if (args.length === 0) {
          namePathList = null;
        } else if (args.length === 1) {
          if (Array.isArray(arg0)) {
            namePathList = arg0.map(getNamePath);
            isAllFieldsTouched = false;
          } else {
            namePathList = null;
            isAllFieldsTouched = arg0;
          }
        } else {
          namePathList = arg0.map(getNamePath);
          isAllFieldsTouched = arg1;
        }
        var fieldEntities = _this.getFieldEntities(true);
        var isFieldTouched = function isFieldTouched2(field) {
          return field.isFieldTouched();
        };
        if (!namePathList) {
          return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);
        }
        var map = new NameMap();
        namePathList.forEach(function(shortNamePath) {
          map.set(shortNamePath, []);
        });
        fieldEntities.forEach(function(field) {
          var fieldNamePath = field.getNamePath();
          namePathList.forEach(function(shortNamePath) {
            if (shortNamePath.every(function(nameUnit, i2) {
              return fieldNamePath[i2] === nameUnit;
            })) {
              map.update(shortNamePath, function(list2) {
                return [].concat(_toConsumableArray(list2), [field]);
              });
            }
          });
        });
        var isNamePathListTouched = function isNamePathListTouched2(entities) {
          return entities.some(isFieldTouched);
        };
        var namePathListEntities = map.map(function(_ref2) {
          var value = _ref2.value;
          return value;
        });
        return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
      };
      this.isFieldTouched = function(name) {
        _this.warningUnhooked();
        return _this.isFieldsTouched([name]);
      };
      this.isFieldsValidating = function(nameList) {
        _this.warningUnhooked();
        var fieldEntities = _this.getFieldEntities();
        if (!nameList) {
          return fieldEntities.some(function(testField) {
            return testField.isFieldValidating();
          });
        }
        var namePathList = nameList.map(getNamePath);
        return fieldEntities.some(function(testField) {
          var fieldNamePath = testField.getNamePath();
          return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
        });
      };
      this.isFieldValidating = function(name) {
        _this.warningUnhooked();
        return _this.isFieldsValidating([name]);
      };
      this.resetWithFieldInitialValue = function() {
        var info2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var cache2 = new NameMap();
        var fieldEntities = _this.getFieldEntities(true);
        fieldEntities.forEach(function(field) {
          var initialValue = field.props.initialValue;
          var namePath = field.getNamePath();
          if (initialValue !== void 0) {
            var records = cache2.get(namePath) || /* @__PURE__ */ new Set();
            records.add({
              entity: field,
              value: initialValue
            });
            cache2.set(namePath, records);
          }
        });
        var resetWithFields = function resetWithFields2(entities) {
          entities.forEach(function(field) {
            var initialValue = field.props.initialValue;
            if (initialValue !== void 0) {
              var namePath = field.getNamePath();
              var formInitialValue = _this.getInitialValue(namePath);
              if (formInitialValue !== void 0) {
                warningOnce$1(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
              } else {
                var records = cache2.get(namePath);
                if (records && records.size > 1) {
                  warningOnce$1(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
                } else if (records) {
                  var originValue = _this.getFieldValue(namePath);
                  if (!info2.skipExist || originValue === void 0) {
                    _this.updateStore(setValue(_this.store, namePath, _toConsumableArray(records)[0].value));
                  }
                }
              }
            }
          });
        };
        var requiredFieldEntities;
        if (info2.entities) {
          requiredFieldEntities = info2.entities;
        } else if (info2.namePathList) {
          requiredFieldEntities = [];
          info2.namePathList.forEach(function(namePath) {
            var records = cache2.get(namePath);
            if (records) {
              var _requiredFieldEntitie;
              (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {
                return r2.entity;
              })));
            }
          });
        } else {
          requiredFieldEntities = fieldEntities;
        }
        resetWithFields(requiredFieldEntities);
      };
      this.resetFields = function(nameList) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        if (!nameList) {
          _this.updateStore(setValues({}, _this.initialValues));
          _this.resetWithFieldInitialValue();
          _this.notifyObservers(prevStore, null, {
            type: "reset"
          });
          _this.notifyWatch();
          return;
        }
        var namePathList = nameList.map(getNamePath);
        namePathList.forEach(function(namePath) {
          var initialValue = _this.getInitialValue(namePath);
          _this.updateStore(setValue(_this.store, namePath, initialValue));
        });
        _this.resetWithFieldInitialValue({
          namePathList
        });
        _this.notifyObservers(prevStore, namePathList, {
          type: "reset"
        });
        _this.notifyWatch(namePathList);
      };
      this.setFields = function(fields) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        var namePathList = [];
        fields.forEach(function(fieldData) {
          var name = fieldData.name;
          fieldData.errors;
          var data2 = _objectWithoutProperties$1(fieldData, _excluded$N);
          var namePath = getNamePath(name);
          namePathList.push(namePath);
          if ("value" in data2) {
            _this.updateStore(setValue(_this.store, namePath, data2.value));
          }
          _this.notifyObservers(prevStore, [namePath], {
            type: "setField",
            data: fieldData
          });
        });
        _this.notifyWatch(namePathList);
      };
      this.getFields = function() {
        var entities = _this.getFieldEntities(true);
        var fields = entities.map(function(field) {
          var namePath = field.getNamePath();
          var meta = field.getMeta();
          var fieldData = _objectSpread2$3(_objectSpread2$3({}, meta), {}, {
            name: namePath,
            value: _this.getFieldValue(namePath)
          });
          Object.defineProperty(fieldData, "originRCField", {
            value: true
          });
          return fieldData;
        });
        return fields;
      };
      this.initEntityValue = function(entity) {
        var initialValue = entity.props.initialValue;
        if (initialValue !== void 0) {
          var namePath = entity.getNamePath();
          var prevValue = getValue$3(_this.store, namePath);
          if (prevValue === void 0) {
            _this.updateStore(setValue(_this.store, namePath, initialValue));
          }
        }
      };
      this.isMergedPreserve = function(fieldPreserve) {
        var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
        return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
      };
      this.registerField = function(entity) {
        _this.fieldEntities.push(entity);
        var namePath = entity.getNamePath();
        _this.notifyWatch([namePath]);
        if (entity.props.initialValue !== void 0) {
          var prevStore = _this.store;
          _this.resetWithFieldInitialValue({
            entities: [entity],
            skipExist: true
          });
          _this.notifyObservers(prevStore, [entity.getNamePath()], {
            type: "valueUpdate",
            source: "internal"
          });
        }
        return function(isListField, preserve) {
          var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          _this.fieldEntities = _this.fieldEntities.filter(function(item) {
            return item !== entity;
          });
          if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {
            var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
            if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
              return (
                // Only reset when no namePath exist
                !matchNamePath(field.getNamePath(), namePath)
              );
            })) {
              var _prevStore = _this.store;
              _this.updateStore(setValue(_prevStore, namePath, defaultValue, true));
              _this.notifyObservers(_prevStore, [namePath], {
                type: "remove"
              });
              _this.triggerDependenciesUpdate(_prevStore, namePath);
            }
          }
          _this.notifyWatch([namePath]);
        };
      };
      this.dispatch = function(action) {
        switch (action.type) {
          case "updateValue": {
            var namePath = action.namePath, value = action.value;
            _this.updateValue(namePath, value);
            break;
          }
          case "validateField": {
            var _namePath = action.namePath, triggerName = action.triggerName;
            _this.validateFields([_namePath], {
              triggerName
            });
            break;
          }
        }
      };
      this.notifyObservers = function(prevStore, namePathList, info2) {
        if (_this.subscribable) {
          var mergedInfo = _objectSpread2$3(_objectSpread2$3({}, info2), {}, {
            store: _this.getFieldsValue(true)
          });
          _this.getFieldEntities().forEach(function(_ref3) {
            var onStoreChange = _ref3.onStoreChange;
            onStoreChange(prevStore, namePathList, mergedInfo);
          });
        } else {
          _this.forceRootUpdate();
        }
      };
      this.triggerDependenciesUpdate = function(prevStore, namePath) {
        var childrenFields = _this.getDependencyChildrenFields(namePath);
        if (childrenFields.length) {
          _this.validateFields(childrenFields);
        }
        _this.notifyObservers(prevStore, childrenFields, {
          type: "dependenciesUpdate",
          relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
        });
        return childrenFields;
      };
      this.updateValue = function(name, value) {
        var namePath = getNamePath(name);
        var prevStore = _this.store;
        _this.updateStore(setValue(_this.store, namePath, value));
        _this.notifyObservers(prevStore, [namePath], {
          type: "valueUpdate",
          source: "internal"
        });
        _this.notifyWatch([namePath]);
        var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
        var onValuesChange = _this.callbacks.onValuesChange;
        if (onValuesChange) {
          var changedValues = cloneByNamePathList(_this.store, [namePath]);
          onValuesChange(changedValues, _this.getFieldsValue());
        }
        _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
      };
      this.setFieldsValue = function(store) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        if (store) {
          var nextStore = setValues(_this.store, store);
          _this.updateStore(nextStore);
        }
        _this.notifyObservers(prevStore, null, {
          type: "valueUpdate",
          source: "external"
        });
        _this.notifyWatch();
      };
      this.setFieldValue = function(name, value) {
        _this.setFields([{
          name,
          value
        }]);
      };
      this.getDependencyChildrenFields = function(rootNamePath) {
        var children = /* @__PURE__ */ new Set();
        var childrenFields = [];
        var dependencies2fields = new NameMap();
        _this.getFieldEntities().forEach(function(field) {
          var dependencies = field.props.dependencies;
          (dependencies || []).forEach(function(dependency) {
            var dependencyNamePath = getNamePath(dependency);
            dependencies2fields.update(dependencyNamePath, function() {
              var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
              fields.add(field);
              return fields;
            });
          });
        });
        var fillChildren = function fillChildren2(namePath) {
          var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
          fields.forEach(function(field) {
            if (!children.has(field)) {
              children.add(field);
              var fieldNamePath = field.getNamePath();
              if (field.isFieldDirty() && fieldNamePath.length) {
                childrenFields.push(fieldNamePath);
                fillChildren2(fieldNamePath);
              }
            }
          });
        };
        fillChildren(rootNamePath);
        return childrenFields;
      };
      this.triggerOnFieldsChange = function(namePathList, filedErrors) {
        var onFieldsChange = _this.callbacks.onFieldsChange;
        if (onFieldsChange) {
          var fields = _this.getFields();
          if (filedErrors) {
            var cache2 = new NameMap();
            filedErrors.forEach(function(_ref4) {
              var name = _ref4.name, errors = _ref4.errors;
              cache2.set(name, errors);
            });
            fields.forEach(function(field) {
              field.errors = cache2.get(field.name) || field.errors;
            });
          }
          var changedFields = fields.filter(function(_ref5) {
            var fieldName = _ref5.name;
            return containsNamePath(namePathList, fieldName);
          });
          onFieldsChange(changedFields, fields);
        }
      };
      this.validateFields = function(nameList, options) {
        _this.warningUnhooked();
        var provideNameList = !!nameList;
        var namePathList = provideNameList ? nameList.map(getNamePath) : [];
        var promiseList = [];
        _this.getFieldEntities(true).forEach(function(field) {
          if (!provideNameList) {
            namePathList.push(field.getNamePath());
          }
          if ((options === null || options === void 0 ? void 0 : options.recursive) && provideNameList) {
            var namePath = field.getNamePath();
            if (
              // nameList[i] === undefined 说明是以 nameList 开头的
              // ['name'] -> ['name','list']
              namePath.every(function(nameUnit, i2) {
                return nameList[i2] === nameUnit || nameList[i2] === void 0;
              })
            ) {
              namePathList.push(namePath);
            }
          }
          if (!field.props.rules || !field.props.rules.length) {
            return;
          }
          var fieldNamePath = field.getNamePath();
          if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
            var promise = field.validateRules(_objectSpread2$3({
              validateMessages: _objectSpread2$3(_objectSpread2$3({}, defaultValidateMessages), _this.validateMessages)
            }, options));
            promiseList.push(promise.then(function() {
              return {
                name: fieldNamePath,
                errors: [],
                warnings: []
              };
            }).catch(function(ruleErrors) {
              var _ruleErrors$forEach;
              var mergedErrors = [];
              var mergedWarnings = [];
              (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref6) {
                var warningOnly = _ref6.rule.warningOnly, errors = _ref6.errors;
                if (warningOnly) {
                  mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
                } else {
                  mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
                }
              });
              if (mergedErrors.length) {
                return Promise.reject({
                  name: fieldNamePath,
                  errors: mergedErrors,
                  warnings: mergedWarnings
                });
              }
              return {
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              };
            }));
          }
        });
        var summaryPromise = allPromiseFinish(promiseList);
        _this.lastValidatePromise = summaryPromise;
        summaryPromise.catch(function(results) {
          return results;
        }).then(function(results) {
          var resultNamePathList = results.map(function(_ref7) {
            var name = _ref7.name;
            return name;
          });
          _this.notifyObservers(_this.store, resultNamePathList, {
            type: "validateFinish"
          });
          _this.triggerOnFieldsChange(resultNamePathList, results);
        });
        var returnPromise = summaryPromise.then(function() {
          if (_this.lastValidatePromise === summaryPromise) {
            return Promise.resolve(_this.getFieldsValue(namePathList));
          }
          return Promise.reject([]);
        }).catch(function(results) {
          var errorList = results.filter(function(result) {
            return result && result.errors.length;
          });
          return Promise.reject({
            values: _this.getFieldsValue(namePathList),
            errorFields: errorList,
            outOfDate: _this.lastValidatePromise !== summaryPromise
          });
        });
        returnPromise.catch(function(e2) {
          return e2;
        });
        return returnPromise;
      };
      this.submit = function() {
        _this.warningUnhooked();
        _this.validateFields().then(function(values) {
          var onFinish = _this.callbacks.onFinish;
          if (onFinish) {
            try {
              onFinish(values);
            } catch (err) {
              console.error(err);
            }
          }
        }).catch(function(e2) {
          var onFinishFailed = _this.callbacks.onFinishFailed;
          if (onFinishFailed) {
            onFinishFailed(e2);
          }
        });
      };
      this.forceRootUpdate = forceRootUpdate;
    });
    function useForm$2(form) {
      var formRef = reactExports.useRef();
      var _React$useState = reactExports.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
      if (!formRef.current) {
        if (form) {
          formRef.current = form;
        } else {
          var forceReRender = function forceReRender2() {
            forceUpdate({});
          };
          var formStore = new FormStore(forceReRender);
          formRef.current = formStore.getForm();
        }
      }
      return [formRef.current];
    }
    var FormContext$1 = /* @__PURE__ */ reactExports.createContext({
      triggerFormChange: function triggerFormChange() {
      },
      triggerFormFinish: function triggerFormFinish() {
      },
      registerForm: function registerForm() {
      },
      unregisterForm: function unregisterForm() {
      }
    });
    var FormProvider$1 = function FormProvider2(_ref) {
      var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;
      var formContext = reactExports.useContext(FormContext$1);
      var formsRef = reactExports.useRef({});
      return /* @__PURE__ */ reactExports.createElement(FormContext$1.Provider, {
        value: _objectSpread2$3(_objectSpread2$3({}, formContext), {}, {
          validateMessages: _objectSpread2$3(_objectSpread2$3({}, formContext.validateMessages), validateMessages),
          // =========================================================
          // =                  Global Form Control                  =
          // =========================================================
          triggerFormChange: function triggerFormChange(name, changedFields) {
            if (onFormChange) {
              onFormChange(name, {
                changedFields,
                forms: formsRef.current
              });
            }
            formContext.triggerFormChange(name, changedFields);
          },
          triggerFormFinish: function triggerFormFinish(name, values) {
            if (onFormFinish) {
              onFormFinish(name, {
                values,
                forms: formsRef.current
              });
            }
            formContext.triggerFormFinish(name, values);
          },
          registerForm: function registerForm(name, form) {
            if (name) {
              formsRef.current = _objectSpread2$3(_objectSpread2$3({}, formsRef.current), {}, _defineProperty$7({}, name, form));
            }
            formContext.registerForm(name, form);
          },
          unregisterForm: function unregisterForm(name) {
            var newForms = _objectSpread2$3({}, formsRef.current);
            delete newForms[name];
            formsRef.current = newForms;
            formContext.unregisterForm(name);
          }
        })
      }, children);
    };
    var _excluded$M = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"];
    var Form$3 = function Form2(_ref, ref) {
      var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, restProps = _objectWithoutProperties$1(_ref, _excluded$M);
      var formContext = reactExports.useContext(FormContext$1);
      var _useForm = useForm$2(form), _useForm2 = _slicedToArray(_useForm, 1), formInstance = _useForm2[0];
      var _formInstance$getInte = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _formInstance$getInte.useSubscribe, setInitialValues = _formInstance$getInte.setInitialValues, setCallbacks = _formInstance$getInte.setCallbacks, setValidateMessages = _formInstance$getInte.setValidateMessages, setPreserve = _formInstance$getInte.setPreserve, destroyForm = _formInstance$getInte.destroyForm;
      reactExports.useImperativeHandle(ref, function() {
        return formInstance;
      });
      reactExports.useEffect(function() {
        formContext.registerForm(name, formInstance);
        return function() {
          formContext.unregisterForm(name);
        };
      }, [formContext, formInstance, name]);
      setValidateMessages(_objectSpread2$3(_objectSpread2$3({}, formContext.validateMessages), validateMessages));
      setCallbacks({
        onValuesChange,
        onFieldsChange: function onFieldsChange(changedFields) {
          formContext.triggerFormChange(name, changedFields);
          if (_onFieldsChange) {
            for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              rest[_key - 1] = arguments[_key];
            }
            _onFieldsChange.apply(void 0, [changedFields].concat(rest));
          }
        },
        onFinish: function onFinish(values2) {
          formContext.triggerFormFinish(name, values2);
          if (_onFinish) {
            _onFinish(values2);
          }
        },
        onFinishFailed
      });
      setPreserve(preserve);
      var mountRef = reactExports.useRef(null);
      setInitialValues(initialValues, !mountRef.current);
      if (!mountRef.current) {
        mountRef.current = true;
      }
      reactExports.useEffect(
        function() {
          return destroyForm;
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        []
      );
      var childrenNode;
      var childrenRenderProps = typeof children === "function";
      if (childrenRenderProps) {
        var values = formInstance.getFieldsValue(true);
        childrenNode = children(values, formInstance);
      } else {
        childrenNode = children;
      }
      useSubscribe(!childrenRenderProps);
      var prevFieldsRef = reactExports.useRef();
      reactExports.useEffect(function() {
        if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
          formInstance.setFields(fields || []);
        }
        prevFieldsRef.current = fields;
      }, [fields, formInstance]);
      var formContextValue = reactExports.useMemo(function() {
        return _objectSpread2$3(_objectSpread2$3({}, formInstance), {}, {
          validateTrigger
        });
      }, [formInstance, validateTrigger]);
      var wrapperNode = /* @__PURE__ */ reactExports.createElement(Context$2.Provider, {
        value: formContextValue
      }, childrenNode);
      if (Component === false) {
        return wrapperNode;
      }
      return /* @__PURE__ */ reactExports.createElement(Component, _extends$2({}, restProps, {
        onSubmit: function onSubmit(event) {
          event.preventDefault();
          event.stopPropagation();
          formInstance.submit();
        },
        onReset: function onReset(event) {
          var _restProps$onReset;
          event.preventDefault();
          formInstance.resetFields();
          (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 ? void 0 : _restProps$onReset.call(restProps, event);
        }
      }), wrapperNode);
    };
    function stringify$3(value) {
      try {
        return JSON.stringify(value);
      } catch (err) {
        return Math.random();
      }
    }
    function useWatch$1() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var _args$ = args[0], dependencies = _args$ === void 0 ? [] : _args$, form = args[1];
      var _useState = reactExports.useState(), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue2 = _useState2[1];
      var valueStr = reactExports.useMemo(function() {
        return stringify$3(value);
      }, [value]);
      var valueStrRef = reactExports.useRef(valueStr);
      valueStrRef.current = valueStr;
      var fieldContext = reactExports.useContext(Context$2);
      var formInstance = form || fieldContext;
      var isValidForm = formInstance && formInstance._init;
      var namePath = getNamePath(dependencies);
      var namePathRef = reactExports.useRef(namePath);
      namePathRef.current = namePath;
      reactExports.useEffect(
        function() {
          if (!isValidForm) {
            return;
          }
          var getFieldsValue = formInstance.getFieldsValue, getInternalHooks = formInstance.getInternalHooks;
          var _getInternalHooks = getInternalHooks(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
          var cancelRegister = registerWatch(function(store) {
            var newValue = getValue$3(store, namePathRef.current);
            var nextValueStr = stringify$3(newValue);
            if (valueStrRef.current !== nextValueStr) {
              valueStrRef.current = nextValueStr;
              setValue2(newValue);
            }
          });
          var initialValue = getValue$3(getFieldsValue(), namePathRef.current);
          setValue2(initialValue);
          return cancelRegister;
        },
        // We do not need re-register since namePath content is the same
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [isValidForm]
      );
      return value;
    }
    var InternalForm$2 = /* @__PURE__ */ reactExports.forwardRef(Form$3);
    var RefForm = InternalForm$2;
    RefForm.FormProvider = FormProvider$1;
    RefForm.Field = WrapperField;
    RefForm.List = List$2;
    RefForm.useForm = useForm$2;
    RefForm.useWatch = useWatch$1;
    const enUS$1 = {
      // Options.jsx
      items_per_page: "/ page",
      jump_to: "Go to",
      jump_to_confirm: "confirm",
      page: "Page",
      // Pagination.jsx
      prev_page: "Previous Page",
      next_page: "Next Page",
      prev_5: "Previous 5 Pages",
      next_5: "Next 5 Pages",
      prev_3: "Previous 3 Pages",
      next_3: "Next 3 Pages",
      page_size: "Page Size"
    };
    var locale$2 = {
      locale: "en_US",
      today: "Today",
      now: "Now",
      backToToday: "Back to today",
      ok: "OK",
      clear: "Clear",
      month: "Month",
      year: "Year",
      timeSelect: "select time",
      dateSelect: "select date",
      weekSelect: "Choose a week",
      monthSelect: "Choose a month",
      yearSelect: "Choose a year",
      decadeSelect: "Choose a decade",
      yearFormat: "YYYY",
      dateFormat: "M/D/YYYY",
      dayFormat: "D",
      dateTimeFormat: "M/D/YYYY HH:mm:ss",
      monthBeforeYear: true,
      previousMonth: "Previous month (PageUp)",
      nextMonth: "Next month (PageDown)",
      previousYear: "Last year (Control + left)",
      nextYear: "Next year (Control + right)",
      previousDecade: "Last decade",
      nextDecade: "Next decade",
      previousCentury: "Last century",
      nextCentury: "Next century"
    };
    const locale$1 = {
      placeholder: "Select time",
      rangePlaceholder: ["Start time", "End time"]
    };
    const TimePicker$2 = locale$1;
    const locale = {
      lang: Object.assign({
        placeholder: "Select date",
        yearPlaceholder: "Select year",
        quarterPlaceholder: "Select quarter",
        monthPlaceholder: "Select month",
        weekPlaceholder: "Select week",
        rangePlaceholder: ["Start date", "End date"],
        rangeYearPlaceholder: ["Start year", "End year"],
        rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
        rangeMonthPlaceholder: ["Start month", "End month"],
        rangeWeekPlaceholder: ["Start week", "End week"]
      }, locale$2),
      timePickerLocale: Object.assign({}, TimePicker$2)
    };
    const enUS = locale;
    const typeTemplate = "${label} is not a valid ${type}";
    const localeValues = {
      locale: "en",
      Pagination: enUS$1,
      DatePicker: enUS,
      TimePicker: TimePicker$2,
      Calendar: enUS,
      global: {
        placeholder: "Please select"
      },
      Table: {
        filterTitle: "Filter menu",
        filterConfirm: "OK",
        filterReset: "Reset",
        filterEmptyText: "No filters",
        filterCheckall: "Select all items",
        filterSearchPlaceholder: "Search in filters",
        emptyText: "No data",
        selectAll: "Select current page",
        selectInvert: "Invert current page",
        selectNone: "Clear all data",
        selectionAll: "Select all data",
        sortTitle: "Sort",
        expand: "Expand row",
        collapse: "Collapse row",
        triggerDesc: "Click to sort descending",
        triggerAsc: "Click to sort ascending",
        cancelSort: "Click to cancel sorting"
      },
      Tour: {
        Next: "Next",
        Previous: "Previous",
        Finish: "Finish"
      },
      Modal: {
        okText: "OK",
        cancelText: "Cancel",
        justOkText: "OK"
      },
      Popconfirm: {
        okText: "OK",
        cancelText: "Cancel"
      },
      Transfer: {
        titles: ["", ""],
        searchPlaceholder: "Search here",
        itemUnit: "item",
        itemsUnit: "items",
        remove: "Remove",
        selectCurrent: "Select current page",
        removeCurrent: "Remove current page",
        selectAll: "Select all data",
        removeAll: "Remove all data",
        selectInvert: "Invert current page"
      },
      Upload: {
        uploading: "Uploading...",
        removeFile: "Remove file",
        uploadError: "Upload error",
        previewFile: "Preview file",
        downloadFile: "Download file"
      },
      Empty: {
        description: "No data"
      },
      Icon: {
        icon: "icon"
      },
      Text: {
        edit: "Edit",
        copy: "Copy",
        copied: "Copied",
        expand: "Expand"
      },
      PageHeader: {
        back: "Back"
      },
      Form: {
        optional: "(optional)",
        defaultValidateMessages: {
          default: "Field validation error for ${label}",
          required: "Please enter ${label}",
          enum: "${label} must be one of [${enum}]",
          whitespace: "${label} cannot be a blank character",
          date: {
            format: "${label} date format is invalid",
            parse: "${label} cannot be converted to a date",
            invalid: "${label} is an invalid date"
          },
          types: {
            string: typeTemplate,
            method: typeTemplate,
            array: typeTemplate,
            object: typeTemplate,
            number: typeTemplate,
            date: typeTemplate,
            boolean: typeTemplate,
            integer: typeTemplate,
            float: typeTemplate,
            regexp: typeTemplate,
            email: typeTemplate,
            url: typeTemplate,
            hex: typeTemplate
          },
          string: {
            len: "${label} must be ${len} characters",
            min: "${label} must be at least ${min} characters",
            max: "${label} must be up to ${max} characters",
            range: "${label} must be between ${min}-${max} characters"
          },
          number: {
            len: "${label} must be equal to ${len}",
            min: "${label} must be minimum ${min}",
            max: "${label} must be maximum ${max}",
            range: "${label} must be between ${min}-${max}"
          },
          array: {
            len: "Must be ${len} ${label}",
            min: "At least ${min} ${label}",
            max: "At most ${max} ${label}",
            range: "The amount of ${label} must be between ${min}-${max}"
          },
          pattern: {
            mismatch: "${label} does not match the pattern ${pattern}"
          }
        }
      },
      Image: {
        preview: "Preview"
      },
      QRCode: {
        expired: "QR code expired",
        refresh: "Refresh"
      }
    };
    const defaultLocale = localeValues;
    let runtimeLocale = Object.assign({}, defaultLocale.Modal);
    function changeConfirmLocale(newLocale) {
      if (newLocale) {
        runtimeLocale = Object.assign(Object.assign({}, runtimeLocale), newLocale);
      } else {
        runtimeLocale = Object.assign({}, defaultLocale.Modal);
      }
    }
    function getConfirmLocale() {
      return runtimeLocale;
    }
    const LocaleContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const LocaleContext$1 = LocaleContext;
    const ANT_MARK = "internalMark";
    const LocaleProvider = (props) => {
      const {
        locale: locale2 = {},
        children,
        _ANT_MARK__
      } = props;
      reactExports.useEffect(() => {
        changeConfirmLocale(locale2 && locale2.Modal);
        return () => {
          changeConfirmLocale();
        };
      }, [locale2]);
      const getMemoizedContextValue = reactExports.useMemo(() => Object.assign(Object.assign({}, locale2), {
        exist: true
      }), [locale2]);
      return /* @__PURE__ */ reactExports.createElement(LocaleContext$1.Provider, {
        value: getMemoizedContextValue
      }, children);
    };
    const LocaleProvider$1 = LocaleProvider;
    const version$1 = "5.3.0";
    const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
    function bound01(n2, max) {
      if (isOnePointZero(n2)) {
        n2 = "100%";
      }
      var isPercent = isPercentage(n2);
      n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
      if (isPercent) {
        n2 = parseInt(String(n2 * max), 10) / 100;
      }
      if (Math.abs(n2 - max) < 1e-6) {
        return 1;
      }
      if (max === 360) {
        n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
      } else {
        n2 = n2 % max / parseFloat(String(max));
      }
      return n2;
    }
    function clamp01(val) {
      return Math.min(1, Math.max(0, val));
    }
    function isOnePointZero(n2) {
      return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
    }
    function isPercentage(n2) {
      return typeof n2 === "string" && n2.indexOf("%") !== -1;
    }
    function boundAlpha(a) {
      a = parseFloat(a);
      if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
      }
      return a;
    }
    function convertToPercentage(n2) {
      if (n2 <= 1) {
        return "".concat(Number(n2) * 100, "%");
      }
      return n2;
    }
    function pad2(c2) {
      return c2.length === 1 ? "0" + c2 : String(c2);
    }
    function rgbToRgb(r2, g2, b2) {
      return {
        r: bound01(r2, 255) * 255,
        g: bound01(g2, 255) * 255,
        b: bound01(b2, 255) * 255
      };
    }
    function rgbToHsl(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max = Math.max(r2, g2, b2);
      var min = Math.min(r2, g2, b2);
      var h2 = 0;
      var s = 0;
      var l2 = (max + min) / 2;
      if (max === min) {
        s = 0;
        h2 = 0;
      } else {
        var d2 = max - min;
        s = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
        switch (max) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, l: l2 };
    }
    function hue2rgb(p2, q2, t2) {
      if (t2 < 0) {
        t2 += 1;
      }
      if (t2 > 1) {
        t2 -= 1;
      }
      if (t2 < 1 / 6) {
        return p2 + (q2 - p2) * (6 * t2);
      }
      if (t2 < 1 / 2) {
        return q2;
      }
      if (t2 < 2 / 3) {
        return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
      }
      return p2;
    }
    function hslToRgb(h2, s, l2) {
      var r2;
      var g2;
      var b2;
      h2 = bound01(h2, 360);
      s = bound01(s, 100);
      l2 = bound01(l2, 100);
      if (s === 0) {
        g2 = l2;
        b2 = l2;
        r2 = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
        var p2 = 2 * l2 - q2;
        r2 = hue2rgb(p2, q2, h2 + 1 / 3);
        g2 = hue2rgb(p2, q2, h2);
        b2 = hue2rgb(p2, q2, h2 - 1 / 3);
      }
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHsv(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max = Math.max(r2, g2, b2);
      var min = Math.min(r2, g2, b2);
      var h2 = 0;
      var v2 = max;
      var d2 = max - min;
      var s = max === 0 ? 0 : d2 / max;
      if (max === min) {
        h2 = 0;
      } else {
        switch (max) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, v: v2 };
    }
    function hsvToRgb(h2, s, v2) {
      h2 = bound01(h2, 360) * 6;
      s = bound01(s, 100);
      v2 = bound01(v2, 100);
      var i2 = Math.floor(h2);
      var f2 = h2 - i2;
      var p2 = v2 * (1 - s);
      var q2 = v2 * (1 - f2 * s);
      var t2 = v2 * (1 - (1 - f2) * s);
      var mod = i2 % 6;
      var r2 = [v2, q2, p2, p2, t2, v2][mod];
      var g2 = [t2, v2, v2, q2, p2, p2][mod];
      var b2 = [p2, p2, t2, v2, v2, q2][mod];
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHex(r2, g2, b2, allow3Char) {
      var hex = [
        pad2(Math.round(r2).toString(16)),
        pad2(Math.round(g2).toString(16)),
        pad2(Math.round(b2).toString(16))
      ];
      if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r2, g2, b2, a, allow4Char) {
      var hex = [
        pad2(Math.round(r2).toString(16)),
        pad2(Math.round(g2).toString(16)),
        pad2(Math.round(b2).toString(16)),
        pad2(convertDecimalToHex(a))
      ];
      if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function convertDecimalToHex(d2) {
      return Math.round(parseFloat(d2) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function numberInputToObject(color2) {
      return {
        r: color2 >> 16,
        g: (color2 & 65280) >> 8,
        b: color2 & 255
      };
    }
    var names = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      goldenrod: "#daa520",
      gold: "#ffd700",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavenderblush: "#fff0f5",
      lavender: "#e6e6fa",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    function inputToRGB(color2) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a = 1;
      var s = null;
      var v2 = null;
      var l2 = null;
      var ok2 = false;
      var format2 = false;
      if (typeof color2 === "string") {
        color2 = stringInputToObject(color2);
      }
      if (typeof color2 === "object") {
        if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
          rgb = rgbToRgb(color2.r, color2.g, color2.b);
          ok2 = true;
          format2 = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
          s = convertToPercentage(color2.s);
          v2 = convertToPercentage(color2.v);
          rgb = hsvToRgb(color2.h, s, v2);
          ok2 = true;
          format2 = "hsv";
        } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
          s = convertToPercentage(color2.s);
          l2 = convertToPercentage(color2.l);
          rgb = hslToRgb(color2.h, s, l2);
          ok2 = true;
          format2 = "hsl";
        }
        if (Object.prototype.hasOwnProperty.call(color2, "a")) {
          a = color2.a;
        }
      }
      a = boundAlpha(a);
      return {
        ok: ok2,
        format: color2.format || format2,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a
      };
    }
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var matchers = {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
    function stringInputToObject(color2) {
      color2 = color2.trim().toLowerCase();
      if (color2.length === 0) {
        return false;
      }
      var named = false;
      if (names[color2]) {
        color2 = names[color2];
        named = true;
      } else if (color2 === "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match2 = matchers.rgb.exec(color2);
      if (match2) {
        return { r: match2[1], g: match2[2], b: match2[3] };
      }
      match2 = matchers.rgba.exec(color2);
      if (match2) {
        return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
      }
      match2 = matchers.hsl.exec(color2);
      if (match2) {
        return { h: match2[1], s: match2[2], l: match2[3] };
      }
      match2 = matchers.hsla.exec(color2);
      if (match2) {
        return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
      }
      match2 = matchers.hsv.exec(color2);
      if (match2) {
        return { h: match2[1], s: match2[2], v: match2[3] };
      }
      match2 = matchers.hsva.exec(color2);
      if (match2) {
        return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
      }
      match2 = matchers.hex8.exec(color2);
      if (match2) {
        return {
          r: parseIntFromHex(match2[1]),
          g: parseIntFromHex(match2[2]),
          b: parseIntFromHex(match2[3]),
          a: convertHexToDecimal(match2[4]),
          format: named ? "name" : "hex8"
        };
      }
      match2 = matchers.hex6.exec(color2);
      if (match2) {
        return {
          r: parseIntFromHex(match2[1]),
          g: parseIntFromHex(match2[2]),
          b: parseIntFromHex(match2[3]),
          format: named ? "name" : "hex"
        };
      }
      match2 = matchers.hex4.exec(color2);
      if (match2) {
        return {
          r: parseIntFromHex(match2[1] + match2[1]),
          g: parseIntFromHex(match2[2] + match2[2]),
          b: parseIntFromHex(match2[3] + match2[3]),
          a: convertHexToDecimal(match2[4] + match2[4]),
          format: named ? "name" : "hex8"
        };
      }
      match2 = matchers.hex3.exec(color2);
      if (match2) {
        return {
          r: parseIntFromHex(match2[1] + match2[1]),
          g: parseIntFromHex(match2[2] + match2[2]),
          b: parseIntFromHex(match2[3] + match2[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function isValidCSSUnit(color2) {
      return Boolean(matchers.CSS_UNIT.exec(String(color2)));
    }
    var TinyColor = (
      /** @class */
      function() {
        function TinyColor2(color2, opts) {
          if (color2 === void 0) {
            color2 = "";
          }
          if (opts === void 0) {
            opts = {};
          }
          var _a;
          if (color2 instanceof TinyColor2) {
            return color2;
          }
          if (typeof color2 === "number") {
            color2 = numberInputToObject(color2);
          }
          this.originalInput = color2;
          var rgb = inputToRGB(color2);
          this.originalInput = color2;
          this.r = rgb.r;
          this.g = rgb.g;
          this.b = rgb.b;
          this.a = rgb.a;
          this.roundA = Math.round(100 * this.a) / 100;
          this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
          this.gradientType = opts.gradientType;
          if (this.r < 1) {
            this.r = Math.round(this.r);
          }
          if (this.g < 1) {
            this.g = Math.round(this.g);
          }
          if (this.b < 1) {
            this.b = Math.round(this.b);
          }
          this.isValid = rgb.ok;
        }
        TinyColor2.prototype.isDark = function() {
          return this.getBrightness() < 128;
        };
        TinyColor2.prototype.isLight = function() {
          return !this.isDark();
        };
        TinyColor2.prototype.getBrightness = function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        };
        TinyColor2.prototype.getLuminance = function() {
          var rgb = this.toRgb();
          var R2;
          var G2;
          var B2;
          var RsRGB = rgb.r / 255;
          var GsRGB = rgb.g / 255;
          var BsRGB = rgb.b / 255;
          if (RsRGB <= 0.03928) {
            R2 = RsRGB / 12.92;
          } else {
            R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G2 = GsRGB / 12.92;
          } else {
            G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B2 = BsRGB / 12.92;
          } else {
            B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
        };
        TinyColor2.prototype.getAlpha = function() {
          return this.a;
        };
        TinyColor2.prototype.setAlpha = function(alpha) {
          this.a = boundAlpha(alpha);
          this.roundA = Math.round(100 * this.a) / 100;
          return this;
        };
        TinyColor2.prototype.isMonochrome = function() {
          var s = this.toHsl().s;
          return s === 0;
        };
        TinyColor2.prototype.toHsv = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
        };
        TinyColor2.prototype.toHsvString = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          var h2 = Math.round(hsv.h * 360);
          var s = Math.round(hsv.s * 100);
          var v2 = Math.round(hsv.v * 100);
          return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHsl = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
        };
        TinyColor2.prototype.toHslString = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          var h2 = Math.round(hsl.h * 360);
          var s = Math.round(hsl.s * 100);
          var l2 = Math.round(hsl.l * 100);
          return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHex = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return rgbToHex(this.r, this.g, this.b, allow3Char);
        };
        TinyColor2.prototype.toHexString = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return "#" + this.toHex(allow3Char);
        };
        TinyColor2.prototype.toHex8 = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
        };
        TinyColor2.prototype.toHex8String = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return "#" + this.toHex8(allow4Char);
        };
        TinyColor2.prototype.toHexShortString = function(allowShortChar) {
          if (allowShortChar === void 0) {
            allowShortChar = false;
          }
          return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
        };
        TinyColor2.prototype.toRgb = function() {
          return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toRgbString = function() {
          var r2 = Math.round(this.r);
          var g2 = Math.round(this.g);
          var b2 = Math.round(this.b);
          return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toPercentageRgb = function() {
          var fmt = function(x2) {
            return "".concat(Math.round(bound01(x2, 255) * 100), "%");
          };
          return {
            r: fmt(this.r),
            g: fmt(this.g),
            b: fmt(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toPercentageRgbString = function() {
          var rnd = function(x2) {
            return Math.round(bound01(x2, 255) * 100);
          };
          return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toName = function() {
          if (this.a === 0) {
            return "transparent";
          }
          if (this.a < 1) {
            return false;
          }
          var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
          for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            if (hex === value) {
              return key;
            }
          }
          return false;
        };
        TinyColor2.prototype.toString = function(format2) {
          var formatSet = Boolean(format2);
          format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
          var formattedString = false;
          var hasAlpha = this.a < 1 && this.a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
          if (needsAlphaFormat) {
            if (format2 === "name" && this.a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format2 === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format2 === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format2 === "hex" || format2 === "hex6") {
            formattedString = this.toHexString();
          }
          if (format2 === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format2 === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format2 === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format2 === "name") {
            formattedString = this.toName();
          }
          if (format2 === "hsl") {
            formattedString = this.toHslString();
          }
          if (format2 === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        };
        TinyColor2.prototype.toNumber = function() {
          return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
        };
        TinyColor2.prototype.clone = function() {
          return new TinyColor2(this.toString());
        };
        TinyColor2.prototype.lighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.brighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var rgb = this.toRgb();
          rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
          rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
          rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
          return new TinyColor2(rgb);
        };
        TinyColor2.prototype.darken = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.tint = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("white", amount);
        };
        TinyColor2.prototype.shade = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("black", amount);
        };
        TinyColor2.prototype.desaturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.saturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.greyscale = function() {
          return this.desaturate(100);
        };
        TinyColor2.prototype.spin = function(amount) {
          var hsl = this.toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.mix = function(color2, amount) {
          if (amount === void 0) {
            amount = 50;
          }
          var rgb1 = this.toRgb();
          var rgb2 = new TinyColor2(color2).toRgb();
          var p2 = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
            g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
            b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
            a: (rgb2.a - rgb1.a) * p2 + rgb1.a
          };
          return new TinyColor2(rgba);
        };
        TinyColor2.prototype.analogous = function(results, slices) {
          if (results === void 0) {
            results = 6;
          }
          if (slices === void 0) {
            slices = 30;
          }
          var hsl = this.toHsl();
          var part = 360 / slices;
          var ret = [this];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(new TinyColor2(hsl));
          }
          return ret;
        };
        TinyColor2.prototype.complement = function() {
          var hsl = this.toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.monochromatic = function(results) {
          if (results === void 0) {
            results = 6;
          }
          var hsv = this.toHsv();
          var h2 = hsv.h;
          var s = hsv.s;
          var v2 = hsv.v;
          var res = [];
          var modification = 1 / results;
          while (results--) {
            res.push(new TinyColor2({ h: h2, s, v: v2 }));
            v2 = (v2 + modification) % 1;
          }
          return res;
        };
        TinyColor2.prototype.splitcomplement = function() {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          return [
            this,
            new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
            new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
          ];
        };
        TinyColor2.prototype.onBackground = function(background) {
          var fg2 = this.toRgb();
          var bg2 = new TinyColor2(background).toRgb();
          var alpha = fg2.a + bg2.a * (1 - fg2.a);
          return new TinyColor2({
            r: (fg2.r * fg2.a + bg2.r * bg2.a * (1 - fg2.a)) / alpha,
            g: (fg2.g * fg2.a + bg2.g * bg2.a * (1 - fg2.a)) / alpha,
            b: (fg2.b * fg2.a + bg2.b * bg2.a * (1 - fg2.a)) / alpha,
            a: alpha
          });
        };
        TinyColor2.prototype.triad = function() {
          return this.polyad(3);
        };
        TinyColor2.prototype.tetrad = function() {
          return this.polyad(4);
        };
        TinyColor2.prototype.polyad = function(n2) {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          var result = [this];
          var increment2 = 360 / n2;
          for (var i2 = 1; i2 < n2; i2++) {
            result.push(new TinyColor2({ h: (h2 + i2 * increment2) % 360, s: hsl.s, l: hsl.l }));
          }
          return result;
        };
        TinyColor2.prototype.equals = function(color2) {
          return this.toRgbString() === new TinyColor2(color2).toRgbString();
        };
        return TinyColor2;
      }()
    );
    var hueStep$1 = 2;
    var saturationStep$1 = 0.16;
    var saturationStep2$1 = 0.05;
    var brightnessStep1$1 = 0.05;
    var brightnessStep2$1 = 0.15;
    var lightColorCount$1 = 5;
    var darkColorCount$1 = 4;
    var darkColorMap$1 = [{
      index: 7,
      opacity: 0.15
    }, {
      index: 6,
      opacity: 0.25
    }, {
      index: 5,
      opacity: 0.3
    }, {
      index: 5,
      opacity: 0.45
    }, {
      index: 5,
      opacity: 0.65
    }, {
      index: 5,
      opacity: 0.85
    }, {
      index: 4,
      opacity: 0.9
    }, {
      index: 3,
      opacity: 0.95
    }, {
      index: 2,
      opacity: 0.97
    }, {
      index: 1,
      opacity: 0.98
    }];
    function toHsv$1(_ref) {
      var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
      var hsv = rgbToHsv(r2, g2, b2);
      return {
        h: hsv.h * 360,
        s: hsv.s,
        v: hsv.v
      };
    }
    function toHex$1(_ref2) {
      var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
      return "#".concat(rgbToHex(r2, g2, b2, false));
    }
    function mix$2(rgb1, rgb2, amount) {
      var p2 = amount / 100;
      var rgb = {
        r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p2 + rgb1.b
      };
      return rgb;
    }
    function getHue$1(hsv, i2, light) {
      var hue;
      if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
        hue = light ? Math.round(hsv.h) - hueStep$1 * i2 : Math.round(hsv.h) + hueStep$1 * i2;
      } else {
        hue = light ? Math.round(hsv.h) + hueStep$1 * i2 : Math.round(hsv.h) - hueStep$1 * i2;
      }
      if (hue < 0) {
        hue += 360;
      } else if (hue >= 360) {
        hue -= 360;
      }
      return hue;
    }
    function getSaturation$1(hsv, i2, light) {
      if (hsv.h === 0 && hsv.s === 0) {
        return hsv.s;
      }
      var saturation;
      if (light) {
        saturation = hsv.s - saturationStep$1 * i2;
      } else if (i2 === darkColorCount$1) {
        saturation = hsv.s + saturationStep$1;
      } else {
        saturation = hsv.s + saturationStep2$1 * i2;
      }
      if (saturation > 1) {
        saturation = 1;
      }
      if (light && i2 === lightColorCount$1 && saturation > 0.1) {
        saturation = 0.1;
      }
      if (saturation < 0.06) {
        saturation = 0.06;
      }
      return Number(saturation.toFixed(2));
    }
    function getValue$2(hsv, i2, light) {
      var value;
      if (light) {
        value = hsv.v + brightnessStep1$1 * i2;
      } else {
        value = hsv.v - brightnessStep2$1 * i2;
      }
      if (value > 1) {
        value = 1;
      }
      return Number(value.toFixed(2));
    }
    function generate$3(color2) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var patterns = [];
      var pColor = inputToRGB(color2);
      for (var i2 = lightColorCount$1; i2 > 0; i2 -= 1) {
        var hsv = toHsv$1(pColor);
        var colorString = toHex$1(inputToRGB({
          h: getHue$1(hsv, i2, true),
          s: getSaturation$1(hsv, i2, true),
          v: getValue$2(hsv, i2, true)
        }));
        patterns.push(colorString);
      }
      patterns.push(toHex$1(pColor));
      for (var _i = 1; _i <= darkColorCount$1; _i += 1) {
        var _hsv = toHsv$1(pColor);
        var _colorString = toHex$1(inputToRGB({
          h: getHue$1(_hsv, _i),
          s: getSaturation$1(_hsv, _i),
          v: getValue$2(_hsv, _i)
        }));
        patterns.push(_colorString);
      }
      if (opts.theme === "dark") {
        return darkColorMap$1.map(function(_ref3) {
          var index2 = _ref3.index, opacity = _ref3.opacity;
          var darkColorString = toHex$1(mix$2(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
          return darkColorString;
        });
      }
      return patterns;
    }
    var presetPrimaryColors$1 = {
      red: "#F5222D",
      volcano: "#FA541C",
      orange: "#FA8C16",
      gold: "#FAAD14",
      yellow: "#FADB14",
      lime: "#A0D911",
      green: "#52C41A",
      cyan: "#13C2C2",
      blue: "#1677FF",
      geekblue: "#2F54EB",
      purple: "#722ED1",
      magenta: "#EB2F96",
      grey: "#666666"
    };
    var presetPalettes$1 = {};
    var presetDarkPalettes$1 = {};
    Object.keys(presetPrimaryColors$1).forEach(function(key) {
      presetPalettes$1[key] = generate$3(presetPrimaryColors$1[key]);
      presetPalettes$1[key].primary = presetPalettes$1[key][5];
      presetDarkPalettes$1[key] = generate$3(presetPrimaryColors$1[key], {
        theme: "dark",
        backgroundColor: "#141414"
      });
      presetDarkPalettes$1[key].primary = presetDarkPalettes$1[key][5];
    });
    var red = presetPalettes$1.red;
    var volcano = presetPalettes$1.volcano;
    var gold = presetPalettes$1.gold;
    var orange = presetPalettes$1.orange;
    var yellow = presetPalettes$1.yellow;
    var lime = presetPalettes$1.lime;
    var green = presetPalettes$1.green;
    var cyan = presetPalettes$1.cyan;
    var blue = presetPalettes$1.blue;
    var geekblue = presetPalettes$1.geekblue;
    var purple = presetPalettes$1.purple;
    var magenta = presetPalettes$1.magenta;
    var grey = presetPalettes$1.grey;
    var gray = presetPalettes$1.grey;
    const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      blue,
      cyan,
      geekblue,
      generate: generate$3,
      gold,
      gray,
      green,
      grey,
      lime,
      magenta,
      orange,
      presetDarkPalettes: presetDarkPalettes$1,
      presetPalettes: presetPalettes$1,
      presetPrimaryColors: presetPrimaryColors$1,
      purple,
      red,
      volcano,
      yellow
    }, Symbol.toStringTag, { value: "Module" }));
    const genControlHeight = (token2) => {
      const {
        controlHeight
      } = token2;
      return {
        controlHeightSM: controlHeight * 0.75,
        controlHeightXS: controlHeight * 0.5,
        controlHeightLG: controlHeight * 1.25
      };
    };
    const genControlHeight$1 = genControlHeight;
    function genSizeMapToken$1(token2) {
      const {
        sizeUnit,
        sizeStep
      } = token2;
      return {
        sizeXXL: sizeUnit * (sizeStep + 8),
        sizeXL: sizeUnit * (sizeStep + 4),
        sizeLG: sizeUnit * (sizeStep + 2),
        sizeMD: sizeUnit * (sizeStep + 1),
        sizeMS: sizeUnit * sizeStep,
        size: sizeUnit * sizeStep,
        sizeSM: sizeUnit * (sizeStep - 1),
        sizeXS: sizeUnit * (sizeStep - 2),
        sizeXXS: sizeUnit * (sizeStep - 3)
        // 4
      };
    }
    const defaultPresetColors = {
      blue: "#1677ff",
      purple: "#722ED1",
      cyan: "#13C2C2",
      green: "#52C41A",
      magenta: "#EB2F96",
      pink: "#eb2f96",
      red: "#F5222D",
      orange: "#FA8C16",
      yellow: "#FADB14",
      volcano: "#FA541C",
      geekblue: "#2F54EB",
      gold: "#FAAD14",
      lime: "#A0D911"
    };
    const seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
      // Color
      colorPrimary: "#1677ff",
      colorSuccess: "#52c41a",
      colorWarning: "#faad14",
      colorError: "#ff4d4f",
      colorInfo: "#1677ff",
      colorTextBase: "",
      colorBgBase: "",
      // Font
      fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
      fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
      fontSize: 14,
      // Line
      lineWidth: 1,
      lineType: "solid",
      // Motion
      motionUnit: 0.1,
      motionBase: 0,
      motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
      motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
      motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
      motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
      motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
      motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
      motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
      motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
      // Radius
      borderRadius: 6,
      // Size
      sizeUnit: 4,
      sizeStep: 4,
      sizePopupArrow: 16,
      // Control Base
      controlHeight: 32,
      // zIndex
      zIndexBase: 0,
      zIndexPopupBase: 1e3,
      // Image
      opacityImage: 1,
      // Wireframe
      wireframe: false
    });
    function genColorMapToken(seed, _ref) {
      let {
        generateColorPalettes: generateColorPalettes2,
        generateNeutralColorPalettes: generateNeutralColorPalettes2
      } = _ref;
      const {
        colorSuccess: colorSuccessBase,
        colorWarning: colorWarningBase,
        colorError: colorErrorBase,
        colorInfo: colorInfoBase,
        colorPrimary: colorPrimaryBase,
        colorBgBase,
        colorTextBase
      } = seed;
      const primaryColors = generateColorPalettes2(colorPrimaryBase);
      const successColors = generateColorPalettes2(colorSuccessBase);
      const warningColors = generateColorPalettes2(colorWarningBase);
      const errorColors = generateColorPalettes2(colorErrorBase);
      const infoColors = generateColorPalettes2(colorInfoBase);
      const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
      return Object.assign(Object.assign({}, neutralColors), {
        colorPrimaryBg: primaryColors[1],
        colorPrimaryBgHover: primaryColors[2],
        colorPrimaryBorder: primaryColors[3],
        colorPrimaryBorderHover: primaryColors[4],
        colorPrimaryHover: primaryColors[5],
        colorPrimary: primaryColors[6],
        colorPrimaryActive: primaryColors[7],
        colorPrimaryTextHover: primaryColors[8],
        colorPrimaryText: primaryColors[9],
        colorPrimaryTextActive: primaryColors[10],
        colorSuccessBg: successColors[1],
        colorSuccessBgHover: successColors[2],
        colorSuccessBorder: successColors[3],
        colorSuccessBorderHover: successColors[4],
        colorSuccessHover: successColors[4],
        colorSuccess: successColors[6],
        colorSuccessActive: successColors[7],
        colorSuccessTextHover: successColors[8],
        colorSuccessText: successColors[9],
        colorSuccessTextActive: successColors[10],
        colorErrorBg: errorColors[1],
        colorErrorBgHover: errorColors[2],
        colorErrorBorder: errorColors[3],
        colorErrorBorderHover: errorColors[4],
        colorErrorHover: errorColors[5],
        colorError: errorColors[6],
        colorErrorActive: errorColors[7],
        colorErrorTextHover: errorColors[8],
        colorErrorText: errorColors[9],
        colorErrorTextActive: errorColors[10],
        colorWarningBg: warningColors[1],
        colorWarningBgHover: warningColors[2],
        colorWarningBorder: warningColors[3],
        colorWarningBorderHover: warningColors[4],
        colorWarningHover: warningColors[4],
        colorWarning: warningColors[6],
        colorWarningActive: warningColors[7],
        colorWarningTextHover: warningColors[8],
        colorWarningText: warningColors[9],
        colorWarningTextActive: warningColors[10],
        colorInfoBg: infoColors[1],
        colorInfoBgHover: infoColors[2],
        colorInfoBorder: infoColors[3],
        colorInfoBorderHover: infoColors[4],
        colorInfoHover: infoColors[4],
        colorInfo: infoColors[6],
        colorInfoActive: infoColors[7],
        colorInfoTextHover: infoColors[8],
        colorInfoText: infoColors[9],
        colorInfoTextActive: infoColors[10],
        colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
        colorWhite: "#fff"
      });
    }
    const genRadius = (radiusBase) => {
      let radiusLG = radiusBase;
      let radiusSM = radiusBase;
      let radiusXS = radiusBase;
      let radiusOuter = radiusBase;
      if (radiusBase < 6 && radiusBase >= 5) {
        radiusLG = radiusBase + 1;
      } else if (radiusBase < 16 && radiusBase >= 6) {
        radiusLG = radiusBase + 2;
      } else if (radiusBase >= 16) {
        radiusLG = 16;
      }
      if (radiusBase < 7 && radiusBase >= 5) {
        radiusSM = 4;
      } else if (radiusBase < 8 && radiusBase >= 7) {
        radiusSM = 5;
      } else if (radiusBase < 14 && radiusBase >= 8) {
        radiusSM = 6;
      } else if (radiusBase < 16 && radiusBase >= 14) {
        radiusSM = 7;
      } else if (radiusBase >= 16) {
        radiusSM = 8;
      }
      if (radiusBase < 6 && radiusBase >= 2) {
        radiusXS = 1;
      } else if (radiusBase >= 6) {
        radiusXS = 2;
      }
      if (radiusBase > 4 && radiusBase < 8) {
        radiusOuter = 4;
      } else if (radiusBase >= 8) {
        radiusOuter = 6;
      }
      return {
        borderRadius: radiusBase > 16 ? 16 : radiusBase,
        borderRadiusXS: radiusXS,
        borderRadiusSM: radiusSM,
        borderRadiusLG: radiusLG,
        borderRadiusOuter: radiusOuter
      };
    };
    const genRadius$1 = genRadius;
    function genCommonMapToken(token2) {
      const {
        motionUnit,
        motionBase,
        borderRadius,
        lineWidth
      } = token2;
      return Object.assign({
        // motion
        motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
        motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
        motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
        // line
        lineWidthBold: lineWidth + 1
      }, genRadius$1(borderRadius));
    }
    const getAlphaColor$2 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
    const getSolidColor$1 = (baseColor, brightness) => {
      const instance = new TinyColor(baseColor);
      return instance.darken(brightness).toHexString();
    };
    const generateColorPalettes$1 = (baseColor) => {
      const colors = generate$3(baseColor);
      return {
        1: colors[0],
        2: colors[1],
        3: colors[2],
        4: colors[3],
        5: colors[4],
        6: colors[5],
        7: colors[6],
        8: colors[4],
        9: colors[5],
        10: colors[6]
        // 8: colors[7],
        // 9: colors[8],
        // 10: colors[9],
      };
    };
    const generateNeutralColorPalettes$1 = (bgBaseColor, textBaseColor) => {
      const colorBgBase = bgBaseColor || "#fff";
      const colorTextBase = textBaseColor || "#000";
      return {
        colorBgBase,
        colorTextBase,
        colorText: getAlphaColor$2(colorTextBase, 0.88),
        colorTextSecondary: getAlphaColor$2(colorTextBase, 0.65),
        colorTextTertiary: getAlphaColor$2(colorTextBase, 0.45),
        colorTextQuaternary: getAlphaColor$2(colorTextBase, 0.25),
        colorFill: getAlphaColor$2(colorTextBase, 0.15),
        colorFillSecondary: getAlphaColor$2(colorTextBase, 0.06),
        colorFillTertiary: getAlphaColor$2(colorTextBase, 0.04),
        colorFillQuaternary: getAlphaColor$2(colorTextBase, 0.02),
        colorBgLayout: getSolidColor$1(colorBgBase, 4),
        colorBgContainer: getSolidColor$1(colorBgBase, 0),
        colorBgElevated: getSolidColor$1(colorBgBase, 0),
        colorBgSpotlight: getAlphaColor$2(colorTextBase, 0.85),
        colorBorder: getSolidColor$1(colorBgBase, 15),
        colorBorderSecondary: getSolidColor$1(colorBgBase, 6)
      };
    };
    function getFontSizes(base) {
      const fontSizes = new Array(10).fill(null).map((_, index2) => {
        const i2 = index2 - 1;
        const baseSize = base * Math.pow(2.71828, i2 / 5);
        const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
        return Math.floor(intSize / 2) * 2;
      });
      fontSizes[1] = base;
      return fontSizes.map((size) => {
        const height = size + 8;
        return {
          size,
          lineHeight: height / size
        };
      });
    }
    const genFontMapToken = (fontSize) => {
      const fontSizePairs = getFontSizes(fontSize);
      const fontSizes = fontSizePairs.map((pair) => pair.size);
      const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
      return {
        fontSizeSM: fontSizes[0],
        fontSize: fontSizes[1],
        fontSizeLG: fontSizes[2],
        fontSizeXL: fontSizes[3],
        fontSizeHeading1: fontSizes[6],
        fontSizeHeading2: fontSizes[5],
        fontSizeHeading3: fontSizes[4],
        fontSizeHeading4: fontSizes[3],
        fontSizeHeading5: fontSizes[2],
        lineHeight: lineHeights[1],
        lineHeightLG: lineHeights[2],
        lineHeightSM: lineHeights[0],
        lineHeightHeading1: lineHeights[6],
        lineHeightHeading2: lineHeights[5],
        lineHeightHeading3: lineHeights[4],
        lineHeightHeading4: lineHeights[3],
        lineHeightHeading5: lineHeights[2]
      };
    };
    const genFontMapToken$1 = genFontMapToken;
    function derivative$2(token2) {
      const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
        const colors = generate$3(token2[colorKey]);
        return new Array(10).fill(1).reduce((prev2, _, i2) => {
          prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
          prev2[`${colorKey}${i2 + 1}`] = colors[i2];
          return prev2;
        }, {});
      }).reduce((prev2, cur) => {
        prev2 = Object.assign(Object.assign({}, prev2), cur);
        return prev2;
      }, {});
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token2), colorPalettes), genColorMapToken(token2, {
        generateColorPalettes: generateColorPalettes$1,
        generateNeutralColorPalettes: generateNeutralColorPalettes$1
      })), genFontMapToken$1(token2.fontSize)), genSizeMapToken$1(token2)), genControlHeight$1(token2)), genCommonMapToken(token2));
    }
    function isStableColor(color2) {
      return color2 >= 0 && color2 <= 255;
    }
    function getAlphaColor$1(frontColor, backgroundColor) {
      const {
        r: fR,
        g: fG,
        b: fB,
        a: originAlpha
      } = new TinyColor(frontColor).toRgb();
      if (originAlpha < 1) {
        return frontColor;
      }
      const {
        r: bR,
        g: bG,
        b: bB
      } = new TinyColor(backgroundColor).toRgb();
      for (let fA = 0.01; fA <= 1; fA += 0.01) {
        const r2 = Math.round((fR - bR * (1 - fA)) / fA);
        const g2 = Math.round((fG - bG * (1 - fA)) / fA);
        const b2 = Math.round((fB - bB * (1 - fA)) / fA);
        if (isStableColor(r2) && isStableColor(g2) && isStableColor(b2)) {
          return new TinyColor({
            r: r2,
            g: g2,
            b: b2,
            a: Math.round(fA * 100) / 100
          }).toRgbString();
        }
      }
      return new TinyColor({
        r: fR,
        g: fG,
        b: fB,
        a: 1
      }).toRgbString();
    }
    var __rest$15 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function formatToken(derivativeToken) {
      const {
        override
      } = derivativeToken, restToken = __rest$15(derivativeToken, ["override"]);
      const overrideTokens = Object.assign({}, override);
      Object.keys(seedToken).forEach((token2) => {
        delete overrideTokens[token2];
      });
      const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
      const screenXS = 480;
      const screenSM = 576;
      const screenMD = 768;
      const screenLG = 992;
      const screenXL = 1200;
      const screenXXL = 1600;
      const aliasToken = Object.assign(Object.assign(Object.assign({}, mergedToken), {
        colorLink: mergedToken.colorInfoText,
        colorLinkHover: mergedToken.colorInfoHover,
        colorLinkActive: mergedToken.colorInfoActive,
        // ============== Background ============== //
        colorFillContent: mergedToken.colorFillSecondary,
        colorFillContentHover: mergedToken.colorFill,
        colorFillAlter: mergedToken.colorFillQuaternary,
        colorBgContainerDisabled: mergedToken.colorFillTertiary,
        // ============== Split ============== //
        colorBorderBg: mergedToken.colorBgContainer,
        colorSplit: getAlphaColor$1(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
        // ============== Text ============== //
        colorTextPlaceholder: mergedToken.colorTextQuaternary,
        colorTextDisabled: mergedToken.colorTextQuaternary,
        colorTextHeading: mergedToken.colorText,
        colorTextLabel: mergedToken.colorTextSecondary,
        colorTextDescription: mergedToken.colorTextTertiary,
        colorTextLightSolid: mergedToken.colorWhite,
        colorHighlight: mergedToken.colorError,
        colorBgTextHover: mergedToken.colorFillSecondary,
        colorBgTextActive: mergedToken.colorFill,
        colorIcon: mergedToken.colorTextTertiary,
        colorIconHover: mergedToken.colorText,
        colorErrorOutline: getAlphaColor$1(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
        colorWarningOutline: getAlphaColor$1(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
        // Font
        fontSizeIcon: mergedToken.fontSizeSM,
        // Line
        lineWidthFocus: mergedToken.lineWidth * 4,
        // Control
        lineWidth: mergedToken.lineWidth,
        controlOutlineWidth: mergedToken.lineWidth * 2,
        // Checkbox size and expand icon size
        controlInteractiveSize: mergedToken.controlHeight / 2,
        controlItemBgHover: mergedToken.colorFillTertiary,
        controlItemBgActive: mergedToken.colorPrimaryBg,
        controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
        controlItemBgActiveDisabled: mergedToken.colorFill,
        controlTmpOutline: mergedToken.colorFillQuaternary,
        controlOutline: getAlphaColor$1(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
        lineType: mergedToken.lineType,
        borderRadius: mergedToken.borderRadius,
        borderRadiusXS: mergedToken.borderRadiusXS,
        borderRadiusSM: mergedToken.borderRadiusSM,
        borderRadiusLG: mergedToken.borderRadiusLG,
        fontWeightStrong: 600,
        opacityLoading: 0.65,
        linkDecoration: "none",
        linkHoverDecoration: "none",
        linkFocusDecoration: "none",
        controlPaddingHorizontal: 12,
        controlPaddingHorizontalSM: 8,
        paddingXXS: mergedToken.sizeXXS,
        paddingXS: mergedToken.sizeXS,
        paddingSM: mergedToken.sizeSM,
        padding: mergedToken.size,
        paddingMD: mergedToken.sizeMD,
        paddingLG: mergedToken.sizeLG,
        paddingXL: mergedToken.sizeXL,
        paddingContentHorizontalLG: mergedToken.sizeLG,
        paddingContentVerticalLG: mergedToken.sizeMS,
        paddingContentHorizontal: mergedToken.sizeMS,
        paddingContentVertical: mergedToken.sizeSM,
        paddingContentHorizontalSM: mergedToken.size,
        paddingContentVerticalSM: mergedToken.sizeXS,
        marginXXS: mergedToken.sizeXXS,
        marginXS: mergedToken.sizeXS,
        marginSM: mergedToken.sizeSM,
        margin: mergedToken.size,
        marginMD: mergedToken.sizeMD,
        marginLG: mergedToken.sizeLG,
        marginXL: mergedToken.sizeXL,
        marginXXL: mergedToken.sizeXXL,
        boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
        screenXS,
        screenXSMin: screenXS,
        screenXSMax: screenSM - 1,
        screenSM,
        screenSMMin: screenSM,
        screenSMMax: screenMD - 1,
        screenMD,
        screenMDMin: screenMD,
        screenMDMax: screenLG - 1,
        screenLG,
        screenLGMin: screenLG,
        screenLGMax: screenXL - 1,
        screenXL,
        screenXLMin: screenXL,
        screenXLMax: screenXXL - 1,
        screenXXL,
        screenXXLMin: screenXXL,
        boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
        boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
        boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
      }), overrideTokens);
      return aliasToken;
    }
    const operationUnit$1 = (token2) => ({
      // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
      // And Typography use this to generate link style which should not do this.
      color: token2.colorLink,
      textDecoration: "none",
      outline: "none",
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "&:focus, &:hover": {
        color: token2.colorLinkHover
      },
      "&:active": {
        color: token2.colorLinkActive
      }
    });
    function genPresetColor(token2, genCss) {
      return PresetColors.reduce((prev2, colorKey) => {
        const lightColor = token2[`${colorKey}1`];
        const lightBorderColor = token2[`${colorKey}3`];
        const darkColor = token2[`${colorKey}6`];
        const textColor = token2[`${colorKey}7`];
        return Object.assign(Object.assign({}, prev2), genCss(colorKey, {
          lightColor,
          lightBorderColor,
          darkColor,
          textColor
        }));
      }, {});
    }
    const roundedArrow = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
      const unitWidth = width / 2;
      const ax = 0;
      const ay = unitWidth;
      const bx = outerRadius * 1 / Math.sqrt(2);
      const by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2));
      const cx = unitWidth - innerRadius * (1 / Math.sqrt(2));
      const cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2));
      const dx = 2 * unitWidth - cx;
      const dy = cy;
      const ex = 2 * unitWidth - bx;
      const ey = by;
      const fx = 2 * unitWidth - ax;
      const fy = ay;
      const shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2);
      return {
        pointerEvents: "none",
        width,
        height: width,
        overflow: "hidden",
        "&::before": {
          position: "absolute",
          bottom: 0,
          insetInlineStart: 0,
          width,
          height: width / 2,
          background: bgColor,
          clipPath: `path('M ${ax} ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')`,
          content: '""'
        },
        "&::after": {
          content: '""',
          position: "absolute",
          width: shadowWidth,
          height: shadowWidth,
          bottom: 0,
          insetInline: 0,
          margin: "auto",
          borderRadius: {
            _skip_check_: true,
            value: `0 0 ${innerRadius}px 0`
          },
          transform: "translateY(50%) rotate(-135deg)",
          boxShadow,
          zIndex: 0,
          background: "transparent"
        }
      };
    };
    const textEllipsis = {
      overflow: "hidden",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis"
    };
    const resetComponent$1 = (token2) => ({
      boxSizing: "border-box",
      margin: 0,
      padding: 0,
      color: token2.colorText,
      fontSize: token2.fontSize,
      // font-variant: @font-variant-base;
      lineHeight: token2.lineHeight,
      listStyle: "none",
      // font-feature-settings: @font-feature-settings-base;
      fontFamily: token2.fontFamily
    });
    const resetIcon = () => ({
      display: "inline-flex",
      alignItems: "center",
      color: "inherit",
      fontStyle: "normal",
      lineHeight: 0,
      textAlign: "center",
      textTransform: "none",
      // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
      verticalAlign: "-0.125em",
      textRendering: "optimizeLegibility",
      "-webkit-font-smoothing": "antialiased",
      "-moz-osx-font-smoothing": "grayscale",
      "> *": {
        lineHeight: 1
      },
      svg: {
        display: "inline-block"
      }
    });
    const clearFix = () => ({
      // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
      "&::before": {
        display: "table",
        content: '""'
      },
      "&::after": {
        // https://github.com/ant-design/ant-design/issues/21864
        display: "table",
        clear: "both",
        content: '""'
      }
    });
    const genLinkStyle = (token2) => ({
      a: {
        color: token2.colorLink,
        textDecoration: token2.linkDecoration,
        backgroundColor: "transparent",
        outline: "none",
        cursor: "pointer",
        transition: `color ${token2.motionDurationSlow}`,
        "-webkit-text-decoration-skip": "objects",
        "&:hover": {
          color: token2.colorLinkHover
        },
        "&:active": {
          color: token2.colorLinkActive
        },
        [`&:active,
  &:hover`]: {
          textDecoration: token2.linkHoverDecoration,
          outline: 0
        },
        // https://github.com/ant-design/ant-design/issues/22503
        "&:focus": {
          textDecoration: token2.linkFocusDecoration,
          outline: 0
        },
        "&[disabled]": {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      }
    });
    const genCommonStyle = (token2, componentPrefixCls) => {
      const {
        fontFamily,
        fontSize
      } = token2;
      const rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
      return {
        [rootPrefixSelector]: {
          fontFamily,
          fontSize,
          boxSizing: "border-box",
          "&::before, &::after": {
            boxSizing: "border-box"
          },
          [rootPrefixSelector]: {
            boxSizing: "border-box",
            "&::before, &::after": {
              boxSizing: "border-box"
            }
          }
        }
      };
    };
    const genFocusOutline = (token2) => ({
      outline: `${token2.lineWidthFocus}px solid ${token2.colorPrimaryBorder}`,
      outlineOffset: 1,
      transition: "outline-offset 0s, outline 0s"
    });
    const genFocusStyle = (token2) => ({
      "&:focus-visible": Object.assign({}, genFocusOutline(token2))
    });
    const defaultIconPrefixCls = "anticon";
    const defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls)
        return customizePrefixCls;
      return suffixCls ? `ant-${suffixCls}` : "ant";
    };
    const ConfigContext = /* @__PURE__ */ reactExports.createContext({
      // We provide a default function for Context without provider
      getPrefixCls: defaultGetPrefixCls,
      iconPrefixCls: defaultIconPrefixCls
    });
    function genComponentStyleHook(component, styleFn, getDefaultToken) {
      return (prefixCls) => {
        const [theme2, token2, hashId] = useToken$3();
        const {
          getPrefixCls,
          iconPrefixCls
        } = reactExports.useContext(ConfigContext);
        const rootPrefixCls = getPrefixCls();
        useStyleRegister({
          theme: theme2,
          token: token2,
          hashId,
          path: ["Shared", rootPrefixCls]
        }, () => [{
          // Link
          "&": genLinkStyle(token2)
        }]);
        return [useStyleRegister({
          theme: theme2,
          token: token2,
          hashId,
          path: [component, prefixCls, iconPrefixCls]
        }, () => {
          const {
            token: proxyToken,
            flush
          } = statisticToken(token2);
          const defaultComponentToken = typeof getDefaultToken === "function" ? getDefaultToken(proxyToken) : getDefaultToken;
          const mergedComponentToken = Object.assign(Object.assign({}, defaultComponentToken), token2[component]);
          const componentCls = `.${prefixCls}`;
          const mergedToken = merge$4(proxyToken, {
            componentCls,
            prefixCls,
            iconCls: `.${iconPrefixCls}`,
            antCls: `.${rootPrefixCls}`
          }, mergedComponentToken);
          const styleInterpolation = styleFn(mergedToken, {
            hashId,
            prefixCls,
            rootPrefixCls,
            iconPrefixCls,
            overrideComponentToken: token2[component]
          });
          flush(component, mergedComponentToken);
          return [genCommonStyle(token2, prefixCls), styleInterpolation];
        }), hashId];
      };
    }
    const enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
    let recording = true;
    function merge$4() {
      for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
        objs[_key] = arguments[_key];
      }
      if (!enableStatistic) {
        return Object.assign.apply(Object, [{}].concat(objs));
      }
      recording = false;
      const ret = {};
      objs.forEach((obj) => {
        const keys2 = Object.keys(obj);
        keys2.forEach((key) => {
          Object.defineProperty(ret, key, {
            configurable: true,
            enumerable: true,
            get: () => obj[key]
          });
        });
      });
      recording = true;
      return ret;
    }
    function noop$4() {
    }
    function statisticToken(token2) {
      let tokenKeys2;
      let proxy = token2;
      let flush = noop$4;
      if (enableStatistic) {
        tokenKeys2 = /* @__PURE__ */ new Set();
        proxy = new Proxy(token2, {
          get(obj, prop) {
            if (recording) {
              tokenKeys2.add(prop);
            }
            return obj[prop];
          }
        });
        flush = (componentName, componentToken) => {
          ({
            global: Array.from(tokenKeys2),
            component: componentToken
          });
        };
      }
      return {
        token: proxy,
        keys: tokenKeys2,
        flush
      };
    }
    const defaultTheme = createTheme(derivative$2);
    const defaultConfig = {
      token: seedToken,
      hashed: true
    };
    const DesignTokenContext = /* @__PURE__ */ React$3.createContext(defaultConfig);
    function useToken$3() {
      const {
        token: rootDesignToken,
        hashed,
        theme: theme2,
        components
      } = React$3.useContext(DesignTokenContext);
      const salt = `${version$1}-${hashed || ""}`;
      const mergedTheme = theme2 || defaultTheme;
      const [token2, hashId] = useCacheToken(mergedTheme, [seedToken, rootDesignToken], {
        salt,
        override: Object.assign({
          override: rootDesignToken
        }, components),
        formatToken
      });
      return [mergedTheme, token2, hashed ? hashId : ""];
    }
    const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
    function getStyle$2(globalPrefixCls2, theme2) {
      const variables = {};
      const formatColor = (color2, updater) => {
        let clone = color2.clone();
        clone = (updater === null || updater === void 0 ? void 0 : updater(clone)) || clone;
        return clone.toRgbString();
      };
      const fillColor = (colorVal, type2) => {
        const baseColor = new TinyColor(colorVal);
        const colorPalettes = generate$3(baseColor.toRgbString());
        variables[`${type2}-color`] = formatColor(baseColor);
        variables[`${type2}-color-disabled`] = colorPalettes[1];
        variables[`${type2}-color-hover`] = colorPalettes[4];
        variables[`${type2}-color-active`] = colorPalettes[6];
        variables[`${type2}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString();
        variables[`${type2}-color-deprecated-bg`] = colorPalettes[0];
        variables[`${type2}-color-deprecated-border`] = colorPalettes[2];
      };
      if (theme2.primaryColor) {
        fillColor(theme2.primaryColor, "primary");
        const primaryColor = new TinyColor(theme2.primaryColor);
        const primaryColors = generate$3(primaryColor.toRgbString());
        primaryColors.forEach((color2, index2) => {
          variables[`primary-${index2 + 1}`] = color2;
        });
        variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2) => c2.lighten(35));
        variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2) => c2.lighten(20));
        variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2) => c2.tint(20));
        variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2) => c2.tint(50));
        variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.12));
        const primaryActiveColor = new TinyColor(primaryColors[0]);
        variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.3));
        variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2) => c2.darken(2));
      }
      if (theme2.successColor) {
        fillColor(theme2.successColor, "success");
      }
      if (theme2.warningColor) {
        fillColor(theme2.warningColor, "warning");
      }
      if (theme2.errorColor) {
        fillColor(theme2.errorColor, "error");
      }
      if (theme2.infoColor) {
        fillColor(theme2.infoColor, "info");
      }
      const cssList = Object.keys(variables).map((key) => `--${globalPrefixCls2}-${key}: ${variables[key]};`);
      return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
    }
    function registerTheme(globalPrefixCls2, theme2) {
      const style2 = getStyle$2(globalPrefixCls2, theme2);
      if (canUseDom$2()) {
        updateCSS$1(style2, `${dynamicStyleMark}-dynamic-theme`);
      }
    }
    const DisabledContext = /* @__PURE__ */ reactExports.createContext(false);
    const DisabledContextProvider = (_ref) => {
      let {
        children,
        disabled
      } = _ref;
      const originDisabled = reactExports.useContext(DisabledContext);
      return /* @__PURE__ */ reactExports.createElement(DisabledContext.Provider, {
        value: disabled !== null && disabled !== void 0 ? disabled : originDisabled
      }, children);
    };
    const DisabledContext$1 = DisabledContext;
    const SizeContext$1 = /* @__PURE__ */ reactExports.createContext(void 0);
    const SizeContextProvider$1 = (_ref) => {
      let {
        children,
        size
      } = _ref;
      const originSize = reactExports.useContext(SizeContext$1);
      return /* @__PURE__ */ reactExports.createElement(SizeContext$1.Provider, {
        value: size || originSize
      }, children);
    };
    const SizeContext$2 = SizeContext$1;
    function useConfig() {
      const componentDisabled = reactExports.useContext(DisabledContext$1);
      const componentSize = reactExports.useContext(SizeContext$2);
      return {
        componentDisabled,
        componentSize
      };
    }
    function useTheme(theme2, parentTheme) {
      const themeConfig = theme2 || {};
      const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? defaultConfig : parentTheme;
      const mergedTheme = useMemo(() => {
        if (!theme2) {
          return parentTheme;
        }
        const mergedComponents = Object.assign({}, parentThemeConfig.components);
        Object.keys(theme2.components || {}).forEach((componentName) => {
          mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme2.components[componentName]);
        });
        return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
          token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
          components: mergedComponents
        });
      }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index2) => {
        const nextTheme = next2[index2];
        return !isEqual$1(prevTheme, nextTheme, true);
      }));
      return mergedTheme;
    }
    const useStyle$A = (iconPrefixCls) => {
      const [theme2, token2] = useToken$3();
      return useStyleRegister({
        theme: theme2,
        token: token2,
        hashId: "",
        path: ["ant-design-icons", iconPrefixCls]
      }, () => [{
        [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, resetIcon()), {
          [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
            display: "block"
          }
        })
      }]);
    };
    const useStyle$B = useStyle$A;
    var __rest$14 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "pageHeader", "input", "pagination", "form", "select"];
    const defaultPrefixCls = "ant";
    let globalPrefixCls;
    let globalIconPrefixCls;
    function getGlobalPrefixCls() {
      return globalPrefixCls || defaultPrefixCls;
    }
    function getGlobalIconPrefixCls() {
      return globalIconPrefixCls || defaultIconPrefixCls;
    }
    const setGlobalConfig = (_ref) => {
      let {
        prefixCls,
        iconPrefixCls,
        theme: theme2
      } = _ref;
      if (prefixCls !== void 0) {
        globalPrefixCls = prefixCls;
      }
      if (iconPrefixCls !== void 0) {
        globalIconPrefixCls = iconPrefixCls;
      }
      if (theme2) {
        registerTheme(getGlobalPrefixCls(), theme2);
      }
    };
    const globalConfig = () => ({
      getPrefixCls: (suffixCls, customizePrefixCls) => {
        if (customizePrefixCls)
          return customizePrefixCls;
        return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
      },
      getIconPrefixCls: getGlobalIconPrefixCls,
      getRootPrefixCls: () => {
        if (globalPrefixCls) {
          return globalPrefixCls;
        }
        return getGlobalPrefixCls();
      }
    });
    const ProviderChildren = (props) => {
      const {
        children,
        csp: customCsp,
        autoInsertSpaceInButton,
        form,
        locale: locale2,
        componentSize,
        direction,
        space,
        virtual,
        dropdownMatchSelectWidth,
        legacyLocale,
        parentContext,
        iconPrefixCls: customIconPrefixCls,
        theme: theme2,
        componentDisabled
      } = props;
      const getPrefixCls = reactExports.useCallback((suffixCls, customizePrefixCls) => {
        const {
          prefixCls
        } = props;
        if (customizePrefixCls)
          return customizePrefixCls;
        const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
        return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
      }, [parentContext.getPrefixCls, props.prefixCls]);
      const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
      const shouldWrapSSR = iconPrefixCls !== parentContext.iconPrefixCls;
      const csp = customCsp || parentContext.csp;
      const wrapSSR = useStyle$B(iconPrefixCls);
      const mergedTheme = useTheme(theme2, parentContext.theme);
      const baseConfig = {
        csp,
        autoInsertSpaceInButton,
        locale: locale2 || legacyLocale,
        direction,
        space,
        virtual,
        dropdownMatchSelectWidth,
        getPrefixCls,
        iconPrefixCls,
        theme: mergedTheme
      };
      const config = Object.assign({}, parentContext);
      Object.keys(baseConfig).forEach((key) => {
        if (baseConfig[key] !== void 0) {
          config[key] = baseConfig[key];
        }
      });
      PASSED_PROPS.forEach((propName) => {
        const propValue = props[propName];
        if (propValue) {
          config[propName] = propValue;
        }
      });
      const memoedConfig = useMemo(() => config, config, (prevConfig, currentConfig) => {
        const prevKeys = Object.keys(prevConfig);
        const currentKeys = Object.keys(currentConfig);
        return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
      });
      const memoIconContextValue = reactExports.useMemo(() => ({
        prefixCls: iconPrefixCls,
        csp
      }), [iconPrefixCls, csp]);
      let childNode = shouldWrapSSR ? wrapSSR(children) : children;
      const validateMessages = reactExports.useMemo(() => {
        var _a, _b, _c;
        return setValues({}, ((_a = defaultLocale.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, (form === null || form === void 0 ? void 0 : form.validateMessages) || {});
      }, [memoedConfig, form === null || form === void 0 ? void 0 : form.validateMessages]);
      if (Object.keys(validateMessages).length > 0) {
        childNode = /* @__PURE__ */ reactExports.createElement(FormProvider$1, {
          validateMessages
        }, children);
      }
      if (locale2) {
        childNode = /* @__PURE__ */ reactExports.createElement(LocaleProvider$1, {
          locale: locale2,
          _ANT_MARK__: ANT_MARK
        }, childNode);
      }
      if (iconPrefixCls || csp) {
        childNode = /* @__PURE__ */ reactExports.createElement(Context$3.Provider, {
          value: memoIconContextValue
        }, childNode);
      }
      if (componentSize) {
        childNode = /* @__PURE__ */ reactExports.createElement(SizeContextProvider$1, {
          size: componentSize
        }, childNode);
      }
      const memoTheme = reactExports.useMemo(() => {
        const _a = mergedTheme || {}, {
          algorithm,
          token: token2
        } = _a, rest = __rest$14(_a, ["algorithm", "token"]);
        const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : void 0;
        return Object.assign(Object.assign({}, rest), {
          theme: themeObj,
          token: Object.assign(Object.assign({}, seedToken), token2)
        });
      }, [mergedTheme]);
      if (theme2) {
        childNode = /* @__PURE__ */ reactExports.createElement(DesignTokenContext.Provider, {
          value: memoTheme
        }, childNode);
      }
      if (componentDisabled !== void 0) {
        childNode = /* @__PURE__ */ reactExports.createElement(DisabledContextProvider, {
          disabled: componentDisabled
        }, childNode);
      }
      return /* @__PURE__ */ reactExports.createElement(ConfigContext.Provider, {
        value: memoedConfig
      }, childNode);
    };
    const ConfigProvider = (props) => {
      const context = reactExports.useContext(ConfigContext);
      const antLocale = reactExports.useContext(LocaleContext$1);
      return /* @__PURE__ */ reactExports.createElement(ProviderChildren, Object.assign({
        parentContext: context,
        legacyLocale: antLocale
      }, props));
    };
    ConfigProvider.ConfigContext = ConfigContext;
    ConfigProvider.SizeContext = SizeContext$2;
    ConfigProvider.config = setGlobalConfig;
    ConfigProvider.useConfig = useConfig;
    Object.defineProperty(ConfigProvider, "SizeContext", {
      get: () => {
        return SizeContext$2;
      }
    });
    const ConfigProvider$1 = ConfigProvider;
    var raf = function raf2(callback) {
      return +setTimeout(callback, 16);
    };
    var caf = function caf2(num) {
      return clearTimeout(num);
    };
    if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
      raf = function raf2(callback) {
        return window.requestAnimationFrame(callback);
      };
      caf = function caf2(handle) {
        return window.cancelAnimationFrame(handle);
      };
    }
    var rafUUID = 0;
    var rafIds = /* @__PURE__ */ new Map();
    function cleanup(id2) {
      rafIds.delete(id2);
    }
    var wrapperRaf = function wrapperRaf2(callback) {
      var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      rafUUID += 1;
      var id2 = rafUUID;
      function callRef(leftTimes) {
        if (leftTimes === 0) {
          cleanup(id2);
          callback();
        } else {
          var realId = raf(function() {
            callRef(leftTimes - 1);
          });
          rafIds.set(id2, realId);
        }
      }
      callRef(times);
      return id2;
    };
    wrapperRaf.cancel = function(id2) {
      var realId = rafIds.get(id2);
      cleanup(realId);
      return caf(realId);
    };
    function addEventListenerWrap(target, eventType, cb2, option) {
      var callback = ReactDOM.unstable_batchedUpdates ? function run(e2) {
        ReactDOM.unstable_batchedUpdates(cb2, e2);
      } : cb2;
      if (target.addEventListener) {
        target.addEventListener(eventType, callback, option);
      }
      return {
        remove: function remove() {
          if (target.removeEventListener) {
            target.removeEventListener(eventType, callback, option);
          }
        }
      };
    }
    var CheckCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
    const CheckCircleFilledSvg = CheckCircleFilled$2;
    function warning$3(valid, message2) {
      warningOnce$1(valid, "[@ant-design/icons] ".concat(message2));
    }
    function isIconDefinition$1(target) {
      return _typeof$4(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof$4(target.icon) === "object" || typeof target.icon === "function");
    }
    function normalizeAttrs$1() {
      var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return Object.keys(attrs).reduce(function(acc, key) {
        var val = attrs[key];
        switch (key) {
          case "class":
            acc.className = val;
            delete acc.class;
            break;
          default:
            acc[key] = val;
        }
        return acc;
      }, {});
    }
    function generate$2(node2, key, rootProps) {
      if (!rootProps) {
        return /* @__PURE__ */ React$3.createElement(node2.tag, _objectSpread2$3({
          key
        }, normalizeAttrs$1(node2.attrs)), (node2.children || []).map(function(child, index2) {
          return generate$2(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
        }));
      }
      return /* @__PURE__ */ React$3.createElement(node2.tag, _objectSpread2$3(_objectSpread2$3({
        key
      }, normalizeAttrs$1(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
        return generate$2(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
      }));
    }
    function getSecondaryColor$1(primaryColor) {
      return generate$3(primaryColor)[0];
    }
    function normalizeTwoToneColors$1(twoToneColor) {
      if (!twoToneColor) {
        return [];
      }
      return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
    }
    var iconStyles$1 = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
    var useInsertStyles$1 = function useInsertStyles2() {
      var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles$1;
      var _useContext = reactExports.useContext(Context$3), csp = _useContext.csp, prefixCls = _useContext.prefixCls;
      var mergedStyleStr = styleStr;
      if (prefixCls) {
        mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
      }
      reactExports.useEffect(function() {
        updateCSS$1(mergedStyleStr, "@ant-design-icons", {
          prepend: true,
          csp
        });
      }, []);
    };
    var _excluded$L = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
    var twoToneColorPalette$1 = {
      primaryColor: "#333",
      secondaryColor: "#E6E6E6",
      calculated: false
    };
    function setTwoToneColors$1(_ref) {
      var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
      twoToneColorPalette$1.primaryColor = primaryColor;
      twoToneColorPalette$1.secondaryColor = secondaryColor || getSecondaryColor$1(primaryColor);
      twoToneColorPalette$1.calculated = !!secondaryColor;
    }
    function getTwoToneColors$1() {
      return _objectSpread2$3({}, twoToneColorPalette$1);
    }
    var IconBase$2 = function IconBase2(props) {
      var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties$1(props, _excluded$L);
      var colors = twoToneColorPalette$1;
      if (primaryColor) {
        colors = {
          primaryColor,
          secondaryColor: secondaryColor || getSecondaryColor$1(primaryColor)
        };
      }
      useInsertStyles$1();
      warning$3(isIconDefinition$1(icon), "icon should be icon definiton, but got ".concat(icon));
      if (!isIconDefinition$1(icon)) {
        return null;
      }
      var target = icon;
      if (target && typeof target.icon === "function") {
        target = _objectSpread2$3(_objectSpread2$3({}, target), {}, {
          icon: target.icon(colors.primaryColor, colors.secondaryColor)
        });
      }
      return generate$2(target.icon, "svg-".concat(target.name), _objectSpread2$3({
        className,
        onClick,
        style: style2,
        "data-icon": target.name,
        width: "1em",
        height: "1em",
        fill: "currentColor",
        "aria-hidden": "true"
      }, restProps));
    };
    IconBase$2.displayName = "IconReact";
    IconBase$2.getTwoToneColors = getTwoToneColors$1;
    IconBase$2.setTwoToneColors = setTwoToneColors$1;
    const ReactIcon$1 = IconBase$2;
    function setTwoToneColor$1(twoToneColor) {
      var _normalizeTwoToneColo = normalizeTwoToneColors$1(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
      return ReactIcon$1.setTwoToneColors({
        primaryColor,
        secondaryColor
      });
    }
    function getTwoToneColor$1() {
      var colors = ReactIcon$1.getTwoToneColors();
      if (!colors.calculated) {
        return colors.primaryColor;
      }
      return [colors.primaryColor, colors.secondaryColor];
    }
    var _excluded$K = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
    setTwoToneColor$1("#1890ff");
    var Icon$7 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _classNames;
      var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties$1(props, _excluded$K);
      var _React$useContext = reactExports.useContext(Context$3), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
      var classString = classNames(rootClassName, prefixCls, (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty$7(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _classNames), className);
      var iconTabIndex = tabIndex;
      if (iconTabIndex === void 0 && onClick) {
        iconTabIndex = -1;
      }
      var svgStyle = rotate ? {
        msTransform: "rotate(".concat(rotate, "deg)"),
        transform: "rotate(".concat(rotate, "deg)")
      } : void 0;
      var _normalizeTwoToneColo = normalizeTwoToneColors$1(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
      return /* @__PURE__ */ reactExports.createElement("span", _objectSpread2$3(_objectSpread2$3({
        role: "img",
        "aria-label": icon.name
      }, restProps), {}, {
        ref,
        tabIndex: iconTabIndex,
        onClick,
        className: classString
      }), /* @__PURE__ */ reactExports.createElement(ReactIcon$1, {
        icon,
        primaryColor,
        secondaryColor,
        style: svgStyle
      }));
    });
    Icon$7.displayName = "AntdIcon";
    Icon$7.getTwoToneColor = getTwoToneColor$1;
    Icon$7.setTwoToneColor = setTwoToneColor$1;
    const AntdIcon$2 = Icon$7;
    var CheckCircleFilled = function CheckCircleFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: CheckCircleFilledSvg
      }));
    };
    CheckCircleFilled.displayName = "CheckCircleFilled";
    const CheckCircleFilled$1 = /* @__PURE__ */ reactExports.forwardRef(CheckCircleFilled);
    var CloseCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z" } }] }, "name": "close-circle", "theme": "filled" };
    const CloseCircleFilledSvg = CloseCircleFilled$2;
    var CloseCircleFilled = function CloseCircleFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: CloseCircleFilledSvg
      }));
    };
    CloseCircleFilled.displayName = "CloseCircleFilled";
    const CloseCircleFilled$1 = /* @__PURE__ */ reactExports.forwardRef(CloseCircleFilled);
    var CloseOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z" } }] }, "name": "close", "theme": "outlined" };
    const CloseOutlinedSvg = CloseOutlined$2;
    var CloseOutlined = function CloseOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: CloseOutlinedSvg
      }));
    };
    CloseOutlined.displayName = "CloseOutlined";
    const CloseOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CloseOutlined);
    var ExclamationCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
    const ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
    var ExclamationCircleFilled = function ExclamationCircleFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: ExclamationCircleFilledSvg
      }));
    };
    ExclamationCircleFilled.displayName = "ExclamationCircleFilled";
    const ExclamationCircleFilled$1 = /* @__PURE__ */ reactExports.forwardRef(ExclamationCircleFilled);
    var InfoCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
    const InfoCircleFilledSvg = InfoCircleFilled$2;
    var InfoCircleFilled = function InfoCircleFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: InfoCircleFilledSvg
      }));
    };
    InfoCircleFilled.displayName = "InfoCircleFilled";
    const InfoCircleFilled$1 = /* @__PURE__ */ reactExports.forwardRef(InfoCircleFilled);
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
      prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
      prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
      prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
      return prefixes;
    }
    function getVendorPrefixes(domSupport, win) {
      var prefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      if (domSupport) {
        if (!("AnimationEvent" in win)) {
          delete prefixes.animationend.animation;
        }
        if (!("TransitionEvent" in win)) {
          delete prefixes.transitionend.transition;
        }
      }
      return prefixes;
    }
    var vendorPrefixes = getVendorPrefixes(canUseDom$2(), typeof window !== "undefined" ? window : {});
    var style = {};
    if (canUseDom$2()) {
      var _document$createEleme = document.createElement("div");
      style = _document$createEleme.style;
    }
    var prefixedEventNames = {};
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) {
        return prefixedEventNames[eventName];
      }
      var prefixMap = vendorPrefixes[eventName];
      if (prefixMap) {
        var stylePropList = Object.keys(prefixMap);
        var len = stylePropList.length;
        for (var i2 = 0; i2 < len; i2 += 1) {
          var styleProp = stylePropList[i2];
          if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
            prefixedEventNames[eventName] = prefixMap[styleProp];
            return prefixedEventNames[eventName];
          }
        }
      }
      return "";
    }
    var internalAnimationEndName = getVendorPrefixedEventName("animationend");
    var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
    var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
    var animationEndName = internalAnimationEndName || "animationend";
    var transitionEndName = internalTransitionEndName || "transitionend";
    function getTransitionName$2(transitionName, transitionType) {
      if (!transitionName)
        return null;
      if (_typeof$4(transitionName) === "object") {
        var type2 = transitionType.replace(/-\w/g, function(match2) {
          return match2[1].toUpperCase();
        });
        return transitionName[type2];
      }
      return "".concat(transitionName, "-").concat(transitionType);
    }
    var STATUS_NONE = "none";
    var STATUS_APPEAR = "appear";
    var STATUS_ENTER = "enter";
    var STATUS_LEAVE = "leave";
    var STEP_NONE = "none";
    var STEP_PREPARE = "prepare";
    var STEP_START = "start";
    var STEP_ACTIVE = "active";
    var STEP_ACTIVATED = "end";
    function useSafeState(defaultValue) {
      var destroyRef = reactExports.useRef(false);
      var _React$useState = reactExports.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue2 = _React$useState2[1];
      reactExports.useEffect(function() {
        destroyRef.current = false;
        return function() {
          destroyRef.current = true;
        };
      }, []);
      function safeSetState(updater, ignoreDestroy) {
        if (ignoreDestroy && destroyRef.current) {
          return;
        }
        setValue2(updater);
      }
      return [value, safeSetState];
    }
    const useNextFrame = function() {
      var nextFrameRef = reactExports.useRef(null);
      function cancelNextFrame() {
        wrapperRaf.cancel(nextFrameRef.current);
      }
      function nextFrame(callback) {
        var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        cancelNextFrame();
        var nextFrameId = wrapperRaf(function() {
          if (delay <= 1) {
            callback({
              isCanceled: function isCanceled() {
                return nextFrameId !== nextFrameRef.current;
              }
            });
          } else {
            nextFrame(callback, delay - 1);
          }
        });
        nextFrameRef.current = nextFrameId;
      }
      reactExports.useEffect(function() {
        return function() {
          cancelNextFrame();
        };
      }, []);
      return [nextFrame, cancelNextFrame];
    };
    var useIsomorphicLayoutEffect$1 = canUseDom$2() ? reactExports.useLayoutEffect : reactExports.useEffect;
    var STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
    var SkipStep = false;
    var DoStep = true;
    function isActive(step) {
      return step === STEP_ACTIVE || step === STEP_ACTIVATED;
    }
    const useStepQueue = function(status, callback) {
      var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray(_useState, 2), step = _useState2[0], setStep = _useState2[1];
      var _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
      function startQueue() {
        setStep(STEP_PREPARE, true);
      }
      useIsomorphicLayoutEffect$1(function() {
        if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
          var index2 = STEP_QUEUE.indexOf(step);
          var nextStep = STEP_QUEUE[index2 + 1];
          var result = callback(step);
          if (result === SkipStep) {
            setStep(nextStep, true);
          } else {
            nextFrame(function(info2) {
              function doNext() {
                if (info2.isCanceled())
                  return;
                setStep(nextStep, true);
              }
              if (result === true) {
                doNext();
              } else {
                Promise.resolve(result).then(doNext);
              }
            });
          }
        }
      }, [status, step]);
      reactExports.useEffect(function() {
        return function() {
          cancelNextFrame();
        };
      }, []);
      return [startQueue, step];
    };
    const useDomMotionEvents = function(callback) {
      var cacheElementRef = reactExports.useRef();
      var callbackRef = reactExports.useRef(callback);
      callbackRef.current = callback;
      var onInternalMotionEnd = reactExports.useCallback(function(event) {
        callbackRef.current(event);
      }, []);
      function removeMotionEvents(element) {
        if (element) {
          element.removeEventListener(transitionEndName, onInternalMotionEnd);
          element.removeEventListener(animationEndName, onInternalMotionEnd);
        }
      }
      function patchMotionEvents(element) {
        if (cacheElementRef.current && cacheElementRef.current !== element) {
          removeMotionEvents(cacheElementRef.current);
        }
        if (element && element !== cacheElementRef.current) {
          element.addEventListener(transitionEndName, onInternalMotionEnd);
          element.addEventListener(animationEndName, onInternalMotionEnd);
          cacheElementRef.current = element;
        }
      }
      reactExports.useEffect(function() {
        return function() {
          removeMotionEvents(cacheElementRef.current);
        };
      }, []);
      return [patchMotionEvents, removeMotionEvents];
    };
    function useStatus(supportMotion, visible, getElement2, _ref) {
      var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;
      var _useState = useSafeState(), _useState2 = _slicedToArray(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
      var _useState3 = useSafeState(STATUS_NONE), _useState4 = _slicedToArray(_useState3, 2), status = _useState4[0], setStatus = _useState4[1];
      var _useState5 = useSafeState(null), _useState6 = _slicedToArray(_useState5, 2), style2 = _useState6[0], setStyle = _useState6[1];
      var mountedRef = reactExports.useRef(false);
      var deadlineRef = reactExports.useRef(null);
      function getDomElement() {
        return getElement2();
      }
      var activeRef = reactExports.useRef(false);
      function onInternalMotionEnd(event) {
        var element = getDomElement();
        if (event && !event.deadline && event.target !== element) {
          return;
        }
        var currentActive = activeRef.current;
        var canEnd;
        if (status === STATUS_APPEAR && currentActive) {
          canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
        } else if (status === STATUS_ENTER && currentActive) {
          canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
        } else if (status === STATUS_LEAVE && currentActive) {
          canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
        }
        if (status !== STATUS_NONE && currentActive && canEnd !== false) {
          setStatus(STATUS_NONE, true);
          setStyle(null, true);
        }
      }
      var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
      var eventHandlers = reactExports.useMemo(function() {
        var _ref2, _ref3, _ref4;
        switch (status) {
          case STATUS_APPEAR:
            return _ref2 = {}, _defineProperty$7(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty$7(_ref2, STEP_START, onAppearStart), _defineProperty$7(_ref2, STEP_ACTIVE, onAppearActive), _ref2;
          case STATUS_ENTER:
            return _ref3 = {}, _defineProperty$7(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty$7(_ref3, STEP_START, onEnterStart), _defineProperty$7(_ref3, STEP_ACTIVE, onEnterActive), _ref3;
          case STATUS_LEAVE:
            return _ref4 = {}, _defineProperty$7(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty$7(_ref4, STEP_START, onLeaveStart), _defineProperty$7(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;
          default:
            return {};
        }
      }, [status]);
      var _useStepQueue = useStepQueue(status, function(newStep) {
        if (newStep === STEP_PREPARE) {
          var onPrepare = eventHandlers[STEP_PREPARE];
          if (!onPrepare) {
            return SkipStep;
          }
          return onPrepare(getDomElement());
        }
        if (step in eventHandlers) {
          var _eventHandlers$step;
          setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
        }
        if (step === STEP_ACTIVE) {
          patchMotionEvents(getDomElement());
          if (motionDeadline > 0) {
            clearTimeout(deadlineRef.current);
            deadlineRef.current = setTimeout(function() {
              onInternalMotionEnd({
                deadline: true
              });
            }, motionDeadline);
          }
        }
        return DoStep;
      }), _useStepQueue2 = _slicedToArray(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
      var active = isActive(step);
      activeRef.current = active;
      useIsomorphicLayoutEffect$1(function() {
        setAsyncVisible(visible);
        var isMounted = mountedRef.current;
        mountedRef.current = true;
        if (!supportMotion) {
          return;
        }
        var nextStatus;
        if (!isMounted && visible && motionAppear) {
          nextStatus = STATUS_APPEAR;
        }
        if (isMounted && visible && motionEnter) {
          nextStatus = STATUS_ENTER;
        }
        if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
          nextStatus = STATUS_LEAVE;
        }
        if (nextStatus) {
          setStatus(nextStatus);
          startStep();
        }
      }, [visible]);
      reactExports.useEffect(function() {
        if (
          // Cancel appear
          status === STATUS_APPEAR && !motionAppear || // Cancel enter
          status === STATUS_ENTER && !motionEnter || // Cancel leave
          status === STATUS_LEAVE && !motionLeave
        ) {
          setStatus(STATUS_NONE);
        }
      }, [motionAppear, motionEnter, motionLeave]);
      reactExports.useEffect(function() {
        return function() {
          mountedRef.current = false;
          clearTimeout(deadlineRef.current);
        };
      }, []);
      var firstMountChangeRef = reactExports.useRef(false);
      reactExports.useEffect(function() {
        if (asyncVisible) {
          firstMountChangeRef.current = true;
        }
        if (asyncVisible !== void 0 && status === STATUS_NONE) {
          if (firstMountChangeRef.current || asyncVisible) {
            onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
          }
          firstMountChangeRef.current = true;
        }
      }, [asyncVisible, status]);
      var mergedStyle = style2;
      if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
        mergedStyle = _objectSpread2$3({
          transition: "none"
        }, mergedStyle);
      }
      return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
    }
    var DomWrapper = /* @__PURE__ */ function(_React$Component) {
      _inherits(DomWrapper2, _React$Component);
      var _super = _createSuper(DomWrapper2);
      function DomWrapper2() {
        _classCallCheck(this, DomWrapper2);
        return _super.apply(this, arguments);
      }
      _createClass(DomWrapper2, [{
        key: "render",
        value: function render2() {
          return this.props.children;
        }
      }]);
      return DomWrapper2;
    }(reactExports.Component);
    function genCSSMotion(config) {
      var transitionSupport = config;
      if (_typeof$4(config) === "object") {
        transitionSupport = config.transitionSupport;
      }
      function isSupportTransition(props) {
        return !!(props.motionName && transitionSupport);
      }
      var CSSMotion2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
        var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
        var supportMotion = isSupportTransition(props);
        var nodeRef = reactExports.useRef();
        var wrapperNodeRef = reactExports.useRef();
        function getDomElement() {
          try {
            return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
          } catch (e2) {
            return null;
          }
        }
        var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
        var renderedRef = reactExports.useRef(mergedVisible);
        if (mergedVisible) {
          renderedRef.current = true;
        }
        var setNodeRef = reactExports.useCallback(function(node2) {
          nodeRef.current = node2;
          fillRef(ref, node2);
        }, [ref]);
        var motionChildren;
        var mergedProps = _objectSpread2$3(_objectSpread2$3({}, eventProps), {}, {
          visible
        });
        if (!children) {
          motionChildren = null;
        } else if (status === STATUS_NONE || !isSupportTransition(props)) {
          if (mergedVisible) {
            motionChildren = children(_objectSpread2$3({}, mergedProps), setNodeRef);
          } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
            motionChildren = children(_objectSpread2$3(_objectSpread2$3({}, mergedProps), {}, {
              className: leavedClassName
            }), setNodeRef);
          } else if (forceRender || !removeOnLeave && !leavedClassName) {
            motionChildren = children(_objectSpread2$3(_objectSpread2$3({}, mergedProps), {}, {
              style: {
                display: "none"
              }
            }), setNodeRef);
          } else {
            motionChildren = null;
          }
        } else {
          var _classNames;
          var statusSuffix;
          if (statusStep === STEP_PREPARE) {
            statusSuffix = "prepare";
          } else if (isActive(statusStep)) {
            statusSuffix = "active";
          } else if (statusStep === STEP_START) {
            statusSuffix = "start";
          }
          motionChildren = children(_objectSpread2$3(_objectSpread2$3({}, mergedProps), {}, {
            className: classNames(getTransitionName$2(motionName, status), (_classNames = {}, _defineProperty$7(_classNames, getTransitionName$2(motionName, "".concat(status, "-").concat(statusSuffix)), statusSuffix), _defineProperty$7(_classNames, motionName, typeof motionName === "string"), _classNames)),
            style: statusStyle
          }), setNodeRef);
        }
        if (/* @__PURE__ */ reactExports.isValidElement(motionChildren) && supportRef(motionChildren)) {
          var _ref = motionChildren, originNodeRef = _ref.ref;
          if (!originNodeRef) {
            motionChildren = /* @__PURE__ */ reactExports.cloneElement(motionChildren, {
              ref: setNodeRef
            });
          }
        }
        return /* @__PURE__ */ reactExports.createElement(DomWrapper, {
          ref: wrapperNodeRef
        }, motionChildren);
      });
      CSSMotion2.displayName = "CSSMotion";
      return CSSMotion2;
    }
    const CSSMotion = genCSSMotion(supportTransition);
    var STATUS_ADD = "add";
    var STATUS_KEEP = "keep";
    var STATUS_REMOVE = "remove";
    var STATUS_REMOVED = "removed";
    function wrapKeyToObject(key) {
      var keyObj;
      if (key && _typeof$4(key) === "object" && "key" in key) {
        keyObj = key;
      } else {
        keyObj = {
          key
        };
      }
      return _objectSpread2$3(_objectSpread2$3({}, keyObj), {}, {
        key: String(keyObj.key)
      });
    }
    function parseKeys() {
      var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return keys2.map(wrapKeyToObject);
    }
    function diffKeys() {
      var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var list2 = [];
      var currentIndex = 0;
      var currentLen = currentKeys.length;
      var prevKeyObjects = parseKeys(prevKeys);
      var currentKeyObjects = parseKeys(currentKeys);
      prevKeyObjects.forEach(function(keyObj) {
        var hit = false;
        for (var i2 = currentIndex; i2 < currentLen; i2 += 1) {
          var currentKeyObj = currentKeyObjects[i2];
          if (currentKeyObj.key === keyObj.key) {
            if (currentIndex < i2) {
              list2 = list2.concat(currentKeyObjects.slice(currentIndex, i2).map(function(obj) {
                return _objectSpread2$3(_objectSpread2$3({}, obj), {}, {
                  status: STATUS_ADD
                });
              }));
              currentIndex = i2;
            }
            list2.push(_objectSpread2$3(_objectSpread2$3({}, currentKeyObj), {}, {
              status: STATUS_KEEP
            }));
            currentIndex += 1;
            hit = true;
            break;
          }
        }
        if (!hit) {
          list2.push(_objectSpread2$3(_objectSpread2$3({}, keyObj), {}, {
            status: STATUS_REMOVE
          }));
        }
      });
      if (currentIndex < currentLen) {
        list2 = list2.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
          return _objectSpread2$3(_objectSpread2$3({}, obj), {}, {
            status: STATUS_ADD
          });
        }));
      }
      var keys2 = {};
      list2.forEach(function(_ref) {
        var key = _ref.key;
        keys2[key] = (keys2[key] || 0) + 1;
      });
      var duplicatedKeys = Object.keys(keys2).filter(function(key) {
        return keys2[key] > 1;
      });
      duplicatedKeys.forEach(function(matchKey) {
        list2 = list2.filter(function(_ref2) {
          var key = _ref2.key, status = _ref2.status;
          return key !== matchKey || status !== STATUS_REMOVE;
        });
        list2.forEach(function(node2) {
          if (node2.key === matchKey) {
            node2.status = STATUS_KEEP;
          }
        });
      });
      return list2;
    }
    var _excluded$J = ["component", "children", "onVisibleChanged", "onAllRemoved"], _excluded2$7 = ["status"];
    var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
    function genCSSMotionList(transitionSupport) {
      var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion;
      var CSSMotionList2 = /* @__PURE__ */ function(_React$Component) {
        _inherits(CSSMotionList3, _React$Component);
        var _super = _createSuper(CSSMotionList3);
        function CSSMotionList3() {
          var _this;
          _classCallCheck(this, CSSMotionList3);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty$7(_assertThisInitialized(_this), "state", {
            keyEntities: []
          });
          _defineProperty$7(_assertThisInitialized(_this), "removeKey", function(removeKey) {
            var keyEntities = _this.state.keyEntities;
            var nextKeyEntities = keyEntities.map(function(entity) {
              if (entity.key !== removeKey)
                return entity;
              return _objectSpread2$3(_objectSpread2$3({}, entity), {}, {
                status: STATUS_REMOVED
              });
            });
            _this.setState({
              keyEntities: nextKeyEntities
            });
            return nextKeyEntities.filter(function(_ref) {
              var status = _ref.status;
              return status !== STATUS_REMOVED;
            }).length;
          });
          return _this;
        }
        _createClass(CSSMotionList3, [{
          key: "render",
          value: function render2() {
            var _this2 = this;
            var keyEntities = this.state.keyEntities;
            var _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, onAllRemoved = _this$props.onAllRemoved, restProps = _objectWithoutProperties$1(_this$props, _excluded$J);
            var Component = component || reactExports.Fragment;
            var motionProps = {};
            MOTION_PROP_NAMES.forEach(function(prop) {
              motionProps[prop] = restProps[prop];
              delete restProps[prop];
            });
            delete restProps.keys;
            return /* @__PURE__ */ reactExports.createElement(Component, restProps, keyEntities.map(function(_ref2) {
              var status = _ref2.status, eventProps = _objectWithoutProperties$1(_ref2, _excluded2$7);
              var visible = status === STATUS_ADD || status === STATUS_KEEP;
              return /* @__PURE__ */ reactExports.createElement(CSSMotion$1, _extends$2({}, motionProps, {
                key: eventProps.key,
                visible,
                eventProps,
                onVisibleChanged: function onVisibleChanged(changedVisible) {
                  _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                    key: eventProps.key
                  });
                  if (!changedVisible) {
                    var restKeysCount = _this2.removeKey(eventProps.key);
                    if (restKeysCount === 0 && onAllRemoved) {
                      onAllRemoved();
                    }
                  }
                }
              }), children);
            }));
          }
        }], [{
          key: "getDerivedStateFromProps",
          value: function getDerivedStateFromProps(_ref3, _ref4) {
            var keys2 = _ref3.keys;
            var keyEntities = _ref4.keyEntities;
            var parsedKeyObjects = parseKeys(keys2);
            var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
            return {
              keyEntities: mixedKeyEntities.filter(function(entity) {
                var prevEntity = keyEntities.find(function(_ref5) {
                  var key = _ref5.key;
                  return entity.key === key;
                });
                if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
                  return false;
                }
                return true;
              })
            };
          }
          // ZombieJ: Return the count of rest keys. It's safe to refactor if need more info.
        }]);
        return CSSMotionList3;
      }(reactExports.Component);
      _defineProperty$7(CSSMotionList2, "defaultProps", {
        component: "div"
      });
      return CSSMotionList2;
    }
    const CSSMotionList = genCSSMotionList(supportTransition);
    function getDataOrAriaProps$1(props) {
      return Object.keys(props).reduce((prev2, key) => {
        if ((key.startsWith("data-") || key.startsWith("aria-") || key === "role") && !key.startsWith("data-__")) {
          prev2[key] = props[key];
        }
        return prev2;
      }, {});
    }
    const {
      isValidElement
    } = React$4;
    function isFragment(child) {
      return child && isValidElement(child) && child.type === reactExports.Fragment;
    }
    function replaceElement(element, replacement, props) {
      if (!isValidElement(element)) {
        return replacement;
      }
      return /* @__PURE__ */ reactExports.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
    }
    function cloneElement(element, props) {
      return replaceElement(element, element, props);
    }
    let t$1 = (t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType, e$1 = (t2, e2) => (!e2 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2), n$2 = (t2, n2) => {
      if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
        let l2 = getComputedStyle(t2, null);
        return e$1(l2.overflowY, n2) || e$1(l2.overflowX, n2) || ((t3) => {
          let e2 = ((t4) => {
            if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
              return null;
            try {
              return t4.ownerDocument.defaultView.frameElement;
            } catch (t5) {
              return null;
            }
          })(t3);
          return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
        })(t2);
      }
      return false;
    }, l$1 = (t2, e2, n2, l2, i2, o2, r2, d2) => o2 < t2 && r2 > e2 || o2 > t2 && r2 < e2 ? 0 : o2 <= t2 && d2 <= n2 || r2 >= e2 && d2 >= n2 ? o2 - t2 - l2 : r2 > e2 && d2 < n2 || o2 < t2 && d2 > n2 ? r2 - e2 + i2 : 0, i = (t2) => {
      let e2 = t2.parentElement;
      return null == e2 ? t2.getRootNode().host || null : e2;
    }, o$1 = (e2, o2) => {
      var r2, d2, h2, f2;
      if ("undefined" == typeof document)
        return [];
      let { scrollMode: u2, block: s, inline: c2, boundary: a, skipOverflowHiddenElements: g2 } = o2, m2 = "function" == typeof a ? a : (t2) => t2 !== a;
      if (!t$1(e2))
        throw new TypeError("Invalid target");
      let p2 = document.scrollingElement || document.documentElement, w2 = [], W2 = e2;
      for (; t$1(W2) && m2(W2); ) {
        if (W2 = i(W2), W2 === p2) {
          w2.push(W2);
          break;
        }
        null != W2 && W2 === document.body && n$2(W2) && !n$2(document.documentElement) || null != W2 && n$2(W2, g2) && w2.push(W2);
      }
      let H2 = null != (d2 = null == (r2 = window.visualViewport) ? void 0 : r2.width) ? d2 : innerWidth, b2 = null != (f2 = null == (h2 = window.visualViewport) ? void 0 : h2.height) ? f2 : innerHeight, { scrollX: v2, scrollY: y2 } = window, { height: E2, width: M2, top: x2, right: I2, bottom: C2, left: R2 } = e2.getBoundingClientRect(), T2 = "start" === s || "nearest" === s ? x2 : "end" === s ? C2 : x2 + E2 / 2, V2 = "center" === c2 ? R2 + M2 / 2 : "end" === c2 ? I2 : R2, k2 = [];
      for (let t2 = 0; t2 < w2.length; t2++) {
        let e3 = w2[t2], { height: n2, width: i2, top: o3, right: r3, bottom: d3, left: h3 } = e3.getBoundingClientRect();
        if ("if-needed" === u2 && x2 >= 0 && R2 >= 0 && C2 <= b2 && I2 <= H2 && x2 >= o3 && C2 <= d3 && R2 >= h3 && I2 <= r3)
          return k2;
        let f3 = getComputedStyle(e3), a2 = parseInt(f3.borderLeftWidth, 10), g3 = parseInt(f3.borderTopWidth, 10), m3 = parseInt(f3.borderRightWidth, 10), W3 = parseInt(f3.borderBottomWidth, 10), B2 = 0, D2 = 0, L2 = "offsetWidth" in e3 ? e3.offsetWidth - e3.clientWidth - a2 - m3 : 0, S2 = "offsetHeight" in e3 ? e3.offsetHeight - e3.clientHeight - g3 - W3 : 0, X2 = "offsetWidth" in e3 ? 0 === e3.offsetWidth ? 0 : i2 / e3.offsetWidth : 0, Y2 = "offsetHeight" in e3 ? 0 === e3.offsetHeight ? 0 : n2 / e3.offsetHeight : 0;
        if (p2 === e3)
          B2 = "start" === s ? T2 : "end" === s ? T2 - b2 : "nearest" === s ? l$1(y2, y2 + b2, b2, g3, W3, y2 + T2, y2 + T2 + E2, E2) : T2 - b2 / 2, D2 = "start" === c2 ? V2 : "center" === c2 ? V2 - H2 / 2 : "end" === c2 ? V2 - H2 : l$1(v2, v2 + H2, H2, a2, m3, v2 + V2, v2 + V2 + M2, M2), B2 = Math.max(0, B2 + y2), D2 = Math.max(0, D2 + v2);
        else {
          B2 = "start" === s ? T2 - o3 - g3 : "end" === s ? T2 - d3 + W3 + S2 : "nearest" === s ? l$1(o3, d3, n2, g3, W3 + S2, T2, T2 + E2, E2) : T2 - (o3 + n2 / 2) + S2 / 2, D2 = "start" === c2 ? V2 - h3 - a2 : "center" === c2 ? V2 - (h3 + i2 / 2) + L2 / 2 : "end" === c2 ? V2 - r3 + m3 + L2 : l$1(h3, r3, i2, a2, m3 + L2, V2, V2 + M2, M2);
          let { scrollLeft: t3, scrollTop: f4 } = e3;
          B2 = Math.max(0, Math.min(f4 + B2 / Y2, e3.scrollHeight - n2 / Y2 + S2)), D2 = Math.max(0, Math.min(t3 + D2 / X2, e3.scrollWidth - i2 / X2 + L2)), T2 += f4 - B2, V2 += t3 - D2;
        }
        k2.push({ el: e3, top: B2, left: D2 });
      }
      return k2;
    };
    let t = (e2) => "object" == typeof e2 && "function" == typeof e2.behavior, o = (e2) => false === e2 ? { block: "end", inline: "nearest" } : ((e3) => e3 === Object(e3) && 0 !== Object.keys(e3).length)(e2) ? e2 : { block: "start", inline: "nearest" };
    function n$1(n2, l2) {
      if (!n2.isConnected || !n2.ownerDocument.documentElement.contains(n2))
        return;
      if (t(l2))
        return l2.behavior(o$1(n2, l2));
      let i2 = "boolean" == typeof l2 || null == l2 ? void 0 : l2.behavior;
      for (let { el: t2, top: r2, left: c2 } of o$1(n2, o(l2)))
        t2.scroll({ top: r2, left: c2, behavior: i2 });
    }
    function isWindow$1(obj) {
      return obj !== null && obj !== void 0 && obj === obj.window;
    }
    function getScroll$2(target, top) {
      var _a, _b;
      if (typeof window === "undefined") {
        return 0;
      }
      const method2 = top ? "scrollTop" : "scrollLeft";
      let result = 0;
      if (isWindow$1(target)) {
        result = target[top ? "pageYOffset" : "pageXOffset"];
      } else if (target instanceof Document) {
        result = target.documentElement[method2];
      } else if (target instanceof HTMLElement) {
        result = target[method2];
      } else if (target) {
        result = target[method2];
      }
      if (target && !isWindow$1(target) && typeof result !== "number") {
        result = (_b = ((_a = target.ownerDocument) !== null && _a !== void 0 ? _a : target).documentElement) === null || _b === void 0 ? void 0 : _b[method2];
      }
      return result;
    }
    function easeInOutCubic(t2, b2, c2, d2) {
      const cc2 = c2 - b2;
      t2 /= d2 / 2;
      if (t2 < 1) {
        return cc2 / 2 * t2 * t2 * t2 + b2;
      }
      return cc2 / 2 * ((t2 -= 2) * t2 * t2 + 2) + b2;
    }
    function scrollTo$1(y2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        getContainer: getContainer2 = () => window,
        callback,
        duration = 450
      } = options;
      const container2 = getContainer2();
      const scrollTop = getScroll$2(container2, true);
      const startTime = Date.now();
      const frameFunc = () => {
        const timestamp = Date.now();
        const time = timestamp - startTime;
        const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y2, duration);
        if (isWindow$1(container2)) {
          container2.scrollTo(window.pageXOffset, nextScrollTop);
        } else if (container2 instanceof Document || container2.constructor.name === "HTMLDocument") {
          container2.documentElement.scrollTop = nextScrollTop;
        } else {
          container2.scrollTop = nextScrollTop;
        }
        if (time < duration) {
          wrapperRaf(frameFunc);
        } else if (typeof callback === "function") {
          callback();
        }
      };
      wrapperRaf(frameFunc);
    }
    var Notify = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, style2 = props.style, className = props.className, _props$duration = props.duration, duration = _props$duration === void 0 ? 4.5 : _props$duration, eventKey = props.eventKey, content2 = props.content, closable = props.closable, _props$closeIcon = props.closeIcon, closeIcon = _props$closeIcon === void 0 ? "x" : _props$closeIcon, divProps = props.props, onClick = props.onClick, onNoticeClose = props.onNoticeClose, times = props.times;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), hovering = _React$useState2[0], setHovering = _React$useState2[1];
      var onInternalClose = function onInternalClose2() {
        onNoticeClose(eventKey);
      };
      reactExports.useEffect(function() {
        if (!hovering && duration > 0) {
          var timeout = setTimeout(function() {
            onInternalClose();
          }, duration * 1e3);
          return function() {
            clearTimeout(timeout);
          };
        }
      }, [duration, hovering, times]);
      var noticePrefixCls = "".concat(prefixCls, "-notice");
      return /* @__PURE__ */ reactExports.createElement("div", _extends$2({}, divProps, {
        ref,
        className: classNames(noticePrefixCls, className, _defineProperty$7({}, "".concat(noticePrefixCls, "-closable"), closable)),
        style: style2,
        onMouseEnter: function onMouseEnter() {
          setHovering(true);
        },
        onMouseLeave: function onMouseLeave() {
          setHovering(false);
        },
        onClick
      }), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(noticePrefixCls, "-content")
      }, content2), closable && /* @__PURE__ */ reactExports.createElement("a", {
        tabIndex: 0,
        className: "".concat(noticePrefixCls, "-close"),
        onClick: function onClick2(e2) {
          e2.preventDefault();
          e2.stopPropagation();
          onInternalClose();
        }
      }, closeIcon));
    });
    const Notice = Notify;
    var Notifications = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-notification" : _props$prefixCls, container2 = props.container, motion2 = props.motion, maxCount = props.maxCount, className = props.className, style2 = props.style, onAllRemoved = props.onAllRemoved;
      var _React$useState = reactExports.useState([]), _React$useState2 = _slicedToArray(_React$useState, 2), configList = _React$useState2[0], setConfigList = _React$useState2[1];
      var onNoticeClose = function onNoticeClose2(key) {
        var _config$onClose;
        var config = configList.find(function(item) {
          return item.key === key;
        });
        config === null || config === void 0 ? void 0 : (_config$onClose = config.onClose) === null || _config$onClose === void 0 ? void 0 : _config$onClose.call(config);
        setConfigList(function(list2) {
          return list2.filter(function(item) {
            return item.key !== key;
          });
        });
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          open: function open2(config) {
            setConfigList(function(list2) {
              var clone = _toConsumableArray(list2);
              var index2 = clone.findIndex(function(item) {
                return item.key === config.key;
              });
              var innerConfig = _objectSpread2$3({}, config);
              if (index2 >= 0) {
                var _list$index;
                innerConfig.times = (((_list$index = list2[index2]) === null || _list$index === void 0 ? void 0 : _list$index.times) || 0) + 1;
                clone[index2] = innerConfig;
              } else {
                innerConfig.times = 0;
                clone.push(innerConfig);
              }
              if (maxCount > 0 && clone.length > maxCount) {
                clone = clone.slice(-maxCount);
              }
              return clone;
            });
          },
          close: function close(key) {
            onNoticeClose(key);
          },
          destroy: function destroy2() {
            setConfigList([]);
          }
        };
      });
      var _React$useState3 = reactExports.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), placements2 = _React$useState4[0], setPlacements = _React$useState4[1];
      reactExports.useEffect(function() {
        var nextPlacements = {};
        configList.forEach(function(config) {
          var _config$placement = config.placement, placement = _config$placement === void 0 ? "topRight" : _config$placement;
          if (placement) {
            nextPlacements[placement] = nextPlacements[placement] || [];
            nextPlacements[placement].push(config);
          }
        });
        Object.keys(placements2).forEach(function(placement) {
          nextPlacements[placement] = nextPlacements[placement] || [];
        });
        setPlacements(nextPlacements);
      }, [configList]);
      var onAllNoticeRemoved = function onAllNoticeRemoved2(placement) {
        setPlacements(function(originPlacements) {
          var clone = _objectSpread2$3({}, originPlacements);
          var list2 = clone[placement] || [];
          if (!list2.length) {
            delete clone[placement];
          }
          return clone;
        });
      };
      var emptyRef = reactExports.useRef(false);
      reactExports.useEffect(function() {
        if (Object.keys(placements2).length > 0) {
          emptyRef.current = true;
        } else if (emptyRef.current) {
          onAllRemoved === null || onAllRemoved === void 0 ? void 0 : onAllRemoved();
          emptyRef.current = false;
        }
      }, [placements2]);
      if (!container2) {
        return null;
      }
      var placementList = Object.keys(placements2);
      return /* @__PURE__ */ reactDomExports.createPortal(/* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, placementList.map(function(placement) {
        var placementConfigList = placements2[placement];
        var keys2 = placementConfigList.map(function(config) {
          return {
            config,
            key: config.key
          };
        });
        var placementMotion = typeof motion2 === "function" ? motion2(placement) : motion2;
        return /* @__PURE__ */ reactExports.createElement(CSSMotionList, _extends$2({
          key: placement,
          className: classNames(prefixCls, "".concat(prefixCls, "-").concat(placement), className === null || className === void 0 ? void 0 : className(placement)),
          style: style2 === null || style2 === void 0 ? void 0 : style2(placement),
          keys: keys2,
          motionAppear: true
        }, placementMotion, {
          onAllRemoved: function onAllRemoved2() {
            onAllNoticeRemoved(placement);
          }
        }), function(_ref, nodeRef) {
          var config = _ref.config, motionClassName = _ref.className, motionStyle = _ref.style;
          var key = config.key, times = config.times;
          var configClassName = config.className, configStyle = config.style;
          return /* @__PURE__ */ reactExports.createElement(Notice, _extends$2({}, config, {
            ref: nodeRef,
            prefixCls,
            className: classNames(motionClassName, configClassName),
            style: _objectSpread2$3(_objectSpread2$3({}, motionStyle), configStyle),
            times,
            key,
            eventKey: key,
            onNoticeClose
          }));
        });
      })), container2);
    });
    var _excluded$I = ["getContainer", "motion", "prefixCls", "maxCount", "className", "style", "onAllRemoved"];
    var defaultGetContainer = function defaultGetContainer2() {
      return document.body;
    };
    var uniqueKey = 0;
    function mergeConfig$3() {
      var clone = {};
      for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
        objList[_key] = arguments[_key];
      }
      objList.forEach(function(obj) {
        if (obj) {
          Object.keys(obj).forEach(function(key) {
            var val = obj[key];
            if (val !== void 0) {
              clone[key] = val;
            }
          });
        }
      });
      return clone;
    }
    function useNotification$1() {
      var rootConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var _rootConfig$getContai = rootConfig.getContainer, getContainer2 = _rootConfig$getContai === void 0 ? defaultGetContainer : _rootConfig$getContai, motion2 = rootConfig.motion, prefixCls = rootConfig.prefixCls, maxCount = rootConfig.maxCount, className = rootConfig.className, style2 = rootConfig.style, onAllRemoved = rootConfig.onAllRemoved, shareConfig = _objectWithoutProperties$1(rootConfig, _excluded$I);
      var _React$useState = reactExports.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), container2 = _React$useState2[0], setContainer = _React$useState2[1];
      var notificationsRef = reactExports.useRef();
      var contextHolder = /* @__PURE__ */ reactExports.createElement(Notifications, {
        container: container2,
        ref: notificationsRef,
        prefixCls,
        motion: motion2,
        maxCount,
        className,
        style: style2,
        onAllRemoved
      });
      var _React$useState3 = reactExports.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), taskQueue2 = _React$useState4[0], setTaskQueue = _React$useState4[1];
      var api = reactExports.useMemo(function() {
        return {
          open: function open2(config) {
            var mergedConfig = mergeConfig$3(shareConfig, config);
            if (mergedConfig.key === null || mergedConfig.key === void 0) {
              mergedConfig.key = "rc-notification-".concat(uniqueKey);
              uniqueKey += 1;
            }
            setTaskQueue(function(queue) {
              return [].concat(_toConsumableArray(queue), [{
                type: "open",
                config: mergedConfig
              }]);
            });
          },
          close: function close(key) {
            setTaskQueue(function(queue) {
              return [].concat(_toConsumableArray(queue), [{
                type: "close",
                key
              }]);
            });
          },
          destroy: function destroy2() {
            setTaskQueue(function(queue) {
              return [].concat(_toConsumableArray(queue), [{
                type: "destroy"
              }]);
            });
          }
        };
      }, []);
      reactExports.useEffect(function() {
        setContainer(getContainer2());
      });
      reactExports.useEffect(function() {
        if (notificationsRef.current && taskQueue2.length) {
          taskQueue2.forEach(function(task) {
            switch (task.type) {
              case "open":
                notificationsRef.current.open(task.config);
                break;
              case "close":
                notificationsRef.current.close(task.key);
                break;
              case "destroy":
                notificationsRef.current.destroy();
                break;
            }
          });
          setTaskQueue([]);
        }
      }, [taskQueue2]);
      return [api, contextHolder];
    }
    var LoadingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
    const LoadingOutlinedSvg = LoadingOutlined$2;
    var LoadingOutlined = function LoadingOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: LoadingOutlinedSvg
      }));
    };
    LoadingOutlined.displayName = "LoadingOutlined";
    const LoadingOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(LoadingOutlined);
    function usePatchElement() {
      const [elements, setElements] = reactExports.useState([]);
      const patchElement = reactExports.useCallback((element) => {
        setElements((originElements) => [].concat(_toConsumableArray(originElements), [element]));
        return () => {
          setElements((originElements) => originElements.filter((ele) => ele !== element));
        };
      }, []);
      return [elements, patchElement];
    }
    var fullClone = _objectSpread2$3({}, ReactDOM$1);
    var version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
    var createRoot;
    try {
      var mainVersion = Number((version || "").split(".")[0]);
      if (mainVersion >= 18) {
        createRoot = fullClone.createRoot;
      }
    } catch (e2) {
    }
    function toggleWarning(skip) {
      var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof$4(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") {
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
      }
    }
    var MARK = "__rc_react_root__";
    function modernRender(node2, container2) {
      toggleWarning(true);
      var root2 = container2[MARK] || createRoot(container2);
      toggleWarning(false);
      root2.render(node2);
      container2[MARK] = root2;
    }
    function legacyRender(node2, container2) {
      reactRender(node2, container2);
    }
    function render(node2, container2) {
      if (createRoot) {
        modernRender(node2, container2);
        return;
      }
      legacyRender(node2, container2);
    }
    function modernUnmount(_x) {
      return _modernUnmount.apply(this, arguments);
    }
    function _modernUnmount() {
      _modernUnmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(container2) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", Promise.resolve().then(function() {
                  var _container$MARK;
                  (_container$MARK = container2[MARK]) === null || _container$MARK === void 0 ? void 0 : _container$MARK.unmount();
                  delete container2[MARK];
                }));
              case 1:
              case "end":
                return _context.stop();
            }
        }, _callee);
      }));
      return _modernUnmount.apply(this, arguments);
    }
    function legacyUnmount(container2) {
      unmountComponentAtNode(container2);
    }
    function unmount(_x2) {
      return _unmount.apply(this, arguments);
    }
    function _unmount() {
      _unmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(container2) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(createRoot !== void 0)) {
                  _context2.next = 2;
                  break;
                }
                return _context2.abrupt("return", modernUnmount(container2));
              case 2:
                legacyUnmount(container2);
              case 3:
              case "end":
                return _context2.stop();
            }
        }, _callee2);
      }));
      return _unmount.apply(this, arguments);
    }
    const useLocale = (componentName, defaultLocale$1) => {
      const fullLocale = reactExports.useContext(LocaleContext$1);
      const getLocale = reactExports.useMemo(() => {
        var _a;
        const locale2 = defaultLocale$1 || defaultLocale[componentName];
        const localeFromContext = (_a = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale[componentName]) !== null && _a !== void 0 ? _a : {};
        return Object.assign(Object.assign({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {});
      }, [componentName, defaultLocale$1, fullLocale]);
      const getLocaleCode = reactExports.useMemo(() => {
        const localeCode = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.locale;
        if ((fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.exist) && !localeCode) {
          return defaultLocale.locale;
        }
        return localeCode;
      }, [fullLocale]);
      return [getLocale, getLocaleCode];
    };
    const useLocale$1 = useLocale;
    const genSpaceCompactStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          display: "inline-flex",
          "&-block": {
            display: "flex",
            width: "100%"
          },
          "&-vertical": {
            flexDirection: "column"
          }
        }
      };
    };
    const genSpaceCompactStyle$1 = genSpaceCompactStyle;
    const genSpaceStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          display: "inline-flex",
          "&-rtl": {
            direction: "rtl"
          },
          "&-vertical": {
            flexDirection: "column"
          },
          "&-align": {
            flexDirection: "column",
            "&-center": {
              alignItems: "center"
            },
            "&-start": {
              alignItems: "flex-start"
            },
            "&-end": {
              alignItems: "flex-end"
            },
            "&-baseline": {
              alignItems: "baseline"
            }
          },
          [`${componentCls}-item`]: {
            "&:empty": {
              display: "none"
            }
          }
        }
      };
    };
    const useStyle$z = genComponentStyleHook("Space", (token2) => [genSpaceStyle(token2), genSpaceCompactStyle$1(token2)]);
    var __rest$13 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const SpaceCompactItemContext = /* @__PURE__ */ reactExports.createContext(null);
    const useCompactItemContext = (prefixCls, direction) => {
      const compactItemContext = reactExports.useContext(SpaceCompactItemContext);
      const compactItemClassnames = reactExports.useMemo(() => {
        if (!compactItemContext)
          return "";
        const {
          compactDirection,
          isFirstItem,
          isLastItem
        } = compactItemContext;
        const separator = compactDirection === "vertical" ? "-vertical-" : "-";
        return classNames({
          [`${prefixCls}-compact${separator}item`]: true,
          [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
          [`${prefixCls}-compact${separator}last-item`]: isLastItem,
          [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
        });
      }, [prefixCls, direction, compactItemContext]);
      return {
        compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
        compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
        compactItemClassnames
      };
    };
    const NoCompactStyle = (_ref) => {
      let {
        children
      } = _ref;
      return /* @__PURE__ */ reactExports.createElement(SpaceCompactItemContext.Provider, {
        value: null
      }, children);
    };
    const CompactItem = (_a) => {
      var {
        children
      } = _a, otherProps = __rest$13(_a, ["children"]);
      return /* @__PURE__ */ reactExports.createElement(SpaceCompactItemContext.Provider, {
        value: otherProps
      }, children);
    };
    const Compact = (props) => {
      const {
        getPrefixCls,
        direction: directionConfig
      } = reactExports.useContext(ConfigContext);
      const {
        size = "middle",
        direction,
        block,
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        children
      } = props, restProps = __rest$13(props, ["size", "direction", "block", "prefixCls", "className", "rootClassName", "children"]);
      const prefixCls = getPrefixCls("space-compact", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$z(prefixCls);
      const clx = classNames(prefixCls, hashId, {
        [`${prefixCls}-rtl`]: directionConfig === "rtl",
        [`${prefixCls}-block`]: block,
        [`${prefixCls}-vertical`]: direction === "vertical"
      }, className, rootClassName);
      const compactItemContext = reactExports.useContext(SpaceCompactItemContext);
      const childNodes = toArray$8(children);
      const nodes = reactExports.useMemo(() => childNodes.map((child, i2) => {
        const key = child && child.key || `${prefixCls}-item-${i2}`;
        return /* @__PURE__ */ reactExports.createElement(CompactItem, {
          key,
          compactSize: size,
          compactDirection: direction,
          isFirstItem: i2 === 0 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isFirstItem)),
          isLastItem: i2 === childNodes.length - 1 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isLastItem))
        }, child);
      }), [size, childNodes, compactItemContext]);
      if (childNodes.length === 0) {
        return null;
      }
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        className: clx
      }, restProps), nodes));
    };
    const isVisible$1 = function(element) {
      if (!element) {
        return false;
      }
      if (element instanceof HTMLElement && element.offsetParent) {
        return true;
      }
      if (element instanceof SVGGraphicsElement && element.getBBox) {
        var _element$getBBox = element.getBBox(), width = _element$getBBox.width, height = _element$getBBox.height;
        if (width || height) {
          return true;
        }
      }
      if (element instanceof HTMLElement && element.getBoundingClientRect) {
        var _element$getBoundingC = element.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
        if (_width || _height) {
          return true;
        }
      }
      return false;
    };
    const genWaveStyle = (token2) => {
      const {
        componentCls,
        colorPrimary
      } = token2;
      return {
        [componentCls]: {
          position: "absolute",
          background: "transparent",
          pointerEvents: "none",
          boxSizing: "border-box",
          color: `var(--wave-color, ${colorPrimary})`,
          boxShadow: `0 0 0 0 currentcolor`,
          opacity: 0.2,
          // =================== Motion ===================
          "&.wave-motion-appear": {
            transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
            "&-active": {
              boxShadow: `0 0 0 6px currentcolor`,
              opacity: 0
            }
          }
        }
      };
    };
    const useStyle$y = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]);
    function isNotGrey(color2) {
      const match2 = (color2 || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
      if (match2 && match2[1] && match2[2] && match2[3]) {
        return !(match2[1] === match2[2] && match2[2] === match2[3]);
      }
      return true;
    }
    function isValidWaveColor(color2) {
      return color2 && color2 !== "#fff" && color2 !== "#ffffff" && color2 !== "rgb(255, 255, 255)" && color2 !== "rgba(255, 255, 255, 1)" && isNotGrey(color2) && !/rgba\((?:\d*, ){3}0\)/.test(color2) && // any transparent rgba color
      color2 !== "transparent";
    }
    function getTargetWaveColor(node2) {
      const {
        borderTopColor,
        borderColor,
        backgroundColor
      } = getComputedStyle(node2);
      if (isValidWaveColor(borderTopColor)) {
        return borderTopColor;
      }
      if (isValidWaveColor(borderColor)) {
        return borderColor;
      }
      if (isValidWaveColor(backgroundColor)) {
        return backgroundColor;
      }
      return null;
    }
    function validateNum(value) {
      return Number.isNaN(value) ? 0 : value;
    }
    const WaveEffect = (props) => {
      const {
        className,
        target
      } = props;
      const divRef = reactExports.useRef(null);
      const [color2, setWaveColor] = reactExports.useState(null);
      const [borderRadius, setBorderRadius] = reactExports.useState([]);
      const [left, setLeft] = reactExports.useState(0);
      const [top, setTop] = reactExports.useState(0);
      const [width, setWidth] = reactExports.useState(0);
      const [height, setHeight] = reactExports.useState(0);
      const [enabled, setEnabled] = reactExports.useState(false);
      const waveStyle = {
        left,
        top,
        width,
        height,
        borderRadius: borderRadius.map((radius) => `${radius}px`).join(" ")
      };
      if (color2) {
        waveStyle["--wave-color"] = color2;
      }
      function syncPos() {
        const nodeStyle = getComputedStyle(target);
        setWaveColor(getTargetWaveColor(target));
        const isStatic = nodeStyle.position === "static";
        const {
          borderLeftWidth,
          borderTopWidth
        } = nodeStyle;
        setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
        setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
        setWidth(target.offsetWidth);
        setHeight(target.offsetHeight);
        const {
          borderTopLeftRadius,
          borderTopRightRadius,
          borderBottomLeftRadius,
          borderBottomRightRadius
        } = nodeStyle;
        setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius) => validateNum(parseFloat(radius))));
      }
      reactExports.useEffect(() => {
        if (target) {
          const id2 = wrapperRaf(() => {
            syncPos();
            setEnabled(true);
          });
          let resizeObserver2;
          if (typeof ResizeObserver !== "undefined") {
            resizeObserver2 = new ResizeObserver(syncPos);
            resizeObserver2.observe(target);
          }
          return () => {
            wrapperRaf.cancel(id2);
            resizeObserver2 === null || resizeObserver2 === void 0 ? void 0 : resizeObserver2.disconnect();
          };
        }
      }, []);
      if (!enabled) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, {
        visible: true,
        motionAppear: true,
        motionName: "wave-motion",
        motionDeadline: 5e3,
        onAppearEnd: (_, event) => {
          var _a;
          if (event.deadline || event.propertyName === "opacity") {
            const holder = (_a = divRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
            unmount(holder).then(() => {
              var _a2;
              (_a2 = holder.parentElement) === null || _a2 === void 0 ? void 0 : _a2.removeChild(holder);
            });
          }
          return false;
        }
      }, (_ref) => {
        let {
          className: motionClassName
        } = _ref;
        return /* @__PURE__ */ reactExports.createElement("div", {
          ref: divRef,
          className: classNames(className, motionClassName),
          style: waveStyle
        });
      });
    };
    function showWaveEffect(node2, className) {
      const holder = document.createElement("div");
      holder.style.position = "absolute";
      holder.style.left = `0px`;
      holder.style.top = `0px`;
      node2 === null || node2 === void 0 ? void 0 : node2.insertBefore(holder, node2 === null || node2 === void 0 ? void 0 : node2.firstChild);
      render(/* @__PURE__ */ reactExports.createElement(WaveEffect, {
        target: node2,
        className
      }), holder);
    }
    function useWave(nodeRef, className) {
      function showWave() {
        const node2 = nodeRef.current;
        showWaveEffect(node2, className);
      }
      return showWave;
    }
    const Wave = (props) => {
      const {
        children,
        disabled
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const containerRef = reactExports.useRef(null);
      const prefixCls = getPrefixCls("wave");
      const [, hashId] = useStyle$y(prefixCls);
      const showWave = useWave(containerRef, classNames(prefixCls, hashId));
      React$3.useEffect(() => {
        const node2 = containerRef.current;
        if (!node2 || node2.nodeType !== 1 || disabled) {
          return;
        }
        const onClick = (e2) => {
          if (e2.target.tagName === "INPUT" || !isVisible$1(e2.target) || // No need wave
          !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
            return;
          }
          showWave();
        };
        node2.addEventListener("click", onClick, true);
        return () => {
          node2.removeEventListener("click", onClick, true);
        };
      }, [disabled]);
      if (!/* @__PURE__ */ React$3.isValidElement(children)) {
        return children !== null && children !== void 0 ? children : null;
      }
      const ref = supportRef(children) ? composeRef(children.ref, containerRef) : containerRef;
      return cloneElement(children, {
        ref
      });
    };
    const Wave$1 = Wave;
    var __rest$12 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const GroupSizeContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const ButtonGroup = (props) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        size,
        className
      } = props, others = __rest$12(props, ["prefixCls", "size", "className"]);
      const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
      const [, , hashId] = useToken$3();
      let sizeCls = "";
      switch (size) {
        case "large":
          sizeCls = "lg";
          break;
        case "small":
          sizeCls = "sm";
          break;
      }
      const classes = classNames(prefixCls, {
        [`${prefixCls}-${sizeCls}`]: sizeCls,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, hashId);
      return /* @__PURE__ */ reactExports.createElement(GroupSizeContext.Provider, {
        value: size
      }, /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, others, {
        className: classes
      })));
    };
    const Group$6 = ButtonGroup;
    const rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
    const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
    function isString$2(str) {
      return typeof str === "string";
    }
    function isUnBorderedButtonType(type2) {
      return type2 === "text" || type2 === "link";
    }
    function splitCNCharsBySpace(child, needInserted) {
      if (child === null || child === void 0) {
        return;
      }
      const SPACE = needInserted ? " " : "";
      if (typeof child !== "string" && typeof child !== "number" && isString$2(child.type) && isTwoCNChar(child.props.children)) {
        return cloneElement(child, {
          children: child.props.children.split("").join(SPACE)
        });
      }
      if (typeof child === "string") {
        return isTwoCNChar(child) ? /* @__PURE__ */ React$3.createElement("span", null, child.split("").join(SPACE)) : /* @__PURE__ */ React$3.createElement("span", null, child);
      }
      if (isFragment(child)) {
        return /* @__PURE__ */ React$3.createElement("span", null, child);
      }
      return child;
    }
    function spaceChildren(children, needInserted) {
      let isPrevChildPure = false;
      const childList = [];
      React$3.Children.forEach(children, (child) => {
        const type2 = typeof child;
        const isCurrentChildPure = type2 === "string" || type2 === "number";
        if (isPrevChildPure && isCurrentChildPure) {
          const lastIndex = childList.length - 1;
          const lastChild = childList[lastIndex];
          childList[lastIndex] = `${lastChild}${child}`;
        } else {
          childList.push(child);
        }
        isPrevChildPure = isCurrentChildPure;
      });
      return React$3.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted));
    }
    const getCollapsedWidth = () => ({
      width: 0,
      opacity: 0,
      transform: "scale(0)"
    });
    const getRealWidth = (node2) => ({
      width: node2.scrollWidth,
      opacity: 1,
      transform: "scale(1)"
    });
    const LoadingIcon = (_ref) => {
      let {
        prefixCls,
        loading,
        existIcon
      } = _ref;
      const visible = !!loading;
      if (existIcon) {
        return /* @__PURE__ */ React$3.createElement("span", {
          className: `${prefixCls}-loading-icon`
        }, /* @__PURE__ */ React$3.createElement(LoadingOutlined$1, null));
      }
      return /* @__PURE__ */ React$3.createElement(CSSMotion, {
        visible,
        // We do not really use this motionName
        motionName: `${prefixCls}-loading-icon-motion`,
        removeOnLeave: true,
        onAppearStart: getCollapsedWidth,
        onAppearActive: getRealWidth,
        onEnterStart: getCollapsedWidth,
        onEnterActive: getRealWidth,
        onLeaveStart: getRealWidth,
        onLeaveActive: getCollapsedWidth
      }, (_ref2, ref) => {
        let {
          className,
          style: style2
        } = _ref2;
        return /* @__PURE__ */ React$3.createElement("span", {
          className: `${prefixCls}-loading-icon`,
          style: style2,
          ref
        }, /* @__PURE__ */ React$3.createElement(LoadingOutlined$1, {
          className
        }));
      });
    };
    const LoadingIcon$1 = LoadingIcon;
    const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
      // Border
      [`> span, > ${buttonTypeCls}`]: {
        "&:not(:last-child)": {
          [`&, & > ${buttonTypeCls}`]: {
            "&:not(:disabled)": {
              borderInlineEndColor: borderColor
            }
          }
        },
        "&:not(:first-child)": {
          [`&, & > ${buttonTypeCls}`]: {
            "&:not(:disabled)": {
              borderInlineStartColor: borderColor
            }
          }
        }
      }
    });
    const genGroupStyle$2 = (token2) => {
      const {
        componentCls,
        fontSize,
        lineWidth,
        colorPrimaryHover,
        colorErrorHover
      } = token2;
      return {
        [`${componentCls}-group`]: [
          {
            position: "relative",
            display: "inline-flex",
            // Border
            [`> span, > ${componentCls}`]: {
              "&:not(:last-child)": {
                [`&, & > ${componentCls}`]: {
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0
                }
              },
              "&:not(:first-child)": {
                marginInlineStart: -lineWidth,
                [`&, & > ${componentCls}`]: {
                  borderStartStartRadius: 0,
                  borderEndStartRadius: 0
                }
              }
            },
            [componentCls]: {
              position: "relative",
              zIndex: 1,
              [`&:hover,
          &:focus,
          &:active`]: {
                zIndex: 2
              },
              "&[disabled]": {
                zIndex: 0
              }
            },
            [`${componentCls}-icon-only`]: {
              fontSize
            }
          },
          // Border Color
          genButtonBorderStyle(`${componentCls}-primary`, colorPrimaryHover),
          genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
        ]
      };
    };
    const genGroupStyle$3 = genGroupStyle$2;
    function compactItemBorder(token2, parentCls, options) {
      const {
        focusElCls,
        focus,
        borderElCls
      } = options;
      const childCombinator = borderElCls ? "> *" : "";
      const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
      return {
        [`&-item:not(${parentCls}-last-item)`]: {
          marginInlineEnd: -token2.lineWidth
        },
        "&-item": Object.assign(Object.assign({
          [hoverEffects]: {
            zIndex: 2
          }
        }, focusElCls ? {
          [`&${focusElCls}`]: {
            zIndex: 2
          }
        } : {}), {
          [`&[disabled] ${childCombinator}`]: {
            zIndex: 0
          }
        })
      };
    }
    function compactItemBorderRadius(prefixCls, parentCls, options) {
      const {
        borderElCls
      } = options;
      const childCombinator = borderElCls ? `> ${borderElCls}` : "";
      return {
        [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
          borderRadius: 0
        },
        [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
          [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
          [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        }
      };
    }
    function genCompactItemStyle(token2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        focus: true
      };
      const {
        componentCls
      } = token2;
      const compactCls = `${componentCls}-compact`;
      return {
        [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token2, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
      };
    }
    function compactItemVerticalBorder(token2, parentCls) {
      return {
        // border collapse
        [`&-item:not(${parentCls}-last-item)`]: {
          marginBottom: -token2.lineWidth
        },
        "&-item": {
          "&:hover,&:focus,&:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        }
      };
    }
    function compactItemBorderVerticalRadius(prefixCls, parentCls) {
      return {
        [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
          borderRadius: 0
        },
        [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
          [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
            borderEndEndRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
          [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
            borderStartStartRadius: 0,
            borderStartEndRadius: 0
          }
        }
      };
    }
    function genCompactItemVerticalStyle(token2) {
      const compactCls = `${token2.componentCls}-compact-vertical`;
      return {
        [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
      };
    }
    const genSharedButtonStyle = (token2) => {
      const {
        componentCls,
        iconCls
      } = token2;
      return {
        [componentCls]: {
          outline: "none",
          position: "relative",
          display: "inline-block",
          fontWeight: 400,
          whiteSpace: "nowrap",
          textAlign: "center",
          backgroundImage: "none",
          backgroundColor: "transparent",
          border: `${token2.lineWidth}px ${token2.lineType} transparent`,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
          userSelect: "none",
          touchAction: "manipulation",
          lineHeight: token2.lineHeight,
          color: token2.colorText,
          "> span": {
            display: "inline-block"
          },
          // Leave a space between icon and text.
          [`> ${iconCls} + span, > span + ${iconCls}`]: {
            marginInlineStart: token2.marginXS
          },
          "> a": {
            color: "currentColor"
          },
          "&:not(:disabled)": Object.assign({}, genFocusStyle(token2)),
          // make `btn-icon-only` not too narrow
          [`&-icon-only${componentCls}-compact-item`]: {
            flex: "none"
          },
          // Special styles for Primary Button
          [`&-compact-item${componentCls}-primary`]: {
            [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
              position: "relative",
              "&:before": {
                position: "absolute",
                top: -token2.lineWidth,
                insetInlineStart: -token2.lineWidth,
                display: "inline-block",
                width: token2.lineWidth,
                height: `calc(100% + ${token2.lineWidth * 2}px)`,
                backgroundColor: token2.colorPrimaryHover,
                content: '""'
              }
            }
          },
          // Special styles for Primary Button
          "&-compact-vertical-item": {
            [`&${componentCls}-primary`]: {
              [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
                position: "relative",
                "&:before": {
                  position: "absolute",
                  top: -token2.lineWidth,
                  insetInlineStart: -token2.lineWidth,
                  display: "inline-block",
                  width: `calc(100% + ${token2.lineWidth * 2}px)`,
                  height: token2.lineWidth,
                  backgroundColor: token2.colorPrimaryHover,
                  content: '""'
                }
              }
            }
          }
        }
      };
    };
    const genHoverActiveButtonStyle = (hoverStyle, activeStyle) => ({
      "&:not(:disabled)": {
        "&:hover": hoverStyle,
        "&:active": activeStyle
      }
    });
    const genCircleButtonStyle = (token2) => ({
      minWidth: token2.controlHeight,
      paddingInlineStart: 0,
      paddingInlineEnd: 0,
      borderRadius: "50%"
    });
    const genRoundButtonStyle = (token2) => ({
      borderRadius: token2.controlHeight,
      paddingInlineStart: token2.controlHeight / 2,
      paddingInlineEnd: token2.controlHeight / 2
    });
    const genDisabledStyle$1 = (token2) => ({
      cursor: "not-allowed",
      borderColor: token2.colorBorder,
      color: token2.colorTextDisabled,
      backgroundColor: token2.colorBgContainerDisabled,
      boxShadow: "none"
    });
    const genGhostButtonStyle = (btnCls, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
      [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
        color: textColor || void 0,
        backgroundColor: "transparent",
        borderColor: borderColor || void 0,
        boxShadow: "none"
      }, genHoverActiveButtonStyle(Object.assign({
        backgroundColor: "transparent"
      }, hoverStyle), Object.assign({
        backgroundColor: "transparent"
      }, activeStyle))), {
        "&:disabled": {
          cursor: "not-allowed",
          color: textColorDisabled || void 0,
          borderColor: borderColorDisabled || void 0
        }
      })
    });
    const genSolidDisabledButtonStyle = (token2) => ({
      "&:disabled": Object.assign({}, genDisabledStyle$1(token2))
    });
    const genSolidButtonStyle = (token2) => Object.assign({}, genSolidDisabledButtonStyle(token2));
    const genPureDisabledButtonStyle = (token2) => ({
      "&:disabled": {
        cursor: "not-allowed",
        color: token2.colorTextDisabled
      }
    });
    const genDefaultButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
      backgroundColor: token2.colorBgContainer,
      borderColor: token2.colorBorder,
      boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`
    }), genHoverActiveButtonStyle({
      color: token2.colorPrimaryHover,
      borderColor: token2.colorPrimaryHover
    }, {
      color: token2.colorPrimaryActive,
      borderColor: token2.colorPrimaryActive
    })), genGhostButtonStyle(token2.componentCls, token2.colorBgContainer, token2.colorBgContainer, token2.colorTextDisabled, token2.colorBorder)), {
      [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
        color: token2.colorError,
        borderColor: token2.colorError
      }, genHoverActiveButtonStyle({
        color: token2.colorErrorHover,
        borderColor: token2.colorErrorBorderHover
      }, {
        color: token2.colorErrorActive,
        borderColor: token2.colorErrorActive
      })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder)), genSolidDisabledButtonStyle(token2))
    });
    const genPrimaryButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
      color: token2.colorTextLightSolid,
      backgroundColor: token2.colorPrimary,
      boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`
    }), genHoverActiveButtonStyle({
      color: token2.colorTextLightSolid,
      backgroundColor: token2.colorPrimaryHover
    }, {
      color: token2.colorTextLightSolid,
      backgroundColor: token2.colorPrimaryActive
    })), genGhostButtonStyle(token2.componentCls, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
      color: token2.colorPrimaryHover,
      borderColor: token2.colorPrimaryHover
    }, {
      color: token2.colorPrimaryActive,
      borderColor: token2.colorPrimaryActive
    })), {
      [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
        backgroundColor: token2.colorError,
        boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`
      }, genHoverActiveButtonStyle({
        backgroundColor: token2.colorErrorHover
      }, {
        backgroundColor: token2.colorErrorActive
      })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
        color: token2.colorErrorHover,
        borderColor: token2.colorErrorHover
      }, {
        color: token2.colorErrorActive,
        borderColor: token2.colorErrorActive
      })), genSolidDisabledButtonStyle(token2))
    });
    const genDashedButtonStyle = (token2) => Object.assign(Object.assign({}, genDefaultButtonStyle(token2)), {
      borderStyle: "dashed"
    });
    const genLinkButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({
      color: token2.colorLink
    }, genHoverActiveButtonStyle({
      color: token2.colorLinkHover
    }, {
      color: token2.colorLinkActive
    })), genPureDisabledButtonStyle(token2)), {
      [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
        color: token2.colorError
      }, genHoverActiveButtonStyle({
        color: token2.colorErrorHover
      }, {
        color: token2.colorErrorActive
      })), genPureDisabledButtonStyle(token2))
    });
    const genTextButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({}, genHoverActiveButtonStyle({
      color: token2.colorText,
      backgroundColor: token2.colorBgTextHover
    }, {
      color: token2.colorText,
      backgroundColor: token2.colorBgTextActive
    })), genPureDisabledButtonStyle(token2)), {
      [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
        color: token2.colorError
      }, genPureDisabledButtonStyle(token2)), genHoverActiveButtonStyle({
        color: token2.colorErrorHover,
        backgroundColor: token2.colorErrorBg
      }, {
        color: token2.colorErrorHover,
        backgroundColor: token2.colorErrorBg
      }))
    });
    const genDisabledButtonStyle = (token2) => Object.assign(Object.assign({}, genDisabledStyle$1(token2)), {
      [`&${token2.componentCls}:hover`]: Object.assign({}, genDisabledStyle$1(token2))
    });
    const genTypeButtonStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-default`]: genDefaultButtonStyle(token2),
        [`${componentCls}-primary`]: genPrimaryButtonStyle(token2),
        [`${componentCls}-dashed`]: genDashedButtonStyle(token2),
        [`${componentCls}-link`]: genLinkButtonStyle(token2),
        [`${componentCls}-text`]: genTextButtonStyle(token2),
        [`${componentCls}-disabled`]: genDisabledButtonStyle(token2)
      };
    };
    const genSizeButtonStyle = function(token2) {
      let sizePrefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      const {
        componentCls,
        iconCls,
        controlHeight,
        fontSize,
        lineHeight,
        lineWidth,
        borderRadius,
        buttonPaddingHorizontal
      } = token2;
      const paddingVertical = Math.max(0, (controlHeight - fontSize * lineHeight) / 2 - lineWidth);
      const paddingHorizontal = buttonPaddingHorizontal - lineWidth;
      const iconOnlyCls = `${componentCls}-icon-only`;
      return [
        // Size
        {
          [`${componentCls}${sizePrefixCls}`]: {
            fontSize,
            height: controlHeight,
            padding: `${paddingVertical}px ${paddingHorizontal}px`,
            borderRadius,
            [`&${iconOnlyCls}`]: {
              width: controlHeight,
              paddingInlineStart: 0,
              paddingInlineEnd: 0,
              [`&${componentCls}-round`]: {
                width: "auto"
              },
              "> span": {
                transform: "scale(1.143)"
                // 14px -> 16px
              }
            },
            // Loading
            [`&${componentCls}-loading`]: {
              opacity: token2.opacityLoading,
              cursor: "default"
            },
            [`${componentCls}-loading-icon`]: {
              transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
            },
            [`&:not(${iconOnlyCls}) ${componentCls}-loading-icon > ${iconCls}`]: {
              marginInlineEnd: token2.marginXS
            }
          }
        },
        // Shape - patch prefixCls again to override solid border radius style
        {
          [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle(token2)
        },
        {
          [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle(token2)
        }
      ];
    };
    const genSizeBaseButtonStyle = (token2) => genSizeButtonStyle(token2);
    const genSizeSmallButtonStyle = (token2) => {
      const smallToken = merge$4(token2, {
        controlHeight: token2.controlHeightSM,
        padding: token2.paddingXS,
        buttonPaddingHorizontal: 8,
        borderRadius: token2.borderRadiusSM
      });
      return genSizeButtonStyle(smallToken, `${token2.componentCls}-sm`);
    };
    const genSizeLargeButtonStyle = (token2) => {
      const largeToken = merge$4(token2, {
        controlHeight: token2.controlHeightLG,
        fontSize: token2.fontSizeLG,
        borderRadius: token2.borderRadiusLG
      });
      return genSizeButtonStyle(largeToken, `${token2.componentCls}-lg`);
    };
    const genBlockButtonStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          [`&${componentCls}-block`]: {
            width: "100%"
          }
        }
      };
    };
    const useStyle$x = genComponentStyleHook("Button", (token2) => {
      const {
        controlTmpOutline,
        paddingContentHorizontal
      } = token2;
      const buttonToken = merge$4(token2, {
        colorOutlineDefault: controlTmpOutline,
        buttonPaddingHorizontal: paddingContentHorizontal
      });
      return [
        // Shared
        genSharedButtonStyle(buttonToken),
        // Size
        genSizeSmallButtonStyle(buttonToken),
        genSizeBaseButtonStyle(buttonToken),
        genSizeLargeButtonStyle(buttonToken),
        // Block
        genBlockButtonStyle(buttonToken),
        // Group (type, ghost, danger, disabled, loading)
        genTypeButtonStyle(buttonToken),
        // Button Group
        genGroupStyle$3(buttonToken),
        // Space Compact
        genCompactItemStyle(token2, {
          focus: false
        }),
        genCompactItemVerticalStyle(token2)
      ];
    });
    var __rest$11 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function convertLegacyProps(type2) {
      if (type2 === "danger") {
        return {
          danger: true
        };
      }
      return {
        type: type2
      };
    }
    function getLoadingConfig(loading) {
      if (typeof loading === "object" && loading) {
        const delay = loading === null || loading === void 0 ? void 0 : loading.delay;
        const isDelay = !Number.isNaN(delay) && typeof delay === "number";
        return {
          loading: false,
          delay: isDelay ? delay : 0
        };
      }
      return {
        loading: !!loading,
        delay: 0
      };
    }
    const InternalButton = (props, ref) => {
      const {
        loading = false,
        prefixCls: customizePrefixCls,
        type: type2 = "default",
        danger,
        shape = "default",
        size: customizeSize,
        disabled: customDisabled,
        className,
        rootClassName,
        children,
        icon,
        ghost = false,
        block = false,
        // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
        htmlType = "button"
      } = props, rest = __rest$11(props, ["loading", "prefixCls", "type", "danger", "shape", "size", "disabled", "className", "rootClassName", "children", "icon", "ghost", "block", "htmlType"]);
      const {
        getPrefixCls,
        autoInsertSpaceInButton,
        direction
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("btn", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$x(prefixCls);
      const size = reactExports.useContext(SizeContext$2);
      const disabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const groupSize = reactExports.useContext(GroupSizeContext);
      const loadingOrDelay = reactExports.useMemo(() => getLoadingConfig(loading), [loading]);
      const [innerLoading, setLoading] = reactExports.useState(loadingOrDelay.loading);
      const [hasTwoCNChar, setHasTwoCNChar] = reactExports.useState(false);
      const buttonRef = ref || /* @__PURE__ */ reactExports.createRef();
      const isNeedInserted = () => reactExports.Children.count(children) === 1 && !icon && !isUnBorderedButtonType(type2);
      const fixTwoCNChar = () => {
        if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
          return;
        }
        const buttonText = buttonRef.current.textContent;
        if (isNeedInserted() && isTwoCNChar(buttonText)) {
          if (!hasTwoCNChar) {
            setHasTwoCNChar(true);
          }
        } else if (hasTwoCNChar) {
          setHasTwoCNChar(false);
        }
      };
      reactExports.useEffect(() => {
        let delayTimer = null;
        if (loadingOrDelay.delay > 0) {
          delayTimer = window.setTimeout(() => {
            delayTimer = null;
            setLoading(true);
          }, loadingOrDelay.delay);
        } else {
          setLoading(loadingOrDelay.loading);
        }
        function cleanupTimer() {
          if (delayTimer) {
            window.clearTimeout(delayTimer);
            delayTimer = null;
          }
        }
        return cleanupTimer;
      }, [loadingOrDelay]);
      reactExports.useEffect(fixTwoCNChar, [buttonRef]);
      const handleClick = (e2) => {
        const {
          onClick
        } = props;
        if (innerLoading || mergedDisabled) {
          e2.preventDefault();
          return;
        }
        onClick === null || onClick === void 0 ? void 0 : onClick(e2);
      };
      const autoInsertSpace = autoInsertSpaceInButton !== false;
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const sizeClassNameMap = {
        large: "lg",
        small: "sm",
        middle: void 0
      };
      const sizeFullname = compactSize || groupSize || customizeSize || size;
      const sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || "" : "";
      const iconType = innerLoading ? "loading" : icon;
      const linkButtonRestProps = omit(rest, ["navigate"]);
      const hrefAndDisabled = linkButtonRestProps.href !== void 0 && mergedDisabled;
      const classes = classNames(prefixCls, hashId, {
        [`${prefixCls}-${shape}`]: shape !== "default" && shape,
        [`${prefixCls}-${type2}`]: type2,
        [`${prefixCls}-${sizeCls}`]: sizeCls,
        [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
        [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonType(type2),
        [`${prefixCls}-loading`]: innerLoading,
        [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && autoInsertSpace && !innerLoading,
        [`${prefixCls}-block`]: block,
        [`${prefixCls}-dangerous`]: !!danger,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-disabled`]: hrefAndDisabled
      }, compactItemClassnames, className, rootClassName);
      const iconNode = icon && !innerLoading ? icon : /* @__PURE__ */ reactExports.createElement(LoadingIcon$1, {
        existIcon: !!icon,
        prefixCls,
        loading: !!innerLoading
      });
      const kids = children || children === 0 ? spaceChildren(children, isNeedInserted() && autoInsertSpace) : null;
      if (linkButtonRestProps.href !== void 0) {
        return wrapSSR(/* @__PURE__ */ reactExports.createElement("a", Object.assign({}, linkButtonRestProps, {
          className: classes,
          onClick: handleClick,
          ref: buttonRef
        }), iconNode, kids));
      }
      let buttonNode = /* @__PURE__ */ reactExports.createElement("button", Object.assign({}, rest, {
        type: htmlType,
        className: classes,
        onClick: handleClick,
        disabled: mergedDisabled,
        ref: buttonRef
      }), iconNode, kids);
      if (!isUnBorderedButtonType(type2)) {
        buttonNode = /* @__PURE__ */ reactExports.createElement(Wave$1, {
          disabled: !!innerLoading
        }, buttonNode);
      }
      return wrapSSR(buttonNode);
    };
    const Button$1 = /* @__PURE__ */ reactExports.forwardRef(InternalButton);
    Button$1.Group = Group$6;
    Button$1.__ANT_BUTTON = true;
    const Button$2 = Button$1;
    function isThenable(thing) {
      return !!(thing && thing.then);
    }
    const ActionButton = (props) => {
      const {
        type: type2,
        children,
        prefixCls,
        buttonProps,
        close,
        autoFocus,
        emitEvent,
        quitOnNullishReturnValue,
        actionFn
      } = props;
      const clickedRef = reactExports.useRef(false);
      const buttonRef = reactExports.useRef(null);
      const [loading, setLoading] = useSafeState(false);
      const onInternalClose = function() {
        close === null || close === void 0 ? void 0 : close.apply(void 0, arguments);
      };
      reactExports.useEffect(() => {
        let timeoutId = null;
        if (autoFocus) {
          timeoutId = setTimeout(() => {
            var _a;
            (_a = buttonRef.current) === null || _a === void 0 ? void 0 : _a.focus();
          });
        }
        return () => {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
        };
      }, []);
      const handlePromiseOnOk = (returnValueOfOnOk) => {
        if (!isThenable(returnValueOfOnOk)) {
          return;
        }
        setLoading(true);
        returnValueOfOnOk.then(function() {
          onInternalClose.apply(void 0, arguments);
          clickedRef.current = false;
        }, (e2) => {
          setLoading(false, true);
          clickedRef.current = false;
          return Promise.reject(e2);
        });
      };
      const onClick = (e2) => {
        if (clickedRef.current) {
          return;
        }
        clickedRef.current = true;
        if (!actionFn) {
          onInternalClose();
          return;
        }
        let returnValueOfOnOk;
        if (emitEvent) {
          returnValueOfOnOk = actionFn(e2);
          if (quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
            clickedRef.current = false;
            onInternalClose(e2);
            return;
          }
        } else if (actionFn.length) {
          returnValueOfOnOk = actionFn(close);
          clickedRef.current = false;
        } else {
          returnValueOfOnOk = actionFn();
          if (!returnValueOfOnOk) {
            onInternalClose();
            return;
          }
        }
        handlePromiseOnOk(returnValueOfOnOk);
      };
      return /* @__PURE__ */ reactExports.createElement(Button$2, Object.assign({}, convertLegacyProps(type2), {
        onClick,
        loading,
        prefixCls
      }, buttonProps, {
        ref: buttonRef
      }), children);
    };
    const ActionButton$1 = ActionButton;
    const getCollapsedHeight = () => ({
      height: 0,
      opacity: 0
    });
    const getRealHeight = (node2) => {
      const {
        scrollHeight
      } = node2;
      return {
        height: scrollHeight,
        opacity: 1
      };
    };
    const getCurrentHeight = (node2) => ({
      height: node2 ? node2.offsetHeight : 0
    });
    const skipOpacityTransition = (_, event) => (event === null || event === void 0 ? void 0 : event.deadline) === true || event.propertyName === "height";
    const initCollapseMotion = function() {
      let rootCls = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant";
      return {
        motionName: `${rootCls}-motion-collapse`,
        onAppearStart: getCollapsedHeight,
        onEnterStart: getCollapsedHeight,
        onAppearActive: getRealHeight,
        onEnterActive: getRealHeight,
        onLeaveStart: getCurrentHeight,
        onLeaveActive: getCollapsedHeight,
        onAppearEnd: skipOpacityTransition,
        onEnterEnd: skipOpacityTransition,
        onLeaveEnd: skipOpacityTransition,
        motionDeadline: 500
      };
    };
    const getTransitionDirection = (placement) => {
      if (placement !== void 0 && (placement === "topLeft" || placement === "topRight")) {
        return `slide-down`;
      }
      return `slide-up`;
    };
    const getTransitionName$1 = (rootPrefixCls, motion2, transitionName) => {
      if (transitionName !== void 0) {
        return transitionName;
      }
      return `${rootPrefixCls}-${motion2}`;
    };
    const initCollapseMotion$1 = initCollapseMotion;
    var OrderContext = /* @__PURE__ */ reactExports.createContext(null);
    var useLayoutEffect$1 = canUseDom$2() ? reactExports.useLayoutEffect : reactExports.useEffect;
    var useLayoutUpdateEffect = function useLayoutUpdateEffect2(callback, deps) {
      var firstMountRef = reactExports.useRef(true);
      useLayoutEffect$1(function() {
        if (!firstMountRef.current) {
          return callback();
        }
      }, deps);
      useLayoutEffect$1(function() {
        firstMountRef.current = false;
        return function() {
          firstMountRef.current = true;
        };
      }, []);
    };
    var EMPTY_LIST$4 = [];
    function useDom(render2, debug) {
      var _React$useState = reactExports.useState(function() {
        if (!canUseDom$2()) {
          return null;
        }
        var defaultEle = document.createElement("div");
        return defaultEle;
      }), _React$useState2 = _slicedToArray(_React$useState, 1), ele = _React$useState2[0];
      var appendedRef = reactExports.useRef(false);
      var queueCreate = reactExports.useContext(OrderContext);
      var _React$useState3 = reactExports.useState(EMPTY_LIST$4), _React$useState4 = _slicedToArray(_React$useState3, 2), queue = _React$useState4[0], setQueue = _React$useState4[1];
      var mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
        setQueue(function(origin) {
          var newQueue = [appendFn].concat(_toConsumableArray(origin));
          return newQueue;
        });
      });
      function append2() {
        if (!ele.parentElement) {
          document.body.appendChild(ele);
        }
        appendedRef.current = true;
      }
      function cleanup2() {
        var _ele$parentElement;
        (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 ? void 0 : _ele$parentElement.removeChild(ele);
        appendedRef.current = false;
      }
      useLayoutEffect$1(function() {
        if (render2) {
          if (queueCreate) {
            queueCreate(append2);
          } else {
            append2();
          }
        } else {
          cleanup2();
        }
        return cleanup2;
      }, [render2]);
      useLayoutEffect$1(function() {
        if (queue.length) {
          queue.forEach(function(appendFn) {
            return appendFn();
          });
          setQueue(EMPTY_LIST$4);
        }
      }, [queue]);
      return [ele, mergedQueueCreate];
    }
    var cached;
    function getScrollBarSize(fresh) {
      if (typeof document === "undefined") {
        return 0;
      }
      if (fresh || cached === void 0) {
        var inner = document.createElement("div");
        inner.style.width = "100%";
        inner.style.height = "200px";
        var outer = document.createElement("div");
        var outerStyle = outer.style;
        outerStyle.position = "absolute";
        outerStyle.top = "0";
        outerStyle.left = "0";
        outerStyle.pointerEvents = "none";
        outerStyle.visibility = "hidden";
        outerStyle.width = "200px";
        outerStyle.height = "150px";
        outerStyle.overflow = "hidden";
        outer.appendChild(inner);
        document.body.appendChild(outer);
        var widthContained = inner.offsetWidth;
        outer.style.overflow = "scroll";
        var widthScroll = inner.offsetWidth;
        if (widthContained === widthScroll) {
          widthScroll = outer.clientWidth;
        }
        document.body.removeChild(outer);
        cached = widthContained - widthScroll;
      }
      return cached;
    }
    function ensureSize(str) {
      var match2 = str.match(/^(.*)px$/);
      var value = Number(match2 === null || match2 === void 0 ? void 0 : match2[1]);
      return Number.isNaN(value) ? getScrollBarSize() : value;
    }
    function getTargetScrollBarSize(target) {
      if (typeof document === "undefined" || !target || !(target instanceof Element)) {
        return {
          width: 0,
          height: 0
        };
      }
      var _getComputedStyle2 = getComputedStyle(target, "::-webkit-scrollbar"), width = _getComputedStyle2.width, height = _getComputedStyle2.height;
      return {
        width: ensureSize(width),
        height: ensureSize(height)
      };
    }
    function isBodyOverflowing() {
      return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
    }
    var UNIQUE_ID = "rc-util-locker-".concat(Date.now());
    var uuid$5 = 0;
    function useScrollLocker(lock) {
      var mergedLock = !!lock;
      var _React$useState = reactExports.useState(function() {
        uuid$5 += 1;
        return "".concat(UNIQUE_ID, "_").concat(uuid$5);
      }), _React$useState2 = _slicedToArray(_React$useState, 1), id2 = _React$useState2[0];
      useLayoutEffect$1(function() {
        if (mergedLock) {
          var scrollbarSize = getScrollBarSize();
          var isOverflow = isBodyOverflowing();
          updateCSS$1("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id2);
        } else {
          removeCSS$1(id2);
        }
        return function() {
          removeCSS$1(id2);
        };
      }, [mergedLock, id2]);
    }
    var inline = false;
    function inlineMock(nextInline) {
      if (typeof nextInline === "boolean") {
        inline = nextInline;
      }
      return inline;
    }
    var getPortalContainer = function getPortalContainer2(getContainer2) {
      if (getContainer2 === false) {
        return false;
      }
      if (!canUseDom$2() || !getContainer2) {
        return null;
      }
      if (typeof getContainer2 === "string") {
        return document.querySelector(getContainer2);
      }
      if (typeof getContainer2 === "function") {
        return getContainer2();
      }
      return getContainer2;
    };
    var Portal$1 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var open2 = props.open, autoLock = props.autoLock, getContainer2 = props.getContainer;
      props.debug;
      var _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy, children = props.children;
      var _React$useState = reactExports.useState(open2), _React$useState2 = _slicedToArray(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1];
      var mergedRender = shouldRender || open2;
      reactExports.useEffect(function() {
        if (autoDestroy || open2) {
          setShouldRender(open2);
        }
      }, [open2, autoDestroy]);
      var _React$useState3 = reactExports.useState(function() {
        return getPortalContainer(getContainer2);
      }), _React$useState4 = _slicedToArray(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
      reactExports.useEffect(function() {
        var customizeContainer = getPortalContainer(getContainer2);
        setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
      });
      var _useDom = useDom(mergedRender && !innerContainer), _useDom2 = _slicedToArray(_useDom, 2), defaultContainer2 = _useDom2[0], queueCreate = _useDom2[1];
      var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer2;
      useScrollLocker(autoLock && open2 && canUseDom$2() && (mergedContainer === defaultContainer2 || mergedContainer === document.body));
      var childRef = null;
      if (children && supportRef(children) && ref) {
        var _ref = children;
        childRef = _ref.ref;
      }
      var mergedRef = useComposeRef(childRef, ref);
      if (!mergedRender || !canUseDom$2() || innerContainer === void 0) {
        return null;
      }
      var renderInline = mergedContainer === false || inlineMock();
      var reffedChildren = children;
      if (ref) {
        reffedChildren = /* @__PURE__ */ reactExports.cloneElement(children, {
          ref: mergedRef
        });
      }
      return /* @__PURE__ */ reactExports.createElement(OrderContext.Provider, {
        value: queueCreate
      }, renderInline ? reffedChildren : /* @__PURE__ */ reactDomExports.createPortal(reffedChildren, mergedContainer));
    });
    var KeyCode = {
      /**
       * MAC_ENTER
       */
      MAC_ENTER: 3,
      /**
       * BACKSPACE
       */
      BACKSPACE: 8,
      /**
       * TAB
       */
      TAB: 9,
      /**
       * NUMLOCK on FF/Safari Mac
       */
      NUM_CENTER: 12,
      // NUMLOCK on FF/Safari Mac
      /**
       * ENTER
       */
      ENTER: 13,
      /**
       * SHIFT
       */
      SHIFT: 16,
      /**
       * CTRL
       */
      CTRL: 17,
      /**
       * ALT
       */
      ALT: 18,
      /**
       * PAUSE
       */
      PAUSE: 19,
      /**
       * CAPS_LOCK
       */
      CAPS_LOCK: 20,
      /**
       * ESC
       */
      ESC: 27,
      /**
       * SPACE
       */
      SPACE: 32,
      /**
       * PAGE_UP
       */
      PAGE_UP: 33,
      // also NUM_NORTH_EAST
      /**
       * PAGE_DOWN
       */
      PAGE_DOWN: 34,
      // also NUM_SOUTH_EAST
      /**
       * END
       */
      END: 35,
      // also NUM_SOUTH_WEST
      /**
       * HOME
       */
      HOME: 36,
      // also NUM_NORTH_WEST
      /**
       * LEFT
       */
      LEFT: 37,
      // also NUM_WEST
      /**
       * UP
       */
      UP: 38,
      // also NUM_NORTH
      /**
       * RIGHT
       */
      RIGHT: 39,
      // also NUM_EAST
      /**
       * DOWN
       */
      DOWN: 40,
      // also NUM_SOUTH
      /**
       * PRINT_SCREEN
       */
      PRINT_SCREEN: 44,
      /**
       * INSERT
       */
      INSERT: 45,
      // also NUM_INSERT
      /**
       * DELETE
       */
      DELETE: 46,
      // also NUM_DELETE
      /**
       * ZERO
       */
      ZERO: 48,
      /**
       * ONE
       */
      ONE: 49,
      /**
       * TWO
       */
      TWO: 50,
      /**
       * THREE
       */
      THREE: 51,
      /**
       * FOUR
       */
      FOUR: 52,
      /**
       * FIVE
       */
      FIVE: 53,
      /**
       * SIX
       */
      SIX: 54,
      /**
       * SEVEN
       */
      SEVEN: 55,
      /**
       * EIGHT
       */
      EIGHT: 56,
      /**
       * NINE
       */
      NINE: 57,
      /**
       * QUESTION_MARK
       */
      QUESTION_MARK: 63,
      // needs localization
      /**
       * A
       */
      A: 65,
      /**
       * B
       */
      B: 66,
      /**
       * C
       */
      C: 67,
      /**
       * D
       */
      D: 68,
      /**
       * E
       */
      E: 69,
      /**
       * F
       */
      F: 70,
      /**
       * G
       */
      G: 71,
      /**
       * H
       */
      H: 72,
      /**
       * I
       */
      I: 73,
      /**
       * J
       */
      J: 74,
      /**
       * K
       */
      K: 75,
      /**
       * L
       */
      L: 76,
      /**
       * M
       */
      M: 77,
      /**
       * N
       */
      N: 78,
      /**
       * O
       */
      O: 79,
      /**
       * P
       */
      P: 80,
      /**
       * Q
       */
      Q: 81,
      /**
       * R
       */
      R: 82,
      /**
       * S
       */
      S: 83,
      /**
       * T
       */
      T: 84,
      /**
       * U
       */
      U: 85,
      /**
       * V
       */
      V: 86,
      /**
       * W
       */
      W: 87,
      /**
       * X
       */
      X: 88,
      /**
       * Y
       */
      Y: 89,
      /**
       * Z
       */
      Z: 90,
      /**
       * META
       */
      META: 91,
      // WIN_KEY_LEFT
      /**
       * WIN_KEY_RIGHT
       */
      WIN_KEY_RIGHT: 92,
      /**
       * CONTEXT_MENU
       */
      CONTEXT_MENU: 93,
      /**
       * NUM_ZERO
       */
      NUM_ZERO: 96,
      /**
       * NUM_ONE
       */
      NUM_ONE: 97,
      /**
       * NUM_TWO
       */
      NUM_TWO: 98,
      /**
       * NUM_THREE
       */
      NUM_THREE: 99,
      /**
       * NUM_FOUR
       */
      NUM_FOUR: 100,
      /**
       * NUM_FIVE
       */
      NUM_FIVE: 101,
      /**
       * NUM_SIX
       */
      NUM_SIX: 102,
      /**
       * NUM_SEVEN
       */
      NUM_SEVEN: 103,
      /**
       * NUM_EIGHT
       */
      NUM_EIGHT: 104,
      /**
       * NUM_NINE
       */
      NUM_NINE: 105,
      /**
       * NUM_MULTIPLY
       */
      NUM_MULTIPLY: 106,
      /**
       * NUM_PLUS
       */
      NUM_PLUS: 107,
      /**
       * NUM_MINUS
       */
      NUM_MINUS: 109,
      /**
       * NUM_PERIOD
       */
      NUM_PERIOD: 110,
      /**
       * NUM_DIVISION
       */
      NUM_DIVISION: 111,
      /**
       * F1
       */
      F1: 112,
      /**
       * F2
       */
      F2: 113,
      /**
       * F3
       */
      F3: 114,
      /**
       * F4
       */
      F4: 115,
      /**
       * F5
       */
      F5: 116,
      /**
       * F6
       */
      F6: 117,
      /**
       * F7
       */
      F7: 118,
      /**
       * F8
       */
      F8: 119,
      /**
       * F9
       */
      F9: 120,
      /**
       * F10
       */
      F10: 121,
      /**
       * F11
       */
      F11: 122,
      /**
       * F12
       */
      F12: 123,
      /**
       * NUMLOCK
       */
      NUMLOCK: 144,
      /**
       * SEMICOLON
       */
      SEMICOLON: 186,
      // needs localization
      /**
       * DASH
       */
      DASH: 189,
      // needs localization
      /**
       * EQUALS
       */
      EQUALS: 187,
      // needs localization
      /**
       * COMMA
       */
      COMMA: 188,
      // needs localization
      /**
       * PERIOD
       */
      PERIOD: 190,
      // needs localization
      /**
       * SLASH
       */
      SLASH: 191,
      // needs localization
      /**
       * APOSTROPHE
       */
      APOSTROPHE: 192,
      // needs localization
      /**
       * SINGLE_QUOTE
       */
      SINGLE_QUOTE: 222,
      // needs localization
      /**
       * OPEN_SQUARE_BRACKET
       */
      OPEN_SQUARE_BRACKET: 219,
      // needs localization
      /**
       * BACKSLASH
       */
      BACKSLASH: 220,
      // needs localization
      /**
       * CLOSE_SQUARE_BRACKET
       */
      CLOSE_SQUARE_BRACKET: 221,
      // needs localization
      /**
       * WIN_KEY
       */
      WIN_KEY: 224,
      /**
       * MAC_FF_META
       */
      MAC_FF_META: 224,
      // Firefox (Gecko) fires this for the meta key instead of 91
      /**
       * WIN_IME
       */
      WIN_IME: 229,
      // ======================== Function ========================
      /**
       * whether text and modified key is entered at the same time.
       */
      isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
        var keyCode = e2.keyCode;
        if (e2.altKey && !e2.ctrlKey || e2.metaKey || // Function keys don't generate text
        keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
          return false;
        }
        switch (keyCode) {
          case KeyCode.ALT:
          case KeyCode.CAPS_LOCK:
          case KeyCode.CONTEXT_MENU:
          case KeyCode.CTRL:
          case KeyCode.DOWN:
          case KeyCode.END:
          case KeyCode.ESC:
          case KeyCode.HOME:
          case KeyCode.INSERT:
          case KeyCode.LEFT:
          case KeyCode.MAC_FF_META:
          case KeyCode.META:
          case KeyCode.NUMLOCK:
          case KeyCode.NUM_CENTER:
          case KeyCode.PAGE_DOWN:
          case KeyCode.PAGE_UP:
          case KeyCode.PAUSE:
          case KeyCode.PRINT_SCREEN:
          case KeyCode.RIGHT:
          case KeyCode.SHIFT:
          case KeyCode.UP:
          case KeyCode.WIN_KEY:
          case KeyCode.WIN_KEY_RIGHT:
            return false;
          default:
            return true;
        }
      },
      /**
       * whether character is entered.
       */
      isCharacterKey: function isCharacterKey(keyCode) {
        if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
          return true;
        }
        if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
          return true;
        }
        if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
          return true;
        }
        if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
          return true;
        }
        switch (keyCode) {
          case KeyCode.SPACE:
          case KeyCode.QUESTION_MARK:
          case KeyCode.NUM_PLUS:
          case KeyCode.NUM_MINUS:
          case KeyCode.NUM_PERIOD:
          case KeyCode.NUM_DIVISION:
          case KeyCode.SEMICOLON:
          case KeyCode.DASH:
          case KeyCode.EQUALS:
          case KeyCode.COMMA:
          case KeyCode.PERIOD:
          case KeyCode.SLASH:
          case KeyCode.APOSTROPHE:
          case KeyCode.SINGLE_QUOTE:
          case KeyCode.OPEN_SQUARE_BRACKET:
          case KeyCode.BACKSLASH:
          case KeyCode.CLOSE_SQUARE_BRACKET:
            return true;
          default:
            return false;
        }
      }
    };
    function getUseId() {
      var fullClone2 = _objectSpread2$3({}, React$4);
      return fullClone2.useId;
    }
    var uuid$4 = 0;
    function useId$2(id2) {
      var _React$useState = reactExports.useState("ssr-id"), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
      var useOriginId = getUseId();
      var reactNativeId = useOriginId === null || useOriginId === void 0 ? void 0 : useOriginId();
      reactExports.useEffect(function() {
        if (!useOriginId) {
          var nextId = uuid$4;
          uuid$4 += 1;
          setInnerId("rc_unique_".concat(nextId));
        }
      }, []);
      if (id2) {
        return id2;
      }
      return reactNativeId || innerId;
    }
    var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
    var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
    var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
    var ariaPrefix = "aria-";
    var dataPrefix = "data-";
    function match(key, prefix) {
      return key.indexOf(prefix) === 0;
    }
    function pickAttrs(props) {
      var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var mergedConfig;
      if (ariaOnly === false) {
        mergedConfig = {
          aria: true,
          data: true,
          attr: true
        };
      } else if (ariaOnly === true) {
        mergedConfig = {
          aria: true
        };
      } else {
        mergedConfig = _objectSpread2$3({}, ariaOnly);
      }
      var attrs = {};
      Object.keys(props).forEach(function(key) {
        if (
          // Aria
          mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || // Data
          mergedConfig.data && match(key, dataPrefix) || // Attr
          mergedConfig.attr && propList.includes(key)
        ) {
          attrs[key] = props[key];
        }
      });
      return attrs;
    }
    function Mask$2(props) {
      var prefixCls = props.prefixCls, style2 = props.style, visible = props.visible, maskProps = props.maskProps, motionName = props.motionName;
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, {
        key: "mask",
        visible,
        motionName,
        leavedClassName: "".concat(prefixCls, "-mask-hidden")
      }, function(_ref, ref) {
        var motionClassName = _ref.className, motionStyle = _ref.style;
        return /* @__PURE__ */ reactExports.createElement("div", _extends$2({
          ref,
          style: _objectSpread2$3(_objectSpread2$3({}, motionStyle), style2),
          className: classNames("".concat(prefixCls, "-mask"), motionClassName)
        }, maskProps));
      });
    }
    function getMotionName(prefixCls, transitionName, animationName) {
      var motionName = transitionName;
      if (!motionName && animationName) {
        motionName = "".concat(prefixCls, "-").concat(animationName);
      }
      return motionName;
    }
    function getScroll$1(w2, top) {
      var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
      var method2 = "scroll".concat(top ? "Top" : "Left");
      if (typeof ret !== "number") {
        var d2 = w2.document;
        ret = d2.documentElement[method2];
        if (typeof ret !== "number") {
          ret = d2.body[method2];
        }
      }
      return ret;
    }
    function offset$1(el2) {
      var rect = el2.getBoundingClientRect();
      var pos = {
        left: rect.left,
        top: rect.top
      };
      var doc = el2.ownerDocument;
      var w2 = doc.defaultView || doc.parentWindow;
      pos.left += getScroll$1(w2);
      pos.top += getScroll$1(w2, true);
      return pos;
    }
    const MemoChildren = /* @__PURE__ */ reactExports.memo(function(_ref) {
      var children = _ref.children;
      return children;
    }, function(_, _ref2) {
      var shouldUpdate = _ref2.shouldUpdate;
      return !shouldUpdate;
    });
    var sentinelStyle$1 = {
      width: 0,
      height: 0,
      overflow: "hidden",
      outline: "none"
    };
    var Panel$1 = /* @__PURE__ */ React$3.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, className = props.className, style2 = props.style, title = props.title, ariaId = props.ariaId, footer2 = props.footer, closable = props.closable, closeIcon = props.closeIcon, onClose = props.onClose, children = props.children, bodyStyle = props.bodyStyle, bodyProps = props.bodyProps, modalRender = props.modalRender, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, holderRef = props.holderRef, visible = props.visible, forceRender = props.forceRender, width = props.width, height = props.height;
      var sentinelStartRef = reactExports.useRef();
      var sentinelEndRef = reactExports.useRef();
      React$3.useImperativeHandle(ref, function() {
        return {
          focus: function focus() {
            var _sentinelStartRef$cur;
            (_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 ? void 0 : _sentinelStartRef$cur.focus();
          },
          changeActive: function changeActive(next2) {
            var _document = document, activeElement = _document.activeElement;
            if (next2 && activeElement === sentinelEndRef.current) {
              sentinelStartRef.current.focus();
            } else if (!next2 && activeElement === sentinelStartRef.current) {
              sentinelEndRef.current.focus();
            }
          }
        };
      });
      var contentStyle = {};
      if (width !== void 0) {
        contentStyle.width = width;
      }
      if (height !== void 0) {
        contentStyle.height = height;
      }
      var footerNode;
      if (footer2) {
        footerNode = /* @__PURE__ */ React$3.createElement("div", {
          className: "".concat(prefixCls, "-footer")
        }, footer2);
      }
      var headerNode;
      if (title) {
        headerNode = /* @__PURE__ */ React$3.createElement("div", {
          className: "".concat(prefixCls, "-header")
        }, /* @__PURE__ */ React$3.createElement("div", {
          className: "".concat(prefixCls, "-title"),
          id: ariaId
        }, title));
      }
      var closer;
      if (closable) {
        closer = /* @__PURE__ */ React$3.createElement("button", {
          type: "button",
          onClick: onClose,
          "aria-label": "Close",
          className: "".concat(prefixCls, "-close")
        }, closeIcon || /* @__PURE__ */ React$3.createElement("span", {
          className: "".concat(prefixCls, "-close-x")
        }));
      }
      var content2 = /* @__PURE__ */ React$3.createElement("div", {
        className: "".concat(prefixCls, "-content")
      }, closer, headerNode, /* @__PURE__ */ React$3.createElement("div", _extends$2({
        className: "".concat(prefixCls, "-body"),
        style: bodyStyle
      }, bodyProps), children), footerNode);
      return /* @__PURE__ */ React$3.createElement("div", {
        key: "dialog-element",
        role: "dialog",
        "aria-labelledby": title ? ariaId : null,
        "aria-modal": "true",
        ref: holderRef,
        style: _objectSpread2$3(_objectSpread2$3({}, style2), contentStyle),
        className: classNames(prefixCls, className),
        onMouseDown,
        onMouseUp
      }, /* @__PURE__ */ React$3.createElement("div", {
        tabIndex: 0,
        ref: sentinelStartRef,
        style: sentinelStyle$1,
        "aria-hidden": "true"
      }), /* @__PURE__ */ React$3.createElement(MemoChildren, {
        shouldUpdate: visible || forceRender
      }, modalRender ? modalRender(content2) : content2), /* @__PURE__ */ React$3.createElement("div", {
        tabIndex: 0,
        ref: sentinelEndRef,
        style: sentinelStyle$1,
        "aria-hidden": "true"
      }));
    });
    var Content$1 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, title = props.title, style2 = props.style, className = props.className, visible = props.visible, forceRender = props.forceRender, destroyOnClose = props.destroyOnClose, motionName = props.motionName, ariaId = props.ariaId, onVisibleChanged = props.onVisibleChanged, mousePosition2 = props.mousePosition;
      var dialogRef = reactExports.useRef();
      var _React$useState = reactExports.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), transformOrigin = _React$useState2[0], setTransformOrigin = _React$useState2[1];
      var contentStyle = {};
      if (transformOrigin) {
        contentStyle.transformOrigin = transformOrigin;
      }
      function onPrepare() {
        var elementOffset = offset$1(dialogRef.current);
        setTransformOrigin(mousePosition2 ? "".concat(mousePosition2.x - elementOffset.left, "px ").concat(mousePosition2.y - elementOffset.top, "px") : "");
      }
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, {
        visible,
        onVisibleChanged,
        onAppearPrepare: onPrepare,
        onEnterPrepare: onPrepare,
        forceRender,
        motionName,
        removeOnLeave: destroyOnClose,
        ref: dialogRef
      }, function(_ref, motionRef) {
        var motionClassName = _ref.className, motionStyle = _ref.style;
        return /* @__PURE__ */ reactExports.createElement(Panel$1, _extends$2({}, props, {
          ref,
          title,
          ariaId,
          prefixCls,
          holderRef: motionRef,
          style: _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, motionStyle), style2), contentStyle),
          className: classNames(className, motionClassName)
        }));
      });
    });
    Content$1.displayName = "Content";
    function Dialog(props) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dialog" : _props$prefixCls, zIndex = props.zIndex, _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$focusTriggerAf = props.focusTriggerAfterClose, focusTriggerAfterClose = _props$focusTriggerAf === void 0 ? true : _props$focusTriggerAf, wrapStyle = props.wrapStyle, wrapClassName = props.wrapClassName, wrapProps = props.wrapProps, onClose = props.onClose, afterClose = props.afterClose, transitionName = props.transitionName, animation = props.animation, _props$closable = props.closable, closable = _props$closable === void 0 ? true : _props$closable, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, maskStyle = props.maskStyle, maskProps = props.maskProps, rootClassName = props.rootClassName;
      var lastOutSideActiveElementRef = reactExports.useRef();
      var wrapperRef = reactExports.useRef();
      var contentRef = reactExports.useRef();
      var _React$useState = reactExports.useState(visible), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
      var ariaId = useId$2();
      function saveLastOutSideActiveElementRef() {
        if (!contains$2(wrapperRef.current, document.activeElement)) {
          lastOutSideActiveElementRef.current = document.activeElement;
        }
      }
      function focusDialogContent() {
        if (!contains$2(wrapperRef.current, document.activeElement)) {
          var _contentRef$current;
          (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 ? void 0 : _contentRef$current.focus();
        }
      }
      function onDialogVisibleChanged(newVisible) {
        if (newVisible) {
          focusDialogContent();
        } else {
          setAnimatedVisible(false);
          if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
            try {
              lastOutSideActiveElementRef.current.focus({
                preventScroll: true
              });
            } catch (e2) {
            }
            lastOutSideActiveElementRef.current = null;
          }
          if (animatedVisible) {
            afterClose === null || afterClose === void 0 ? void 0 : afterClose();
          }
        }
      }
      function onInternalClose(e2) {
        onClose === null || onClose === void 0 ? void 0 : onClose(e2);
      }
      var contentClickRef = reactExports.useRef(false);
      var contentTimeoutRef = reactExports.useRef();
      var onContentMouseDown = function onContentMouseDown2() {
        clearTimeout(contentTimeoutRef.current);
        contentClickRef.current = true;
      };
      var onContentMouseUp = function onContentMouseUp2() {
        contentTimeoutRef.current = setTimeout(function() {
          contentClickRef.current = false;
        });
      };
      var onWrapperClick = null;
      if (maskClosable) {
        onWrapperClick = function onWrapperClick2(e2) {
          if (contentClickRef.current) {
            contentClickRef.current = false;
          } else if (wrapperRef.current === e2.target) {
            onInternalClose(e2);
          }
        };
      }
      function onWrapperKeyDown(e2) {
        if (keyboard && e2.keyCode === KeyCode.ESC) {
          e2.stopPropagation();
          onInternalClose(e2);
          return;
        }
        if (visible) {
          if (e2.keyCode === KeyCode.TAB) {
            contentRef.current.changeActive(!e2.shiftKey);
          }
        }
      }
      reactExports.useEffect(function() {
        if (visible) {
          setAnimatedVisible(true);
          saveLastOutSideActiveElementRef();
        }
      }, [visible]);
      reactExports.useEffect(function() {
        return function() {
          clearTimeout(contentTimeoutRef.current);
        };
      }, []);
      return /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        className: classNames("".concat(prefixCls, "-root"), rootClassName)
      }, pickAttrs(props, {
        data: true
      })), /* @__PURE__ */ reactExports.createElement(Mask$2, {
        prefixCls,
        visible: mask && visible,
        motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
        style: _objectSpread2$3({
          zIndex
        }, maskStyle),
        maskProps
      }), /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        tabIndex: -1,
        onKeyDown: onWrapperKeyDown,
        className: classNames("".concat(prefixCls, "-wrap"), wrapClassName),
        ref: wrapperRef,
        onClick: onWrapperClick,
        style: _objectSpread2$3(_objectSpread2$3({
          zIndex
        }, wrapStyle), {}, {
          display: !animatedVisible ? "none" : null
        })
      }, wrapProps), /* @__PURE__ */ reactExports.createElement(Content$1, _extends$2({}, props, {
        onMouseDown: onContentMouseDown,
        onMouseUp: onContentMouseUp,
        ref: contentRef,
        closable,
        ariaId,
        prefixCls,
        visible: visible && animatedVisible,
        onClose: onInternalClose,
        onVisibleChanged: onDialogVisibleChanged,
        motionName: getMotionName(prefixCls, transitionName, animation)
      }))));
    }
    var DialogWrap = function DialogWrap2(props) {
      var visible = props.visible, getContainer2 = props.getContainer, forceRender = props.forceRender, _props$destroyOnClose = props.destroyOnClose, destroyOnClose = _props$destroyOnClose === void 0 ? false : _props$destroyOnClose, _afterClose = props.afterClose;
      var _React$useState = reactExports.useState(visible), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
      reactExports.useEffect(function() {
        if (visible) {
          setAnimatedVisible(true);
        }
      }, [visible]);
      if (!forceRender && destroyOnClose && !animatedVisible) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(Portal$1, {
        open: visible || forceRender || animatedVisible,
        autoDestroy: false,
        getContainer: getContainer2,
        autoLock: visible || animatedVisible
      }, /* @__PURE__ */ reactExports.createElement(Dialog, _extends$2({}, props, {
        destroyOnClose,
        afterClose: function afterClose() {
          _afterClose === null || _afterClose === void 0 ? void 0 : _afterClose();
          setAnimatedVisible(false);
        }
      })));
    };
    DialogWrap.displayName = "Dialog";
    const FormContext = /* @__PURE__ */ reactExports.createContext({
      labelAlign: "right",
      vertical: false,
      itemRef: () => {
      }
    });
    const NoStyleItemContext = /* @__PURE__ */ reactExports.createContext(null);
    const FormProvider = (props) => {
      const providerProps = omit(props, ["prefixCls"]);
      return /* @__PURE__ */ reactExports.createElement(FormProvider$1, Object.assign({}, providerProps));
    };
    const FormItemPrefixContext = /* @__PURE__ */ reactExports.createContext({
      prefixCls: ""
    });
    const FormItemInputContext = /* @__PURE__ */ reactExports.createContext({});
    const NoFormStyle = (_ref) => {
      let {
        children,
        status,
        override
      } = _ref;
      const formItemInputContext = reactExports.useContext(FormItemInputContext);
      const newFormItemInputContext = reactExports.useMemo(() => {
        const newContext = Object.assign({}, formItemInputContext);
        if (override) {
          delete newContext.isFormItemInput;
        }
        if (status) {
          delete newContext.status;
          delete newContext.hasFeedback;
          delete newContext.feedbackIcon;
        }
        return newContext;
      }, [status, override, formItemInputContext]);
      return /* @__PURE__ */ reactExports.createElement(FormItemInputContext.Provider, {
        value: newFormItemInputContext
      }, children);
    };
    var isStyleNameSupport = function isStyleNameSupport2(styleName) {
      if (canUseDom$2() && window.document.documentElement) {
        var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
        var documentElement = window.document.documentElement;
        return styleNameList.some(function(name) {
          return name in documentElement.style;
        });
      }
      return false;
    };
    var isStyleValueSupport = function isStyleValueSupport2(styleName, value) {
      if (!isStyleNameSupport(styleName)) {
        return false;
      }
      var ele = document.createElement("div");
      var origin = ele.style[styleName];
      ele.style[styleName] = value;
      return ele.style[styleName] !== origin;
    };
    function isStyleSupport(styleName, styleValue) {
      if (!Array.isArray(styleName) && styleValue !== void 0) {
        return isStyleValueSupport(styleName, styleValue);
      }
      return isStyleNameSupport(styleName);
    }
    const canUseDocElement = () => canUseDom$2() && window.document.documentElement;
    let flexGapSupported;
    const detectFlexGapSupported = () => {
      if (!canUseDocElement()) {
        return false;
      }
      if (flexGapSupported !== void 0) {
        return flexGapSupported;
      }
      const flex = document.createElement("div");
      flex.style.display = "flex";
      flex.style.flexDirection = "column";
      flex.style.rowGap = "1px";
      flex.appendChild(document.createElement("div"));
      flex.appendChild(document.createElement("div"));
      document.body.appendChild(flex);
      flexGapSupported = flex.scrollHeight === 1;
      document.body.removeChild(flex);
      return flexGapSupported;
    };
    const initMotionCommon = (duration) => ({
      animationDuration: duration,
      animationFillMode: "both"
    });
    const initMotionCommonLeave = (duration) => ({
      animationDuration: duration,
      animationFillMode: "both"
    });
    const initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
      let sameLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      const sameLevelPrefix = sameLevel ? "&" : "";
      return {
        [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: Object.assign(Object.assign({}, initMotionCommon(duration)), {
          animationPlayState: "paused"
        }),
        [`${sameLevelPrefix}${motionCls}-leave`]: Object.assign(Object.assign({}, initMotionCommonLeave(duration)), {
          animationPlayState: "paused"
        }),
        [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
          animationName: inKeyframes,
          animationPlayState: "running"
        },
        [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
          animationName: outKeyframes,
          animationPlayState: "running",
          pointerEvents: "none"
        }
      };
    };
    const fadeIn = new Keyframe("antFadeIn", {
      "0%": {
        opacity: 0
      },
      "100%": {
        opacity: 1
      }
    });
    const fadeOut = new Keyframe("antFadeOut", {
      "0%": {
        opacity: 1
      },
      "100%": {
        opacity: 0
      }
    });
    const initFadeMotion = function(token2) {
      let sameLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const {
        antCls
      } = token2;
      const motionCls = `${antCls}-fade`;
      const sameLevelPrefix = sameLevel ? "&" : "";
      return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
        [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
          opacity: 0,
          animationTimingFunction: "linear"
        },
        [`${sameLevelPrefix}${motionCls}-leave`]: {
          animationTimingFunction: "linear"
        }
      }];
    };
    const moveDownIn = new Keyframe("antMoveDownIn", {
      "0%": {
        transform: "translate3d(0, 100%, 0)",
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveDownOut = new Keyframe("antMoveDownOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: "translate3d(0, 100%, 0)",
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    const moveLeftIn = new Keyframe("antMoveLeftIn", {
      "0%": {
        transform: "translate3d(-100%, 0, 0)",
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveLeftOut = new Keyframe("antMoveLeftOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: "translate3d(-100%, 0, 0)",
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    const moveRightIn = new Keyframe("antMoveRightIn", {
      "0%": {
        transform: "translate3d(100%, 0, 0)",
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveRightOut = new Keyframe("antMoveRightOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: "translate3d(100%, 0, 0)",
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    const moveUpIn = new Keyframe("antMoveUpIn", {
      "0%": {
        transform: "translate3d(0, -100%, 0)",
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveUpOut = new Keyframe("antMoveUpOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: "translate3d(0, -100%, 0)",
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    const moveMotion = {
      "move-up": {
        inKeyframes: moveUpIn,
        outKeyframes: moveUpOut
      },
      "move-down": {
        inKeyframes: moveDownIn,
        outKeyframes: moveDownOut
      },
      "move-left": {
        inKeyframes: moveLeftIn,
        outKeyframes: moveLeftOut
      },
      "move-right": {
        inKeyframes: moveRightIn,
        outKeyframes: moveRightOut
      }
    };
    const initMoveMotion = (token2, motionName) => {
      const {
        antCls
      } = token2;
      const motionCls = `${antCls}-${motionName}`;
      const {
        inKeyframes,
        outKeyframes
      } = moveMotion[motionName];
      return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
        [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
          opacity: 0,
          animationTimingFunction: token2.motionEaseOutCirc
        },
        [`${motionCls}-leave`]: {
          animationTimingFunction: token2.motionEaseInOutCirc
        }
      }];
    };
    const slideUpIn = new Keyframe("antSlideUpIn", {
      "0%": {
        transform: "scaleY(0.8)",
        transformOrigin: "0% 0%",
        opacity: 0
      },
      "100%": {
        transform: "scaleY(1)",
        transformOrigin: "0% 0%",
        opacity: 1
      }
    });
    const slideUpOut = new Keyframe("antSlideUpOut", {
      "0%": {
        transform: "scaleY(1)",
        transformOrigin: "0% 0%",
        opacity: 1
      },
      "100%": {
        transform: "scaleY(0.8)",
        transformOrigin: "0% 0%",
        opacity: 0
      }
    });
    const slideDownIn = new Keyframe("antSlideDownIn", {
      "0%": {
        transform: "scaleY(0.8)",
        transformOrigin: "100% 100%",
        opacity: 0
      },
      "100%": {
        transform: "scaleY(1)",
        transformOrigin: "100% 100%",
        opacity: 1
      }
    });
    const slideDownOut = new Keyframe("antSlideDownOut", {
      "0%": {
        transform: "scaleY(1)",
        transformOrigin: "100% 100%",
        opacity: 1
      },
      "100%": {
        transform: "scaleY(0.8)",
        transformOrigin: "100% 100%",
        opacity: 0
      }
    });
    const slideLeftIn = new Keyframe("antSlideLeftIn", {
      "0%": {
        transform: "scaleX(0.8)",
        transformOrigin: "0% 0%",
        opacity: 0
      },
      "100%": {
        transform: "scaleX(1)",
        transformOrigin: "0% 0%",
        opacity: 1
      }
    });
    const slideLeftOut = new Keyframe("antSlideLeftOut", {
      "0%": {
        transform: "scaleX(1)",
        transformOrigin: "0% 0%",
        opacity: 1
      },
      "100%": {
        transform: "scaleX(0.8)",
        transformOrigin: "0% 0%",
        opacity: 0
      }
    });
    const slideRightIn = new Keyframe("antSlideRightIn", {
      "0%": {
        transform: "scaleX(0.8)",
        transformOrigin: "100% 0%",
        opacity: 0
      },
      "100%": {
        transform: "scaleX(1)",
        transformOrigin: "100% 0%",
        opacity: 1
      }
    });
    const slideRightOut = new Keyframe("antSlideRightOut", {
      "0%": {
        transform: "scaleX(1)",
        transformOrigin: "100% 0%",
        opacity: 1
      },
      "100%": {
        transform: "scaleX(0.8)",
        transformOrigin: "100% 0%",
        opacity: 0
      }
    });
    const slideMotion = {
      "slide-up": {
        inKeyframes: slideUpIn,
        outKeyframes: slideUpOut
      },
      "slide-down": {
        inKeyframes: slideDownIn,
        outKeyframes: slideDownOut
      },
      "slide-left": {
        inKeyframes: slideLeftIn,
        outKeyframes: slideLeftOut
      },
      "slide-right": {
        inKeyframes: slideRightIn,
        outKeyframes: slideRightOut
      }
    };
    const initSlideMotion = (token2, motionName) => {
      const {
        antCls
      } = token2;
      const motionCls = `${antCls}-${motionName}`;
      const {
        inKeyframes,
        outKeyframes
      } = slideMotion[motionName];
      return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
        [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
          transform: "scale(0)",
          transformOrigin: "0% 0%",
          opacity: 0,
          animationTimingFunction: token2.motionEaseOutQuint,
          [`&-prepare`]: {
            transform: "scale(1)"
          }
        },
        [`${motionCls}-leave`]: {
          animationTimingFunction: token2.motionEaseInQuint
        }
      }];
    };
    const zoomIn = new Keyframe("antZoomIn", {
      "0%": {
        transform: "scale(0.2)",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        opacity: 1
      }
    });
    const zoomOut = new Keyframe("antZoomOut", {
      "0%": {
        transform: "scale(1)"
      },
      "100%": {
        transform: "scale(0.2)",
        opacity: 0
      }
    });
    const zoomBigIn = new Keyframe("antZoomBigIn", {
      "0%": {
        transform: "scale(0.8)",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        opacity: 1
      }
    });
    const zoomBigOut = new Keyframe("antZoomBigOut", {
      "0%": {
        transform: "scale(1)"
      },
      "100%": {
        transform: "scale(0.8)",
        opacity: 0
      }
    });
    const zoomUpIn = new Keyframe("antZoomUpIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 0%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "50% 0%"
      }
    });
    const zoomUpOut = new Keyframe("antZoomUpOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "50% 0%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 0%",
        opacity: 0
      }
    });
    const zoomLeftIn = new Keyframe("antZoomLeftIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "0% 50%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "0% 50%"
      }
    });
    const zoomLeftOut = new Keyframe("antZoomLeftOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "0% 50%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "0% 50%",
        opacity: 0
      }
    });
    const zoomRightIn = new Keyframe("antZoomRightIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "100% 50%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "100% 50%"
      }
    });
    const zoomRightOut = new Keyframe("antZoomRightOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "100% 50%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "100% 50%",
        opacity: 0
      }
    });
    const zoomDownIn = new Keyframe("antZoomDownIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 100%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "50% 100%"
      }
    });
    const zoomDownOut = new Keyframe("antZoomDownOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "50% 100%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 100%",
        opacity: 0
      }
    });
    const zoomMotion = {
      zoom: {
        inKeyframes: zoomIn,
        outKeyframes: zoomOut
      },
      "zoom-big": {
        inKeyframes: zoomBigIn,
        outKeyframes: zoomBigOut
      },
      "zoom-big-fast": {
        inKeyframes: zoomBigIn,
        outKeyframes: zoomBigOut
      },
      "zoom-left": {
        inKeyframes: zoomLeftIn,
        outKeyframes: zoomLeftOut
      },
      "zoom-right": {
        inKeyframes: zoomRightIn,
        outKeyframes: zoomRightOut
      },
      "zoom-up": {
        inKeyframes: zoomUpIn,
        outKeyframes: zoomUpOut
      },
      "zoom-down": {
        inKeyframes: zoomDownIn,
        outKeyframes: zoomDownOut
      }
    };
    const initZoomMotion = (token2, motionName) => {
      const {
        antCls
      } = token2;
      const motionCls = `${antCls}-${motionName}`;
      const {
        inKeyframes,
        outKeyframes
      } = zoomMotion[motionName];
      return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
        [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
          transform: "scale(0)",
          opacity: 0,
          animationTimingFunction: token2.motionEaseOutCirc,
          "&-prepare": {
            transform: "none"
          }
        },
        [`${motionCls}-leave`]: {
          animationTimingFunction: token2.motionEaseInOutCirc
        }
      }];
    };
    const genCollapseMotion = (token2) => ({
      [token2.componentCls]: {
        // For common/openAnimation
        [`${token2.antCls}-motion-collapse-legacy`]: {
          overflow: "hidden",
          "&-active": {
            transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
          }
        },
        [`${token2.antCls}-motion-collapse`]: {
          overflow: "hidden",
          transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
        }
      }
    });
    const genCollapseMotion$1 = genCollapseMotion;
    function box(position2) {
      return {
        position: position2,
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0
      };
    }
    const genModalMaskStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return [{
        [`${componentCls}-root`]: {
          [`${componentCls}${token2.antCls}-zoom-enter, ${componentCls}${token2.antCls}-zoom-appear`]: {
            // reset scale avoid mousePosition bug
            transform: "none",
            opacity: 0,
            animationDuration: token2.motionDurationSlow,
            // https://github.com/ant-design/ant-design/issues/11777
            userSelect: "none"
          },
          [`${componentCls}-mask`]: Object.assign(Object.assign({}, box("fixed")), {
            zIndex: token2.zIndexPopupBase,
            height: "100%",
            backgroundColor: token2.colorBgMask,
            [`${componentCls}-hidden`]: {
              display: "none"
            }
          }),
          [`${componentCls}-wrap`]: Object.assign(Object.assign({}, box("fixed")), {
            overflow: "auto",
            outline: 0,
            WebkitOverflowScrolling: "touch"
          })
        }
      }, {
        [`${componentCls}-root`]: initFadeMotion(token2)
      }];
    };
    const genModalStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return [
        // ======================== Root =========================
        {
          [`${componentCls}-root`]: {
            [`${componentCls}-wrap`]: {
              zIndex: token2.zIndexPopupBase,
              position: "fixed",
              inset: 0,
              overflow: "auto",
              outline: 0,
              WebkitOverflowScrolling: "touch"
            },
            [`${componentCls}-wrap-rtl`]: {
              direction: "rtl"
            },
            [`${componentCls}-centered`]: {
              textAlign: "center",
              "&::before": {
                display: "inline-block",
                width: 0,
                height: "100%",
                verticalAlign: "middle",
                content: '""'
              },
              [componentCls]: {
                top: 0,
                display: "inline-block",
                paddingBottom: 0,
                textAlign: "start",
                verticalAlign: "middle"
              }
            },
            [`@media (max-width: ${token2.screenSMMax})`]: {
              [componentCls]: {
                maxWidth: "calc(100vw - 16px)",
                margin: `${token2.marginXS} auto`
              },
              [`${componentCls}-centered`]: {
                [componentCls]: {
                  flex: 1
                }
              }
            }
          }
        },
        // ======================== Modal ========================
        {
          [componentCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
            pointerEvents: "none",
            position: "relative",
            top: 100,
            width: "auto",
            maxWidth: `calc(100vw - ${token2.margin * 2}px)`,
            margin: "0 auto",
            paddingBottom: token2.paddingLG,
            [`${componentCls}-title`]: {
              margin: 0,
              color: token2.modalHeadingColor,
              fontWeight: token2.fontWeightStrong,
              fontSize: token2.modalHeaderTitleFontSize,
              lineHeight: token2.modalHeaderTitleLineHeight,
              wordWrap: "break-word"
            },
            [`${componentCls}-content`]: {
              position: "relative",
              backgroundColor: token2.modalContentBg,
              backgroundClip: "padding-box",
              border: 0,
              borderRadius: token2.borderRadiusLG,
              boxShadow: token2.boxShadow,
              pointerEvents: "auto",
              padding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`
            },
            [`${componentCls}-close`]: Object.assign({
              position: "absolute",
              top: (token2.modalHeaderCloseSize - token2.modalCloseBtnSize) / 2,
              insetInlineEnd: (token2.modalHeaderCloseSize - token2.modalCloseBtnSize) / 2,
              zIndex: token2.zIndexPopupBase + 10,
              padding: 0,
              color: token2.modalCloseColor,
              fontWeight: token2.fontWeightStrong,
              lineHeight: 1,
              textDecoration: "none",
              background: "transparent",
              borderRadius: token2.borderRadiusSM,
              width: token2.modalConfirmIconSize,
              height: token2.modalConfirmIconSize,
              border: 0,
              outline: 0,
              cursor: "pointer",
              transition: `color ${token2.motionDurationMid}, background-color ${token2.motionDurationMid}`,
              "&-x": {
                display: "block",
                fontSize: token2.fontSizeLG,
                fontStyle: "normal",
                lineHeight: `${token2.modalCloseBtnSize}px`,
                textAlign: "center",
                textTransform: "none",
                textRendering: "auto"
              },
              "&:hover": {
                color: token2.modalIconHoverColor,
                backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContent,
                textDecoration: "none"
              },
              "&:active": {
                backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContentHover
              }
            }, genFocusStyle(token2)),
            [`${componentCls}-header`]: {
              color: token2.colorText,
              background: token2.modalHeaderBg,
              borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`,
              marginBottom: token2.marginXS
            },
            [`${componentCls}-body`]: {
              fontSize: token2.fontSize,
              lineHeight: token2.lineHeight,
              wordWrap: "break-word"
            },
            [`${componentCls}-footer`]: {
              textAlign: "end",
              background: token2.modalFooterBg,
              marginTop: token2.marginSM,
              [`${token2.antCls}-btn + ${token2.antCls}-btn:not(${token2.antCls}-dropdown-trigger)`]: {
                marginBottom: 0,
                marginInlineStart: token2.marginXS
              }
            },
            [`${componentCls}-open`]: {
              overflow: "hidden"
            }
          })
        },
        // ======================== Pure =========================
        {
          [`${componentCls}-pure-panel`]: {
            top: "auto",
            padding: 0,
            display: "flex",
            flexDirection: "column",
            [`${componentCls}-content,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
              display: "flex",
              flexDirection: "column",
              flex: "auto"
            },
            [`${componentCls}-confirm-body`]: {
              marginBottom: "auto"
            }
          }
        }
      ];
    };
    const genModalConfirmStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const confirmComponentCls = `${componentCls}-confirm`;
      return {
        [confirmComponentCls]: {
          "&-rtl": {
            direction: "rtl"
          },
          [`${token2.antCls}-modal-header`]: {
            display: "none"
          },
          [`${confirmComponentCls}-body-wrapper`]: Object.assign({}, clearFix()),
          [`${confirmComponentCls}-body`]: {
            display: "flex",
            flexWrap: "wrap",
            alignItems: "center",
            [`${confirmComponentCls}-title`]: {
              flex: "0 0 100%",
              display: "block",
              // create BFC to avoid
              // https://user-images.githubusercontent.com/507615/37702510-ba844e06-2d2d-11e8-9b67-8e19be57f445.png
              overflow: "hidden",
              color: token2.colorTextHeading,
              fontWeight: token2.fontWeightStrong,
              fontSize: token2.modalHeaderTitleFontSize,
              lineHeight: token2.modalHeaderTitleLineHeight,
              [`+ ${confirmComponentCls}-content`]: {
                marginBlockStart: token2.marginXS,
                flexBasis: "100%",
                maxWidth: `calc(100% - ${token2.modalConfirmIconSize + token2.marginSM}px)`
              }
            },
            [`${confirmComponentCls}-content`]: {
              color: token2.colorText,
              fontSize: token2.fontSize
            },
            [`> ${token2.iconCls}`]: {
              flex: "none",
              marginInlineEnd: token2.marginSM,
              fontSize: token2.modalConfirmIconSize,
              [`+ ${confirmComponentCls}-title`]: {
                flex: 1
              },
              // `content` after `icon` should set marginLeft
              [`+ ${confirmComponentCls}-title + ${confirmComponentCls}-content`]: {
                marginInlineStart: token2.modalConfirmIconSize + token2.marginSM
              }
            }
          },
          [`${confirmComponentCls}-btns`]: {
            textAlign: "end",
            marginTop: token2.marginSM,
            [`${token2.antCls}-btn + ${token2.antCls}-btn`]: {
              marginBottom: 0,
              marginInlineStart: token2.marginXS
            }
          }
        },
        [`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token2.iconCls}`]: {
          color: token2.colorError
        },
        [`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token2.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token2.iconCls}`]: {
          color: token2.colorWarning
        },
        [`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token2.iconCls}`]: {
          color: token2.colorInfo
        },
        [`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token2.iconCls}`]: {
          color: token2.colorSuccess
        },
        // https://github.com/ant-design/ant-design/issues/37329
        [`${componentCls}-zoom-leave ${componentCls}-btns`]: {
          pointerEvents: "none"
        }
      };
    };
    const genRTLStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-root`]: {
          [`${componentCls}-wrap-rtl`]: {
            direction: "rtl",
            [`${componentCls}-confirm-body`]: {
              direction: "rtl"
            }
          }
        }
      };
    };
    const genWireframeStyle$1 = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      const confirmComponentCls = `${componentCls}-confirm`;
      return {
        [componentCls]: {
          [`${componentCls}-content`]: {
            padding: 0
          },
          [`${componentCls}-header`]: {
            padding: token2.modalHeaderPadding,
            borderBottom: `${token2.modalHeaderBorderWidth}px ${token2.modalHeaderBorderStyle} ${token2.modalHeaderBorderColorSplit}`,
            marginBottom: 0
          },
          [`${componentCls}-body`]: {
            padding: token2.modalBodyPadding
          },
          [`${componentCls}-footer`]: {
            padding: `${token2.modalFooterPaddingVertical}px ${token2.modalFooterPaddingHorizontal}px`,
            borderTop: `${token2.modalFooterBorderWidth}px ${token2.modalFooterBorderStyle} ${token2.modalFooterBorderColorSplit}`,
            borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`,
            marginTop: 0
          }
        },
        [confirmComponentCls]: {
          [`${antCls}-modal-body`]: {
            padding: `${token2.padding * 2}px ${token2.padding * 2}px ${token2.paddingLG}px`
          },
          [`${confirmComponentCls}-body`]: {
            [`> ${token2.iconCls}`]: {
              marginInlineEnd: token2.margin,
              // `content` after `icon` should set marginLeft
              [`+ ${confirmComponentCls}-title + ${confirmComponentCls}-content`]: {
                marginInlineStart: token2.modalConfirmIconSize + token2.margin
              }
            }
          },
          [`${confirmComponentCls}-btns`]: {
            marginTop: token2.marginLG
          }
        }
      };
    };
    const useStyle$w = genComponentStyleHook("Modal", (token2) => {
      const headerPaddingVertical = token2.padding;
      const headerFontSize = token2.fontSizeHeading5;
      const headerLineHeight = token2.lineHeightHeading5;
      const modalToken = merge$4(token2, {
        modalBodyPadding: token2.paddingLG,
        modalHeaderBg: token2.colorBgElevated,
        modalHeaderPadding: `${headerPaddingVertical}px ${token2.paddingLG}px`,
        modalHeaderBorderWidth: token2.lineWidth,
        modalHeaderBorderStyle: token2.lineType,
        modalHeaderTitleLineHeight: headerLineHeight,
        modalHeaderTitleFontSize: headerFontSize,
        modalHeaderBorderColorSplit: token2.colorSplit,
        modalHeaderCloseSize: headerLineHeight * headerFontSize + headerPaddingVertical * 2,
        modalContentBg: token2.colorBgElevated,
        modalHeadingColor: token2.colorTextHeading,
        modalCloseColor: token2.colorTextDescription,
        modalFooterBg: "transparent",
        modalFooterBorderColorSplit: token2.colorSplit,
        modalFooterBorderStyle: token2.lineType,
        modalFooterPaddingVertical: token2.paddingXS,
        modalFooterPaddingHorizontal: token2.padding,
        modalFooterBorderWidth: token2.lineWidth,
        modalConfirmTitleFontSize: token2.fontSizeLG,
        modalIconHoverColor: token2.colorIconHover,
        modalConfirmIconSize: token2.fontSize * token2.lineHeight,
        modalCloseBtnSize: token2.controlHeightLG * 0.55
      });
      return [genModalStyle(modalToken), genModalConfirmStyle(modalToken), genRTLStyle(modalToken), genModalMaskStyle(modalToken), token2.wireframe && genWireframeStyle$1(modalToken), initZoomMotion(modalToken, "zoom")];
    });
    var __rest$10 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function renderCloseIcon(prefixCls, closeIcon) {
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-close-x`
      }, closeIcon || /* @__PURE__ */ reactExports.createElement(CloseOutlined$1, {
        className: `${prefixCls}-close-icon`
      }));
    }
    const Footer$3 = (props) => {
      const {
        okText,
        okType = "primary",
        cancelText,
        confirmLoading,
        onOk,
        onCancel,
        okButtonProps,
        cancelButtonProps,
        footer: footer2
      } = props;
      const [locale2] = useLocale$1("Modal", getConfirmLocale());
      return footer2 === void 0 ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Button$2, Object.assign({
        onClick: onCancel
      }, cancelButtonProps), cancelText || (locale2 === null || locale2 === void 0 ? void 0 : locale2.cancelText)), /* @__PURE__ */ reactExports.createElement(Button$2, Object.assign({}, convertLegacyProps(okType), {
        loading: confirmLoading,
        onClick: onOk
      }, okButtonProps), okText || (locale2 === null || locale2 === void 0 ? void 0 : locale2.okText))) : footer2;
    };
    const PurePanel$9 = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        closeIcon,
        closable,
        type: type2,
        title,
        children
      } = props, restProps = __rest$10(props, ["prefixCls", "className", "closeIcon", "closable", "type", "title", "children"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const rootPrefixCls = getPrefixCls();
      const prefixCls = customizePrefixCls || getPrefixCls("modal");
      const [, hashId] = useStyle$w(prefixCls);
      const confirmPrefixCls = `${prefixCls}-confirm`;
      let additionalProps = {};
      if (type2) {
        additionalProps = {
          closable: closable !== null && closable !== void 0 ? closable : false,
          title: "",
          footer: "",
          children: /* @__PURE__ */ reactExports.createElement(ConfirmContent, Object.assign({}, props, {
            confirmPrefixCls,
            rootPrefixCls,
            content: children
          }))
        };
      } else {
        additionalProps = {
          closable: closable !== null && closable !== void 0 ? closable : true,
          title,
          footer: props.footer === null ? props.footer : /* @__PURE__ */ reactExports.createElement(Footer$3, Object.assign({}, props)),
          children
        };
      }
      return /* @__PURE__ */ reactExports.createElement(Panel$1, Object.assign({
        prefixCls,
        className: classNames(hashId, `${prefixCls}-pure-panel`, type2 && confirmPrefixCls, type2 && `${confirmPrefixCls}-${type2}`, className)
      }, restProps, {
        closeIcon: renderCloseIcon(prefixCls, closeIcon),
        closable
      }, additionalProps));
    };
    const PurePanel$a = PurePanel$9;
    var __rest$$ = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    let mousePosition;
    const getClickPosition = (e2) => {
      mousePosition = {
        x: e2.pageX,
        y: e2.pageY
      };
      setTimeout(() => {
        mousePosition = null;
      }, 100);
    };
    if (canUseDocElement()) {
      document.documentElement.addEventListener("click", getClickPosition, true);
    }
    const Modal$2 = (props) => {
      var _a;
      const {
        getPopupContainer: getContextPopupContainer,
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const handleCancel = (e2) => {
        const {
          onCancel
        } = props;
        onCancel === null || onCancel === void 0 ? void 0 : onCancel(e2);
      };
      const handleOk = (e2) => {
        const {
          onOk
        } = props;
        onOk === null || onOk === void 0 ? void 0 : onOk(e2);
      };
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        open: open2,
        wrapClassName,
        centered,
        getContainer: getContainer2,
        closeIcon,
        focusTriggerAfterClose = true,
        // Deprecated
        visible,
        width = 520
      } = props, restProps = __rest$$(props, ["prefixCls", "className", "rootClassName", "open", "wrapClassName", "centered", "getContainer", "closeIcon", "focusTriggerAfterClose", "visible", "width"]);
      const prefixCls = getPrefixCls("modal", customizePrefixCls);
      const rootPrefixCls = getPrefixCls();
      const [wrapSSR, hashId] = useStyle$w(prefixCls);
      const wrapClassNameExtended = classNames(wrapClassName, {
        [`${prefixCls}-centered`]: !!centered,
        [`${prefixCls}-wrap-rtl`]: direction === "rtl"
      });
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(NoCompactStyle, null, /* @__PURE__ */ reactExports.createElement(NoFormStyle, {
        status: true,
        override: true
      }, /* @__PURE__ */ reactExports.createElement(DialogWrap, Object.assign({
        width
      }, restProps, {
        getContainer: getContainer2 === void 0 ? getContextPopupContainer : getContainer2,
        prefixCls,
        rootClassName: classNames(hashId, rootClassName),
        wrapClassName: wrapClassNameExtended,
        footer: props.footer === null ? props.footer : /* @__PURE__ */ reactExports.createElement(Footer$3, Object.assign({}, props, {
          onOk: handleOk,
          onCancel: handleCancel
        })),
        visible: open2 !== null && open2 !== void 0 ? open2 : visible,
        mousePosition: (_a = restProps.mousePosition) !== null && _a !== void 0 ? _a : mousePosition,
        onClose: handleCancel,
        closeIcon: renderCloseIcon(prefixCls, closeIcon),
        focusTriggerAfterClose,
        transitionName: getTransitionName$1(rootPrefixCls, "zoom", props.transitionName),
        maskTransitionName: getTransitionName$1(rootPrefixCls, "fade", props.maskTransitionName),
        className: classNames(hashId, className)
      })))));
    };
    const OriginModal = Modal$2;
    function ConfirmContent(props) {
      const {
        icon,
        onCancel,
        onOk,
        close,
        okText,
        okButtonProps,
        cancelText,
        cancelButtonProps,
        confirmPrefixCls,
        rootPrefixCls,
        type: type2,
        okCancel,
        footer: footer2,
        // Legacy for static function usage
        locale: staticLocale
      } = props;
      let mergedIcon = icon;
      if (!icon && icon !== null) {
        switch (type2) {
          case "info":
            mergedIcon = /* @__PURE__ */ reactExports.createElement(InfoCircleFilled$1, null);
            break;
          case "success":
            mergedIcon = /* @__PURE__ */ reactExports.createElement(CheckCircleFilled$1, null);
            break;
          case "error":
            mergedIcon = /* @__PURE__ */ reactExports.createElement(CloseCircleFilled$1, null);
            break;
          default:
            mergedIcon = /* @__PURE__ */ reactExports.createElement(ExclamationCircleFilled$1, null);
        }
      }
      const okType = props.okType || "primary";
      const mergedOkCancel = okCancel !== null && okCancel !== void 0 ? okCancel : type2 === "confirm";
      const autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || "ok";
      const [locale2] = useLocale$1("Modal");
      const mergedLocale = staticLocale || locale2;
      const cancelButton = mergedOkCancel && /* @__PURE__ */ reactExports.createElement(ActionButton$1, {
        actionFn: onCancel,
        close,
        autoFocus: autoFocusButton === "cancel",
        buttonProps: cancelButtonProps,
        prefixCls: `${rootPrefixCls}-btn`
      }, cancelText || (mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.cancelText));
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: `${confirmPrefixCls}-body-wrapper`
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${confirmPrefixCls}-body`
      }, mergedIcon, props.title === void 0 ? null : /* @__PURE__ */ reactExports.createElement("span", {
        className: `${confirmPrefixCls}-title`
      }, props.title), /* @__PURE__ */ reactExports.createElement("div", {
        className: `${confirmPrefixCls}-content`
      }, props.content)), footer2 !== void 0 ? footer2 : /* @__PURE__ */ reactExports.createElement("div", {
        className: `${confirmPrefixCls}-btns`
      }, cancelButton, /* @__PURE__ */ reactExports.createElement(ActionButton$1, {
        type: okType,
        actionFn: onOk,
        close,
        autoFocus: autoFocusButton === "ok",
        buttonProps: okButtonProps,
        prefixCls: `${rootPrefixCls}-btn`
      }, okText || (mergedOkCancel ? mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.okText : mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.justOkText))));
    }
    const ConfirmDialog = (props) => {
      const {
        close,
        zIndex,
        afterClose,
        visible,
        open: open2,
        keyboard,
        centered,
        getContainer: getContainer2,
        maskStyle,
        direction,
        prefixCls,
        wrapClassName,
        rootPrefixCls,
        iconPrefixCls,
        bodyStyle,
        closable = false,
        closeIcon,
        modalRender,
        focusTriggerAfterClose
      } = props;
      const confirmPrefixCls = `${prefixCls}-confirm`;
      const width = props.width || 416;
      const style2 = props.style || {};
      const mask = props.mask === void 0 ? true : props.mask;
      const maskClosable = props.maskClosable === void 0 ? false : props.maskClosable;
      const classString = classNames(confirmPrefixCls, `${confirmPrefixCls}-${props.type}`, {
        [`${confirmPrefixCls}-rtl`]: direction === "rtl"
      }, props.className);
      return /* @__PURE__ */ reactExports.createElement(ConfigProvider$1, {
        prefixCls: rootPrefixCls,
        iconPrefixCls,
        direction
      }, /* @__PURE__ */ reactExports.createElement(OriginModal, {
        prefixCls,
        className: classString,
        wrapClassName: classNames({
          [`${confirmPrefixCls}-centered`]: !!props.centered
        }, wrapClassName),
        onCancel: () => close === null || close === void 0 ? void 0 : close({
          triggerCancel: true
        }),
        open: open2,
        title: "",
        footer: "",
        transitionName: getTransitionName$1(rootPrefixCls, "zoom", props.transitionName),
        maskTransitionName: getTransitionName$1(rootPrefixCls, "fade", props.maskTransitionName),
        mask,
        maskClosable,
        maskStyle,
        style: style2,
        bodyStyle,
        width,
        zIndex,
        afterClose,
        keyboard,
        centered,
        getContainer: getContainer2,
        closable,
        closeIcon,
        modalRender,
        focusTriggerAfterClose
      }, /* @__PURE__ */ reactExports.createElement(ConfirmContent, Object.assign({}, props, {
        confirmPrefixCls
      }))));
    };
    const destroyFns = [];
    const destroyFns$1 = destroyFns;
    var __rest$_ = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    let defaultRootPrefixCls = "";
    function getRootPrefixCls() {
      return defaultRootPrefixCls;
    }
    function confirm(config) {
      const container2 = document.createDocumentFragment();
      let currentConfig = Object.assign(Object.assign({}, config), {
        close,
        open: true
      });
      let timeoutId;
      function destroy2() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const triggerCancel = args.some((param) => param && param.triggerCancel);
        if (config.onCancel && triggerCancel) {
          config.onCancel.apply(config, [() => {
          }].concat(_toConsumableArray(args.slice(1))));
        }
        for (let i2 = 0; i2 < destroyFns$1.length; i2++) {
          const fn = destroyFns$1[i2];
          if (fn === close) {
            destroyFns$1.splice(i2, 1);
            break;
          }
        }
        unmount(container2);
      }
      function render$1(_a) {
        var {
          okText,
          cancelText,
          prefixCls: customizePrefixCls
        } = _a, props = __rest$_(_a, ["okText", "cancelText", "prefixCls"]);
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          const runtimeLocale2 = getConfirmLocale();
          const {
            getPrefixCls,
            getIconPrefixCls
          } = globalConfig();
          const rootPrefixCls = getPrefixCls(void 0, getRootPrefixCls());
          const prefixCls = customizePrefixCls || `${rootPrefixCls}-modal`;
          const iconPrefixCls = getIconPrefixCls();
          render(/* @__PURE__ */ reactExports.createElement(ConfirmDialog, Object.assign({}, props, {
            prefixCls,
            rootPrefixCls,
            iconPrefixCls,
            okText,
            locale: runtimeLocale2,
            cancelText: cancelText || runtimeLocale2.cancelText
          })), container2);
        });
      }
      function close() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        currentConfig = Object.assign(Object.assign({}, currentConfig), {
          open: false,
          afterClose: () => {
            if (typeof config.afterClose === "function") {
              config.afterClose();
            }
            destroy2.apply(this, args);
          }
        });
        if (currentConfig.visible) {
          delete currentConfig.visible;
        }
        render$1(currentConfig);
      }
      function update2(configUpdate) {
        if (typeof configUpdate === "function") {
          currentConfig = configUpdate(currentConfig);
        } else {
          currentConfig = Object.assign(Object.assign({}, currentConfig), configUpdate);
        }
        render$1(currentConfig);
      }
      render$1(currentConfig);
      destroyFns$1.push(close);
      return {
        destroy: close,
        update: update2
      };
    }
    function withWarn(props) {
      return Object.assign(Object.assign({}, props), {
        type: "warning"
      });
    }
    function withInfo(props) {
      return Object.assign(Object.assign({}, props), {
        type: "info"
      });
    }
    function withSuccess(props) {
      return Object.assign(Object.assign({}, props), {
        type: "success"
      });
    }
    function withError(props) {
      return Object.assign(Object.assign({}, props), {
        type: "error"
      });
    }
    function withConfirm(props) {
      return Object.assign(Object.assign({}, props), {
        type: "confirm"
      });
    }
    function modalGlobalConfig(_ref) {
      let {
        rootPrefixCls
      } = _ref;
      defaultRootPrefixCls = rootPrefixCls;
    }
    const HookModal = (_ref, ref) => {
      let {
        afterClose,
        config
      } = _ref;
      var _a;
      const [open2, setOpen] = reactExports.useState(true);
      const [innerConfig, setInnerConfig] = reactExports.useState(config);
      const {
        direction,
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("modal");
      const rootPrefixCls = getPrefixCls();
      const close = function() {
        setOpen(false);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const triggerCancel = args.some((param) => param && param.triggerCancel);
        if (innerConfig.onCancel && triggerCancel) {
          innerConfig.onCancel.apply(innerConfig, [() => {
          }].concat(_toConsumableArray(args.slice(1))));
        }
      };
      reactExports.useImperativeHandle(ref, () => ({
        destroy: close,
        update: (newConfig) => {
          setInnerConfig((originConfig) => Object.assign(Object.assign({}, originConfig), newConfig));
        }
      }));
      const mergedOkCancel = (_a = innerConfig.okCancel) !== null && _a !== void 0 ? _a : innerConfig.type === "confirm";
      const [contextLocale] = useLocale$1("Modal", defaultLocale.Modal);
      return /* @__PURE__ */ reactExports.createElement(ConfirmDialog, Object.assign({
        prefixCls,
        rootPrefixCls
      }, innerConfig, {
        close,
        open: open2,
        afterClose,
        okText: innerConfig.okText || (mergedOkCancel ? contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.okText : contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.justOkText),
        direction,
        cancelText: innerConfig.cancelText || (contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.cancelText)
      }));
    };
    const HookModal$1 = /* @__PURE__ */ reactExports.forwardRef(HookModal);
    let uuid$3 = 0;
    const ElementsHolder = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef((_props, ref) => {
      const [elements, patchElement] = usePatchElement();
      reactExports.useImperativeHandle(ref, () => ({
        patchElement
      }), []);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, elements);
    }));
    function useModal$1() {
      const holderRef = reactExports.useRef(null);
      const [actionQueue, setActionQueue] = reactExports.useState([]);
      reactExports.useEffect(() => {
        if (actionQueue.length) {
          const cloneQueue = _toConsumableArray(actionQueue);
          cloneQueue.forEach((action) => {
            action();
          });
          setActionQueue([]);
        }
      }, [actionQueue]);
      const getConfirmFunc = reactExports.useCallback((withFunc) => function hookConfirm(config) {
        var _a;
        uuid$3 += 1;
        const modalRef = /* @__PURE__ */ reactExports.createRef();
        let closeFunc;
        const modal = /* @__PURE__ */ reactExports.createElement(HookModal$1, {
          key: `modal-${uuid$3}`,
          config: withFunc(config),
          ref: modalRef,
          afterClose: () => {
            closeFunc === null || closeFunc === void 0 ? void 0 : closeFunc();
          }
        });
        closeFunc = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.patchElement(modal);
        if (closeFunc) {
          destroyFns$1.push(closeFunc);
        }
        return {
          destroy: () => {
            function destroyAction() {
              var _a2;
              (_a2 = modalRef.current) === null || _a2 === void 0 ? void 0 : _a2.destroy();
            }
            if (modalRef.current) {
              destroyAction();
            } else {
              setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [destroyAction]));
            }
          },
          update: (newConfig) => {
            function updateAction() {
              var _a2;
              (_a2 = modalRef.current) === null || _a2 === void 0 ? void 0 : _a2.update(newConfig);
            }
            if (modalRef.current) {
              updateAction();
            } else {
              setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [updateAction]));
            }
          }
        };
      }, []);
      const fns = reactExports.useMemo(() => ({
        info: getConfirmFunc(withInfo),
        success: getConfirmFunc(withSuccess),
        error: getConfirmFunc(withError),
        warning: getConfirmFunc(withWarn),
        confirm: getConfirmFunc(withConfirm)
      }), []);
      return [fns, /* @__PURE__ */ reactExports.createElement(ElementsHolder, {
        key: "modal-holder",
        ref: holderRef
      })];
    }
    function getPlacementStyle(placement, top, bottom) {
      let style2;
      switch (placement) {
        case "top":
          style2 = {
            left: "50%",
            transform: "translateX(-50%)",
            right: "auto",
            top,
            bottom: "auto"
          };
          break;
        case "topLeft":
          style2 = {
            left: 0,
            top,
            bottom: "auto"
          };
          break;
        case "topRight":
          style2 = {
            right: 0,
            top,
            bottom: "auto"
          };
          break;
        case "bottom":
          style2 = {
            left: "50%",
            transform: "translateX(-50%)",
            right: "auto",
            top: "auto",
            bottom
          };
          break;
        case "bottomLeft":
          style2 = {
            left: 0,
            top: "auto",
            bottom
          };
          break;
        default:
          style2 = {
            right: 0,
            top: "auto",
            bottom
          };
          break;
      }
      return style2;
    }
    function getMotion$3(prefixCls) {
      return {
        motionName: `${prefixCls}-fade`
      };
    }
    const genNotificationPlacementStyle = (token2) => {
      const {
        componentCls,
        width,
        notificationMarginEdge
      } = token2;
      const notificationTopFadeIn = new Keyframe("antNotificationTopFadeIn", {
        "0%": {
          marginTop: "-100%",
          opacity: 0
        },
        "100%": {
          marginTop: 0,
          opacity: 1
        }
      });
      const notificationBottomFadeIn = new Keyframe("antNotificationBottomFadeIn", {
        "0%": {
          marginBottom: "-100%",
          opacity: 0
        },
        "100%": {
          marginBottom: 0,
          opacity: 1
        }
      });
      const notificationLeftFadeIn = new Keyframe("antNotificationLeftFadeIn", {
        "0%": {
          right: {
            _skip_check_: true,
            value: width
          },
          opacity: 0
        },
        "100%": {
          right: {
            _skip_check_: true,
            value: 0
          },
          opacity: 1
        }
      });
      return {
        [`&${componentCls}-top, &${componentCls}-bottom`]: {
          marginInline: 0
        },
        [`&${componentCls}-top`]: {
          [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
            animationName: notificationTopFadeIn
          }
        },
        [`&${componentCls}-bottom`]: {
          [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
            animationName: notificationBottomFadeIn
          }
        },
        [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
          marginInlineEnd: 0,
          marginInlineStart: notificationMarginEdge,
          [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
            animationName: notificationLeftFadeIn
          }
        }
      };
    };
    const genNotificationPlacementStyle$1 = genNotificationPlacementStyle;
    const genNotificationStyle = (token2) => {
      const {
        iconCls,
        componentCls,
        // .ant-notification
        boxShadow,
        fontSizeLG,
        notificationMarginBottom,
        borderRadiusLG,
        colorSuccess,
        colorInfo,
        colorWarning,
        colorError,
        colorTextHeading,
        notificationBg,
        notificationPadding,
        notificationMarginEdge,
        motionDurationMid,
        motionEaseInOut,
        fontSize,
        lineHeight,
        width,
        notificationIconSize
      } = token2;
      const noticeCls = `${componentCls}-notice`;
      const notificationFadeIn = new Keyframe("antNotificationFadeIn", {
        "0%": {
          left: {
            _skip_check_: true,
            value: width
          },
          opacity: 0
        },
        "100%": {
          left: {
            _skip_check_: true,
            value: 0
          },
          opacity: 1
        }
      });
      const notificationFadeOut = new Keyframe("antNotificationFadeOut", {
        "0%": {
          maxHeight: token2.animationMaxHeight,
          marginBottom: notificationMarginBottom,
          opacity: 1
        },
        "100%": {
          maxHeight: 0,
          marginBottom: 0,
          paddingTop: 0,
          paddingBottom: 0,
          opacity: 0
        }
      });
      return [
        // ============================ Holder ============================
        {
          [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), {
            position: "fixed",
            zIndex: token2.zIndexPopup,
            marginInlineEnd: notificationMarginEdge,
            [`${componentCls}-hook-holder`]: {
              position: "relative"
            },
            [`&${componentCls}-top, &${componentCls}-bottom`]: {
              [`${componentCls}-notice`]: {
                marginInline: "auto auto"
              }
            },
            [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
              [`${componentCls}-notice`]: {
                marginInlineEnd: "auto",
                marginInlineStart: 0
              }
            },
            //  animation
            [`${componentCls}-fade-enter, ${componentCls}-fade-appear`]: {
              animationDuration: token2.motionDurationMid,
              animationTimingFunction: motionEaseInOut,
              animationFillMode: "both",
              opacity: 0,
              animationPlayState: "paused"
            },
            [`${componentCls}-fade-leave`]: {
              animationTimingFunction: motionEaseInOut,
              animationFillMode: "both",
              animationDuration: motionDurationMid,
              animationPlayState: "paused"
            },
            [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
              animationName: notificationFadeIn,
              animationPlayState: "running"
            },
            [`${componentCls}-fade-leave${componentCls}-fade-leave-active`]: {
              animationName: notificationFadeOut,
              animationPlayState: "running"
            }
          }), genNotificationPlacementStyle$1(token2)), {
            // RTL
            "&-rtl": {
              direction: "rtl",
              [`${componentCls}-notice-btn`]: {
                float: "left"
              }
            }
          })
        },
        // ============================ Notice ============================
        {
          [noticeCls]: {
            position: "relative",
            width,
            maxWidth: `calc(100vw - ${notificationMarginEdge * 2}px)`,
            marginBottom: notificationMarginBottom,
            marginInlineStart: "auto",
            padding: notificationPadding,
            overflow: "hidden",
            lineHeight,
            wordWrap: "break-word",
            background: notificationBg,
            borderRadius: borderRadiusLG,
            boxShadow,
            [`${componentCls}-close-icon`]: {
              fontSize,
              cursor: "pointer"
            },
            [`${noticeCls}-message`]: {
              marginBottom: token2.marginXS,
              color: colorTextHeading,
              fontSize: fontSizeLG,
              lineHeight: token2.lineHeightLG
            },
            [`${noticeCls}-description`]: {
              fontSize
            },
            [`&${noticeCls}-closable ${noticeCls}-message`]: {
              paddingInlineEnd: token2.paddingLG
            },
            [`${noticeCls}-with-icon ${noticeCls}-message`]: {
              marginBottom: token2.marginXS,
              marginInlineStart: token2.marginSM + notificationIconSize,
              fontSize: fontSizeLG
            },
            [`${noticeCls}-with-icon ${noticeCls}-description`]: {
              marginInlineStart: token2.marginSM + notificationIconSize,
              fontSize
            },
            // Icon & color style in different selector level
            // https://github.com/ant-design/ant-design/issues/16503
            // https://github.com/ant-design/ant-design/issues/15512
            [`${noticeCls}-icon`]: {
              position: "absolute",
              fontSize: notificationIconSize,
              lineHeight: 0,
              // icon-font
              [`&-success${iconCls}`]: {
                color: colorSuccess
              },
              [`&-info${iconCls}`]: {
                color: colorInfo
              },
              [`&-warning${iconCls}`]: {
                color: colorWarning
              },
              [`&-error${iconCls}`]: {
                color: colorError
              }
            },
            [`${noticeCls}-close`]: {
              position: "absolute",
              top: token2.notificationPaddingVertical,
              insetInlineEnd: token2.notificationPaddingHorizontal,
              color: token2.colorIcon,
              outline: "none",
              width: token2.notificationCloseButtonSize,
              height: token2.notificationCloseButtonSize,
              borderRadius: token2.borderRadiusSM,
              transition: `background-color ${token2.motionDurationMid}, color ${token2.motionDurationMid}`,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              "&:hover": {
                color: token2.colorIconHover,
                backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContent
              }
            },
            [`${noticeCls}-btn`]: {
              float: "right",
              marginTop: token2.marginSM
            }
          }
        },
        // ============================= Pure =============================
        {
          [`${noticeCls}-pure-panel`]: {
            margin: 0
          }
        }
      ];
    };
    const useStyle$v = genComponentStyleHook("Notification", (token2) => {
      const notificationPaddingVertical = token2.paddingMD;
      const notificationPaddingHorizontal = token2.paddingLG;
      const notificationToken = merge$4(token2, {
        // default.less variables
        notificationBg: token2.colorBgElevated,
        notificationPaddingVertical,
        notificationPaddingHorizontal,
        // index.less variables
        notificationPadding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`,
        notificationMarginBottom: token2.margin,
        notificationMarginEdge: token2.marginLG,
        animationMaxHeight: 150,
        notificationIconSize: token2.fontSizeLG * token2.lineHeightLG,
        notificationCloseButtonSize: token2.controlHeightLG * 0.55
      });
      return [genNotificationStyle(notificationToken)];
    }, (token2) => ({
      zIndexPopup: token2.zIndexPopupBase + 50,
      width: 384
    }));
    var __rest$Z = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function getCloseIcon(prefixCls, closeIcon) {
      return closeIcon || /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-close-x`
      }, /* @__PURE__ */ reactExports.createElement(CloseOutlined$1, {
        className: `${prefixCls}-close-icon`
      }));
    }
    const typeToIcon = {
      success: CheckCircleFilled$1,
      info: InfoCircleFilled$1,
      error: CloseCircleFilled$1,
      warning: ExclamationCircleFilled$1
    };
    function PureContent(_ref) {
      let {
        prefixCls,
        icon,
        type: type2,
        message: message2,
        description,
        btn
      } = _ref;
      let iconNode = null;
      if (icon) {
        iconNode = /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-icon`
        }, icon);
      } else if (type2) {
        iconNode = /* @__PURE__ */ reactExports.createElement(typeToIcon[type2] || null, {
          className: classNames(`${prefixCls}-icon`, `${prefixCls}-icon-${type2}`)
        });
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames({
          [`${prefixCls}-with-icon`]: iconNode
        }),
        role: "alert"
      }, iconNode, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-message`
      }, message2), /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-description`
      }, description), btn && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-btn`
      }, btn));
    }
    function PurePanel$8(props) {
      const {
        prefixCls: staticPrefixCls,
        className,
        icon,
        type: type2,
        message: message2,
        description,
        btn,
        closable = true,
        closeIcon
      } = props, restProps = __rest$Z(props, ["prefixCls", "className", "icon", "type", "message", "description", "btn", "closable", "closeIcon"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = staticPrefixCls || getPrefixCls("notification");
      const noticePrefixCls = `${prefixCls}-notice`;
      const [, hashId] = useStyle$v(prefixCls);
      return /* @__PURE__ */ reactExports.createElement(Notice, Object.assign({}, restProps, {
        prefixCls,
        className: classNames(className, hashId, `${noticePrefixCls}-pure-panel`),
        eventKey: "pure",
        duration: null,
        closable,
        closeIcon: getCloseIcon(prefixCls, closeIcon),
        content: /* @__PURE__ */ reactExports.createElement(PureContent, {
          prefixCls: noticePrefixCls,
          icon,
          type: type2,
          message: message2,
          description,
          btn
        })
      }));
    }
    var __rest$Y = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const DEFAULT_OFFSET = 24;
    const DEFAULT_DURATION = 4.5;
    const Holder = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        top,
        bottom,
        prefixCls: staticPrefixCls,
        getContainer: staticGetContainer,
        maxCount,
        rtl,
        onAllRemoved
      } = props;
      const {
        getPrefixCls,
        getPopupContainer
      } = reactExports.useContext(ConfigContext);
      const prefixCls = staticPrefixCls || getPrefixCls("notification");
      const getStyle2 = (placement) => getPlacementStyle(placement, top !== null && top !== void 0 ? top : DEFAULT_OFFSET, bottom !== null && bottom !== void 0 ? bottom : DEFAULT_OFFSET);
      const [, hashId] = useStyle$v(prefixCls);
      const getClassName = () => classNames(hashId, {
        [`${prefixCls}-rtl`]: rtl
      });
      const getNotificationMotion = () => getMotion$3(prefixCls);
      const [api, holder] = useNotification$1({
        prefixCls,
        style: getStyle2,
        className: getClassName,
        motion: getNotificationMotion,
        closable: true,
        closeIcon: getCloseIcon(prefixCls),
        duration: DEFAULT_DURATION,
        getContainer: () => (staticGetContainer === null || staticGetContainer === void 0 ? void 0 : staticGetContainer()) || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer()) || document.body,
        maxCount,
        onAllRemoved
      });
      reactExports.useImperativeHandle(ref, () => Object.assign(Object.assign({}, api), {
        prefixCls,
        hashId
      }));
      return holder;
    });
    function useInternalNotification(notificationConfig) {
      const holderRef = reactExports.useRef(null);
      const wrapAPI = reactExports.useMemo(() => {
        const open2 = (config) => {
          if (!holderRef.current) {
            return;
          }
          const {
            open: originOpen,
            prefixCls,
            hashId
          } = holderRef.current;
          const noticePrefixCls = `${prefixCls}-notice`;
          const {
            message: message2,
            description,
            icon,
            type: type2,
            btn,
            className
          } = config, restConfig = __rest$Y(config, ["message", "description", "icon", "type", "btn", "className"]);
          return originOpen(Object.assign(Object.assign({
            placement: "topRight"
          }, restConfig), {
            content: /* @__PURE__ */ reactExports.createElement(PureContent, {
              prefixCls: noticePrefixCls,
              icon,
              type: type2,
              message: message2,
              description,
              btn
            }),
            className: classNames(type2 && `${noticePrefixCls}-${type2}`, hashId, className)
          }));
        };
        const destroy2 = (key) => {
          var _a, _b;
          if (key !== void 0) {
            (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.close(key);
          } else {
            (_b = holderRef.current) === null || _b === void 0 ? void 0 : _b.destroy();
          }
        };
        const clone = {
          open: open2,
          destroy: destroy2
        };
        const keys2 = ["success", "info", "warning", "error"];
        keys2.forEach((type2) => {
          clone[type2] = (config) => open2(Object.assign(Object.assign({}, config), {
            type: type2
          }));
        });
        return clone;
      }, []);
      return [wrapAPI, /* @__PURE__ */ reactExports.createElement(Holder, Object.assign({
        key: "notification-holder"
      }, notificationConfig, {
        ref: holderRef
      }))];
    }
    function useNotification(notificationConfig) {
      return useInternalNotification(notificationConfig);
    }
    function useEvent(callback) {
      var fnRef = reactExports.useRef();
      fnRef.current = callback;
      var memoFn = reactExports.useCallback(function() {
        var _fnRef$current;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
      }, []);
      return memoFn;
    }
    function hasValue$1(value) {
      return value !== void 0;
    }
    function useMergedState(defaultStateValue, option) {
      var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState;
      var _useState = useSafeState(function() {
        if (hasValue$1(value)) {
          return value;
        } else if (hasValue$1(defaultValue)) {
          return typeof defaultValue === "function" ? defaultValue() : defaultValue;
        } else {
          return typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
        }
      }), _useState2 = _slicedToArray(_useState, 2), innerValue = _useState2[0], setInnerValue = _useState2[1];
      var mergedValue = value !== void 0 ? value : innerValue;
      var postMergedValue = postState ? postState(mergedValue) : mergedValue;
      var onChangeFn = useEvent(onChange);
      var _useState3 = useSafeState([mergedValue]), _useState4 = _slicedToArray(_useState3, 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
      useLayoutUpdateEffect(function() {
        var prev2 = prevValue[0];
        if (innerValue !== prev2) {
          onChangeFn(innerValue, prev2);
        }
      }, [prevValue]);
      useLayoutUpdateEffect(function() {
        if (!hasValue$1(value)) {
          setInnerValue(value);
        }
      }, [value]);
      var triggerChange = useEvent(function(updater, ignoreDestroy) {
        setInnerValue(updater, ignoreDestroy);
        setPrevValue([mergedValue], ignoreDestroy);
      });
      return [postMergedValue, triggerChange];
    }
    const isMobile = function() {
      if (typeof navigator === "undefined" || typeof window === "undefined") {
        return false;
      }
      var agent = navigator.userAgent || navigator.vendor || window.opera;
      return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
    };
    var BaseSelectContext = /* @__PURE__ */ reactExports.createContext(null);
    function useBaseProps() {
      return reactExports.useContext(BaseSelectContext);
    }
    function useDelayReset() {
      var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), bool = _React$useState2[0], setBool = _React$useState2[1];
      var delayRef = reactExports.useRef(null);
      var cancelLatest = function cancelLatest2() {
        window.clearTimeout(delayRef.current);
      };
      reactExports.useEffect(function() {
        return cancelLatest;
      }, []);
      var delaySetBool = function delaySetBool2(value, callback) {
        cancelLatest();
        delayRef.current = window.setTimeout(function() {
          setBool(value);
          if (callback) {
            callback();
          }
        }, timeout);
      };
      return [bool, delaySetBool, cancelLatest];
    }
    function useLock() {
      var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
      var lockRef = reactExports.useRef(null);
      var timeoutRef = reactExports.useRef(null);
      reactExports.useEffect(function() {
        return function() {
          window.clearTimeout(timeoutRef.current);
        };
      }, []);
      function doLock(locked) {
        if (locked || lockRef.current === null) {
          lockRef.current = locked;
        }
        window.clearTimeout(timeoutRef.current);
        timeoutRef.current = window.setTimeout(function() {
          lockRef.current = null;
        }, duration);
      }
      return [function() {
        return lockRef.current;
      }, doLock];
    }
    function useSelectTriggerControl(elements, open2, triggerOpen, customizedTrigger) {
      var propsRef = reactExports.useRef(null);
      propsRef.current = {
        open: open2,
        triggerOpen,
        customizedTrigger
      };
      reactExports.useEffect(function() {
        function onGlobalMouseDown(event) {
          var _propsRef$current;
          if ((_propsRef$current = propsRef.current) !== null && _propsRef$current !== void 0 && _propsRef$current.customizedTrigger) {
            return;
          }
          var target = event.target;
          if (target.shadowRoot && event.composed) {
            target = event.composedPath()[0] || target;
          }
          if (propsRef.current.open && elements().filter(function(element) {
            return element;
          }).every(function(element) {
            return !element.contains(target) && element !== target;
          })) {
            propsRef.current.triggerOpen(false);
          }
        }
        window.addEventListener("mousedown", onGlobalMouseDown);
        return function() {
          return window.removeEventListener("mousedown", onGlobalMouseDown);
        };
      }, []);
    }
    var _excluded$H = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];
    var UNDEFINED$1 = void 0;
    function InternalItem(props, ref) {
      var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey2 = props.itemKey, className = props.className, style2 = props.style, children = props.children, display = props.display, order2 = props.order, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties$1(props, _excluded$H);
      var mergedHidden = responsive && !display;
      function internalRegisterSize(width) {
        registerSize(itemKey2, width);
      }
      reactExports.useEffect(function() {
        return function() {
          internalRegisterSize(null);
        };
      }, []);
      var childNode = renderItem && item !== UNDEFINED$1 ? renderItem(item) : children;
      var overflowStyle;
      if (!invalidate) {
        overflowStyle = {
          opacity: mergedHidden ? 0 : 1,
          height: mergedHidden ? 0 : UNDEFINED$1,
          overflowY: mergedHidden ? "hidden" : UNDEFINED$1,
          order: responsive ? order2 : UNDEFINED$1,
          pointerEvents: mergedHidden ? "none" : UNDEFINED$1,
          position: mergedHidden ? "absolute" : UNDEFINED$1
        };
      }
      var overflowProps = {};
      if (mergedHidden) {
        overflowProps["aria-hidden"] = true;
      }
      var itemNode = /* @__PURE__ */ reactExports.createElement(Component, _extends$2({
        className: classNames(!invalidate && prefixCls, className),
        style: _objectSpread2$3(_objectSpread2$3({}, overflowStyle), style2)
      }, overflowProps, restProps, {
        ref
      }), childNode);
      if (responsive) {
        itemNode = /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
          onResize: function onResize2(_ref) {
            var offsetWidth = _ref.offsetWidth;
            internalRegisterSize(offsetWidth);
          },
          disabled: responsiveDisabled
        }, itemNode);
      }
      return itemNode;
    }
    var Item$4 = /* @__PURE__ */ reactExports.forwardRef(InternalItem);
    Item$4.displayName = "Item";
    function useBatchFrameState() {
      var _useState = useSafeState({}), _useState2 = _slicedToArray(_useState, 2), forceUpdate = _useState2[1];
      var statesRef = reactExports.useRef([]);
      var walkingIndex = 0;
      var beforeFrameId = 0;
      function createState(defaultValue) {
        var myIndex = walkingIndex;
        walkingIndex += 1;
        if (statesRef.current.length < myIndex + 1) {
          statesRef.current[myIndex] = defaultValue;
        }
        var value = statesRef.current[myIndex];
        function setValue2(val) {
          statesRef.current[myIndex] = typeof val === "function" ? val(statesRef.current[myIndex]) : val;
          wrapperRaf.cancel(beforeFrameId);
          beforeFrameId = wrapperRaf(function() {
            forceUpdate({}, true);
          });
        }
        return [value, setValue2];
      }
      return createState;
    }
    var _excluded$G = ["component"], _excluded2$6 = ["className"], _excluded3$1 = ["className"];
    var InternalRawItem = function InternalRawItem2(props, ref) {
      var context = reactExports.useContext(OverflowContext);
      if (!context) {
        var _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties$1(props, _excluded$G);
        return /* @__PURE__ */ reactExports.createElement(Component, _extends$2({}, _restProps, {
          ref
        }));
      }
      var contextClassName = context.className, restContext = _objectWithoutProperties$1(context, _excluded2$6);
      var className = props.className, restProps = _objectWithoutProperties$1(props, _excluded3$1);
      return /* @__PURE__ */ reactExports.createElement(OverflowContext.Provider, {
        value: null
      }, /* @__PURE__ */ reactExports.createElement(Item$4, _extends$2({
        ref,
        className: classNames(contextClassName, className)
      }, restContext, restProps)));
    };
    var RawItem = /* @__PURE__ */ reactExports.forwardRef(InternalRawItem);
    RawItem.displayName = "RawItem";
    var _excluded$F = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];
    var OverflowContext = /* @__PURE__ */ reactExports.createContext(null);
    var RESPONSIVE = "responsive";
    var INVALIDATE = "invalidate";
    function defaultRenderRest(omittedItems) {
      return "+ ".concat(omittedItems.length, " ...");
    }
    function Overflow(props, ref) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data2 = _props$data === void 0 ? [] : _props$data, renderItem = props.renderItem, renderRawItem = props.renderRawItem, itemKey2 = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style2 = props.style, className = props.className, maxCount = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix = props.suffix, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties$1(props, _excluded$F);
      var createUseState = useBatchFrameState();
      var fullySSR = ssr === "full";
      var _createUseState = createUseState(null), _createUseState2 = _slicedToArray(_createUseState, 2), containerWidth = _createUseState2[0], setContainerWidth = _createUseState2[1];
      var mergedContainerWidth = containerWidth || 0;
      var _createUseState3 = createUseState(/* @__PURE__ */ new Map()), _createUseState4 = _slicedToArray(_createUseState3, 2), itemWidths = _createUseState4[0], setItemWidths = _createUseState4[1];
      var _createUseState5 = createUseState(0), _createUseState6 = _slicedToArray(_createUseState5, 2), prevRestWidth = _createUseState6[0], setPrevRestWidth = _createUseState6[1];
      var _createUseState7 = createUseState(0), _createUseState8 = _slicedToArray(_createUseState7, 2), restWidth = _createUseState8[0], setRestWidth = _createUseState8[1];
      var _createUseState9 = createUseState(0), _createUseState10 = _slicedToArray(_createUseState9, 2), suffixWidth = _createUseState10[0], setSuffixWidth = _createUseState10[1];
      var _useState = reactExports.useState(null), _useState2 = _slicedToArray(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1];
      var _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1];
      var mergedDisplayCount = reactExports.useMemo(function() {
        if (displayCount === null && fullySSR) {
          return Number.MAX_SAFE_INTEGER;
        }
        return displayCount || 0;
      }, [displayCount, containerWidth]);
      var _useState5 = reactExports.useState(false), _useState6 = _slicedToArray(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1];
      var itemPrefixCls = "".concat(prefixCls, "-item");
      var mergedRestWidth = Math.max(prevRestWidth, restWidth);
      var isResponsive = maxCount === RESPONSIVE;
      var shouldResponsive = data2.length && isResponsive;
      var invalidate = maxCount === INVALIDATE;
      var showRest = shouldResponsive || typeof maxCount === "number" && data2.length > maxCount;
      var mergedData = reactExports.useMemo(function() {
        var items = data2;
        if (shouldResponsive) {
          if (containerWidth === null && fullySSR) {
            items = data2;
          } else {
            items = data2.slice(0, Math.min(data2.length, mergedContainerWidth / itemWidth));
          }
        } else if (typeof maxCount === "number") {
          items = data2.slice(0, maxCount);
        }
        return items;
      }, [data2, itemWidth, containerWidth, maxCount, shouldResponsive]);
      var omittedItems = reactExports.useMemo(function() {
        if (shouldResponsive) {
          return data2.slice(mergedDisplayCount + 1);
        }
        return data2.slice(mergedData.length);
      }, [data2, mergedData, shouldResponsive, mergedDisplayCount]);
      var getKey2 = reactExports.useCallback(function(item, index2) {
        var _ref;
        if (typeof itemKey2 === "function") {
          return itemKey2(item);
        }
        return (_ref = itemKey2 && (item === null || item === void 0 ? void 0 : item[itemKey2])) !== null && _ref !== void 0 ? _ref : index2;
      }, [itemKey2]);
      var mergedRenderItem = reactExports.useCallback(renderItem || function(item) {
        return item;
      }, [renderItem]);
      function updateDisplayCount(count, suffixFixedStartVal, notReady) {
        if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
          return;
        }
        setDisplayCount(count);
        if (!notReady) {
          setRestReady(count < data2.length - 1);
          onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(count);
        }
        if (suffixFixedStartVal !== void 0) {
          setSuffixFixedStart(suffixFixedStartVal);
        }
      }
      function onOverflowResize(_, element) {
        setContainerWidth(element.clientWidth);
      }
      function registerSize(key, width) {
        setItemWidths(function(origin) {
          var clone = new Map(origin);
          if (width === null) {
            clone.delete(key);
          } else {
            clone.set(key, width);
          }
          return clone;
        });
      }
      function registerOverflowSize(_, width) {
        setRestWidth(width);
        setPrevRestWidth(restWidth);
      }
      function registerSuffixSize(_, width) {
        setSuffixWidth(width);
      }
      function getItemWidth(index2) {
        return itemWidths.get(getKey2(mergedData[index2], index2));
      }
      useLayoutEffect$1(function() {
        if (mergedContainerWidth && mergedRestWidth && mergedData) {
          var totalWidth = suffixWidth;
          var len = mergedData.length;
          var lastIndex = len - 1;
          if (!len) {
            updateDisplayCount(0, null);
            return;
          }
          for (var i2 = 0; i2 < len; i2 += 1) {
            var currentItemWidth = getItemWidth(i2);
            if (fullySSR) {
              currentItemWidth = currentItemWidth || 0;
            }
            if (currentItemWidth === void 0) {
              updateDisplayCount(i2 - 1, void 0, true);
              break;
            }
            totalWidth += currentItemWidth;
            if (
              // Only one means `totalWidth` is the final width
              lastIndex === 0 && totalWidth <= mergedContainerWidth || // Last two width will be the final width
              i2 === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth
            ) {
              updateDisplayCount(lastIndex, null);
              break;
            } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
              updateDisplayCount(i2 - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
              break;
            }
          }
          if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
            setSuffixFixedStart(null);
          }
        }
      }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey2, mergedData]);
      var displayRest = restReady && !!omittedItems.length;
      var suffixStyle = {};
      if (suffixFixedStart !== null && shouldResponsive) {
        suffixStyle = {
          position: "absolute",
          left: suffixFixedStart,
          top: 0
        };
      }
      var itemSharedProps = {
        prefixCls: itemPrefixCls,
        responsive: shouldResponsive,
        component: itemComponent,
        invalidate
      };
      var internalRenderItemNode = renderRawItem ? function(item, index2) {
        var key = getKey2(item, index2);
        return /* @__PURE__ */ reactExports.createElement(OverflowContext.Provider, {
          key,
          value: _objectSpread2$3(_objectSpread2$3({}, itemSharedProps), {}, {
            order: index2,
            item,
            itemKey: key,
            registerSize,
            display: index2 <= mergedDisplayCount
          })
        }, renderRawItem(item, index2));
      } : function(item, index2) {
        var key = getKey2(item, index2);
        return /* @__PURE__ */ reactExports.createElement(Item$4, _extends$2({}, itemSharedProps, {
          order: index2,
          key,
          item,
          renderItem: mergedRenderItem,
          itemKey: key,
          registerSize,
          display: index2 <= mergedDisplayCount
        }));
      };
      var restNode;
      var restContextProps = {
        order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
        className: "".concat(itemPrefixCls, "-rest"),
        registerSize: registerOverflowSize,
        display: displayRest
      };
      if (!renderRawRest) {
        var mergedRenderRest = renderRest || defaultRenderRest;
        restNode = /* @__PURE__ */ reactExports.createElement(Item$4, _extends$2({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
      } else if (renderRawRest) {
        restNode = /* @__PURE__ */ reactExports.createElement(OverflowContext.Provider, {
          value: _objectSpread2$3(_objectSpread2$3({}, itemSharedProps), restContextProps)
        }, renderRawRest(omittedItems));
      }
      var overflowNode = /* @__PURE__ */ reactExports.createElement(Component, _extends$2({
        className: classNames(!invalidate && prefixCls, className),
        style: style2,
        ref
      }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ reactExports.createElement(Item$4, _extends$2({}, itemSharedProps, {
        responsive: isResponsive,
        responsiveDisabled: !shouldResponsive,
        order: mergedDisplayCount,
        className: "".concat(itemPrefixCls, "-suffix"),
        registerSize: registerSuffixSize,
        display: true,
        style: suffixStyle
      }), suffix));
      if (isResponsive) {
        overflowNode = /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
          onResize: onOverflowResize,
          disabled: !shouldResponsive
        }, overflowNode);
      }
      return overflowNode;
    }
    var ForwardOverflow = /* @__PURE__ */ reactExports.forwardRef(Overflow);
    ForwardOverflow.displayName = "Overflow";
    ForwardOverflow.Item = RawItem;
    ForwardOverflow.RESPONSIVE = RESPONSIVE;
    ForwardOverflow.INVALIDATE = INVALIDATE;
    var TransBtn = function TransBtn2(_ref) {
      var className = _ref.className, customizeIcon = _ref.customizeIcon, customizeIconProps = _ref.customizeIconProps, _onMouseDown = _ref.onMouseDown, onClick = _ref.onClick, children = _ref.children;
      var icon;
      if (typeof customizeIcon === "function") {
        icon = customizeIcon(customizeIconProps);
      } else {
        icon = customizeIcon;
      }
      return /* @__PURE__ */ reactExports.createElement("span", {
        className,
        onMouseDown: function onMouseDown(event) {
          event.preventDefault();
          if (_onMouseDown) {
            _onMouseDown(event);
          }
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        },
        unselectable: "on",
        onClick,
        "aria-hidden": true
      }, icon !== void 0 ? icon : /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames(className.split(/\s+/).map(function(cls) {
          return "".concat(cls, "-icon");
        }))
      }, children));
    };
    var Input$4 = function Input2(_ref, ref) {
      var _inputNode2, _inputNode2$props;
      var prefixCls = _ref.prefixCls, id2 = _ref.id, inputElement = _ref.inputElement, disabled = _ref.disabled, tabIndex = _ref.tabIndex, autoFocus = _ref.autoFocus, autoComplete = _ref.autoComplete, editable = _ref.editable, activeDescendantId = _ref.activeDescendantId, value = _ref.value, maxLength = _ref.maxLength, _onKeyDown = _ref.onKeyDown, _onMouseDown = _ref.onMouseDown, _onChange = _ref.onChange, onPaste = _ref.onPaste, _onCompositionStart = _ref.onCompositionStart, _onCompositionEnd = _ref.onCompositionEnd, open2 = _ref.open, attrs = _ref.attrs;
      var inputNode = inputElement || /* @__PURE__ */ reactExports.createElement("input", null);
      var _inputNode = inputNode, originRef = _inputNode.ref, originProps = _inputNode.props;
      var onOriginKeyDown = originProps.onKeyDown, onOriginChange = originProps.onChange, onOriginMouseDown = originProps.onMouseDown, onOriginCompositionStart = originProps.onCompositionStart, onOriginCompositionEnd = originProps.onCompositionEnd, style2 = originProps.style;
      warning$5(!("maxLength" in inputNode.props));
      inputNode = /* @__PURE__ */ reactExports.cloneElement(inputNode, _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({
        type: "search"
      }, originProps), {}, {
        // Override over origin props
        id: id2,
        ref: composeRef(ref, originRef),
        disabled,
        tabIndex,
        autoComplete: autoComplete || "off",
        autoFocus,
        className: classNames("".concat(prefixCls, "-selection-search-input"), (_inputNode2 = inputNode) === null || _inputNode2 === void 0 ? void 0 : (_inputNode2$props = _inputNode2.props) === null || _inputNode2$props === void 0 ? void 0 : _inputNode2$props.className),
        role: "combobox",
        "aria-expanded": open2,
        "aria-haspopup": "listbox",
        "aria-owns": "".concat(id2, "_list"),
        "aria-autocomplete": "list",
        "aria-controls": "".concat(id2, "_list"),
        "aria-activedescendant": activeDescendantId
      }, attrs), {}, {
        value: editable ? value : "",
        maxLength,
        readOnly: !editable,
        unselectable: !editable ? "on" : null,
        style: _objectSpread2$3(_objectSpread2$3({}, style2), {}, {
          opacity: editable ? null : 0
        }),
        onKeyDown: function onKeyDown2(event) {
          _onKeyDown(event);
          if (onOriginKeyDown) {
            onOriginKeyDown(event);
          }
        },
        onMouseDown: function onMouseDown(event) {
          _onMouseDown(event);
          if (onOriginMouseDown) {
            onOriginMouseDown(event);
          }
        },
        onChange: function onChange(event) {
          _onChange(event);
          if (onOriginChange) {
            onOriginChange(event);
          }
        },
        onCompositionStart: function onCompositionStart(event) {
          _onCompositionStart(event);
          if (onOriginCompositionStart) {
            onOriginCompositionStart(event);
          }
        },
        onCompositionEnd: function onCompositionEnd(event) {
          _onCompositionEnd(event);
          if (onOriginCompositionEnd) {
            onOriginCompositionEnd(event);
          }
        },
        onPaste
      }));
      return inputNode;
    };
    var RefInput = /* @__PURE__ */ reactExports.forwardRef(Input$4);
    RefInput.displayName = "Input";
    function toArray$6(value) {
      if (Array.isArray(value)) {
        return value;
      }
      return value !== void 0 ? [value] : [];
    }
    var isClient = typeof window !== "undefined" && window.document && window.document.documentElement;
    var isBrowserClient$2 = isClient;
    function hasValue(value) {
      return value !== void 0 && value !== null;
    }
    function isTitleType$1(title) {
      return ["string", "number"].includes(_typeof$4(title));
    }
    function getTitle(item) {
      var title = void 0;
      if (item) {
        if (isTitleType$1(item.title)) {
          title = item.title.toString();
        } else if (isTitleType$1(item.label)) {
          title = item.label.toString();
        }
      }
      return title;
    }
    function useLayoutEffect(effect, deps) {
      if (isBrowserClient$2) {
        reactExports.useLayoutEffect(effect, deps);
      } else {
        reactExports.useEffect(effect, deps);
      }
    }
    function itemKey$1(value) {
      var _value$key;
      return (_value$key = value.key) !== null && _value$key !== void 0 ? _value$key : value.value;
    }
    var onPreventMouseDown = function onPreventMouseDown2(event) {
      event.preventDefault();
      event.stopPropagation();
    };
    var SelectSelector = function SelectSelector2(props) {
      var id2 = props.id, prefixCls = props.prefixCls, values = props.values, open2 = props.open, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, inputRef = props.inputRef, placeholder = props.placeholder, disabled = props.disabled, mode = props.mode, showSearch = props.showSearch, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, tabIndex = props.tabIndex, removeIcon = props.removeIcon, maxTagCount = props.maxTagCount, maxTagTextLength = props.maxTagTextLength, _props$maxTagPlacehol = props.maxTagPlaceholder, maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function(omittedValues) {
        return "+ ".concat(omittedValues.length, " ...");
      } : _props$maxTagPlacehol, tagRender = props.tagRender, onToggleOpen = props.onToggleOpen, onRemove = props.onRemove, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd;
      var measureRef = reactExports.useRef(null);
      var _useState = reactExports.useState(0), _useState2 = _slicedToArray(_useState, 2), inputWidth = _useState2[0], setInputWidth = _useState2[1];
      var _useState3 = reactExports.useState(false), _useState4 = _slicedToArray(_useState3, 2), focused = _useState4[0], setFocused = _useState4[1];
      var selectionPrefixCls = "".concat(prefixCls, "-selection");
      var inputValue = open2 || mode === "multiple" && autoClearSearchValue === false || mode === "tags" ? searchValue : "";
      var inputEditable = mode === "tags" || mode === "multiple" && autoClearSearchValue === false || showSearch && (open2 || focused);
      useLayoutEffect(function() {
        setInputWidth(measureRef.current.scrollWidth);
      }, [inputValue]);
      function defaultRenderSelector(item, content2, itemDisabled, closable, onClose) {
        return /* @__PURE__ */ reactExports.createElement("span", {
          className: classNames("".concat(selectionPrefixCls, "-item"), _defineProperty$7({}, "".concat(selectionPrefixCls, "-item-disabled"), itemDisabled)),
          title: getTitle(item)
        }, /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(selectionPrefixCls, "-item-content")
        }, content2), closable && /* @__PURE__ */ reactExports.createElement(TransBtn, {
          className: "".concat(selectionPrefixCls, "-item-remove"),
          onMouseDown: onPreventMouseDown,
          onClick: onClose,
          customizeIcon: removeIcon
        }, "×"));
      }
      function customizeRenderSelector(value, content2, itemDisabled, closable, onClose) {
        var onMouseDown = function onMouseDown2(e2) {
          onPreventMouseDown(e2);
          onToggleOpen(!open2);
        };
        return /* @__PURE__ */ reactExports.createElement("span", {
          onMouseDown
        }, tagRender({
          label: content2,
          value,
          disabled: itemDisabled,
          closable,
          onClose
        }));
      }
      function renderItem(valueItem) {
        var itemDisabled = valueItem.disabled, label = valueItem.label, value = valueItem.value;
        var closable = !disabled && !itemDisabled;
        var displayLabel = label;
        if (typeof maxTagTextLength === "number") {
          if (typeof label === "string" || typeof label === "number") {
            var strLabel = String(displayLabel);
            if (strLabel.length > maxTagTextLength) {
              displayLabel = "".concat(strLabel.slice(0, maxTagTextLength), "...");
            }
          }
        }
        var onClose = function onClose2(event) {
          if (event)
            event.stopPropagation();
          onRemove(valueItem);
        };
        return typeof tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
      }
      function renderRest(omittedValues) {
        var content2 = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
        return defaultRenderSelector({
          title: content2
        }, content2, false);
      }
      var inputNode = /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(selectionPrefixCls, "-search"),
        style: {
          width: inputWidth
        },
        onFocus: function onFocus() {
          setFocused(true);
        },
        onBlur: function onBlur() {
          setFocused(false);
        }
      }, /* @__PURE__ */ reactExports.createElement(RefInput, {
        ref: inputRef,
        open: open2,
        prefixCls,
        id: id2,
        inputElement: null,
        disabled,
        autoFocus,
        autoComplete,
        editable: inputEditable,
        activeDescendantId,
        value: inputValue,
        onKeyDown: onInputKeyDown,
        onMouseDown: onInputMouseDown,
        onChange: onInputChange,
        onPaste: onInputPaste,
        onCompositionStart: onInputCompositionStart,
        onCompositionEnd: onInputCompositionEnd,
        tabIndex,
        attrs: pickAttrs(props, true)
      }), /* @__PURE__ */ reactExports.createElement("span", {
        ref: measureRef,
        className: "".concat(selectionPrefixCls, "-search-mirror"),
        "aria-hidden": true
      }, inputValue, " "));
      var selectionNode = /* @__PURE__ */ reactExports.createElement(ForwardOverflow, {
        prefixCls: "".concat(selectionPrefixCls, "-overflow"),
        data: values,
        renderItem,
        renderRest,
        suffix: inputNode,
        itemKey: itemKey$1,
        maxCount: maxTagCount
      });
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, selectionNode, !values.length && !inputValue && /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(selectionPrefixCls, "-placeholder")
      }, placeholder));
    };
    var SingleSelector = function SingleSelector2(props) {
      var inputElement = props.inputElement, prefixCls = props.prefixCls, id2 = props.id, inputRef = props.inputRef, disabled = props.disabled, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, mode = props.mode, open2 = props.open, values = props.values, placeholder = props.placeholder, tabIndex = props.tabIndex, showSearch = props.showSearch, searchValue = props.searchValue, activeValue = props.activeValue, maxLength = props.maxLength, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), inputChanged = _React$useState2[0], setInputChanged = _React$useState2[1];
      var combobox = mode === "combobox";
      var inputEditable = combobox || showSearch;
      var item = values[0];
      var inputValue = searchValue || "";
      if (combobox && activeValue && !inputChanged) {
        inputValue = activeValue;
      }
      reactExports.useEffect(function() {
        if (combobox) {
          setInputChanged(false);
        }
      }, [combobox, activeValue]);
      var hasTextInput = mode !== "combobox" && !open2 && !showSearch ? false : !!inputValue;
      var title = getTitle(item);
      var renderPlaceholder = function renderPlaceholder2() {
        if (item) {
          return null;
        }
        var hiddenStyle = hasTextInput ? {
          visibility: "hidden"
        } : void 0;
        return /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(prefixCls, "-selection-placeholder"),
          style: hiddenStyle
        }, placeholder);
      };
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-selection-search")
      }, /* @__PURE__ */ reactExports.createElement(RefInput, {
        ref: inputRef,
        prefixCls,
        id: id2,
        open: open2,
        inputElement,
        disabled,
        autoFocus,
        autoComplete,
        editable: inputEditable,
        activeDescendantId,
        value: inputValue,
        onKeyDown: onInputKeyDown,
        onMouseDown: onInputMouseDown,
        onChange: function onChange(e2) {
          setInputChanged(true);
          onInputChange(e2);
        },
        onPaste: onInputPaste,
        onCompositionStart: onInputCompositionStart,
        onCompositionEnd: onInputCompositionEnd,
        tabIndex,
        attrs: pickAttrs(props, true),
        maxLength: combobox ? maxLength : void 0
      })), !combobox && item && !hasTextInput && /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-selection-item"),
        title
      }, item.label), renderPlaceholder());
    };
    function isValidateOpenKey(currentKeyCode) {
      return ![
        // System function button
        KeyCode.ESC,
        KeyCode.SHIFT,
        KeyCode.BACKSPACE,
        KeyCode.TAB,
        KeyCode.WIN_KEY,
        KeyCode.ALT,
        KeyCode.META,
        KeyCode.WIN_KEY_RIGHT,
        KeyCode.CTRL,
        KeyCode.SEMICOLON,
        KeyCode.EQUALS,
        KeyCode.CAPS_LOCK,
        KeyCode.CONTEXT_MENU,
        // F1-F12
        KeyCode.F1,
        KeyCode.F2,
        KeyCode.F3,
        KeyCode.F4,
        KeyCode.F5,
        KeyCode.F6,
        KeyCode.F7,
        KeyCode.F8,
        KeyCode.F9,
        KeyCode.F10,
        KeyCode.F11,
        KeyCode.F12
      ].includes(currentKeyCode);
    }
    var Selector = function Selector2(props, ref) {
      var inputRef = reactExports.useRef(null);
      var compositionStatusRef = reactExports.useRef(false);
      var prefixCls = props.prefixCls, open2 = props.open, mode = props.mode, showSearch = props.showSearch, tokenWithEnter = props.tokenWithEnter, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSubmit = props.onSearchSubmit, onToggleOpen = props.onToggleOpen, onInputKeyDown = props.onInputKeyDown, domRef = props.domRef;
      reactExports.useImperativeHandle(ref, function() {
        return {
          focus: function focus() {
            inputRef.current.focus();
          },
          blur: function blur() {
            inputRef.current.blur();
          }
        };
      });
      var _useLock = useLock(0), _useLock2 = _slicedToArray(_useLock, 2), getInputMouseDown = _useLock2[0], setInputMouseDown = _useLock2[1];
      var onInternalInputKeyDown = function onInternalInputKeyDown2(event) {
        var which = event.which;
        if (which === KeyCode.UP || which === KeyCode.DOWN) {
          event.preventDefault();
        }
        if (onInputKeyDown) {
          onInputKeyDown(event);
        }
        if (which === KeyCode.ENTER && mode === "tags" && !compositionStatusRef.current && !open2) {
          onSearchSubmit === null || onSearchSubmit === void 0 ? void 0 : onSearchSubmit(event.target.value);
        }
        if (isValidateOpenKey(which)) {
          onToggleOpen(true);
        }
      };
      var onInternalInputMouseDown = function onInternalInputMouseDown2() {
        setInputMouseDown(true);
      };
      var pastedTextRef = reactExports.useRef(null);
      var triggerOnSearch = function triggerOnSearch2(value) {
        if (onSearch(value, true, compositionStatusRef.current) !== false) {
          onToggleOpen(true);
        }
      };
      var onInputCompositionStart = function onInputCompositionStart2() {
        compositionStatusRef.current = true;
      };
      var onInputCompositionEnd = function onInputCompositionEnd2(e2) {
        compositionStatusRef.current = false;
        if (mode !== "combobox") {
          triggerOnSearch(e2.target.value);
        }
      };
      var onInputChange = function onInputChange2(event) {
        var value = event.target.value;
        if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
          var replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
          value = value.replace(replacedText, pastedTextRef.current);
        }
        pastedTextRef.current = null;
        triggerOnSearch(value);
      };
      var onInputPaste = function onInputPaste2(e2) {
        var clipboardData = e2.clipboardData;
        var value = clipboardData.getData("text");
        pastedTextRef.current = value;
      };
      var onClick = function onClick2(_ref) {
        var target = _ref.target;
        if (target !== inputRef.current) {
          var isIE = document.body.style.msTouchAction !== void 0;
          if (isIE) {
            setTimeout(function() {
              inputRef.current.focus();
            });
          } else {
            inputRef.current.focus();
          }
        }
      };
      var onMouseDown = function onMouseDown2(event) {
        var inputMouseDown = getInputMouseDown();
        if (event.target !== inputRef.current && !inputMouseDown && mode !== "combobox") {
          event.preventDefault();
        }
        if (mode !== "combobox" && (!showSearch || !inputMouseDown) || !open2) {
          if (open2 && autoClearSearchValue !== false) {
            onSearch("", true, false);
          }
          onToggleOpen();
        }
      };
      var sharedProps = {
        inputRef,
        onInputKeyDown: onInternalInputKeyDown,
        onInputMouseDown: onInternalInputMouseDown,
        onInputChange,
        onInputPaste,
        onInputCompositionStart,
        onInputCompositionEnd
      };
      var selectNode = mode === "multiple" || mode === "tags" ? /* @__PURE__ */ reactExports.createElement(SelectSelector, _extends$2({}, props, sharedProps)) : /* @__PURE__ */ reactExports.createElement(SingleSelector, _extends$2({}, props, sharedProps));
      return /* @__PURE__ */ reactExports.createElement("div", {
        ref: domRef,
        className: "".concat(prefixCls, "-selector"),
        onClick,
        onMouseDown
      }, selectNode);
    };
    var ForwardSelector = /* @__PURE__ */ reactExports.forwardRef(Selector);
    ForwardSelector.displayName = "Selector";
    var TriggerContext$1 = /* @__PURE__ */ reactExports.createContext(null);
    function toArray$5(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    }
    function useAction(action, showAction, hideAction) {
      var mergedShowAction = toArray$5(showAction !== null && showAction !== void 0 ? showAction : action);
      var mergedHideAction = toArray$5(hideAction !== null && hideAction !== void 0 ? hideAction : action);
      return [new Set(mergedShowAction), new Set(mergedHideAction)];
    }
    function isPointsEq$1() {
      var a1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var a2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var isAlignPoint = arguments.length > 2 ? arguments[2] : void 0;
      if (isAlignPoint) {
        return a1[0] === a2[0];
      }
      return a1[0] === a2[0] && a1[1] === a2[1];
    }
    function getAlignPopupClassName$1(builtinPlacements, prefixCls, align, isAlignPoint) {
      var points = align.points;
      var placements2 = Object.keys(builtinPlacements);
      for (var i2 = 0; i2 < placements2.length; i2 += 1) {
        var _builtinPlacements$pl;
        var placement = placements2[i2];
        if (isPointsEq$1((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {
          return "".concat(prefixCls, "-placement-").concat(placement);
        }
      }
      return "";
    }
    function getMotion$2(prefixCls, motion2, animation, transitionName) {
      if (motion2) {
        return motion2;
      }
      if (animation) {
        return {
          motionName: "".concat(prefixCls, "-").concat(animation)
        };
      }
      if (transitionName) {
        return {
          motionName: transitionName
        };
      }
      return null;
    }
    function getWin(ele) {
      return ele.ownerDocument.defaultView;
    }
    function collectScroller(ele) {
      var scrollerList = [];
      var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;
      var scrollStyle = ["hidden", "scroll", "auto"];
      while (current) {
        var _getWin$getComputedSt = getWin(current).getComputedStyle(current), overflowX = _getWin$getComputedSt.overflowX, overflowY = _getWin$getComputedSt.overflowY;
        if (scrollStyle.includes(overflowX) || scrollStyle.includes(overflowY)) {
          scrollerList.push(current);
        }
        current = current.parentElement;
      }
      return scrollerList;
    }
    function toNum(num) {
      return Number.isNaN(num) ? 1 : num;
    }
    function splitPoints() {
      var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return [points[0], points[1]];
    }
    function getAlignPoint(rect, points) {
      var topBottom = points[0];
      var leftRight = points[1];
      var x2;
      var y2;
      if (topBottom === "t") {
        y2 = rect.y;
      } else if (topBottom === "b") {
        y2 = rect.y + rect.height;
      } else {
        y2 = rect.y + rect.height / 2;
      }
      if (leftRight === "l") {
        x2 = rect.x;
      } else if (leftRight === "r") {
        x2 = rect.x + rect.width;
      } else {
        x2 = rect.x + rect.width / 2;
      }
      return {
        x: x2,
        y: y2
      };
    }
    function reversePoints(points, index2) {
      var reverseMap = {
        t: "b",
        b: "t",
        l: "r",
        r: "l"
      };
      return points.map(function(point2, i2) {
        if (i2 === index2) {
          return reverseMap[point2] || "c";
        }
        return point2;
      }).join("");
    }
    function useAlign(open2, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
      var _React$useState = reactExports.useState({
        ready: false,
        offsetX: 0,
        offsetY: 0,
        arrowX: 0,
        arrowY: 0,
        scaleX: 1,
        scaleY: 1,
        align: builtinPlacements[placement] || {}
      }), _React$useState2 = _slicedToArray(_React$useState, 2), offsetInfo = _React$useState2[0], setOffsetInfo = _React$useState2[1];
      var alignCountRef = reactExports.useRef(0);
      var scrollerList = reactExports.useMemo(function() {
        if (!popupEle) {
          return [];
        }
        return collectScroller(popupEle);
      }, [popupEle]);
      var onAlign = useEvent(function() {
        if (popupEle && target && open2) {
          var popupElement = popupEle;
          var originLeft = popupElement.style.left;
          var originTop = popupElement.style.top;
          var doc = popupElement.ownerDocument;
          var win = getWin(popupElement);
          var placementInfo = builtinPlacements[placement] || popupAlign || {};
          popupElement.style.left = "0";
          popupElement.style.top = "0";
          var targetRect;
          if (Array.isArray(target)) {
            targetRect = {
              x: target[0],
              y: target[1],
              width: 0,
              height: 0
            };
          } else {
            var rect = target.getBoundingClientRect();
            targetRect = {
              x: rect.x,
              y: rect.y,
              width: rect.width,
              height: rect.height
            };
          }
          var popupRect = popupElement.getBoundingClientRect();
          var _win$getComputedStyle = win.getComputedStyle(popupElement), width = _win$getComputedStyle.width, height = _win$getComputedStyle.height;
          var _doc$documentElement = doc.documentElement, clientWidth = _doc$documentElement.clientWidth, clientHeight = _doc$documentElement.clientHeight, scrollWidth = _doc$documentElement.scrollWidth, scrollHeight = _doc$documentElement.scrollHeight, scrollTop = _doc$documentElement.scrollTop, scrollLeft = _doc$documentElement.scrollLeft;
          var popupHeight = popupRect.height;
          var popupWidth = popupRect.width;
          var targetHeight = targetRect.height;
          var targetWidth = targetRect.width;
          var visibleArea = placementInfo.htmlRegion === "scroll" ? (
            // Scroll region should take scrollLeft & scrollTop into account
            {
              left: -scrollLeft,
              top: -scrollTop,
              right: scrollWidth - scrollLeft,
              bottom: scrollHeight - scrollTop
            }
          ) : {
            left: 0,
            top: 0,
            right: clientWidth,
            bottom: clientHeight
          };
          (scrollerList || []).forEach(function(ele) {
            var eleRect = ele.getBoundingClientRect();
            var eleOutHeight = ele.offsetHeight, eleInnerHeight = ele.clientHeight, eleOutWidth = ele.offsetWidth, eleInnerWidth = ele.clientWidth;
            var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
            var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
            var eleScrollWidth = (eleOutWidth - eleInnerWidth) * scaleX;
            var eleScrollHeight = (eleOutHeight - eleInnerHeight) * scaleY;
            var eleRight = eleRect.x + eleRect.width - eleScrollWidth;
            var eleBottom = eleRect.y + eleRect.height - eleScrollHeight;
            visibleArea.left = Math.max(visibleArea.left, eleRect.left);
            visibleArea.top = Math.max(visibleArea.top, eleRect.top);
            visibleArea.right = Math.min(visibleArea.right, eleRight);
            visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
          });
          popupElement.style.left = originLeft;
          popupElement.style.top = originTop;
          var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
          var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
          if (_scaleX === 0 || _scaleY === 0) {
            return;
          }
          var offset2 = placementInfo.offset, targetOffset2 = placementInfo.targetOffset;
          var _ref = offset2 || [], _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], popupOffsetX = _ref2$ === void 0 ? 0 : _ref2$, _ref2$2 = _ref2[1], popupOffsetY = _ref2$2 === void 0 ? 0 : _ref2$2;
          var _ref3 = targetOffset2 || [], _ref4 = _slicedToArray(_ref3, 2), _ref4$ = _ref4[0], targetOffsetX = _ref4$ === void 0 ? 0 : _ref4$, _ref4$2 = _ref4[1], targetOffsetY = _ref4$2 === void 0 ? 0 : _ref4$2;
          targetRect.x += targetOffsetX;
          targetRect.y += targetOffsetY;
          var _ref5 = placementInfo.points || [], _ref6 = _slicedToArray(_ref5, 2), popupPoint = _ref6[0], targetPoint = _ref6[1];
          var targetPoints = splitPoints(targetPoint);
          var popupPoints = splitPoints(popupPoint);
          var targetAlignPoint = getAlignPoint(targetRect, targetPoints);
          var popupAlignPoint = getAlignPoint(popupRect, popupPoints);
          var nextAlignInfo = _objectSpread2$3({}, placementInfo);
          var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
          var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
          var targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
          var popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
          var targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
          var popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
          var overflow = placementInfo.overflow || {};
          var adjustX = overflow.adjustX, adjustY = overflow.adjustY, shiftX = overflow.shiftX, shiftY = overflow.shiftY;
          var supportAdjust = function supportAdjust2(val) {
            if (typeof val === "boolean") {
              return val;
            }
            return val >= 0;
          };
          var nextPopupY = popupRect.y + nextOffsetY;
          var nextPopupBottom = nextPopupY + popupHeight;
          var needAdjustY = supportAdjust(adjustY);
          var sameTB = popupPoints[0] === targetPoints[0];
          if (needAdjustY && popupPoints[0] === "t" && nextPopupBottom > visibleArea.bottom) {
            if (sameTB) {
              nextOffsetY -= popupHeight - targetHeight;
            } else {
              nextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
            }
            nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
          }
          if (needAdjustY && popupPoints[0] === "b" && nextPopupY < visibleArea.top) {
            if (sameTB) {
              nextOffsetY += popupHeight - targetHeight;
            } else {
              nextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
            }
            nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
          }
          var nextPopupX = popupRect.x + nextOffsetX;
          var nextPopupRight = nextPopupX + popupWidth;
          var needAdjustX = supportAdjust(adjustX);
          var sameLR = popupPoints[1] === targetPoints[1];
          if (needAdjustX && popupPoints[1] === "l" && nextPopupRight > visibleArea.right) {
            if (sameLR) {
              nextOffsetX -= popupWidth - targetWidth;
            } else {
              nextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
            }
            nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
          }
          if (needAdjustX && popupPoints[1] === "r" && nextPopupX < visibleArea.left) {
            if (sameLR) {
              nextOffsetX += popupWidth - targetWidth;
            } else {
              nextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
            }
            nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
          }
          var numShiftX = shiftX === true ? 0 : shiftX;
          if (typeof numShiftX === "number") {
            if (nextPopupX < visibleArea.left) {
              nextOffsetX -= nextPopupX - visibleArea.left;
              if (targetRect.x + targetWidth < visibleArea.left + numShiftX) {
                nextOffsetX += targetRect.x - visibleArea.left + targetWidth - numShiftX;
              }
            }
            if (nextPopupRight > visibleArea.right) {
              nextOffsetX -= nextPopupRight - visibleArea.right;
              if (targetRect.x > visibleArea.right - numShiftX) {
                nextOffsetX += targetRect.x - visibleArea.right + numShiftX;
              }
            }
          }
          var numShiftY = shiftY === true ? 0 : shiftY;
          if (typeof numShiftY === "number") {
            if (nextPopupY < visibleArea.top) {
              nextOffsetY -= nextPopupY - visibleArea.top;
              if (targetRect.y + targetHeight < visibleArea.top + numShiftY) {
                nextOffsetY += targetRect.y - visibleArea.top + targetHeight - numShiftY;
              }
            }
            if (nextPopupBottom > visibleArea.bottom) {
              nextOffsetY -= nextPopupBottom - visibleArea.bottom;
              if (targetRect.y > visibleArea.bottom - numShiftY) {
                nextOffsetY += targetRect.y - visibleArea.bottom + numShiftY;
              }
            }
          }
          var popupLeft = popupRect.x + nextOffsetX;
          var popupRight = popupLeft + popupWidth;
          var popupTop = popupRect.y + nextOffsetY;
          var popupBottom = popupTop + popupHeight;
          var targetLeft = targetRect.x;
          var targetRight = targetLeft + targetWidth;
          var targetTop = targetRect.y;
          var targetBottom = targetTop + targetHeight;
          var maxLeft = Math.max(popupLeft, targetLeft);
          var minRight = Math.min(popupRight, targetRight);
          var xCenter = (maxLeft + minRight) / 2;
          var nextArrowX = xCenter - popupLeft;
          var maxTop = Math.max(popupTop, targetTop);
          var minBottom = Math.min(popupBottom, targetBottom);
          var yCenter = (maxTop + minBottom) / 2;
          var nextArrowY = yCenter - popupTop;
          onPopupAlign === null || onPopupAlign === void 0 ? void 0 : onPopupAlign(popupEle, nextAlignInfo);
          setOffsetInfo({
            ready: true,
            offsetX: nextOffsetX / _scaleX,
            offsetY: nextOffsetY / _scaleY,
            arrowX: nextArrowX / _scaleX,
            arrowY: nextArrowY / _scaleY,
            scaleX: _scaleX,
            scaleY: _scaleY,
            align: nextAlignInfo
          });
        }
      });
      var triggerAlign = function triggerAlign2() {
        alignCountRef.current += 1;
        var id2 = alignCountRef.current;
        Promise.resolve().then(function() {
          if (alignCountRef.current === id2) {
            onAlign();
          }
        });
      };
      var resetReady = function resetReady2() {
        setOffsetInfo(function(ori) {
          return _objectSpread2$3(_objectSpread2$3({}, ori), {}, {
            ready: false
          });
        });
      };
      useLayoutEffect$1(resetReady, [placement]);
      useLayoutEffect$1(function() {
        if (!open2) {
          resetReady();
        }
      }, [open2]);
      return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
    }
    function useWatch(open2, target, popup, onAlign) {
      useLayoutEffect$1(function() {
        if (open2 && target && popup) {
          let notifyScroll2 = function() {
            onAlign();
          };
          var notifyScroll = notifyScroll2;
          var targetElement = target;
          var popupElement = popup;
          var targetScrollList = collectScroller(targetElement);
          var popupScrollList = collectScroller(popupElement);
          var win = getWin(popupElement);
          var mergedList = new Set([win].concat(_toConsumableArray(targetScrollList), _toConsumableArray(popupScrollList)));
          mergedList.forEach(function(scroller) {
            scroller.addEventListener("scroll", notifyScroll2, {
              passive: true
            });
          });
          win.addEventListener("resize", notifyScroll2, {
            passive: true
          });
          onAlign();
          return function() {
            mergedList.forEach(function(scroller) {
              scroller.removeEventListener("scroll", notifyScroll2);
              win.removeEventListener("resize", notifyScroll2);
            });
          };
        }
      }, [open2, target, popup]);
    }
    function Arrow(props) {
      var prefixCls = props.prefixCls, align = props.align, _props$arrowX = props.arrowX, arrowX = _props$arrowX === void 0 ? 0 : _props$arrowX, _props$arrowY = props.arrowY, arrowY = _props$arrowY === void 0 ? 0 : _props$arrowY;
      var arrowRef = reactExports.useRef();
      if (!align || !align.points) {
        return null;
      }
      var alignStyle = {
        position: "absolute"
      };
      if (align.autoArrow !== false) {
        var popupPoints = align.points[0];
        var targetPoints = align.points[1];
        var popupTB = popupPoints[0];
        var popupLR = popupPoints[1];
        var targetTB = targetPoints[0];
        var targetLR = targetPoints[1];
        if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
          alignStyle.top = arrowY;
        } else if (popupTB === "t") {
          alignStyle.top = 0;
        } else {
          alignStyle.bottom = 0;
        }
        if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
          alignStyle.left = arrowX;
        } else if (popupLR === "l") {
          alignStyle.left = 0;
        } else {
          alignStyle.right = 0;
        }
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        ref: arrowRef,
        className: "".concat(prefixCls, "-arrow"),
        style: alignStyle
      });
    }
    function Mask$1(props) {
      var prefixCls = props.prefixCls, open2 = props.open, zIndex = props.zIndex, mask = props.mask, motion2 = props.motion;
      if (!mask) {
        return null;
      }
      return /* @__PURE__ */ React.createElement(CSSMotion, _extends$2({}, motion2, {
        motionAppear: true,
        visible: open2,
        removeOnLeave: true
      }), function(_ref) {
        var className = _ref.className;
        return /* @__PURE__ */ React.createElement("div", {
          style: {
            zIndex
          },
          className: classNames("".concat(prefixCls, "-mask"), className)
        });
      });
    }
    var Popup$2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var popup = props.popup, className = props.className, prefixCls = props.prefixCls, style2 = props.style, target = props.target, _onVisibleChanged = props.onVisibleChanged, open2 = props.open, keepDom = props.keepDom, onClick = props.onClick, mask = props.mask, arrow = props.arrow, align = props.align, arrowX = props.arrowX, arrowY = props.arrowY, motion2 = props.motion, maskMotion = props.maskMotion, forceRender = props.forceRender, getPopupContainer = props.getPopupContainer, autoDestroy = props.autoDestroy, Portal2 = props.portal, zIndex = props.zIndex, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, ready = props.ready, offsetX = props.offsetX, offsetY = props.offsetY, onAlign = props.onAlign, onPrepare = props.onPrepare, stretch = props.stretch, targetWidth = props.targetWidth, targetHeight = props.targetHeight;
      var childNode = typeof popup === "function" ? popup() : popup;
      var isNodeVisible = open2 || keepDom;
      var getPopupContainerNeedParams = (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.length) > 0;
      var _React$useState = reactExports.useState(!getPopupContainer || !getPopupContainerNeedParams), _React$useState2 = _slicedToArray(_React$useState, 2), show = _React$useState2[0], setShow = _React$useState2[1];
      useLayoutEffect$1(function() {
        if (!show && getPopupContainerNeedParams && target) {
          setShow(true);
        }
      }, [show, getPopupContainerNeedParams, target]);
      if (!show) {
        return null;
      }
      var offsetStyle = ready || !open2 ? {
        left: offsetX,
        top: offsetY
      } : {
        left: "-1000vw",
        top: "-1000vh"
      };
      var miscStyle = {};
      if (stretch) {
        if (stretch.includes("height") && targetHeight) {
          miscStyle.height = targetHeight;
        } else if (stretch.includes("minHeight") && targetHeight) {
          miscStyle.minHeight = targetHeight;
        }
        if (stretch.includes("width") && targetWidth) {
          miscStyle.width = targetWidth;
        } else if (stretch.includes("minWidth") && targetWidth) {
          miscStyle.minWidth = targetWidth;
        }
      }
      if (!open2) {
        miscStyle.pointerEvents = "none";
      }
      return /* @__PURE__ */ reactExports.createElement(Portal2, {
        open: forceRender || isNodeVisible,
        getContainer: getPopupContainer && function() {
          return getPopupContainer(target);
        },
        autoDestroy
      }, /* @__PURE__ */ reactExports.createElement(Mask$1, {
        prefixCls,
        open: open2,
        zIndex,
        mask,
        motion: maskMotion
      }), /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onAlign,
        disabled: !open2
      }, function(resizeObserverRef) {
        return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$2({
          motionAppear: true,
          motionEnter: true,
          motionLeave: true,
          removeOnLeave: false,
          forceRender,
          leavedClassName: "".concat(prefixCls, "-hidden")
        }, motion2, {
          onAppearPrepare: onPrepare,
          onEnterPrepare: onPrepare,
          visible: open2,
          onVisibleChanged: function onVisibleChanged(nextVisible) {
            var _motion$onVisibleChan;
            motion2 === null || motion2 === void 0 ? void 0 : (_motion$onVisibleChan = motion2.onVisibleChanged) === null || _motion$onVisibleChan === void 0 ? void 0 : _motion$onVisibleChan.call(motion2, nextVisible);
            _onVisibleChanged(nextVisible);
          }
        }), function(_ref, motionRef) {
          var motionClassName = _ref.className, motionStyle = _ref.style;
          var cls = classNames(prefixCls, motionClassName, className);
          return /* @__PURE__ */ reactExports.createElement("div", {
            ref: composeRef(resizeObserverRef, ref, motionRef),
            className: cls,
            style: _objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, offsetStyle), miscStyle), motionStyle), {}, {
              boxSizing: "border-box",
              zIndex
            }, style2),
            onMouseEnter,
            onMouseLeave,
            onClick
          }, arrow && /* @__PURE__ */ reactExports.createElement(Arrow, {
            prefixCls,
            align,
            arrowX,
            arrowY
          }), childNode);
        });
      }));
    });
    var TriggerWrapper = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var children = props.children, getTriggerDOMNode = props.getTriggerDOMNode;
      var canUseRef = supportRef(children);
      var setRef2 = reactExports.useCallback(function(node2) {
        fillRef(ref, getTriggerDOMNode ? getTriggerDOMNode(node2) : node2);
      }, [getTriggerDOMNode]);
      var mergedRef = useComposeRef(setRef2, children.ref);
      return canUseRef ? /* @__PURE__ */ reactExports.cloneElement(children, {
        ref: mergedRef
      }) : children;
    });
    var _excluded$E = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
    function generateTrigger$1() {
      var PortalComponent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Portal$1;
      var Trigger2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
        var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-trigger-popup" : _props$prefixCls, children = props.children, _props$action = props.action, action = _props$action === void 0 ? "hover" : _props$action, showAction = props.showAction, hideAction = props.hideAction, popupVisible = props.popupVisible, defaultPopupVisible = props.defaultPopupVisible, onPopupVisibleChange = props.onPopupVisibleChange, afterPopupVisibleChange = props.afterPopupVisibleChange, mouseEnterDelay = props.mouseEnterDelay, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, focusDelay = props.focusDelay, blurDelay = props.blurDelay, mask = props.mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getPopupContainer = props.getPopupContainer, forceRender = props.forceRender, autoDestroy = props.autoDestroy, destroyPopupOnHide = props.destroyPopupOnHide, popup = props.popup, popupClassName = props.popupClassName, popupStyle = props.popupStyle, popupPlacement = props.popupPlacement, _props$builtinPlaceme = props.builtinPlacements, builtinPlacements = _props$builtinPlaceme === void 0 ? {} : _props$builtinPlaceme, popupAlign = props.popupAlign, zIndex = props.zIndex, stretch = props.stretch, getPopupClassNameFromAlign = props.getPopupClassNameFromAlign, alignPoint2 = props.alignPoint, onPopupClick = props.onPopupClick, onPopupAlign = props.onPopupAlign, arrow = props.arrow, popupMotion = props.popupMotion, maskMotion = props.maskMotion, popupTransitionName = props.popupTransitionName, popupAnimation = props.popupAnimation, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, className = props.className, getTriggerDOMNode = props.getTriggerDOMNode, restProps = _objectWithoutProperties$1(props, _excluded$E);
        var mergedAutoDestroy = autoDestroy || destroyPopupOnHide || false;
        var subPopupElements = reactExports.useRef({});
        var parentContext = reactExports.useContext(TriggerContext$1);
        var context = reactExports.useMemo(function() {
          return {
            registerSubPopup: function registerSubPopup(id3, subPopupEle) {
              subPopupElements.current[id3] = subPopupEle;
              parentContext === null || parentContext === void 0 ? void 0 : parentContext.registerSubPopup(id3, subPopupEle);
            }
          };
        }, [parentContext]);
        var id2 = useId$2();
        var _React$useState = reactExports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), popupEle = _React$useState2[0], setPopupEle = _React$useState2[1];
        var setPopupRef = reactExports.useCallback(function(node2) {
          if (node2 instanceof HTMLElement) {
            setPopupEle(node2);
          }
          parentContext === null || parentContext === void 0 ? void 0 : parentContext.registerSubPopup(id2, node2);
        }, []);
        var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), targetEle = _React$useState4[0], setTargetEle = _React$useState4[1];
        var setTargetRef = reactExports.useCallback(function(node2) {
          if (node2 instanceof HTMLElement) {
            setTargetEle(node2);
          }
        }, []);
        var child = reactExports.Children.only(children);
        var originChildProps = (child === null || child === void 0 ? void 0 : child.props) || {};
        var cloneProps = {};
        var inPopupOrChild = useEvent(function(ele) {
          var childDOM = targetEle;
          return (childDOM === null || childDOM === void 0 ? void 0 : childDOM.contains(ele)) || ele === childDOM || (popupEle === null || popupEle === void 0 ? void 0 : popupEle.contains(ele)) || ele === popupEle || Object.values(subPopupElements.current).some(function(subPopupEle) {
            return subPopupEle.contains(ele) || ele === subPopupEle;
          });
        });
        var mergePopupMotion = getMotion$2(prefixCls, popupMotion, popupAnimation, popupTransitionName);
        var mergeMaskMotion = getMotion$2(prefixCls, maskMotion, maskAnimation, maskTransitionName);
        var _useMergedState = useMergedState(defaultPopupVisible || false, {
          value: popupVisible
        }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedOpen = _useMergedState2[0], setMergedOpen = _useMergedState2[1];
        var openRef = reactExports.useRef(mergedOpen);
        openRef.current = mergedOpen;
        var internalTriggerOpen = useEvent(function(nextOpen) {
          if (mergedOpen !== nextOpen) {
            setMergedOpen(nextOpen);
            onPopupVisibleChange === null || onPopupVisibleChange === void 0 ? void 0 : onPopupVisibleChange(nextOpen);
          }
        });
        var delayRef = reactExports.useRef();
        var clearDelay = function clearDelay2() {
          clearTimeout(delayRef.current);
        };
        var triggerOpen = function triggerOpen2(nextOpen) {
          var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          clearDelay();
          if (delay === 0) {
            internalTriggerOpen(nextOpen);
          } else {
            delayRef.current = setTimeout(function() {
              internalTriggerOpen(nextOpen);
            }, delay * 1e3);
          }
        };
        reactExports.useEffect(function() {
          return clearDelay;
        }, []);
        var _React$useState5 = reactExports.useState(false), _React$useState6 = _slicedToArray(_React$useState5, 2), inMotion = _React$useState6[0], setInMotion = _React$useState6[1];
        var mountRef = reactExports.useRef(true);
        useLayoutEffect$1(function() {
          if (!mountRef.current || mergedOpen) {
            setInMotion(true);
          }
          mountRef.current = true;
        }, [mergedOpen]);
        var _React$useState7 = reactExports.useState(null), _React$useState8 = _slicedToArray(_React$useState7, 2), motionPrepareResolve = _React$useState8[0], setMotionPrepareResolve = _React$useState8[1];
        var _React$useState9 = reactExports.useState([0, 0]), _React$useState10 = _slicedToArray(_React$useState9, 2), mousePos = _React$useState10[0], setMousePos = _React$useState10[1];
        var setMousePosByEvent = function setMousePosByEvent2(event) {
          setMousePos([event.clientX, event.clientY]);
        };
        var _useAlign = useAlign(mergedOpen, popupEle, alignPoint2 ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign), _useAlign2 = _slicedToArray(_useAlign, 9), ready = _useAlign2[0], offsetX = _useAlign2[1], offsetY = _useAlign2[2], arrowX = _useAlign2[3], arrowY = _useAlign2[4], scaleX = _useAlign2[5], scaleY = _useAlign2[6], alignInfo = _useAlign2[7], onAlign = _useAlign2[8];
        var triggerAlign = useEvent(function() {
          if (!inMotion) {
            onAlign();
          }
        });
        useWatch(mergedOpen, targetEle, popupEle, triggerAlign);
        useLayoutEffect$1(function() {
          triggerAlign();
        }, [mousePos]);
        useLayoutEffect$1(function() {
          if (mergedOpen && !(builtinPlacements !== null && builtinPlacements !== void 0 && builtinPlacements[popupPlacement])) {
            triggerAlign();
          }
        }, [JSON.stringify(popupAlign)]);
        var alignedClassName = reactExports.useMemo(function() {
          var baseClassName = getAlignPopupClassName$1(builtinPlacements, prefixCls, alignInfo, alignPoint2);
          return classNames(baseClassName, getPopupClassNameFromAlign === null || getPopupClassNameFromAlign === void 0 ? void 0 : getPopupClassNameFromAlign(alignInfo));
        }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint2]);
        reactExports.useImperativeHandle(ref, function() {
          return {
            forceAlign: triggerAlign
          };
        });
        var onVisibleChanged = function onVisibleChanged2(visible) {
          setInMotion(false);
          onAlign();
          afterPopupVisibleChange === null || afterPopupVisibleChange === void 0 ? void 0 : afterPopupVisibleChange(visible);
        };
        var onPrepare = function onPrepare2() {
          return new Promise(function(resolve) {
            setMotionPrepareResolve(function() {
              return resolve;
            });
          });
        };
        useLayoutEffect$1(function() {
          if (motionPrepareResolve) {
            onAlign();
            motionPrepareResolve();
            setMotionPrepareResolve(null);
          }
        }, [motionPrepareResolve]);
        var _React$useState11 = reactExports.useState(0), _React$useState12 = _slicedToArray(_React$useState11, 2), targetWidth = _React$useState12[0], setTargetWidth = _React$useState12[1];
        var _React$useState13 = reactExports.useState(0), _React$useState14 = _slicedToArray(_React$useState13, 2), targetHeight = _React$useState14[0], setTargetHeight = _React$useState14[1];
        var onTargetResize = function onTargetResize2(_, ele) {
          triggerAlign();
          if (stretch) {
            var rect = ele.getBoundingClientRect();
            setTargetWidth(rect.width);
            setTargetHeight(rect.height);
          }
        };
        var _useAction = useAction(action, showAction, hideAction), _useAction2 = _slicedToArray(_useAction, 2), showActions = _useAction2[0], hideActions = _useAction2[1];
        var wrapperAction = function wrapperAction2(eventName, nextOpen, delay, preEvent) {
          cloneProps[eventName] = function(event) {
            var _originChildProps$eve;
            preEvent === null || preEvent === void 0 ? void 0 : preEvent(event);
            triggerOpen(nextOpen, delay);
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            (_originChildProps$eve = originChildProps[eventName]) === null || _originChildProps$eve === void 0 ? void 0 : _originChildProps$eve.call.apply(_originChildProps$eve, [originChildProps, event].concat(args));
          };
        };
        var clickToShow = showActions.has("click");
        var clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
        if (clickToShow || clickToHide) {
          cloneProps.onClick = function(event) {
            var _originChildProps$onC;
            if (openRef.current && clickToHide) {
              triggerOpen(false);
            } else if (!openRef.current && clickToShow) {
              setMousePosByEvent(event);
              triggerOpen(true);
            }
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            (_originChildProps$onC = originChildProps.onClick) === null || _originChildProps$onC === void 0 ? void 0 : _originChildProps$onC.call.apply(_originChildProps$onC, [originChildProps, event].concat(args));
          };
        }
        reactExports.useEffect(function() {
          if (clickToHide && popupEle && (!mask || maskClosable)) {
            var onWindowClick = function onWindowClick2(_ref) {
              var target = _ref.target;
              if (openRef.current && !inPopupOrChild(target)) {
                triggerOpen(false);
              }
            };
            var win = getWin(popupEle);
            win.addEventListener("click", onWindowClick);
            return function() {
              win.removeEventListener("click", onWindowClick);
            };
          }
        }, [clickToHide, popupEle, mask, maskClosable]);
        var hoverToShow = showActions.has("hover");
        var hoverToHide = hideActions.has("hover");
        var onPopupMouseEnter;
        var onPopupMouseLeave;
        if (hoverToShow) {
          wrapperAction("onMouseEnter", true, mouseEnterDelay, function(event) {
            setMousePosByEvent(event);
          });
          onPopupMouseEnter = function onPopupMouseEnter2() {
            triggerOpen(true, mouseEnterDelay);
          };
          if (alignPoint2) {
            cloneProps.onMouseMove = function(event) {
              var _originChildProps$onM;
              (_originChildProps$onM = originChildProps.onMouseMove) === null || _originChildProps$onM === void 0 ? void 0 : _originChildProps$onM.call(originChildProps, event);
            };
          }
        }
        if (hoverToHide) {
          wrapperAction("onMouseLeave", false, mouseLeaveDelay);
          onPopupMouseLeave = function onPopupMouseLeave2() {
            triggerOpen(false, mouseLeaveDelay);
          };
        }
        if (showActions.has("focus")) {
          wrapperAction("onFocus", true, focusDelay);
        }
        if (hideActions.has("focus")) {
          wrapperAction("onBlur", false, blurDelay);
        }
        if (showActions.has("contextMenu")) {
          cloneProps.onContextMenu = function(event) {
            var _originChildProps$onC2;
            setMousePosByEvent(event);
            triggerOpen(true);
            event.preventDefault();
            for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
              args[_key3 - 1] = arguments[_key3];
            }
            (_originChildProps$onC2 = originChildProps.onContextMenu) === null || _originChildProps$onC2 === void 0 ? void 0 : _originChildProps$onC2.call.apply(_originChildProps$onC2, [originChildProps, event].concat(args));
          };
        }
        if (className) {
          cloneProps.className = classNames(originChildProps.className, className);
        }
        var mergedChildrenProps = _objectSpread2$3(_objectSpread2$3({}, originChildProps), cloneProps);
        var passedProps = {};
        var passedEventList = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
        passedEventList.forEach(function(eventName) {
          if (restProps[eventName]) {
            passedProps[eventName] = function() {
              var _mergedChildrenProps$;
              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }
              (_mergedChildrenProps$ = mergedChildrenProps[eventName]) === null || _mergedChildrenProps$ === void 0 ? void 0 : _mergedChildrenProps$.call.apply(_mergedChildrenProps$, [mergedChildrenProps].concat(args));
              restProps[eventName].apply(restProps, args);
            };
          }
        });
        var triggerNode = /* @__PURE__ */ reactExports.cloneElement(child, _objectSpread2$3(_objectSpread2$3({}, mergedChildrenProps), passedProps));
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
          disabled: !mergedOpen,
          ref: setTargetRef,
          onResize: onTargetResize
        }, /* @__PURE__ */ reactExports.createElement(TriggerWrapper, {
          getTriggerDOMNode
        }, triggerNode)), /* @__PURE__ */ reactExports.createElement(TriggerContext$1.Provider, {
          value: context
        }, /* @__PURE__ */ reactExports.createElement(Popup$2, {
          portal: PortalComponent,
          ref: setPopupRef,
          prefixCls,
          popup,
          className: classNames(popupClassName, alignedClassName),
          style: popupStyle,
          target: targetEle,
          onMouseEnter: onPopupMouseEnter,
          onMouseLeave: onPopupMouseLeave,
          zIndex,
          open: mergedOpen,
          keepDom: inMotion,
          onClick: onPopupClick,
          mask,
          motion: mergePopupMotion,
          maskMotion: mergeMaskMotion,
          onVisibleChanged,
          onPrepare,
          forceRender,
          autoDestroy: mergedAutoDestroy,
          getPopupContainer,
          align: alignInfo,
          arrow,
          ready,
          offsetX,
          offsetY,
          arrowX,
          arrowY,
          onAlign: triggerAlign,
          stretch,
          targetWidth: targetWidth / scaleX,
          targetHeight: targetHeight / scaleY
        })));
      });
      return Trigger2;
    }
    const Trigger$1 = generateTrigger$1(Portal$1);
    var _excluded$D = ["prefixCls", "disabled", "visible", "children", "popupElement", "containerWidth", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"];
    var getBuiltInPlacements = function getBuiltInPlacements2(dropdownMatchSelectWidth) {
      var adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
      return {
        bottomLeft: {
          points: ["tl", "bl"],
          offset: [0, 4],
          overflow: {
            adjustX,
            adjustY: 1
          },
          htmlRegion: "scroll"
        },
        bottomRight: {
          points: ["tr", "br"],
          offset: [0, 4],
          overflow: {
            adjustX,
            adjustY: 1
          },
          htmlRegion: "scroll"
        },
        topLeft: {
          points: ["bl", "tl"],
          offset: [0, -4],
          overflow: {
            adjustX,
            adjustY: 1
          },
          htmlRegion: "scroll"
        },
        topRight: {
          points: ["br", "tr"],
          offset: [0, -4],
          overflow: {
            adjustX,
            adjustY: 1
          },
          htmlRegion: "scroll"
        }
      };
    };
    var SelectTrigger = function SelectTrigger2(props, ref) {
      var prefixCls = props.prefixCls;
      props.disabled;
      var visible = props.visible, children = props.children, popupElement = props.popupElement, containerWidth = props.containerWidth, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, _props$direction = props.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction, placement = props.placement, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, getPopupContainer = props.getPopupContainer, empty2 = props.empty, getTriggerDOMNode = props.getTriggerDOMNode, onPopupVisibleChange = props.onPopupVisibleChange, onPopupMouseEnter = props.onPopupMouseEnter, restProps = _objectWithoutProperties$1(props, _excluded$D);
      var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
      var popupNode = popupElement;
      if (dropdownRender) {
        popupNode = dropdownRender(popupElement);
      }
      var builtInPlacements = reactExports.useMemo(function() {
        return getBuiltInPlacements(dropdownMatchSelectWidth);
      }, [dropdownMatchSelectWidth]);
      var mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName;
      var popupRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, function() {
        return {
          getPopupElement: function getPopupElement() {
            return popupRef.current;
          }
        };
      });
      var popupStyle = _objectSpread2$3({
        minWidth: containerWidth
      }, dropdownStyle);
      if (typeof dropdownMatchSelectWidth === "number") {
        popupStyle.width = dropdownMatchSelectWidth;
      } else if (dropdownMatchSelectWidth) {
        popupStyle.width = containerWidth;
      }
      return /* @__PURE__ */ reactExports.createElement(Trigger$1, _extends$2({}, restProps, {
        showAction: onPopupVisibleChange ? ["click"] : [],
        hideAction: onPopupVisibleChange ? ["click"] : [],
        popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
        builtinPlacements: builtInPlacements,
        prefixCls: dropdownPrefixCls,
        popupTransitionName: mergedTransitionName,
        popup: /* @__PURE__ */ reactExports.createElement("div", {
          ref: popupRef,
          onMouseEnter: onPopupMouseEnter
        }, popupNode),
        popupAlign: dropdownAlign,
        popupVisible: visible,
        getPopupContainer,
        popupClassName: classNames(dropdownClassName, _defineProperty$7({}, "".concat(dropdownPrefixCls, "-empty"), empty2)),
        popupStyle,
        getTriggerDOMNode,
        onPopupVisibleChange
      }), children);
    };
    var RefSelectTrigger = /* @__PURE__ */ reactExports.forwardRef(SelectTrigger);
    RefSelectTrigger.displayName = "SelectTrigger";
    function getKey$1(data2, index2) {
      var key = data2.key;
      var value;
      if ("value" in data2) {
        value = data2.value;
      }
      if (key !== null && key !== void 0) {
        return key;
      }
      if (value !== void 0) {
        return value;
      }
      return "rc-index-key-".concat(index2);
    }
    function fillFieldNames$1(fieldNames, childrenAsData) {
      var _ref = fieldNames || {}, label = _ref.label, value = _ref.value, options = _ref.options;
      return {
        label: label || (childrenAsData ? "children" : "label"),
        value: value || "value",
        options: options || "options"
      };
    }
    function flattenOptions(options) {
      var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fieldNames = _ref2.fieldNames, childrenAsData = _ref2.childrenAsData;
      var flattenList = [];
      var _fillFieldNames = fillFieldNames$1(fieldNames, false), fieldLabel = _fillFieldNames.label, fieldValue = _fillFieldNames.value, fieldOptions = _fillFieldNames.options;
      function dig(list2, isGroupOption) {
        list2.forEach(function(data2) {
          var label = data2[fieldLabel];
          if (isGroupOption || !(fieldOptions in data2)) {
            var value = data2[fieldValue];
            flattenList.push({
              key: getKey$1(data2, flattenList.length),
              groupOption: isGroupOption,
              data: data2,
              label,
              value
            });
          } else {
            var grpLabel = label;
            if (grpLabel === void 0 && childrenAsData) {
              grpLabel = data2.label;
            }
            flattenList.push({
              key: getKey$1(data2, flattenList.length),
              group: true,
              data: data2,
              label: grpLabel
            });
            dig(data2[fieldOptions], true);
          }
        });
      }
      dig(options, false);
      return flattenList;
    }
    function injectPropsWithOption(option) {
      var newOption = _objectSpread2$3({}, option);
      if (!("props" in newOption)) {
        Object.defineProperty(newOption, "props", {
          get: function get2() {
            warningOnce$1(false, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`.");
            return newOption;
          }
        });
      }
      return newOption;
    }
    function getSeparatedContent(text2, tokens) {
      if (!tokens || !tokens.length) {
        return null;
      }
      var match2 = false;
      function separate(str, _ref3) {
        var _ref4 = _toArray(_ref3), token2 = _ref4[0], restTokens = _ref4.slice(1);
        if (!token2) {
          return [str];
        }
        var list3 = str.split(token2);
        match2 = match2 || list3.length > 1;
        return list3.reduce(function(prevList, unitStr) {
          return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));
        }, []).filter(function(unit) {
          return unit;
        });
      }
      var list2 = separate(text2, tokens);
      return match2 ? list2 : null;
    }
    var _excluded$C = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "autoClearSearchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "showArrow", "inputIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"];
    var DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autoFocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex"];
    function isMultiple(mode) {
      return mode === "tags" || mode === "multiple";
    }
    var BaseSelect = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _customizeRawInputEle, _classNames2;
      var id2 = props.id, prefixCls = props.prefixCls, className = props.className, showSearch = props.showSearch, tagRender = props.tagRender, direction = props.direction, omitDomProps = props.omitDomProps, displayValues = props.displayValues, onDisplayValuesChange = props.onDisplayValuesChange, emptyOptions = props.emptyOptions, _props$notFoundConten = props.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? "Not Found" : _props$notFoundConten, onClear = props.onClear, mode = props.mode, disabled = props.disabled, loading = props.loading, getInputElement = props.getInputElement, getRawInputElement = props.getRawInputElement, open2 = props.open, defaultOpen = props.defaultOpen, onDropdownVisibleChange = props.onDropdownVisibleChange, activeValue = props.activeValue, onActiveValueChange = props.onActiveValueChange, activeDescendantId = props.activeDescendantId, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSplit = props.onSearchSplit, tokenSeparators = props.tokenSeparators, allowClear = props.allowClear, showArrow = props.showArrow, inputIcon = props.inputIcon, clearIcon = props.clearIcon, OptionList2 = props.OptionList, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, placement = props.placement, getPopupContainer = props.getPopupContainer, _props$showAction = props.showAction, showAction = _props$showAction === void 0 ? [] : _props$showAction, onFocus = props.onFocus, onBlur = props.onBlur, onKeyUp = props.onKeyUp, onKeyDown2 = props.onKeyDown, onMouseDown = props.onMouseDown, restProps = _objectWithoutProperties$1(props, _excluded$C);
      var multiple = isMultiple(mode);
      var mergedShowSearch = (showSearch !== void 0 ? showSearch : multiple) || mode === "combobox";
      var domProps = _objectSpread2$3({}, restProps);
      DEFAULT_OMIT_PROPS.forEach(function(propName) {
        delete domProps[propName];
      });
      omitDomProps === null || omitDomProps === void 0 ? void 0 : omitDomProps.forEach(function(propName) {
        delete domProps[propName];
      });
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
      reactExports.useEffect(function() {
        setMobile(isMobile());
      }, []);
      var containerRef = reactExports.useRef(null);
      var selectorDomRef = reactExports.useRef(null);
      var triggerRef = reactExports.useRef(null);
      var selectorRef = reactExports.useRef(null);
      var listRef = reactExports.useRef(null);
      var _useDelayReset = useDelayReset(), _useDelayReset2 = _slicedToArray(_useDelayReset, 3), mockFocused = _useDelayReset2[0], setMockFocused = _useDelayReset2[1], cancelSetMockFocused = _useDelayReset2[2];
      reactExports.useImperativeHandle(ref, function() {
        var _selectorRef$current, _selectorRef$current2;
        return {
          focus: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.focus,
          blur: (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 ? void 0 : _selectorRef$current2.blur,
          scrollTo: function scrollTo2(arg) {
            var _listRef$current;
            return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(arg);
          }
        };
      });
      var mergedSearchValue = reactExports.useMemo(function() {
        var _displayValues$;
        if (mode !== "combobox") {
          return searchValue;
        }
        var val = (_displayValues$ = displayValues[0]) === null || _displayValues$ === void 0 ? void 0 : _displayValues$.value;
        return typeof val === "string" || typeof val === "number" ? String(val) : "";
      }, [searchValue, mode, displayValues]);
      var customizeInputElement = mode === "combobox" && typeof getInputElement === "function" && getInputElement() || null;
      var customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
      var customizeRawInputRef = useComposeRef(selectorDomRef, customizeRawInputElement === null || customizeRawInputElement === void 0 ? void 0 : (_customizeRawInputEle = customizeRawInputElement.props) === null || _customizeRawInputEle === void 0 ? void 0 : _customizeRawInputEle.ref);
      var _useMergedState = useMergedState(void 0, {
        defaultValue: defaultOpen,
        value: open2
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), innerOpen = _useMergedState2[0], setInnerOpen = _useMergedState2[1];
      var mergedOpen = innerOpen;
      var emptyListContent = !notFoundContent && emptyOptions;
      if (disabled || emptyListContent && mergedOpen && mode === "combobox") {
        mergedOpen = false;
      }
      var triggerOpen = emptyListContent ? false : mergedOpen;
      var onToggleOpen = reactExports.useCallback(function(newOpen) {
        var nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen;
        if (!disabled) {
          setInnerOpen(nextOpen);
          if (mergedOpen !== nextOpen) {
            onDropdownVisibleChange === null || onDropdownVisibleChange === void 0 ? void 0 : onDropdownVisibleChange(nextOpen);
          }
        }
      }, [disabled, mergedOpen, setInnerOpen, onDropdownVisibleChange]);
      var tokenWithEnter = reactExports.useMemo(function() {
        return (tokenSeparators || []).some(function(tokenSeparator) {
          return ["\n", "\r\n"].includes(tokenSeparator);
        });
      }, [tokenSeparators]);
      var onInternalSearch = function onInternalSearch2(searchText, fromTyping, isCompositing) {
        var ret = true;
        var newSearchText = searchText;
        onActiveValueChange === null || onActiveValueChange === void 0 ? void 0 : onActiveValueChange(null);
        var patchLabels = isCompositing ? null : getSeparatedContent(searchText, tokenSeparators);
        if (mode !== "combobox" && patchLabels) {
          newSearchText = "";
          onSearchSplit === null || onSearchSplit === void 0 ? void 0 : onSearchSplit(patchLabels);
          onToggleOpen(false);
          ret = false;
        }
        if (onSearch && mergedSearchValue !== newSearchText) {
          onSearch(newSearchText, {
            source: fromTyping ? "typing" : "effect"
          });
        }
        return ret;
      };
      var onInternalSearchSubmit = function onInternalSearchSubmit2(searchText) {
        if (!searchText || !searchText.trim()) {
          return;
        }
        onSearch(searchText, {
          source: "submit"
        });
      };
      reactExports.useEffect(function() {
        if (!mergedOpen && !multiple && mode !== "combobox") {
          onInternalSearch("", false, false);
        }
      }, [mergedOpen]);
      reactExports.useEffect(function() {
        if (innerOpen && disabled) {
          setInnerOpen(false);
        }
        if (disabled) {
          setMockFocused(false);
        }
      }, [disabled]);
      var _useLock = useLock(), _useLock2 = _slicedToArray(_useLock, 2), getClearLock = _useLock2[0], setClearLock = _useLock2[1];
      var onInternalKeyDown = function onInternalKeyDown2(event) {
        var clearLock = getClearLock();
        var which = event.which;
        if (which === KeyCode.ENTER) {
          if (mode !== "combobox") {
            event.preventDefault();
          }
          if (!mergedOpen) {
            onToggleOpen(true);
          }
        }
        setClearLock(!!mergedSearchValue);
        if (which === KeyCode.BACKSPACE && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
          var cloneDisplayValues = _toConsumableArray(displayValues);
          var removedDisplayValue = null;
          for (var i2 = cloneDisplayValues.length - 1; i2 >= 0; i2 -= 1) {
            var current = cloneDisplayValues[i2];
            if (!current.disabled) {
              cloneDisplayValues.splice(i2, 1);
              removedDisplayValue = current;
              break;
            }
          }
          if (removedDisplayValue) {
            onDisplayValuesChange(cloneDisplayValues, {
              type: "remove",
              values: [removedDisplayValue]
            });
          }
        }
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        if (mergedOpen && listRef.current) {
          var _listRef$current2;
          (_listRef$current2 = listRef.current).onKeyDown.apply(_listRef$current2, [event].concat(rest));
        }
        onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2.apply(void 0, [event].concat(rest));
      };
      var onInternalKeyUp = function onInternalKeyUp2(event) {
        for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          rest[_key2 - 1] = arguments[_key2];
        }
        if (mergedOpen && listRef.current) {
          var _listRef$current3;
          (_listRef$current3 = listRef.current).onKeyUp.apply(_listRef$current3, [event].concat(rest));
        }
        onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp.apply(void 0, [event].concat(rest));
      };
      var onSelectorRemove = function onSelectorRemove2(val) {
        var newValues = displayValues.filter(function(i2) {
          return i2 !== val;
        });
        onDisplayValuesChange(newValues, {
          type: "remove",
          values: [val]
        });
      };
      var focusRef = reactExports.useRef(false);
      var onContainerFocus = function onContainerFocus2() {
        setMockFocused(true);
        if (!disabled) {
          if (onFocus && !focusRef.current) {
            onFocus.apply(void 0, arguments);
          }
          if (showAction.includes("focus")) {
            onToggleOpen(true);
          }
        }
        focusRef.current = true;
      };
      var onContainerBlur = function onContainerBlur2() {
        setMockFocused(false, function() {
          focusRef.current = false;
          onToggleOpen(false);
        });
        if (disabled) {
          return;
        }
        if (mergedSearchValue) {
          if (mode === "tags") {
            onSearch(mergedSearchValue, {
              source: "submit"
            });
          } else if (mode === "multiple") {
            onSearch("", {
              source: "blur"
            });
          }
        }
        if (onBlur) {
          onBlur.apply(void 0, arguments);
        }
      };
      var activeTimeoutIds = [];
      reactExports.useEffect(function() {
        return function() {
          activeTimeoutIds.forEach(function(timeoutId) {
            return clearTimeout(timeoutId);
          });
          activeTimeoutIds.splice(0, activeTimeoutIds.length);
        };
      }, []);
      var onInternalMouseDown = function onInternalMouseDown2(event) {
        var _triggerRef$current;
        var target = event.target;
        var popupElement = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getPopupElement();
        if (popupElement && popupElement.contains(target)) {
          var timeoutId = setTimeout(function() {
            var index2 = activeTimeoutIds.indexOf(timeoutId);
            if (index2 !== -1) {
              activeTimeoutIds.splice(index2, 1);
            }
            cancelSetMockFocused();
            if (!mobile && !popupElement.contains(document.activeElement)) {
              var _selectorRef$current3;
              (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 ? void 0 : _selectorRef$current3.focus();
            }
          });
          activeTimeoutIds.push(timeoutId);
        }
        for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          restArgs[_key3 - 1] = arguments[_key3];
        }
        onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown.apply(void 0, [event].concat(restArgs));
      };
      var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), containerWidth = _React$useState4[0], setContainerWidth = _React$useState4[1];
      var _React$useState5 = reactExports.useState({}), _React$useState6 = _slicedToArray(_React$useState5, 2), forceUpdate = _React$useState6[1];
      function onPopupMouseEnter() {
        forceUpdate({});
      }
      useLayoutEffect$1(function() {
        if (triggerOpen) {
          var _containerRef$current;
          var newWidth = Math.ceil((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.offsetWidth);
          if (containerWidth !== newWidth && !Number.isNaN(newWidth)) {
            setContainerWidth(newWidth);
          }
        }
      }, [triggerOpen]);
      var onTriggerVisibleChange;
      if (customizeRawInputElement) {
        onTriggerVisibleChange = function onTriggerVisibleChange2(newOpen) {
          onToggleOpen(newOpen);
        };
      }
      useSelectTriggerControl(function() {
        var _triggerRef$current2;
        return [containerRef.current, (_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getPopupElement()];
      }, triggerOpen, onToggleOpen, !!customizeRawInputElement);
      var baseSelectContext = reactExports.useMemo(function() {
        return _objectSpread2$3(_objectSpread2$3({}, props), {}, {
          notFoundContent,
          open: mergedOpen,
          triggerOpen,
          id: id2,
          showSearch: mergedShowSearch,
          multiple,
          toggleOpen: onToggleOpen
        });
      }, [props, notFoundContent, triggerOpen, mergedOpen, id2, mergedShowSearch, multiple, onToggleOpen]);
      var mergedShowArrow = showArrow !== void 0 ? showArrow : loading || !multiple && mode !== "combobox";
      var arrowNode;
      if (mergedShowArrow) {
        arrowNode = /* @__PURE__ */ reactExports.createElement(TransBtn, {
          className: classNames("".concat(prefixCls, "-arrow"), _defineProperty$7({}, "".concat(prefixCls, "-arrow-loading"), loading)),
          customizeIcon: inputIcon,
          customizeIconProps: {
            loading,
            searchValue: mergedSearchValue,
            open: mergedOpen,
            focused: mockFocused,
            showSearch: mergedShowSearch
          }
        });
      }
      var clearNode;
      var onClearMouseDown = function onClearMouseDown2() {
        var _selectorRef$current4;
        onClear === null || onClear === void 0 ? void 0 : onClear();
        (_selectorRef$current4 = selectorRef.current) === null || _selectorRef$current4 === void 0 ? void 0 : _selectorRef$current4.focus();
        onDisplayValuesChange([], {
          type: "clear",
          values: displayValues
        });
        onInternalSearch("", false, false);
      };
      if (!disabled && allowClear && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === "")) {
        clearNode = /* @__PURE__ */ reactExports.createElement(TransBtn, {
          className: "".concat(prefixCls, "-clear"),
          onMouseDown: onClearMouseDown,
          customizeIcon: clearIcon
        }, "×");
      }
      var optionList = /* @__PURE__ */ reactExports.createElement(OptionList2, {
        ref: listRef
      });
      var mergedClassName = classNames(prefixCls, className, (_classNames2 = {}, _defineProperty$7(_classNames2, "".concat(prefixCls, "-focused"), mockFocused), _defineProperty$7(_classNames2, "".concat(prefixCls, "-multiple"), multiple), _defineProperty$7(_classNames2, "".concat(prefixCls, "-single"), !multiple), _defineProperty$7(_classNames2, "".concat(prefixCls, "-allow-clear"), allowClear), _defineProperty$7(_classNames2, "".concat(prefixCls, "-show-arrow"), mergedShowArrow), _defineProperty$7(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$7(_classNames2, "".concat(prefixCls, "-loading"), loading), _defineProperty$7(_classNames2, "".concat(prefixCls, "-open"), mergedOpen), _defineProperty$7(_classNames2, "".concat(prefixCls, "-customize-input"), customizeInputElement), _defineProperty$7(_classNames2, "".concat(prefixCls, "-show-search"), mergedShowSearch), _classNames2));
      var selectorNode = /* @__PURE__ */ reactExports.createElement(RefSelectTrigger, {
        ref: triggerRef,
        disabled,
        prefixCls,
        visible: triggerOpen,
        popupElement: optionList,
        containerWidth,
        animation,
        transitionName,
        dropdownStyle,
        dropdownClassName,
        direction,
        dropdownMatchSelectWidth,
        dropdownRender,
        dropdownAlign,
        placement,
        getPopupContainer,
        empty: emptyOptions,
        getTriggerDOMNode: function getTriggerDOMNode() {
          return selectorDomRef.current;
        },
        onPopupVisibleChange: onTriggerVisibleChange,
        onPopupMouseEnter
      }, customizeRawInputElement ? /* @__PURE__ */ reactExports.cloneElement(customizeRawInputElement, {
        ref: customizeRawInputRef
      }) : /* @__PURE__ */ reactExports.createElement(ForwardSelector, _extends$2({}, props, {
        domRef: selectorDomRef,
        prefixCls,
        inputElement: customizeInputElement,
        ref: selectorRef,
        id: id2,
        showSearch: mergedShowSearch,
        autoClearSearchValue,
        mode,
        activeDescendantId,
        tagRender,
        values: displayValues,
        open: mergedOpen,
        onToggleOpen,
        activeValue,
        searchValue: mergedSearchValue,
        onSearch: onInternalSearch,
        onSearchSubmit: onInternalSearchSubmit,
        onRemove: onSelectorRemove,
        tokenWithEnter
      })));
      var renderNode;
      if (customizeRawInputElement) {
        renderNode = selectorNode;
      } else {
        renderNode = /* @__PURE__ */ reactExports.createElement("div", _extends$2({
          className: mergedClassName
        }, domProps, {
          ref: containerRef,
          onMouseDown: onInternalMouseDown,
          onKeyDown: onInternalKeyDown,
          onKeyUp: onInternalKeyUp,
          onFocus: onContainerFocus,
          onBlur: onContainerBlur
        }), mockFocused && !mergedOpen && /* @__PURE__ */ reactExports.createElement("span", {
          style: {
            width: 0,
            height: 0,
            position: "absolute",
            overflow: "hidden",
            opacity: 0
          },
          "aria-live": "polite"
        }, "".concat(displayValues.map(function(_ref) {
          var label = _ref.label, value = _ref.value;
          return ["number", "string"].includes(_typeof$4(label)) ? label : value;
        }).join(", "))), selectorNode, arrowNode, clearNode);
      }
      return /* @__PURE__ */ reactExports.createElement(BaseSelectContext.Provider, {
        value: baseSelectContext
      }, renderNode);
    });
    const useCache = function(labeledValues, valueOptions) {
      var cacheRef = reactExports.useRef({
        values: /* @__PURE__ */ new Map(),
        options: /* @__PURE__ */ new Map()
      });
      var filledLabeledValues = reactExports.useMemo(function() {
        var _cacheRef$current = cacheRef.current, prevValueCache = _cacheRef$current.values, prevOptionCache = _cacheRef$current.options;
        var patchedValues = labeledValues.map(function(item) {
          if (item.label === void 0) {
            var _prevValueCache$get;
            return _objectSpread2$3(_objectSpread2$3({}, item), {}, {
              label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label
            });
          }
          return item;
        });
        var valueCache = /* @__PURE__ */ new Map();
        var optionCache = /* @__PURE__ */ new Map();
        patchedValues.forEach(function(item) {
          valueCache.set(item.value, item);
          optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
        });
        cacheRef.current.values = valueCache;
        cacheRef.current.options = optionCache;
        return patchedValues;
      }, [labeledValues, valueOptions]);
      var getOption = reactExports.useCallback(function(val) {
        return valueOptions.get(val) || cacheRef.current.options.get(val);
      }, [valueOptions]);
      return [filledLabeledValues, getOption];
    };
    function includes(test, search2) {
      return toArray$6(test).join("").toUpperCase().includes(search2);
    }
    const useFilterOptions = function(options, fieldNames, searchValue, filterOption, optionFilterProp) {
      return reactExports.useMemo(function() {
        if (!searchValue || filterOption === false) {
          return options;
        }
        var fieldOptions = fieldNames.options, fieldLabel = fieldNames.label, fieldValue = fieldNames.value;
        var filteredOptions = [];
        var customizeFilter = typeof filterOption === "function";
        var upperSearch = searchValue.toUpperCase();
        var filterFunc = customizeFilter ? filterOption : function(_, option) {
          if (optionFilterProp) {
            return includes(option[optionFilterProp], upperSearch);
          }
          if (option[fieldOptions]) {
            return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
          }
          return includes(option[fieldValue], upperSearch);
        };
        var wrapOption = customizeFilter ? function(opt) {
          return injectPropsWithOption(opt);
        } : function(opt) {
          return opt;
        };
        options.forEach(function(item) {
          if (item[fieldOptions]) {
            var matchGroup = filterFunc(searchValue, wrapOption(item));
            if (matchGroup) {
              filteredOptions.push(item);
            } else {
              var subOptions = item[fieldOptions].filter(function(subItem) {
                return filterFunc(searchValue, wrapOption(subItem));
              });
              if (subOptions.length) {
                filteredOptions.push(_objectSpread2$3(_objectSpread2$3({}, item), {}, _defineProperty$7({}, fieldOptions, subOptions)));
              }
            }
            return;
          }
          if (filterFunc(searchValue, wrapOption(item))) {
            filteredOptions.push(item);
          }
        });
        return filteredOptions;
      }, [options, filterOption, optionFilterProp, searchValue, fieldNames]);
    };
    var uuid$2 = 0;
    var isBrowserClient$1 = canUseDom$2();
    function getUUID$1() {
      var retId;
      if (isBrowserClient$1) {
        retId = uuid$2;
        uuid$2 += 1;
      } else {
        retId = "TEST_OR_SSR";
      }
      return retId;
    }
    function useId$1(id2) {
      var _React$useState = reactExports.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
      reactExports.useEffect(function() {
        setInnerId("rc_select_".concat(getUUID$1()));
      }, []);
      return id2 || innerId;
    }
    var _excluded$B = ["children", "value"], _excluded2$5 = ["children"];
    function convertNodeToOption(node2) {
      var _ref = node2, key = _ref.key, _ref$props = _ref.props, children = _ref$props.children, value = _ref$props.value, restProps = _objectWithoutProperties$1(_ref$props, _excluded$B);
      return _objectSpread2$3({
        key,
        value: value !== void 0 ? value : key,
        children
      }, restProps);
    }
    function convertChildrenToData(nodes) {
      var optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return toArray$8(nodes).map(function(node2, index2) {
        if (!/* @__PURE__ */ reactExports.isValidElement(node2) || !node2.type) {
          return null;
        }
        var _ref2 = node2, isSelectOptGroup = _ref2.type.isSelectOptGroup, key = _ref2.key, _ref2$props = _ref2.props, children = _ref2$props.children, restProps = _objectWithoutProperties$1(_ref2$props, _excluded2$5);
        if (optionOnly || !isSelectOptGroup) {
          return convertNodeToOption(node2);
        }
        return _objectSpread2$3(_objectSpread2$3({
          key: "__RC_SELECT_GRP__".concat(key === null ? index2 : key, "__"),
          label: key
        }, restProps), {}, {
          options: convertChildrenToData(children)
        });
      }).filter(function(data2) {
        return data2;
      });
    }
    function useOptions(options, children, fieldNames, optionFilterProp, optionLabelProp) {
      return reactExports.useMemo(function() {
        var mergedOptions = options;
        var childrenAsData = !options;
        if (childrenAsData) {
          mergedOptions = convertChildrenToData(children);
        }
        var valueOptions = /* @__PURE__ */ new Map();
        var labelOptions = /* @__PURE__ */ new Map();
        var setLabelOptions = function setLabelOptions2(labelOptionsMap, option, key) {
          if (key && typeof key === "string") {
            labelOptionsMap.set(option[key], option);
          }
        };
        function dig(optionList) {
          var isChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          for (var i2 = 0; i2 < optionList.length; i2 += 1) {
            var option = optionList[i2];
            if (!option[fieldNames.options] || isChildren) {
              valueOptions.set(option[fieldNames.value], option);
              setLabelOptions(labelOptions, option, fieldNames.label);
              setLabelOptions(labelOptions, option, optionFilterProp);
              setLabelOptions(labelOptions, option, optionLabelProp);
            } else {
              dig(option[fieldNames.options], true);
            }
          }
        }
        dig(mergedOptions);
        return {
          options: mergedOptions,
          valueOptions,
          labelOptions
        };
      }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
    }
    function useRefFunc(callback) {
      var funcRef = reactExports.useRef();
      funcRef.current = callback;
      var cacheFn = reactExports.useCallback(function() {
        return funcRef.current.apply(funcRef, arguments);
      }, []);
      return cacheFn;
    }
    var OptGroup = function OptGroup2() {
      return null;
    };
    OptGroup.isSelectOptGroup = true;
    var Option = function Option2() {
      return null;
    };
    Option.isSelectOption = true;
    var Filler = /* @__PURE__ */ reactExports.forwardRef(function(_ref, ref) {
      var height = _ref.height, offset2 = _ref.offset, children = _ref.children, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize, innerProps = _ref.innerProps;
      var outerStyle = {};
      var innerStyle = {
        display: "flex",
        flexDirection: "column"
      };
      if (offset2 !== void 0) {
        outerStyle = {
          height,
          position: "relative",
          overflow: "hidden"
        };
        innerStyle = _objectSpread2$3(_objectSpread2$3({}, innerStyle), {}, {
          transform: "translateY(".concat(offset2, "px)"),
          position: "absolute",
          left: 0,
          right: 0,
          top: 0
        });
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        style: outerStyle
      }, /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: function onResize2(_ref2) {
          var offsetHeight = _ref2.offsetHeight;
          if (offsetHeight && onInnerResize) {
            onInnerResize();
          }
        }
      }, /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        style: innerStyle,
        className: classNames(_defineProperty$7({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
        ref
      }, innerProps), children)));
    });
    Filler.displayName = "Filler";
    var MIN_SIZE = 20;
    function getPageY(e2) {
      return "touches" in e2 ? e2.touches[0].pageY : e2.pageY;
    }
    var ScrollBar = /* @__PURE__ */ function(_React$Component) {
      _inherits(ScrollBar2, _React$Component);
      var _super = _createSuper(ScrollBar2);
      function ScrollBar2() {
        var _this;
        _classCallCheck(this, ScrollBar2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.moveRaf = null;
        _this.scrollbarRef = /* @__PURE__ */ reactExports.createRef();
        _this.thumbRef = /* @__PURE__ */ reactExports.createRef();
        _this.visibleTimeout = null;
        _this.state = {
          dragging: false,
          pageY: null,
          startTop: null,
          visible: false
        };
        _this.delayHidden = function() {
          clearTimeout(_this.visibleTimeout);
          _this.setState({
            visible: true
          });
          _this.visibleTimeout = setTimeout(function() {
            _this.setState({
              visible: false
            });
          }, 2e3);
        };
        _this.onScrollbarTouchStart = function(e2) {
          e2.preventDefault();
        };
        _this.onContainerMouseDown = function(e2) {
          e2.stopPropagation();
          e2.preventDefault();
        };
        _this.patchEvents = function() {
          window.addEventListener("mousemove", _this.onMouseMove);
          window.addEventListener("mouseup", _this.onMouseUp);
          _this.thumbRef.current.addEventListener("touchmove", _this.onMouseMove);
          _this.thumbRef.current.addEventListener("touchend", _this.onMouseUp);
        };
        _this.removeEvents = function() {
          var _this$scrollbarRef$cu;
          window.removeEventListener("mousemove", _this.onMouseMove);
          window.removeEventListener("mouseup", _this.onMouseUp);
          (_this$scrollbarRef$cu = _this.scrollbarRef.current) === null || _this$scrollbarRef$cu === void 0 ? void 0 : _this$scrollbarRef$cu.removeEventListener("touchstart", _this.onScrollbarTouchStart);
          if (_this.thumbRef.current) {
            _this.thumbRef.current.removeEventListener("touchstart", _this.onMouseDown);
            _this.thumbRef.current.removeEventListener("touchmove", _this.onMouseMove);
            _this.thumbRef.current.removeEventListener("touchend", _this.onMouseUp);
          }
          wrapperRaf.cancel(_this.moveRaf);
        };
        _this.onMouseDown = function(e2) {
          var onStartMove = _this.props.onStartMove;
          _this.setState({
            dragging: true,
            pageY: getPageY(e2),
            startTop: _this.getTop()
          });
          onStartMove();
          _this.patchEvents();
          e2.stopPropagation();
          e2.preventDefault();
        };
        _this.onMouseMove = function(e2) {
          var _this$state = _this.state, dragging = _this$state.dragging, pageY = _this$state.pageY, startTop = _this$state.startTop;
          var onScroll = _this.props.onScroll;
          wrapperRaf.cancel(_this.moveRaf);
          if (dragging) {
            var offsetY = getPageY(e2) - pageY;
            var newTop = startTop + offsetY;
            var enableScrollRange = _this.getEnableScrollRange();
            var enableHeightRange = _this.getEnableHeightRange();
            var ptg = enableHeightRange ? newTop / enableHeightRange : 0;
            var newScrollTop = Math.ceil(ptg * enableScrollRange);
            _this.moveRaf = wrapperRaf(function() {
              onScroll(newScrollTop);
            });
          }
        };
        _this.onMouseUp = function() {
          var onStopMove = _this.props.onStopMove;
          _this.setState({
            dragging: false
          });
          onStopMove();
          _this.removeEvents();
        };
        _this.getSpinHeight = function() {
          var _this$props = _this.props, height = _this$props.height, count = _this$props.count;
          var baseHeight = height / count * 10;
          baseHeight = Math.max(baseHeight, MIN_SIZE);
          baseHeight = Math.min(baseHeight, height / 2);
          return Math.floor(baseHeight);
        };
        _this.getEnableScrollRange = function() {
          var _this$props2 = _this.props, scrollHeight = _this$props2.scrollHeight, height = _this$props2.height;
          return scrollHeight - height || 0;
        };
        _this.getEnableHeightRange = function() {
          var height = _this.props.height;
          var spinHeight = _this.getSpinHeight();
          return height - spinHeight || 0;
        };
        _this.getTop = function() {
          var scrollTop = _this.props.scrollTop;
          var enableScrollRange = _this.getEnableScrollRange();
          var enableHeightRange = _this.getEnableHeightRange();
          if (scrollTop === 0 || enableScrollRange === 0) {
            return 0;
          }
          var ptg = scrollTop / enableScrollRange;
          return ptg * enableHeightRange;
        };
        _this.showScroll = function() {
          var _this$props3 = _this.props, height = _this$props3.height, scrollHeight = _this$props3.scrollHeight;
          return scrollHeight > height;
        };
        return _this;
      }
      _createClass(ScrollBar2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.scrollbarRef.current.addEventListener("touchstart", this.onScrollbarTouchStart);
          this.thumbRef.current.addEventListener("touchstart", this.onMouseDown);
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (prevProps.scrollTop !== this.props.scrollTop) {
            this.delayHidden();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.removeEvents();
          clearTimeout(this.visibleTimeout);
        }
      }, {
        key: "render",
        value: (
          // ====================== Render =======================
          function render2() {
            var _this$state2 = this.state, dragging = _this$state2.dragging, visible = _this$state2.visible;
            var prefixCls = this.props.prefixCls;
            var spinHeight = this.getSpinHeight();
            var top = this.getTop();
            var canScroll = this.showScroll();
            var mergedVisible = canScroll && visible;
            return /* @__PURE__ */ reactExports.createElement("div", {
              ref: this.scrollbarRef,
              className: classNames("".concat(prefixCls, "-scrollbar"), _defineProperty$7({}, "".concat(prefixCls, "-scrollbar-show"), canScroll)),
              style: {
                width: 8,
                top: 0,
                bottom: 0,
                right: 0,
                position: "absolute",
                display: mergedVisible ? null : "none"
              },
              onMouseDown: this.onContainerMouseDown,
              onMouseMove: this.delayHidden
            }, /* @__PURE__ */ reactExports.createElement("div", {
              ref: this.thumbRef,
              className: classNames("".concat(prefixCls, "-scrollbar-thumb"), _defineProperty$7({}, "".concat(prefixCls, "-scrollbar-thumb-moving"), dragging)),
              style: {
                width: "100%",
                height: spinHeight,
                top,
                left: 0,
                position: "absolute",
                background: "rgba(0, 0, 0, 0.5)",
                borderRadius: 99,
                cursor: "pointer",
                userSelect: "none"
              },
              onMouseDown: this.onMouseDown
            }));
          }
        )
      }]);
      return ScrollBar2;
    }(reactExports.Component);
    function Item$3(_ref) {
      var children = _ref.children, setRef2 = _ref.setRef;
      var refFunc = reactExports.useCallback(function(node2) {
        setRef2(node2);
      }, []);
      return /* @__PURE__ */ reactExports.cloneElement(children, {
        ref: refFunc
      });
    }
    function useChildren(list2, startIndex, endIndex, setNodeRef, renderFunc, _ref) {
      var getKey2 = _ref.getKey;
      return list2.slice(startIndex, endIndex + 1).map(function(item, index2) {
        var eleIndex = startIndex + index2;
        var node2 = renderFunc(item, eleIndex, {
          // style: status === 'MEASURE_START' ? { visibility: 'hidden' } : {},
        });
        var key = getKey2(item);
        return /* @__PURE__ */ reactExports.createElement(Item$3, {
          key,
          setRef: function setRef2(ele) {
            return setNodeRef(item, ele);
          }
        }, node2);
      });
    }
    var CacheMap = /* @__PURE__ */ function() {
      function CacheMap2() {
        _classCallCheck(this, CacheMap2);
        this.maps = void 0;
        this.maps = /* @__PURE__ */ Object.create(null);
      }
      _createClass(CacheMap2, [{
        key: "set",
        value: function set2(key, value) {
          this.maps[key] = value;
        }
      }, {
        key: "get",
        value: function get2(key) {
          return this.maps[key];
        }
      }]);
      return CacheMap2;
    }();
    function useHeights(getKey2, onItemAdd, onItemRemove) {
      var _React$useState = reactExports.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1];
      var instanceRef = reactExports.useRef(/* @__PURE__ */ new Map());
      var heightsRef = reactExports.useRef(new CacheMap());
      var collectRafRef = reactExports.useRef();
      function cancelRaf() {
        wrapperRaf.cancel(collectRafRef.current);
      }
      function collectHeight() {
        cancelRaf();
        collectRafRef.current = wrapperRaf(function() {
          instanceRef.current.forEach(function(element, key) {
            if (element && element.offsetParent) {
              var htmlElement = findDOMNode(element);
              var offsetHeight = htmlElement.offsetHeight;
              if (heightsRef.current.get(key) !== offsetHeight) {
                heightsRef.current.set(key, htmlElement.offsetHeight);
              }
            }
          });
          setUpdatedMark(function(c2) {
            return c2 + 1;
          });
        });
      }
      function setInstanceRef(item, instance) {
        var key = getKey2(item);
        var origin = instanceRef.current.get(key);
        if (instance) {
          instanceRef.current.set(key, instance);
          collectHeight();
        } else {
          instanceRef.current.delete(key);
        }
        if (!origin !== !instance) {
          if (instance) {
            onItemAdd === null || onItemAdd === void 0 ? void 0 : onItemAdd(item);
          } else {
            onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(item);
          }
        }
      }
      reactExports.useEffect(function() {
        return cancelRaf;
      }, []);
      return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
    }
    function useScrollTo(containerRef, data2, heights, itemHeight, getKey2, collectHeight, syncScrollTop, triggerFlash) {
      var scrollRef = reactExports.useRef();
      return function(arg) {
        if (arg === null || arg === void 0) {
          triggerFlash();
          return;
        }
        wrapperRaf.cancel(scrollRef.current);
        if (typeof arg === "number") {
          syncScrollTop(arg);
        } else if (arg && _typeof$4(arg) === "object") {
          var index2;
          var align = arg.align;
          if ("index" in arg) {
            index2 = arg.index;
          } else {
            index2 = data2.findIndex(function(item) {
              return getKey2(item) === arg.key;
            });
          }
          var _arg$offset = arg.offset, offset2 = _arg$offset === void 0 ? 0 : _arg$offset;
          var syncScroll = function syncScroll2(times, targetAlign) {
            if (times < 0 || !containerRef.current)
              return;
            var height = containerRef.current.clientHeight;
            var needCollectHeight = false;
            var newTargetAlign = targetAlign;
            if (height) {
              var mergedAlign = targetAlign || align;
              var stackTop = 0;
              var itemTop = 0;
              var itemBottom = 0;
              var maxLen = Math.min(data2.length, index2);
              for (var i2 = 0; i2 <= maxLen; i2 += 1) {
                var key = getKey2(data2[i2]);
                itemTop = stackTop;
                var cacheHeight = heights.get(key);
                itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
                stackTop = itemBottom;
                if (i2 === index2 && cacheHeight === void 0) {
                  needCollectHeight = true;
                }
              }
              var targetTop = null;
              switch (mergedAlign) {
                case "top":
                  targetTop = itemTop - offset2;
                  break;
                case "bottom":
                  targetTop = itemBottom - height + offset2;
                  break;
                default: {
                  var scrollTop = containerRef.current.scrollTop;
                  var scrollBottom = scrollTop + height;
                  if (itemTop < scrollTop) {
                    newTargetAlign = "top";
                  } else if (itemBottom > scrollBottom) {
                    newTargetAlign = "bottom";
                  }
                }
              }
              if (targetTop !== null && targetTop !== containerRef.current.scrollTop) {
                syncScrollTop(targetTop);
              }
            }
            scrollRef.current = wrapperRaf(function() {
              if (needCollectHeight) {
                collectHeight();
              }
              syncScroll2(times - 1, newTargetAlign);
            }, 2);
          };
          syncScroll(3);
        }
      };
    }
    function findListDiffIndex(originList, targetList, getKey2) {
      var originLen = originList.length;
      var targetLen = targetList.length;
      var shortList;
      var longList;
      if (originLen === 0 && targetLen === 0) {
        return null;
      }
      if (originLen < targetLen) {
        shortList = originList;
        longList = targetList;
      } else {
        shortList = targetList;
        longList = originList;
      }
      var notExistKey = {
        __EMPTY_ITEM__: true
      };
      function getItemKey(item) {
        if (item !== void 0) {
          return getKey2(item);
        }
        return notExistKey;
      }
      var diffIndex = null;
      var multiple = Math.abs(originLen - targetLen) !== 1;
      for (var i2 = 0; i2 < longList.length; i2 += 1) {
        var shortKey = getItemKey(shortList[i2]);
        var longKey = getItemKey(longList[i2]);
        if (shortKey !== longKey) {
          diffIndex = i2;
          multiple = multiple || shortKey !== getItemKey(longList[i2 + 1]);
          break;
        }
      }
      return diffIndex === null ? null : {
        index: diffIndex,
        multiple
      };
    }
    function useDiffItem(data2, getKey2, onDiff) {
      var _React$useState = reactExports.useState(data2), _React$useState2 = _slicedToArray(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1];
      var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
      reactExports.useEffect(function() {
        var diff = findListDiffIndex(prevData || [], data2 || [], getKey2);
        if ((diff === null || diff === void 0 ? void 0 : diff.index) !== void 0) {
          onDiff === null || onDiff === void 0 ? void 0 : onDiff(diff.index);
          setDiffItem(data2[diff.index]);
        }
        setPrevData(data2);
      }, [data2]);
      return [diffItem];
    }
    var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof$4(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
    const useOriginScroll = function(isScrollAtTop, isScrollAtBottom) {
      var lockRef = reactExports.useRef(false);
      var lockTimeoutRef = reactExports.useRef(null);
      function lockScroll() {
        clearTimeout(lockTimeoutRef.current);
        lockRef.current = true;
        lockTimeoutRef.current = setTimeout(function() {
          lockRef.current = false;
        }, 50);
      }
      var scrollPingRef = reactExports.useRef({
        top: isScrollAtTop,
        bottom: isScrollAtBottom
      });
      scrollPingRef.current.top = isScrollAtTop;
      scrollPingRef.current.bottom = isScrollAtBottom;
      return function(deltaY) {
        var smoothOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var originScroll = (
          // Pass origin wheel when on the top
          deltaY < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom
          deltaY > 0 && scrollPingRef.current.bottom
        );
        if (smoothOffset && originScroll) {
          clearTimeout(lockTimeoutRef.current);
          lockRef.current = false;
        } else if (!originScroll || lockRef.current) {
          lockScroll();
        }
        return !lockRef.current && originScroll;
      };
    };
    function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, onWheelDelta) {
      var offsetRef = reactExports.useRef(0);
      var nextFrameRef = reactExports.useRef(null);
      var wheelValueRef = reactExports.useRef(null);
      var isMouseScrollRef = reactExports.useRef(false);
      var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
      function onWheel(event) {
        if (!inVirtual)
          return;
        wrapperRaf.cancel(nextFrameRef.current);
        var deltaY = event.deltaY;
        offsetRef.current += deltaY;
        wheelValueRef.current = deltaY;
        if (originScroll(deltaY))
          return;
        if (!isFF) {
          event.preventDefault();
        }
        nextFrameRef.current = wrapperRaf(function() {
          var patchMultiple = isMouseScrollRef.current ? 10 : 1;
          onWheelDelta(offsetRef.current * patchMultiple);
          offsetRef.current = 0;
        });
      }
      function onFireFoxScroll(event) {
        if (!inVirtual)
          return;
        isMouseScrollRef.current = event.detail === wheelValueRef.current;
      }
      return [onWheel, onFireFoxScroll];
    }
    var SMOOTH_PTG = 14 / 15;
    function useMobileTouchMove(inVirtual, listRef, callback) {
      var touchedRef = reactExports.useRef(false);
      var touchYRef = reactExports.useRef(0);
      var elementRef = reactExports.useRef(null);
      var intervalRef = reactExports.useRef(null);
      var cleanUpEvents;
      var onTouchMove = function onTouchMove2(e2) {
        if (touchedRef.current) {
          var currentY = Math.ceil(e2.touches[0].pageY);
          var offsetY = touchYRef.current - currentY;
          touchYRef.current = currentY;
          if (callback(offsetY)) {
            e2.preventDefault();
          }
          clearInterval(intervalRef.current);
          intervalRef.current = setInterval(function() {
            offsetY *= SMOOTH_PTG;
            if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
              clearInterval(intervalRef.current);
            }
          }, 16);
        }
      };
      var onTouchEnd = function onTouchEnd2() {
        touchedRef.current = false;
        cleanUpEvents();
      };
      var onTouchStart = function onTouchStart2(e2) {
        cleanUpEvents();
        if (e2.touches.length === 1 && !touchedRef.current) {
          touchedRef.current = true;
          touchYRef.current = Math.ceil(e2.touches[0].pageY);
          elementRef.current = e2.target;
          elementRef.current.addEventListener("touchmove", onTouchMove);
          elementRef.current.addEventListener("touchend", onTouchEnd);
        }
      };
      cleanUpEvents = function cleanUpEvents2() {
        if (elementRef.current) {
          elementRef.current.removeEventListener("touchmove", onTouchMove);
          elementRef.current.removeEventListener("touchend", onTouchEnd);
        }
      };
      useLayoutEffect$1(function() {
        if (inVirtual) {
          listRef.current.addEventListener("touchstart", onTouchStart);
        }
        return function() {
          var _listRef$current;
          (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.removeEventListener("touchstart", onTouchStart);
          cleanUpEvents();
          clearInterval(intervalRef.current);
        };
      }, [inVirtual]);
    }
    var _excluded$A = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "component", "onScroll", "onVisibleChange", "innerProps"];
    var EMPTY_DATA$1 = [];
    var ScrollStyle = {
      overflowY: "auto",
      overflowAnchor: "none"
    };
    function RawList(props, ref) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-virtual-list" : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight, style2 = props.style, data2 = props.data, children = props.children, itemKey2 = props.itemKey, virtual = props.virtual, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, onScroll = props.onScroll, onVisibleChange = props.onVisibleChange, innerProps = props.innerProps, restProps = _objectWithoutProperties$1(props, _excluded$A);
      var useVirtual = !!(virtual !== false && height && itemHeight);
      var inVirtual = useVirtual && data2 && itemHeight * data2.length > height;
      var _useState = reactExports.useState(0), _useState2 = _slicedToArray(_useState, 2), scrollTop = _useState2[0], setScrollTop = _useState2[1];
      var _useState3 = reactExports.useState(false), _useState4 = _slicedToArray(_useState3, 2), scrollMoving = _useState4[0], setScrollMoving = _useState4[1];
      var mergedClassName = classNames(prefixCls, className);
      var mergedData = data2 || EMPTY_DATA$1;
      var componentRef = reactExports.useRef();
      var fillerInnerRef = reactExports.useRef();
      var scrollBarRef = reactExports.useRef();
      var getKey2 = reactExports.useCallback(function(item) {
        if (typeof itemKey2 === "function") {
          return itemKey2(item);
        }
        return item === null || item === void 0 ? void 0 : item[itemKey2];
      }, [itemKey2]);
      var sharedConfig = {
        getKey: getKey2
      };
      function syncScrollTop(newTop) {
        setScrollTop(function(origin) {
          var value;
          if (typeof newTop === "function") {
            value = newTop(origin);
          } else {
            value = newTop;
          }
          var alignedTop = keepInRange(value);
          componentRef.current.scrollTop = alignedTop;
          return alignedTop;
        });
      }
      var rangeRef = reactExports.useRef({
        start: 0,
        end: mergedData.length
      });
      var diffItemRef = reactExports.useRef();
      var _useDiffItem = useDiffItem(mergedData, getKey2), _useDiffItem2 = _slicedToArray(_useDiffItem, 1), diffItem = _useDiffItem2[0];
      diffItemRef.current = diffItem;
      var _useHeights = useHeights(getKey2, null, null), _useHeights2 = _slicedToArray(_useHeights, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3];
      var _React$useMemo = reactExports.useMemo(function() {
        if (!useVirtual) {
          return {
            scrollHeight: void 0,
            start: 0,
            end: mergedData.length - 1,
            offset: void 0
          };
        }
        if (!inVirtual) {
          var _fillerInnerRef$curre;
          return {
            scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
            start: 0,
            end: mergedData.length - 1,
            offset: void 0
          };
        }
        var itemTop = 0;
        var startIndex;
        var startOffset;
        var endIndex;
        var dataLen = mergedData.length;
        for (var i2 = 0; i2 < dataLen; i2 += 1) {
          var item = mergedData[i2];
          var key = getKey2(item);
          var cacheHeight = heights.get(key);
          var currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
          if (currentItemBottom >= scrollTop && startIndex === void 0) {
            startIndex = i2;
            startOffset = itemTop;
          }
          if (currentItemBottom > scrollTop + height && endIndex === void 0) {
            endIndex = i2;
          }
          itemTop = currentItemBottom;
        }
        if (startIndex === void 0) {
          startIndex = 0;
          startOffset = 0;
          endIndex = Math.ceil(height / itemHeight);
        }
        if (endIndex === void 0) {
          endIndex = mergedData.length - 1;
        }
        endIndex = Math.min(endIndex + 1, mergedData.length);
        return {
          scrollHeight: itemTop,
          start: startIndex,
          end: endIndex,
          offset: startOffset
        };
      }, [inVirtual, useVirtual, scrollTop, mergedData, heightUpdatedMark, height]), scrollHeight = _React$useMemo.scrollHeight, start2 = _React$useMemo.start, end2 = _React$useMemo.end, offset2 = _React$useMemo.offset;
      rangeRef.current.start = start2;
      rangeRef.current.end = end2;
      var maxScrollHeight = scrollHeight - height;
      var maxScrollHeightRef = reactExports.useRef(maxScrollHeight);
      maxScrollHeightRef.current = maxScrollHeight;
      function keepInRange(newScrollTop) {
        var newTop = newScrollTop;
        if (!Number.isNaN(maxScrollHeightRef.current)) {
          newTop = Math.min(newTop, maxScrollHeightRef.current);
        }
        newTop = Math.max(newTop, 0);
        return newTop;
      }
      var isScrollAtTop = scrollTop <= 0;
      var isScrollAtBottom = scrollTop >= maxScrollHeight;
      var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
      function onScrollBar(newScrollTop) {
        var newTop = newScrollTop;
        syncScrollTop(newTop);
      }
      function onFallbackScroll(e2) {
        var newScrollTop = e2.currentTarget.scrollTop;
        if (newScrollTop !== scrollTop) {
          syncScrollTop(newScrollTop);
        }
        onScroll === null || onScroll === void 0 ? void 0 : onScroll(e2);
      }
      var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, function(offsetY) {
        syncScrollTop(function(top) {
          var newTop = top + offsetY;
          return newTop;
        });
      }), _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
      useMobileTouchMove(useVirtual, componentRef, function(deltaY, smoothOffset) {
        if (originScroll(deltaY, smoothOffset)) {
          return false;
        }
        onRawWheel({
          preventDefault: function preventDefault() {
          },
          deltaY
        });
        return true;
      });
      useLayoutEffect$1(function() {
        function onMozMousePixelScroll(e2) {
          if (useVirtual) {
            e2.preventDefault();
          }
        }
        componentRef.current.addEventListener("wheel", onRawWheel);
        componentRef.current.addEventListener("DOMMouseScroll", onFireFoxScroll);
        componentRef.current.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
        return function() {
          if (componentRef.current) {
            componentRef.current.removeEventListener("wheel", onRawWheel);
            componentRef.current.removeEventListener("DOMMouseScroll", onFireFoxScroll);
            componentRef.current.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
          }
        };
      }, [useVirtual]);
      var scrollTo2 = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey2, collectHeight, syncScrollTop, function() {
        var _scrollBarRef$current;
        (_scrollBarRef$current = scrollBarRef.current) === null || _scrollBarRef$current === void 0 ? void 0 : _scrollBarRef$current.delayHidden();
      });
      reactExports.useImperativeHandle(ref, function() {
        return {
          scrollTo: scrollTo2
        };
      });
      useLayoutEffect$1(function() {
        if (onVisibleChange) {
          var renderList = mergedData.slice(start2, end2 + 1);
          onVisibleChange(renderList, mergedData);
        }
      }, [start2, end2, mergedData]);
      var listChildren = useChildren(mergedData, start2, end2, setInstanceRef, children, sharedConfig);
      var componentStyle = null;
      if (height) {
        componentStyle = _objectSpread2$3(_defineProperty$7({}, fullHeight ? "height" : "maxHeight", height), ScrollStyle);
        if (useVirtual) {
          componentStyle.overflowY = "hidden";
          if (scrollMoving) {
            componentStyle.pointerEvents = "none";
          }
        }
      }
      return /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        style: _objectSpread2$3(_objectSpread2$3({}, style2), {}, {
          position: "relative"
        }),
        className: mergedClassName
      }, restProps), /* @__PURE__ */ reactExports.createElement(Component, {
        className: "".concat(prefixCls, "-holder"),
        style: componentStyle,
        ref: componentRef,
        onScroll: onFallbackScroll
      }, /* @__PURE__ */ reactExports.createElement(Filler, {
        prefixCls,
        height: scrollHeight,
        offset: offset2,
        onInnerResize: collectHeight,
        ref: fillerInnerRef,
        innerProps
      }, listChildren)), useVirtual && /* @__PURE__ */ reactExports.createElement(ScrollBar, {
        ref: scrollBarRef,
        prefixCls,
        scrollTop,
        height,
        scrollHeight,
        count: mergedData.length,
        onScroll: onScrollBar,
        onStartMove: function onStartMove() {
          setScrollMoving(true);
        },
        onStopMove: function onStopMove() {
          setScrollMoving(false);
        }
      }));
    }
    var List$1 = /* @__PURE__ */ reactExports.forwardRef(RawList);
    List$1.displayName = "List";
    var SelectContext = /* @__PURE__ */ reactExports.createContext(null);
    function isPlatformMac() {
      return /(mac\sos|macintosh)/i.test(navigator.appVersion);
    }
    var _excluded$z = ["disabled", "title", "children", "style", "className"];
    function isTitleType(content2) {
      return typeof content2 === "string" || typeof content2 === "number";
    }
    var OptionList = function OptionList2(_, ref) {
      var _useBaseProps = useBaseProps(), prefixCls = _useBaseProps.prefixCls, id2 = _useBaseProps.id, open2 = _useBaseProps.open, multiple = _useBaseProps.multiple, mode = _useBaseProps.mode, searchValue = _useBaseProps.searchValue, toggleOpen = _useBaseProps.toggleOpen, notFoundContent = _useBaseProps.notFoundContent, onPopupScroll = _useBaseProps.onPopupScroll;
      var _React$useContext = reactExports.useContext(SelectContext), flattenOptions2 = _React$useContext.flattenOptions, onActiveValue = _React$useContext.onActiveValue, defaultActiveFirstOption = _React$useContext.defaultActiveFirstOption, onSelect = _React$useContext.onSelect, menuItemSelectedIcon = _React$useContext.menuItemSelectedIcon, rawValues = _React$useContext.rawValues, fieldNames = _React$useContext.fieldNames, virtual = _React$useContext.virtual, listHeight = _React$useContext.listHeight, listItemHeight = _React$useContext.listItemHeight;
      var itemPrefixCls = "".concat(prefixCls, "-item");
      var memoFlattenOptions = useMemo(function() {
        return flattenOptions2;
      }, [open2, flattenOptions2], function(prev2, next2) {
        return next2[0] && prev2[1] !== next2[1];
      });
      var listRef = reactExports.useRef(null);
      var onListMouseDown = function onListMouseDown2(event) {
        event.preventDefault();
      };
      var scrollIntoView = function scrollIntoView2(args) {
        if (listRef.current) {
          listRef.current.scrollTo(typeof args === "number" ? {
            index: args
          } : args);
        }
      };
      var getEnabledActiveIndex = function getEnabledActiveIndex2(index2) {
        var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        var len = memoFlattenOptions.length;
        for (var i2 = 0; i2 < len; i2 += 1) {
          var current = (index2 + i2 * offset2 + len) % len;
          var _memoFlattenOptions$c = memoFlattenOptions[current], group = _memoFlattenOptions$c.group, data2 = _memoFlattenOptions$c.data;
          if (!group && !data2.disabled) {
            return current;
          }
        }
        return -1;
      };
      var _React$useState = reactExports.useState(function() {
        return getEnabledActiveIndex(0);
      }), _React$useState2 = _slicedToArray(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
      var setActive = function setActive2(index2) {
        var fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        setActiveIndex(index2);
        var info2 = {
          source: fromKeyboard ? "keyboard" : "mouse"
        };
        var flattenItem = memoFlattenOptions[index2];
        if (!flattenItem) {
          onActiveValue(null, -1, info2);
          return;
        }
        onActiveValue(flattenItem.value, index2, info2);
      };
      reactExports.useEffect(function() {
        setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
      }, [memoFlattenOptions.length, searchValue]);
      var isSelected = reactExports.useCallback(function(value) {
        return rawValues.has(value) && mode !== "combobox";
      }, [mode, _toConsumableArray(rawValues).toString(), rawValues.size]);
      reactExports.useEffect(function() {
        var timeoutId = setTimeout(function() {
          if (!multiple && open2 && rawValues.size === 1) {
            var value = Array.from(rawValues)[0];
            var index2 = memoFlattenOptions.findIndex(function(_ref) {
              var data2 = _ref.data;
              return data2.value === value;
            });
            if (index2 !== -1) {
              setActive(index2);
              scrollIntoView(index2);
            }
          }
        });
        if (open2) {
          var _listRef$current;
          (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(void 0);
        }
        return function() {
          return clearTimeout(timeoutId);
        };
      }, [open2, searchValue, flattenOptions2.length]);
      var onSelectValue = function onSelectValue2(value) {
        if (value !== void 0) {
          onSelect(value, {
            selected: !rawValues.has(value)
          });
        }
        if (!multiple) {
          toggleOpen(false);
        }
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          onKeyDown: function onKeyDown2(event) {
            var which = event.which, ctrlKey = event.ctrlKey;
            switch (which) {
              case KeyCode.N:
              case KeyCode.P:
              case KeyCode.UP:
              case KeyCode.DOWN: {
                var offset2 = 0;
                if (which === KeyCode.UP) {
                  offset2 = -1;
                } else if (which === KeyCode.DOWN) {
                  offset2 = 1;
                } else if (isPlatformMac() && ctrlKey) {
                  if (which === KeyCode.N) {
                    offset2 = 1;
                  } else if (which === KeyCode.P) {
                    offset2 = -1;
                  }
                }
                if (offset2 !== 0) {
                  var nextActiveIndex = getEnabledActiveIndex(activeIndex + offset2, offset2);
                  scrollIntoView(nextActiveIndex);
                  setActive(nextActiveIndex, true);
                }
                break;
              }
              case KeyCode.ENTER: {
                var item = memoFlattenOptions[activeIndex];
                if (item && !item.data.disabled) {
                  onSelectValue(item.value);
                } else {
                  onSelectValue(void 0);
                }
                if (open2) {
                  event.preventDefault();
                }
                break;
              }
              case KeyCode.ESC: {
                toggleOpen(false);
                if (open2) {
                  event.stopPropagation();
                }
              }
            }
          },
          onKeyUp: function onKeyUp() {
          },
          scrollTo: function scrollTo2(index2) {
            scrollIntoView(index2);
          }
        };
      });
      if (memoFlattenOptions.length === 0) {
        return /* @__PURE__ */ reactExports.createElement("div", {
          role: "listbox",
          id: "".concat(id2, "_list"),
          className: "".concat(itemPrefixCls, "-empty"),
          onMouseDown: onListMouseDown
        }, notFoundContent);
      }
      var omitFieldNameList = Object.keys(fieldNames).map(function(key) {
        return fieldNames[key];
      });
      var getLabel = function getLabel2(item) {
        return item.label;
      };
      function getItemAriaProps(item, index2) {
        var group = item.group;
        return {
          role: group ? "presentation" : "option",
          id: "".concat(id2, "_list_").concat(index2)
        };
      }
      var renderItem = function renderItem2(index2) {
        var item = memoFlattenOptions[index2];
        if (!item)
          return null;
        var itemData = item.data || {};
        var value = itemData.value;
        var group = item.group;
        var attrs = pickAttrs(itemData, true);
        var mergedLabel = getLabel(item);
        return item ? /* @__PURE__ */ reactExports.createElement("div", _extends$2({
          "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null
        }, attrs, {
          key: index2
        }, getItemAriaProps(item, index2), {
          "aria-selected": isSelected(value)
        }), value) : null;
      };
      var a11yProps = {
        role: "listbox",
        id: "".concat(id2, "_list")
      };
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, virtual && /* @__PURE__ */ reactExports.createElement("div", _extends$2({}, a11yProps, {
        style: {
          height: 0,
          width: 0,
          overflow: "hidden"
        }
      }), renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)), /* @__PURE__ */ reactExports.createElement(List$1, {
        itemKey: "key",
        ref: listRef,
        data: memoFlattenOptions,
        height: listHeight,
        itemHeight: listItemHeight,
        fullHeight: false,
        onMouseDown: onListMouseDown,
        onScroll: onPopupScroll,
        virtual,
        innerProps: virtual ? null : a11yProps
      }, function(item, itemIndex) {
        var _classNames;
        var group = item.group, groupOption = item.groupOption, data2 = item.data, label = item.label, value = item.value;
        var key = data2.key;
        if (group) {
          var _data$title;
          var groupTitle = (_data$title = data2.title) !== null && _data$title !== void 0 ? _data$title : isTitleType(label) ? label.toString() : void 0;
          return /* @__PURE__ */ reactExports.createElement("div", {
            className: classNames(itemPrefixCls, "".concat(itemPrefixCls, "-group")),
            title: groupTitle
          }, label !== void 0 ? label : key);
        }
        var disabled = data2.disabled, title = data2.title;
        data2.children;
        var style2 = data2.style, className = data2.className, otherProps = _objectWithoutProperties$1(data2, _excluded$z);
        var passedProps = omit(otherProps, omitFieldNameList);
        var selected = isSelected(value);
        var optionPrefixCls = "".concat(itemPrefixCls, "-option");
        var optionClassName = classNames(itemPrefixCls, optionPrefixCls, className, (_classNames = {}, _defineProperty$7(_classNames, "".concat(optionPrefixCls, "-grouped"), groupOption), _defineProperty$7(_classNames, "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !disabled), _defineProperty$7(_classNames, "".concat(optionPrefixCls, "-disabled"), disabled), _defineProperty$7(_classNames, "".concat(optionPrefixCls, "-selected"), selected), _classNames));
        var mergedLabel = getLabel(item);
        var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
        var content2 = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
        var optionTitle = isTitleType(content2) ? content2.toString() : void 0;
        if (title !== void 0) {
          optionTitle = title;
        }
        return /* @__PURE__ */ reactExports.createElement("div", _extends$2({}, pickAttrs(passedProps), !virtual ? getItemAriaProps(item, itemIndex) : {}, {
          "aria-selected": selected,
          className: optionClassName,
          title: optionTitle,
          onMouseMove: function onMouseMove() {
            if (activeIndex === itemIndex || disabled) {
              return;
            }
            setActive(itemIndex);
          },
          onClick: function onClick() {
            if (!disabled) {
              onSelectValue(value);
            }
          },
          style: style2
        }), /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(optionPrefixCls, "-content")
        }, content2), /* @__PURE__ */ reactExports.isValidElement(menuItemSelectedIcon) || selected, iconVisible && /* @__PURE__ */ reactExports.createElement(TransBtn, {
          className: "".concat(itemPrefixCls, "-option-state"),
          customizeIcon: menuItemSelectedIcon,
          customizeIconProps: {
            isSelected: selected
          }
        }, selected ? "✓" : null));
      }));
    };
    var RefOptionList = /* @__PURE__ */ reactExports.forwardRef(OptionList);
    RefOptionList.displayName = "OptionList";
    var _excluded$y = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "listHeight", "listItemHeight", "value", "defaultValue", "labelInValue", "onChange"];
    var OMIT_DOM_PROPS = ["inputValue"];
    function isRawValue(value) {
      return !value || _typeof$4(value) !== "object";
    }
    var Select$2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var id2 = props.id, mode = props.mode, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-select" : _props$prefixCls, backfill = props.backfill, fieldNames = props.fieldNames, inputValue = props.inputValue, searchValue = props.searchValue, onSearch = props.onSearch, _props$autoClearSearc = props.autoClearSearchValue, autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc, onSelect = props.onSelect, onDeselect = props.onDeselect, _props$dropdownMatchS = props.dropdownMatchSelectWidth, dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? true : _props$dropdownMatchS, filterOption = props.filterOption, filterSort = props.filterSort, optionFilterProp = props.optionFilterProp, optionLabelProp = props.optionLabelProp, options = props.options, children = props.children, defaultActiveFirstOption = props.defaultActiveFirstOption, menuItemSelectedIcon = props.menuItemSelectedIcon, virtual = props.virtual, _props$listHeight = props.listHeight, listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight, _props$listItemHeight = props.listItemHeight, listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight, value = props.value, defaultValue = props.defaultValue, labelInValue = props.labelInValue, onChange = props.onChange, restProps = _objectWithoutProperties$1(props, _excluded$y);
      var mergedId = useId$1(id2);
      var multiple = isMultiple(mode);
      var childrenAsData = !!(!options && children);
      var mergedFilterOption = reactExports.useMemo(function() {
        if (filterOption === void 0 && mode === "combobox") {
          return false;
        }
        return filterOption;
      }, [filterOption, mode]);
      var mergedFieldNames = reactExports.useMemo(
        function() {
          return fillFieldNames$1(fieldNames, childrenAsData);
        },
        /* eslint-disable react-hooks/exhaustive-deps */
        [
          // We stringify fieldNames to avoid unnecessary re-renders.
          JSON.stringify(fieldNames),
          childrenAsData
        ]
        /* eslint-enable react-hooks/exhaustive-deps */
      );
      var _useMergedState = useMergedState("", {
        value: searchValue !== void 0 ? searchValue : inputValue,
        postState: function postState(search2) {
          return search2 || "";
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedSearchValue = _useMergedState2[0], setSearchValue = _useMergedState2[1];
      var parsedOptions = useOptions(options, children, mergedFieldNames, optionFilterProp, optionLabelProp);
      var valueOptions = parsedOptions.valueOptions, labelOptions = parsedOptions.labelOptions, mergedOptions = parsedOptions.options;
      var convert2LabelValues = reactExports.useCallback(function(draftValues) {
        var valueList = toArray$6(draftValues);
        return valueList.map(function(val) {
          var rawValue;
          var rawLabel;
          var rawKey;
          var rawDisabled;
          var rawTitle;
          if (isRawValue(val)) {
            rawValue = val;
          } else {
            var _val$value;
            rawKey = val.key;
            rawLabel = val.label;
            rawValue = (_val$value = val.value) !== null && _val$value !== void 0 ? _val$value : rawKey;
          }
          var option = valueOptions.get(rawValue);
          if (option) {
            var _option$key;
            if (rawLabel === void 0)
              rawLabel = option === null || option === void 0 ? void 0 : option[optionLabelProp || mergedFieldNames.label];
            if (rawKey === void 0)
              rawKey = (_option$key = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key !== void 0 ? _option$key : rawValue;
            rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
            rawTitle = option === null || option === void 0 ? void 0 : option.title;
          }
          return {
            label: rawLabel,
            value: rawValue,
            key: rawKey,
            disabled: rawDisabled,
            title: rawTitle
          };
        });
      }, [mergedFieldNames, optionLabelProp, valueOptions]);
      var _useMergedState3 = useMergedState(defaultValue, {
        value
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), internalValue = _useMergedState4[0], setInternalValue = _useMergedState4[1];
      var rawLabeledValues = reactExports.useMemo(function() {
        var _values$;
        var values = convert2LabelValues(internalValue);
        if (mode === "combobox" && !((_values$ = values[0]) !== null && _values$ !== void 0 && _values$.value)) {
          return [];
        }
        return values;
      }, [internalValue, convert2LabelValues, mode]);
      var _useCache = useCache(rawLabeledValues, valueOptions), _useCache2 = _slicedToArray(_useCache, 2), mergedValues = _useCache2[0], getMixedOption = _useCache2[1];
      var displayValues = reactExports.useMemo(function() {
        if (!mode && mergedValues.length === 1) {
          var firstValue = mergedValues[0];
          if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
            return [];
          }
        }
        return mergedValues.map(function(item) {
          var _item$label;
          return _objectSpread2$3(_objectSpread2$3({}, item), {}, {
            label: (_item$label = item.label) !== null && _item$label !== void 0 ? _item$label : item.value
          });
        });
      }, [mode, mergedValues]);
      var rawValues = reactExports.useMemo(function() {
        return new Set(mergedValues.map(function(val) {
          return val.value;
        }));
      }, [mergedValues]);
      reactExports.useEffect(function() {
        if (mode === "combobox") {
          var _mergedValues$;
          var strValue = (_mergedValues$ = mergedValues[0]) === null || _mergedValues$ === void 0 ? void 0 : _mergedValues$.value;
          setSearchValue(hasValue(strValue) ? String(strValue) : "");
        }
      }, [mergedValues]);
      var createTagOption = useRefFunc(function(val, label) {
        var _ref;
        var mergedLabel = label !== null && label !== void 0 ? label : val;
        return _ref = {}, _defineProperty$7(_ref, mergedFieldNames.value, val), _defineProperty$7(_ref, mergedFieldNames.label, mergedLabel), _ref;
      });
      var filledTagOptions = reactExports.useMemo(function() {
        if (mode !== "tags") {
          return mergedOptions;
        }
        var cloneOptions = _toConsumableArray(mergedOptions);
        var existOptions = function existOptions2(val) {
          return valueOptions.has(val);
        };
        _toConsumableArray(mergedValues).sort(function(a, b2) {
          return a.value < b2.value ? -1 : 1;
        }).forEach(function(item) {
          var val = item.value;
          if (!existOptions(val)) {
            cloneOptions.push(createTagOption(val, item.label));
          }
        });
        return cloneOptions;
      }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
      var filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, optionFilterProp);
      var filledSearchOptions = reactExports.useMemo(function() {
        if (mode !== "tags" || !mergedSearchValue || filteredOptions.some(function(item) {
          return item[optionFilterProp || "value"] === mergedSearchValue;
        })) {
          return filteredOptions;
        }
        return [createTagOption(mergedSearchValue)].concat(_toConsumableArray(filteredOptions));
      }, [createTagOption, optionFilterProp, mode, filteredOptions, mergedSearchValue]);
      var orderedFilteredOptions = reactExports.useMemo(function() {
        if (!filterSort) {
          return filledSearchOptions;
        }
        return _toConsumableArray(filledSearchOptions).sort(function(a, b2) {
          return filterSort(a, b2);
        });
      }, [filledSearchOptions, filterSort]);
      var displayOptions = reactExports.useMemo(function() {
        return flattenOptions(orderedFilteredOptions, {
          fieldNames: mergedFieldNames,
          childrenAsData
        });
      }, [orderedFilteredOptions, mergedFieldNames, childrenAsData]);
      var triggerChange = function triggerChange2(values) {
        var labeledValues = convert2LabelValues(values);
        setInternalValue(labeledValues);
        if (onChange && // Trigger event only when value changed
        (labeledValues.length !== mergedValues.length || labeledValues.some(function(newVal, index2) {
          var _mergedValues$index;
          return ((_mergedValues$index = mergedValues[index2]) === null || _mergedValues$index === void 0 ? void 0 : _mergedValues$index.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
        }))) {
          var returnValues = labelInValue ? labeledValues : labeledValues.map(function(v2) {
            return v2.value;
          });
          var returnOptions = labeledValues.map(function(v2) {
            return injectPropsWithOption(getMixedOption(v2.value));
          });
          onChange(
            // Value
            multiple ? returnValues : returnValues[0],
            // Option
            multiple ? returnOptions : returnOptions[0]
          );
        }
      };
      var _React$useState = reactExports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), activeValue = _React$useState2[0], setActiveValue = _React$useState2[1];
      var _React$useState3 = reactExports.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), accessibilityIndex = _React$useState4[0], setAccessibilityIndex = _React$useState4[1];
      var mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
      var onActiveValue = reactExports.useCallback(function(active, index2) {
        var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$source = _ref2.source, source = _ref2$source === void 0 ? "keyboard" : _ref2$source;
        setAccessibilityIndex(index2);
        if (backfill && mode === "combobox" && active !== null && source === "keyboard") {
          setActiveValue(String(active));
        }
      }, [backfill, mode]);
      var triggerSelect = function triggerSelect2(val, selected, type2) {
        var getSelectEnt = function getSelectEnt2() {
          var _option$key2;
          var option = getMixedOption(val);
          return [labelInValue ? {
            label: option === null || option === void 0 ? void 0 : option[mergedFieldNames.label],
            value: val,
            key: (_option$key2 = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key2 !== void 0 ? _option$key2 : val
          } : val, injectPropsWithOption(option)];
        };
        if (selected && onSelect) {
          var _getSelectEnt = getSelectEnt(), _getSelectEnt2 = _slicedToArray(_getSelectEnt, 2), wrappedValue = _getSelectEnt2[0], _option = _getSelectEnt2[1];
          onSelect(wrappedValue, _option);
        } else if (!selected && onDeselect && type2 !== "clear") {
          var _getSelectEnt3 = getSelectEnt(), _getSelectEnt4 = _slicedToArray(_getSelectEnt3, 2), _wrappedValue = _getSelectEnt4[0], _option2 = _getSelectEnt4[1];
          onDeselect(_wrappedValue, _option2);
        }
      };
      var onInternalSelect = useRefFunc(function(val, info2) {
        var cloneValues;
        var mergedSelect = multiple ? info2.selected : true;
        if (mergedSelect) {
          cloneValues = multiple ? [].concat(_toConsumableArray(mergedValues), [val]) : [val];
        } else {
          cloneValues = mergedValues.filter(function(v2) {
            return v2.value !== val;
          });
        }
        triggerChange(cloneValues);
        triggerSelect(val, mergedSelect);
        if (mode === "combobox") {
          setActiveValue("");
        } else if (!isMultiple || autoClearSearchValue) {
          setSearchValue("");
          setActiveValue("");
        }
      });
      var onDisplayValuesChange = function onDisplayValuesChange2(nextValues, info2) {
        triggerChange(nextValues);
        var type2 = info2.type, values = info2.values;
        if (type2 === "remove" || type2 === "clear") {
          values.forEach(function(item) {
            triggerSelect(item.value, false, type2);
          });
        }
      };
      var onInternalSearch = function onInternalSearch2(searchText, info2) {
        setSearchValue(searchText);
        setActiveValue(null);
        if (info2.source === "submit") {
          var formatted = (searchText || "").trim();
          if (formatted) {
            var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), [formatted])));
            triggerChange(newRawValues);
            triggerSelect(formatted, true);
            setSearchValue("");
          }
          return;
        }
        if (info2.source !== "blur") {
          if (mode === "combobox") {
            triggerChange(searchText);
          }
          onSearch === null || onSearch === void 0 ? void 0 : onSearch(searchText);
        }
      };
      var onInternalSearchSplit = function onInternalSearchSplit2(words) {
        var patchValues = words;
        if (mode !== "tags") {
          patchValues = words.map(function(word) {
            var opt = labelOptions.get(word);
            return opt === null || opt === void 0 ? void 0 : opt.value;
          }).filter(function(val) {
            return val !== void 0;
          });
        }
        var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), _toConsumableArray(patchValues))));
        triggerChange(newRawValues);
        newRawValues.forEach(function(newRawValue) {
          triggerSelect(newRawValue, true);
        });
      };
      var selectContext = reactExports.useMemo(function() {
        var realVirtual = virtual !== false && dropdownMatchSelectWidth !== false;
        return _objectSpread2$3(_objectSpread2$3({}, parsedOptions), {}, {
          flattenOptions: displayOptions,
          onActiveValue,
          defaultActiveFirstOption: mergedDefaultActiveFirstOption,
          onSelect: onInternalSelect,
          menuItemSelectedIcon,
          rawValues,
          fieldNames: mergedFieldNames,
          virtual: realVirtual,
          listHeight,
          listItemHeight,
          childrenAsData
        });
      }, [parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual, dropdownMatchSelectWidth, listHeight, listItemHeight, childrenAsData]);
      return /* @__PURE__ */ reactExports.createElement(SelectContext.Provider, {
        value: selectContext
      }, /* @__PURE__ */ reactExports.createElement(BaseSelect, _extends$2({}, restProps, {
        // >>> MISC
        id: mergedId,
        prefixCls,
        ref,
        omitDomProps: OMIT_DOM_PROPS,
        mode,
        displayValues,
        onDisplayValuesChange,
        searchValue: mergedSearchValue,
        onSearch: onInternalSearch,
        autoClearSearchValue,
        onSearchSplit: onInternalSearchSplit,
        dropdownMatchSelectWidth,
        OptionList: RefOptionList,
        emptyOptions: !displayOptions.length,
        activeValue,
        activeDescendantId: "".concat(mergedId, "_list_").concat(accessibilityIndex)
      })));
    });
    var TypedSelect = Select$2;
    TypedSelect.Option = Option;
    TypedSelect.OptGroup = OptGroup;
    const Empty$2 = () => {
      const [, token2] = useToken$3();
      const bgColor = new TinyColor(token2.colorBgBase);
      let themeStyle = {};
      if (bgColor.toHsl().l < 0.5) {
        themeStyle = {
          opacity: 0.65
        };
      }
      return /* @__PURE__ */ reactExports.createElement("svg", {
        style: themeStyle,
        width: "184",
        height: "152",
        viewBox: "0 0 184 152",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ reactExports.createElement("g", {
        fill: "none",
        fillRule: "evenodd"
      }, /* @__PURE__ */ reactExports.createElement("g", {
        transform: "translate(24 31.67)"
      }, /* @__PURE__ */ reactExports.createElement("ellipse", {
        fillOpacity: ".8",
        fill: "#F5F5F7",
        cx: "67.797",
        cy: "106.89",
        rx: "67.797",
        ry: "12.668"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
        fill: "#AEB8C2"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
        fill: "url(#linearGradient-1)",
        transform: "translate(13.56)"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
        fill: "#F5F5F7"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
        fill: "#DCE0E6"
      })), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
        fill: "#DCE0E6"
      }), /* @__PURE__ */ reactExports.createElement("g", {
        transform: "translate(149.65 15.383)",
        fill: "#FFF"
      }, /* @__PURE__ */ reactExports.createElement("ellipse", {
        cx: "20.654",
        cy: "3.167",
        rx: "2.849",
        ry: "2.815"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
      }))));
    };
    const DefaultEmptyImg = Empty$2;
    const Simple = () => {
      const [, token2] = useToken$3();
      const {
        colorFill,
        colorFillTertiary,
        colorFillQuaternary,
        colorBgContainer
      } = token2;
      const {
        borderColor,
        shadowColor,
        contentColor
      } = reactExports.useMemo(() => ({
        borderColor: new TinyColor(colorFill).onBackground(colorBgContainer).toHexShortString(),
        shadowColor: new TinyColor(colorFillTertiary).onBackground(colorBgContainer).toHexShortString(),
        contentColor: new TinyColor(colorFillQuaternary).onBackground(colorBgContainer).toHexShortString()
      }), [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]);
      return /* @__PURE__ */ reactExports.createElement("svg", {
        width: "64",
        height: "41",
        viewBox: "0 0 64 41",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ reactExports.createElement("g", {
        transform: "translate(0 1)",
        fill: "none",
        fillRule: "evenodd"
      }, /* @__PURE__ */ reactExports.createElement("ellipse", {
        fill: shadowColor,
        cx: "32",
        cy: "33",
        rx: "32",
        ry: "7"
      }), /* @__PURE__ */ reactExports.createElement("g", {
        fillRule: "nonzero",
        stroke: borderColor
      }, /* @__PURE__ */ reactExports.createElement("path", {
        d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
        fill: contentColor
      }))));
    };
    const SimpleEmptyImg = Simple;
    const genSharedEmptyStyle = (token2) => {
      const {
        componentCls,
        margin,
        marginXS,
        marginXL,
        fontSize,
        lineHeight
      } = token2;
      return {
        [componentCls]: {
          marginInline: marginXS,
          fontSize,
          lineHeight,
          textAlign: "center",
          // 原来 &-image 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeight,
            marginBottom: marginXS,
            opacity: token2.opacityImage,
            img: {
              height: "100%"
            },
            svg: {
              height: "100%",
              margin: "auto"
            }
          },
          [`${componentCls}-description`]: {
            color: token2.colorText
          },
          // 原来 &-footer 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
          [`${componentCls}-footer`]: {
            marginTop: margin
          },
          "&-normal": {
            marginBlock: marginXL,
            color: token2.colorTextDisabled,
            [`${componentCls}-description`]: {
              color: token2.colorTextDisabled
            },
            [`${componentCls}-image`]: {
              height: token2.emptyImgHeightMD
            }
          },
          "&-small": {
            marginBlock: marginXS,
            color: token2.colorTextDisabled,
            [`${componentCls}-image`]: {
              height: token2.emptyImgHeightSM
            }
          }
        }
      };
    };
    const useStyle$u = genComponentStyleHook("Empty", (token2) => {
      const {
        componentCls,
        controlHeightLG
      } = token2;
      const emptyToken = merge$4(token2, {
        emptyImgCls: `${componentCls}-img`,
        emptyImgHeight: controlHeightLG * 2.5,
        emptyImgHeightMD: controlHeightLG,
        emptyImgHeightSM: controlHeightLG * 0.875
      });
      return [genSharedEmptyStyle(emptyToken)];
    });
    var __rest$X = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const defaultEmptyImg = /* @__PURE__ */ reactExports.createElement(DefaultEmptyImg, null);
    const simpleEmptyImg = /* @__PURE__ */ reactExports.createElement(SimpleEmptyImg, null);
    const Empty = (_a) => {
      var {
        className,
        rootClassName,
        prefixCls: customizePrefixCls,
        image: image2 = defaultEmptyImg,
        description,
        children,
        imageStyle
      } = _a, restProps = __rest$X(_a, ["className", "rootClassName", "prefixCls", "image", "description", "children", "imageStyle"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("empty", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$u(prefixCls);
      const [locale2] = useLocale$1("Empty");
      const des = typeof description !== "undefined" ? description : locale2 === null || locale2 === void 0 ? void 0 : locale2.description;
      const alt = typeof des === "string" ? des : "empty";
      let imageNode = null;
      if (typeof image2 === "string") {
        imageNode = /* @__PURE__ */ reactExports.createElement("img", {
          alt,
          src: image2
        });
      } else {
        imageNode = image2;
      }
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        className: classNames(hashId, prefixCls, {
          [`${prefixCls}-normal`]: image2 === simpleEmptyImg,
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, className, rootClassName)
      }, restProps), /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-image`,
        style: imageStyle
      }, imageNode), des && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-description`
      }, des), children && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-footer`
      }, children)));
    };
    Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
    Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
    const Empty$1 = Empty;
    const DefaultRenderEmpty = (props) => {
      const {
        componentName
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefix = getPrefixCls("empty");
      switch (componentName) {
        case "Table":
        case "List":
          return /* @__PURE__ */ React$3.createElement(Empty$1, {
            image: Empty$1.PRESENTED_IMAGE_SIMPLE
          });
        case "Select":
        case "TreeSelect":
        case "Cascader":
        case "Transfer":
        case "Mentions":
          return /* @__PURE__ */ React$3.createElement(Empty$1, {
            image: Empty$1.PRESENTED_IMAGE_SIMPLE,
            className: `${prefix}-small`
          });
        default:
          return /* @__PURE__ */ React$3.createElement(Empty$1, null);
      }
    };
    const DefaultRenderEmpty$1 = DefaultRenderEmpty;
    function getStatusClassNames(prefixCls, status, hasFeedback) {
      return classNames({
        [`${prefixCls}-status-success`]: status === "success",
        [`${prefixCls}-status-warning`]: status === "warning",
        [`${prefixCls}-status-error`]: status === "error",
        [`${prefixCls}-status-validating`]: status === "validating",
        [`${prefixCls}-has-feedback`]: hasFeedback
      });
    }
    const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;
    var CheckOutlined$3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
    const CheckOutlinedSvg = CheckOutlined$3;
    var CheckOutlined$1 = function CheckOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: CheckOutlinedSvg
      }));
    };
    CheckOutlined$1.displayName = "CheckOutlined";
    const CheckOutlined$2 = /* @__PURE__ */ reactExports.forwardRef(CheckOutlined$1);
    var DownOutlined$4 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
    const DownOutlinedSvg = DownOutlined$4;
    var DownOutlined$2 = function DownOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: DownOutlinedSvg
      }));
    };
    DownOutlined$2.displayName = "DownOutlined";
    const DownOutlined$3 = /* @__PURE__ */ reactExports.forwardRef(DownOutlined$2);
    var SearchOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
    const SearchOutlinedSvg = SearchOutlined$2;
    var SearchOutlined = function SearchOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: SearchOutlinedSvg
      }));
    };
    SearchOutlined.displayName = "SearchOutlined";
    const SearchOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(SearchOutlined);
    function getIcons(_ref) {
      let {
        suffixIcon,
        clearIcon,
        menuItemSelectedIcon,
        removeIcon,
        loading,
        multiple,
        hasFeedback,
        prefixCls,
        showArrow,
        feedbackIcon
      } = _ref;
      const mergedClearIcon = clearIcon !== null && clearIcon !== void 0 ? clearIcon : /* @__PURE__ */ reactExports.createElement(CloseCircleFilled$1, null);
      const getSuffixIconNode = (arrowIcon) => /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, showArrow !== false && arrowIcon, hasFeedback && feedbackIcon);
      let mergedSuffixIcon = null;
      if (suffixIcon !== void 0) {
        mergedSuffixIcon = getSuffixIconNode(suffixIcon);
      } else if (loading) {
        mergedSuffixIcon = getSuffixIconNode(/* @__PURE__ */ reactExports.createElement(LoadingOutlined$1, {
          spin: true
        }));
      } else {
        const iconCls = `${prefixCls}-suffix`;
        mergedSuffixIcon = (_ref2) => {
          let {
            open: open2,
            showSearch
          } = _ref2;
          if (open2 && showSearch) {
            return getSuffixIconNode(/* @__PURE__ */ reactExports.createElement(SearchOutlined$1, {
              className: iconCls
            }));
          }
          return getSuffixIconNode(/* @__PURE__ */ reactExports.createElement(DownOutlined$3, {
            className: iconCls
          }));
        };
      }
      let mergedItemIcon = null;
      if (menuItemSelectedIcon !== void 0) {
        mergedItemIcon = menuItemSelectedIcon;
      } else if (multiple) {
        mergedItemIcon = /* @__PURE__ */ reactExports.createElement(CheckOutlined$2, null);
      } else {
        mergedItemIcon = null;
      }
      let mergedRemoveIcon = null;
      if (removeIcon !== void 0) {
        mergedRemoveIcon = removeIcon;
      } else {
        mergedRemoveIcon = /* @__PURE__ */ reactExports.createElement(CloseOutlined$1, null);
      }
      return {
        clearIcon: mergedClearIcon,
        suffixIcon: mergedSuffixIcon,
        itemIcon: mergedItemIcon,
        removeIcon: mergedRemoveIcon
      };
    }
    function genPurePanel(Component, defaultPrefixCls2, getDropdownCls) {
      return function PurePanel2(props) {
        const {
          prefixCls: customizePrefixCls,
          style: style2
        } = props;
        const holderRef = reactExports.useRef(null);
        const [popupHeight, setPopupHeight] = reactExports.useState(0);
        const [popupWidth, setPopupWidth] = reactExports.useState(0);
        const [open2, setOpen] = useMergedState(false, {
          value: props.open
        });
        const {
          getPrefixCls
        } = reactExports.useContext(ConfigContext);
        const prefixCls = getPrefixCls(defaultPrefixCls2 || "select", customizePrefixCls);
        reactExports.useEffect(() => {
          setOpen(true);
          if (typeof ResizeObserver !== "undefined") {
            const resizeObserver2 = new ResizeObserver((entries) => {
              const element = entries[0].target;
              setPopupHeight(element.offsetHeight + 8);
              setPopupWidth(element.offsetWidth);
            });
            const interval = setInterval(() => {
              var _a;
              const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`;
              const popup = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(dropdownCls);
              if (popup) {
                clearInterval(interval);
                resizeObserver2.observe(popup);
              }
            }, 10);
            return () => {
              clearInterval(interval);
              resizeObserver2.disconnect();
            };
          }
        }, []);
        return /* @__PURE__ */ reactExports.createElement(ConfigProvider$1, {
          theme: {
            token: {
              motionDurationFast: "0.01s",
              motionDurationMid: "0.01s",
              motionDurationSlow: "0.01s"
            }
          }
        }, /* @__PURE__ */ reactExports.createElement("div", {
          ref: holderRef,
          style: {
            paddingBottom: popupHeight,
            position: "relative",
            width: "fit-content",
            minWidth: popupWidth
          }
        }, /* @__PURE__ */ reactExports.createElement(Component, Object.assign({}, props, {
          style: Object.assign(Object.assign({}, style2), {
            margin: 0
          }),
          open: open2,
          visible: open2,
          getPopupContainer: () => holderRef.current
        }))));
      };
    }
    const genItemStyle = (token2) => {
      const {
        controlPaddingHorizontal
      } = token2;
      return {
        position: "relative",
        display: "block",
        minHeight: token2.controlHeight,
        padding: `${(token2.controlHeight - token2.fontSize * token2.lineHeight) / 2}px ${controlPaddingHorizontal}px`,
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        boxSizing: "border-box"
      };
    };
    const genSingleStyle$1 = (token2) => {
      const {
        antCls,
        componentCls
      } = token2;
      const selectItemCls = `${componentCls}-item`;
      return [
        {
          [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
            position: "absolute",
            top: -9999,
            zIndex: token2.zIndexPopup,
            boxSizing: "border-box",
            padding: token2.paddingXXS,
            overflow: "hidden",
            fontSize: token2.fontSize,
            // Fix select render lag of long text in chrome
            // https://github.com/ant-design/ant-design/issues/11456
            // https://github.com/ant-design/ant-design/issues/11843
            fontVariant: "initial",
            backgroundColor: token2.colorBgElevated,
            borderRadius: token2.borderRadiusLG,
            outline: "none",
            boxShadow: token2.boxShadowSecondary,
            [`
            &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
            &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft
          `]: {
              animationName: slideUpIn
            },
            [`
            &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
            &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft
          `]: {
              animationName: slideDownIn
            },
            [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft`]: {
              animationName: slideUpOut
            },
            [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft`]: {
              animationName: slideDownOut
            },
            "&-hidden": {
              display: "none"
            },
            "&-empty": {
              color: token2.colorTextDisabled
            },
            // ========================= Options =========================
            [`${selectItemCls}-empty`]: Object.assign(Object.assign({}, genItemStyle(token2)), {
              color: token2.colorTextDisabled
            }),
            [`${selectItemCls}`]: Object.assign(Object.assign({}, genItemStyle(token2)), {
              cursor: "pointer",
              transition: `background ${token2.motionDurationSlow} ease`,
              borderRadius: token2.borderRadiusSM,
              // =========== Group ============
              "&-group": {
                color: token2.colorTextDescription,
                fontSize: token2.fontSizeSM,
                cursor: "default"
              },
              // =========== Option ===========
              "&-option": {
                display: "flex",
                "&-content": Object.assign(Object.assign({
                  flex: "auto"
                }, textEllipsis), {
                  "> *": Object.assign({}, textEllipsis)
                }),
                "&-state": {
                  flex: "none"
                },
                [`&-active:not(${selectItemCls}-option-disabled)`]: {
                  backgroundColor: token2.controlItemBgHover
                },
                [`&-selected:not(${selectItemCls}-option-disabled)`]: {
                  color: token2.colorText,
                  fontWeight: token2.fontWeightStrong,
                  backgroundColor: token2.controlItemBgActive,
                  [`${selectItemCls}-option-state`]: {
                    color: token2.colorPrimary
                  }
                },
                "&-disabled": {
                  [`&${selectItemCls}-option-selected`]: {
                    backgroundColor: token2.colorBgContainerDisabled
                  },
                  color: token2.colorTextDisabled,
                  cursor: "not-allowed"
                },
                "&-grouped": {
                  paddingInlineStart: token2.controlPaddingHorizontal * 2
                }
              }
            }),
            // =========================== RTL ===========================
            "&-rtl": {
              direction: "rtl"
            }
          })
        },
        // Follow code may reuse in other components
        initSlideMotion(token2, "slide-up"),
        initSlideMotion(token2, "slide-down"),
        initMoveMotion(token2, "move-up"),
        initMoveMotion(token2, "move-down")
      ];
    };
    const genDropdownStyle$1 = genSingleStyle$1;
    const FIXED_ITEM_MARGIN = 2;
    function getSelectItemStyle(_ref) {
      let {
        controlHeightSM,
        controlHeight,
        lineWidth: borderWidth
      } = _ref;
      const selectItemDist = (controlHeight - controlHeightSM) / 2 - borderWidth;
      const selectItemMargin = Math.ceil(selectItemDist / 2);
      return [selectItemDist, selectItemMargin];
    }
    function genSizeStyle$4(token2, suffix) {
      const {
        componentCls,
        iconCls
      } = token2;
      const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
      const selectItemHeight = token2.controlHeightSM;
      const [selectItemDist] = getSelectItemStyle(token2);
      const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
      return {
        [`${componentCls}-multiple${suffixCls}`]: {
          fontSize: token2.fontSize,
          /**
           * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
           * may update to redesign with its align logic.
           */
          // =========================== Overflow ===========================
          [selectOverflowPrefixCls]: {
            position: "relative",
            display: "flex",
            flex: "auto",
            flexWrap: "wrap",
            maxWidth: "100%",
            "&-item": {
              flex: "none",
              alignSelf: "center",
              maxWidth: "100%",
              display: "inline-flex"
            }
          },
          // ========================= Selector =========================
          [`${componentCls}-selector`]: {
            display: "flex",
            flexWrap: "wrap",
            alignItems: "center",
            // Multiple is little different that horizontal is follow the vertical
            padding: `${selectItemDist - FIXED_ITEM_MARGIN}px ${FIXED_ITEM_MARGIN * 2}px`,
            borderRadius: token2.borderRadius,
            [`${componentCls}-show-search&`]: {
              cursor: "text"
            },
            [`${componentCls}-disabled&`]: {
              background: token2.colorBgContainerDisabled,
              cursor: "not-allowed"
            },
            "&:after": {
              display: "inline-block",
              width: 0,
              margin: `${FIXED_ITEM_MARGIN}px 0`,
              lineHeight: `${selectItemHeight}px`,
              content: '"\\a0"'
            }
          },
          [`
        &${componentCls}-show-arrow ${componentCls}-selector,
        &${componentCls}-allow-clear ${componentCls}-selector
      `]: {
            paddingInlineEnd: token2.fontSizeIcon + token2.controlPaddingHorizontal
          },
          // ======================== Selections ========================
          [`${componentCls}-selection-item`]: {
            position: "relative",
            display: "flex",
            flex: "none",
            boxSizing: "border-box",
            maxWidth: "100%",
            height: selectItemHeight,
            marginTop: FIXED_ITEM_MARGIN,
            marginBottom: FIXED_ITEM_MARGIN,
            lineHeight: `${selectItemHeight - token2.lineWidth * 2}px`,
            background: token2.colorFillSecondary,
            border: `${token2.lineWidth}px solid ${token2.colorSplit}`,
            borderRadius: token2.borderRadiusSM,
            cursor: "default",
            transition: `font-size ${token2.motionDurationSlow}, line-height ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
            userSelect: "none",
            marginInlineEnd: FIXED_ITEM_MARGIN * 2,
            paddingInlineStart: token2.paddingXS,
            paddingInlineEnd: token2.paddingXS / 2,
            [`${componentCls}-disabled&`]: {
              color: token2.colorTextDisabled,
              borderColor: token2.colorBorder,
              cursor: "not-allowed"
            },
            // It's ok not to do this, but 24px makes bottom narrow in view should adjust
            "&-content": {
              display: "inline-block",
              marginInlineEnd: token2.paddingXS / 2,
              overflow: "hidden",
              whiteSpace: "pre",
              textOverflow: "ellipsis"
            },
            "&-remove": Object.assign(Object.assign({}, resetIcon()), {
              display: "inline-block",
              color: token2.colorIcon,
              fontWeight: "bold",
              fontSize: 10,
              lineHeight: "inherit",
              cursor: "pointer",
              [`> ${iconCls}`]: {
                verticalAlign: "-0.2em"
              },
              "&:hover": {
                color: token2.colorIconHover
              }
            })
          },
          // ========================== Input ==========================
          [`${selectOverflowPrefixCls}-item + ${selectOverflowPrefixCls}-item`]: {
            [`${componentCls}-selection-search`]: {
              marginInlineStart: 0
            }
          },
          [`${componentCls}-selection-search`]: {
            display: "inline-flex",
            position: "relative",
            maxWidth: "100%",
            marginInlineStart: token2.inputPaddingHorizontalBase - selectItemDist,
            [`
          &-input,
          &-mirror
        `]: {
              height: selectItemHeight,
              fontFamily: token2.fontFamily,
              lineHeight: `${selectItemHeight}px`,
              transition: `all ${token2.motionDurationSlow}`
            },
            "&-input": {
              width: "100%",
              minWidth: 4.1
              // fix search cursor missing
            },
            "&-mirror": {
              position: "absolute",
              top: 0,
              insetInlineStart: 0,
              insetInlineEnd: "auto",
              zIndex: 999,
              whiteSpace: "pre",
              visibility: "hidden"
            }
          },
          // ======================= Placeholder =======================
          [`${componentCls}-selection-placeholder `]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: token2.inputPaddingHorizontalBase,
            insetInlineEnd: token2.inputPaddingHorizontalBase,
            transform: "translateY(-50%)",
            transition: `all ${token2.motionDurationSlow}`
          }
        }
      };
    }
    function genMultipleStyle(token2) {
      const {
        componentCls
      } = token2;
      const smallToken = merge$4(token2, {
        controlHeight: token2.controlHeightSM,
        controlHeightSM: token2.controlHeightXS,
        borderRadius: token2.borderRadiusSM,
        borderRadiusSM: token2.borderRadiusXS
      });
      const [, smSelectItemMargin] = getSelectItemStyle(token2);
      return [
        genSizeStyle$4(token2),
        // ======================== Small ========================
        // Shared
        genSizeStyle$4(smallToken, "sm"),
        // Padding
        {
          [`${componentCls}-multiple${componentCls}-sm`]: {
            [`${componentCls}-selection-placeholder`]: {
              insetInline: token2.controlPaddingHorizontalSM - token2.lineWidth
            },
            // https://github.com/ant-design/ant-design/issues/29559
            [`${componentCls}-selection-search`]: {
              marginInlineStart: smSelectItemMargin
            }
          }
        },
        // ======================== Large ========================
        // Shared
        genSizeStyle$4(merge$4(token2, {
          fontSize: token2.fontSizeLG,
          controlHeight: token2.controlHeightLG,
          controlHeightSM: token2.controlHeight,
          borderRadius: token2.borderRadiusLG,
          borderRadiusSM: token2.borderRadius
        }), "lg")
      ];
    }
    function genSizeStyle$3(token2, suffix) {
      const {
        componentCls,
        inputPaddingHorizontalBase,
        borderRadius
      } = token2;
      const selectHeightWithoutBorder = token2.controlHeight - token2.lineWidth * 2;
      const selectionItemPadding = Math.ceil(token2.fontSize * 1.25);
      const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
      return {
        [`${componentCls}-single${suffixCls}`]: {
          fontSize: token2.fontSize,
          // ========================= Selector =========================
          [`${componentCls}-selector`]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
            display: "flex",
            borderRadius,
            [`${componentCls}-selection-search`]: {
              position: "absolute",
              top: 0,
              insetInlineStart: inputPaddingHorizontalBase,
              insetInlineEnd: inputPaddingHorizontalBase,
              bottom: 0,
              "&-input": {
                width: "100%"
              }
            },
            [`
          ${componentCls}-selection-item,
          ${componentCls}-selection-placeholder
        `]: {
              padding: 0,
              lineHeight: `${selectHeightWithoutBorder}px`,
              transition: `all ${token2.motionDurationSlow}`,
              // Firefox inline-block position calculation is not same as Chrome & Safari. Patch this:
              "@supports (-moz-appearance: meterbar)": {
                lineHeight: `${selectHeightWithoutBorder}px`
              }
            },
            [`${componentCls}-selection-item`]: {
              position: "relative",
              userSelect: "none"
            },
            [`${componentCls}-selection-placeholder`]: {
              transition: "none",
              pointerEvents: "none"
            },
            // For common baseline align
            [[
              "&:after",
              /* For '' value baseline align */
              `${componentCls}-selection-item:after`,
              /* For undefined value baseline align */
              `${componentCls}-selection-placeholder:after`
            ].join(",")]: {
              display: "inline-block",
              width: 0,
              visibility: "hidden",
              content: '"\\a0"'
            }
          }),
          [`
        &${componentCls}-show-arrow ${componentCls}-selection-item,
        &${componentCls}-show-arrow ${componentCls}-selection-placeholder
      `]: {
            paddingInlineEnd: selectionItemPadding
          },
          // Opacity selection if open
          [`&${componentCls}-open ${componentCls}-selection-item`]: {
            color: token2.colorTextPlaceholder
          },
          // ========================== Input ==========================
          // We only change the style of non-customize input which is only support by `combobox` mode.
          // Not customize
          [`&:not(${componentCls}-customize-input)`]: {
            [`${componentCls}-selector`]: {
              width: "100%",
              height: token2.controlHeight,
              padding: `0 ${inputPaddingHorizontalBase}px`,
              [`${componentCls}-selection-search-input`]: {
                height: selectHeightWithoutBorder
              },
              "&:after": {
                lineHeight: `${selectHeightWithoutBorder}px`
              }
            }
          },
          [`&${componentCls}-customize-input`]: {
            [`${componentCls}-selector`]: {
              "&:after": {
                display: "none"
              },
              [`${componentCls}-selection-search`]: {
                position: "static",
                width: "100%"
              },
              [`${componentCls}-selection-placeholder`]: {
                position: "absolute",
                insetInlineStart: 0,
                insetInlineEnd: 0,
                padding: `0 ${inputPaddingHorizontalBase}px`,
                "&:after": {
                  display: "none"
                }
              }
            }
          }
        }
      };
    }
    function genSingleStyle(token2) {
      const {
        componentCls
      } = token2;
      const inputPaddingHorizontalSM = token2.controlPaddingHorizontalSM - token2.lineWidth;
      return [
        genSizeStyle$3(token2),
        // ======================== Small ========================
        // Shared
        genSizeStyle$3(merge$4(token2, {
          controlHeight: token2.controlHeightSM,
          borderRadius: token2.borderRadiusSM
        }), "sm"),
        // padding
        {
          [`${componentCls}-single${componentCls}-sm`]: {
            [`&:not(${componentCls}-customize-input)`]: {
              [`${componentCls}-selection-search`]: {
                insetInlineStart: inputPaddingHorizontalSM,
                insetInlineEnd: inputPaddingHorizontalSM
              },
              [`${componentCls}-selector`]: {
                padding: `0 ${inputPaddingHorizontalSM}px`
              },
              // With arrow should provides `padding-right` to show the arrow
              [`&${componentCls}-show-arrow ${componentCls}-selection-search`]: {
                insetInlineEnd: inputPaddingHorizontalSM + token2.fontSize * 1.5
              },
              [`
            &${componentCls}-show-arrow ${componentCls}-selection-item,
            &${componentCls}-show-arrow ${componentCls}-selection-placeholder
          `]: {
                paddingInlineEnd: token2.fontSize * 1.5
              }
            }
          }
        },
        // ======================== Large ========================
        // Shared
        genSizeStyle$3(merge$4(token2, {
          controlHeight: token2.controlHeightLG,
          fontSize: token2.fontSizeLG,
          borderRadius: token2.borderRadiusLG
        }), "lg")
      ];
    }
    const genSelectorStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        position: "relative",
        backgroundColor: token2.colorBgContainer,
        border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
        transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
        input: {
          cursor: "pointer"
        },
        [`${componentCls}-show-search&`]: {
          cursor: "text",
          input: {
            cursor: "auto",
            color: "inherit"
          }
        },
        [`${componentCls}-disabled&`]: {
          color: token2.colorTextDisabled,
          background: token2.colorBgContainerDisabled,
          cursor: "not-allowed",
          [`${componentCls}-multiple&`]: {
            background: token2.colorBgContainerDisabled
          },
          input: {
            cursor: "not-allowed"
          }
        }
      };
    };
    const genStatusStyle$3 = function(rootSelectCls, token2) {
      let overwriteDefaultBorder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      const {
        componentCls,
        borderHoverColor,
        outlineColor,
        antCls
      } = token2;
      const overwriteStyle = overwriteDefaultBorder ? {
        [`${componentCls}-selector`]: {
          borderColor: borderHoverColor
        }
      } : {};
      return {
        [rootSelectCls]: {
          [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: Object.assign(Object.assign({}, overwriteStyle), {
            [`${componentCls}-focused& ${componentCls}-selector`]: {
              borderColor: borderHoverColor,
              boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${outlineColor}`,
              outline: 0
            },
            [`&:hover ${componentCls}-selector`]: {
              borderColor: borderHoverColor
            }
          })
        }
      };
    };
    const getSearchInputWithoutBorderStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-selection-search-input`]: {
          margin: 0,
          padding: 0,
          background: "transparent",
          border: "none",
          outline: "none",
          appearance: "none",
          "&::-webkit-search-cancel-button": {
            display: "none",
            "-webkit-appearance": "none"
          }
        }
      };
    };
    const genBaseStyle$a = (token2) => {
      const {
        componentCls,
        inputPaddingHorizontalBase,
        iconCls
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
          position: "relative",
          display: "inline-block",
          cursor: "pointer",
          [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: Object.assign(Object.assign({}, genSelectorStyle(token2)), getSearchInputWithoutBorderStyle(token2)),
          // [`&:not(&-disabled):hover ${selectCls}-selector`]: {
          //   ...genHoverStyle(token),
          // },
          // ======================== Selection ========================
          [`${componentCls}-selection-item`]: Object.assign(Object.assign({
            flex: 1,
            fontWeight: "normal"
          }, textEllipsis), {
            "> *": Object.assign({
              lineHeight: "inherit"
            }, textEllipsis)
          }),
          // ======================= Placeholder =======================
          [`${componentCls}-selection-placeholder`]: Object.assign(Object.assign({}, textEllipsis), {
            flex: 1,
            color: token2.colorTextPlaceholder,
            pointerEvents: "none"
          }),
          // ========================== Arrow ==========================
          [`${componentCls}-arrow`]: Object.assign(Object.assign({}, resetIcon()), {
            position: "absolute",
            top: "50%",
            insetInlineStart: "auto",
            insetInlineEnd: inputPaddingHorizontalBase,
            height: token2.fontSizeIcon,
            marginTop: -token2.fontSizeIcon / 2,
            color: token2.colorTextQuaternary,
            fontSize: token2.fontSizeIcon,
            lineHeight: 1,
            textAlign: "center",
            pointerEvents: "none",
            display: "flex",
            alignItems: "center",
            [iconCls]: {
              verticalAlign: "top",
              transition: `transform ${token2.motionDurationSlow}`,
              "> svg": {
                verticalAlign: "top"
              },
              [`&:not(${componentCls}-suffix)`]: {
                pointerEvents: "auto"
              }
            },
            [`${componentCls}-disabled &`]: {
              cursor: "not-allowed"
            },
            "> *:not(:last-child)": {
              marginInlineEnd: 8
              // FIXME: magic
            }
          }),
          // ========================== Clear ==========================
          [`${componentCls}-clear`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: "auto",
            insetInlineEnd: inputPaddingHorizontalBase,
            zIndex: 1,
            display: "inline-block",
            width: token2.fontSizeIcon,
            height: token2.fontSizeIcon,
            marginTop: -token2.fontSizeIcon / 2,
            color: token2.colorTextQuaternary,
            fontSize: token2.fontSizeIcon,
            fontStyle: "normal",
            lineHeight: 1,
            textAlign: "center",
            textTransform: "none",
            background: token2.colorBgContainer,
            cursor: "pointer",
            opacity: 0,
            transition: `color ${token2.motionDurationMid} ease, opacity ${token2.motionDurationSlow} ease`,
            textRendering: "auto",
            "&:before": {
              display: "block"
            },
            "&:hover": {
              color: token2.colorTextTertiary
            }
          },
          "&:hover": {
            [`${componentCls}-clear`]: {
              opacity: 1
            }
          }
        }),
        // ========================= Feedback ==========================
        [`${componentCls}-has-feedback`]: {
          [`${componentCls}-clear`]: {
            insetInlineEnd: inputPaddingHorizontalBase + token2.fontSize + token2.paddingXXS
          }
        }
      };
    };
    const genSelectStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return [
        {
          [componentCls]: {
            // ==================== BorderLess ====================
            [`&-borderless ${componentCls}-selector`]: {
              backgroundColor: `transparent !important`,
              borderColor: `transparent !important`,
              boxShadow: `none !important`
            },
            // ==================== In Form ====================
            [`&${componentCls}-in-form-item`]: {
              width: "100%"
            }
          }
        },
        // =====================================================
        // ==                       LTR                       ==
        // =====================================================
        // Base
        genBaseStyle$a(token2),
        // Single
        genSingleStyle(token2),
        // Multiple
        genMultipleStyle(token2),
        // Dropdown
        genDropdownStyle$1(token2),
        // =====================================================
        // ==                       RTL                       ==
        // =====================================================
        {
          [`${componentCls}-rtl`]: {
            direction: "rtl"
          }
        },
        // =====================================================
        // ==                     Status                      ==
        // =====================================================
        genStatusStyle$3(componentCls, merge$4(token2, {
          borderHoverColor: token2.colorPrimaryHover,
          outlineColor: token2.controlOutline
        })),
        genStatusStyle$3(`${componentCls}-status-error`, merge$4(token2, {
          borderHoverColor: token2.colorErrorHover,
          outlineColor: token2.colorErrorOutline
        }), true),
        genStatusStyle$3(`${componentCls}-status-warning`, merge$4(token2, {
          borderHoverColor: token2.colorWarningHover,
          outlineColor: token2.colorWarningOutline
        }), true),
        // =====================================================
        // ==             Space Compact                       ==
        // =====================================================
        genCompactItemStyle(token2, {
          borderElCls: `${componentCls}-selector`,
          focusElCls: `${componentCls}-focused`
        })
      ];
    };
    const useSelectStyle = genComponentStyleHook("Select", (token2, _ref) => {
      let {
        rootPrefixCls
      } = _ref;
      const selectToken = merge$4(token2, {
        rootPrefixCls,
        inputPaddingHorizontalBase: token2.paddingSM - 1
      });
      return [genSelectStyle(selectToken)];
    }, (token2) => ({
      zIndexPopup: token2.zIndexPopupBase + 50
    }));
    function useShowArrow(showArrow) {
      return showArrow !== null && showArrow !== void 0 ? showArrow : true;
    }
    var __rest$W = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
    const InternalSelect = (_a, ref) => {
      var {
        prefixCls: customizePrefixCls,
        bordered = true,
        className,
        rootClassName,
        getPopupContainer,
        popupClassName,
        dropdownClassName,
        listHeight = 256,
        placement,
        listItemHeight = 24,
        size: customizeSize,
        disabled: customDisabled,
        notFoundContent,
        status: customStatus,
        showArrow
      } = _a, props = __rest$W(_a, ["prefixCls", "bordered", "className", "rootClassName", "getPopupContainer", "popupClassName", "dropdownClassName", "listHeight", "placement", "listItemHeight", "size", "disabled", "notFoundContent", "status", "showArrow"]);
      const {
        getPopupContainer: getContextPopupContainer,
        getPrefixCls,
        renderEmpty,
        direction,
        virtual,
        dropdownMatchSelectWidth,
        select
      } = reactExports.useContext(ConfigContext);
      const size = reactExports.useContext(SizeContext$2);
      const prefixCls = getPrefixCls("select", customizePrefixCls);
      const rootPrefixCls = getPrefixCls();
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const [wrapSSR, hashId] = useSelectStyle(prefixCls);
      const mode = reactExports.useMemo(() => {
        const {
          mode: m2
        } = props;
        if (m2 === "combobox") {
          return void 0;
        }
        if (m2 === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
          return "combobox";
        }
        return m2;
      }, [props.mode]);
      const isMultiple2 = mode === "multiple" || mode === "tags";
      const mergedShowArrow = useShowArrow(showArrow);
      const {
        status: contextStatus,
        hasFeedback,
        isFormItemInput,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      let mergedNotFound;
      if (notFoundContent !== void 0) {
        mergedNotFound = notFoundContent;
      } else if (mode === "combobox") {
        mergedNotFound = null;
      } else {
        mergedNotFound = (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Select")) || /* @__PURE__ */ reactExports.createElement(DefaultRenderEmpty$1, {
          componentName: "Select"
        });
      }
      const {
        suffixIcon,
        itemIcon,
        removeIcon,
        clearIcon
      } = getIcons(Object.assign(Object.assign({}, props), {
        multiple: isMultiple2,
        hasFeedback,
        feedbackIcon,
        showArrow: mergedShowArrow,
        prefixCls
      }));
      const selectProps = omit(props, ["suffixIcon", "itemIcon"]);
      const rcSelectRtlDropdownClassName = classNames(popupClassName || dropdownClassName, {
        [`${prefixCls}-dropdown-${direction}`]: direction === "rtl"
      }, rootClassName, hashId);
      const mergedSize = compactSize || customizeSize || size;
      const disabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const mergedClassName = classNames({
        [`${prefixCls}-lg`]: mergedSize === "large",
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-borderless`]: !bordered,
        [`${prefixCls}-in-form-item`]: isFormItemInput
      }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, className, rootClassName, hashId);
      const getPlacement = () => {
        if (placement !== void 0) {
          return placement;
        }
        return direction === "rtl" ? "bottomRight" : "bottomLeft";
      };
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(TypedSelect, Object.assign({
        ref,
        virtual,
        dropdownMatchSelectWidth,
        showSearch: select === null || select === void 0 ? void 0 : select.showSearch
      }, selectProps, {
        transitionName: getTransitionName$1(rootPrefixCls, getTransitionDirection(placement), props.transitionName),
        listHeight,
        listItemHeight,
        mode,
        prefixCls,
        placement: getPlacement(),
        direction,
        inputIcon: suffixIcon,
        menuItemSelectedIcon: itemIcon,
        removeIcon,
        clearIcon,
        notFoundContent: mergedNotFound,
        className: mergedClassName,
        getPopupContainer: getPopupContainer || getContextPopupContainer,
        dropdownClassName: rcSelectRtlDropdownClassName,
        showArrow: hasFeedback || mergedShowArrow,
        disabled: mergedDisabled
      })));
    };
    const Select = /* @__PURE__ */ reactExports.forwardRef(InternalSelect);
    const PurePanel$7 = genPurePanel(Select);
    Select.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
    Select.Option = Option;
    Select.OptGroup = OptGroup;
    Select._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$7;
    const Select$1 = Select;
    function useForceUpdate() {
      const [, forceUpdate] = reactExports.useReducer((x2) => x2 + 1, 0);
      return forceUpdate;
    }
    const responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"];
    const getResponsiveMap = (token2) => ({
      xs: `(max-width: ${token2.screenXSMax}px)`,
      sm: `(min-width: ${token2.screenSM}px)`,
      md: `(min-width: ${token2.screenMD}px)`,
      lg: `(min-width: ${token2.screenLG}px)`,
      xl: `(min-width: ${token2.screenXL}px)`,
      xxl: `(min-width: ${token2.screenXXL}px)`
    });
    const validateBreakpoints = (token2) => {
      const indexableToken = token2;
      const revBreakpoints = [].concat(responsiveArray).reverse();
      revBreakpoints.forEach((breakpoint, i2) => {
        const breakpointUpper = breakpoint.toUpperCase();
        const screenMin = `screen${breakpointUpper}Min`;
        const screen = `screen${breakpointUpper}`;
        if (!(indexableToken[screenMin] <= indexableToken[screen])) {
          throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);
        }
        if (i2 < revBreakpoints.length - 1) {
          const screenMax = `screen${breakpointUpper}Max`;
          if (!(indexableToken[screen] <= indexableToken[screenMax])) {
            throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);
          }
          const nextBreakpointUpperMin = revBreakpoints[i2 + 1].toUpperCase();
          const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;
          if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {
            throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);
          }
        }
      });
      return token2;
    };
    function useResponsiveObserver() {
      const [, token2] = useToken$3();
      const responsiveMap = getResponsiveMap(validateBreakpoints(token2));
      return React$3.useMemo(() => {
        const subscribers = /* @__PURE__ */ new Map();
        let subUid = -1;
        let screens = {};
        return {
          matchHandlers: {},
          dispatch(pointMap) {
            screens = pointMap;
            subscribers.forEach((func) => func(screens));
            return subscribers.size >= 1;
          },
          subscribe(func) {
            if (!subscribers.size)
              this.register();
            subUid += 1;
            subscribers.set(subUid, func);
            func(screens);
            return subUid;
          },
          unsubscribe(paramToken) {
            subscribers.delete(paramToken);
            if (!subscribers.size)
              this.unregister();
          },
          unregister() {
            Object.keys(responsiveMap).forEach((screen) => {
              const matchMediaQuery = responsiveMap[screen];
              const handler = this.matchHandlers[matchMediaQuery];
              handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);
            });
            subscribers.clear();
          },
          register() {
            Object.keys(responsiveMap).forEach((screen) => {
              const matchMediaQuery = responsiveMap[screen];
              const listener = (_ref) => {
                let {
                  matches
                } = _ref;
                this.dispatch(Object.assign(Object.assign({}, screens), {
                  [screen]: matches
                }));
              };
              const mql = window.matchMedia(matchMediaQuery);
              mql.addListener(listener);
              this.matchHandlers[matchMediaQuery] = {
                mql,
                listener
              };
              listener(mql);
            });
          },
          responsiveMap
        };
      }, [token2]);
    }
    function useBreakpoint$3() {
      let refreshOnChange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      const screensRef = reactExports.useRef({});
      const forceUpdate = useForceUpdate();
      const responsiveObserver = useResponsiveObserver();
      reactExports.useEffect(() => {
        const token2 = responsiveObserver.subscribe((supportScreens) => {
          screensRef.current = supportScreens;
          if (refreshOnChange) {
            forceUpdate();
          }
        });
        return () => responsiveObserver.unsubscribe(token2);
      }, []);
      return screensRef.current;
    }
    const SizeContext = /* @__PURE__ */ reactExports.createContext("default");
    const SizeContextProvider = (_ref) => {
      let {
        children,
        size
      } = _ref;
      const originSize = reactExports.useContext(SizeContext);
      return /* @__PURE__ */ reactExports.createElement(SizeContext.Provider, {
        value: size || originSize
      }, children);
    };
    const genBaseStyle$9 = (token2) => {
      const {
        antCls,
        componentCls,
        iconCls,
        avatarBg,
        avatarColor,
        avatarSizeBase,
        avatarSizeLG,
        avatarSizeSM,
        avatarFontSizeBase,
        avatarFontSizeLG,
        avatarFontSizeSM,
        borderRadius,
        borderRadiusLG,
        borderRadiusSM,
        lineWidth,
        lineType
      } = token2;
      const avatarSizeStyle = (size, fontSize, radius) => ({
        width: size,
        height: size,
        lineHeight: `${size - lineWidth * 2}px`,
        borderRadius: "50%",
        [`&${componentCls}-square`]: {
          borderRadius: radius
        },
        [`${componentCls}-string`]: {
          position: "absolute",
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transformOrigin: "0 center"
        },
        [`&${componentCls}-icon`]: {
          fontSize,
          [`> ${iconCls}`]: {
            margin: 0
          }
        }
      });
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), {
          position: "relative",
          display: "inline-block",
          overflow: "hidden",
          color: avatarColor,
          whiteSpace: "nowrap",
          textAlign: "center",
          verticalAlign: "middle",
          background: avatarBg,
          border: `${lineWidth}px ${lineType} transparent`,
          [`&-image`]: {
            background: "transparent"
          },
          [`${antCls}-image-img`]: {
            display: "block"
          }
        }), avatarSizeStyle(avatarSizeBase, avatarFontSizeBase, borderRadius)), {
          [`&-lg`]: Object.assign({}, avatarSizeStyle(avatarSizeLG, avatarFontSizeLG, borderRadiusLG)),
          [`&-sm`]: Object.assign({}, avatarSizeStyle(avatarSizeSM, avatarFontSizeSM, borderRadiusSM)),
          "> img": {
            display: "block",
            width: "100%",
            height: "100%",
            objectFit: "cover"
          }
        })
      };
    };
    const genGroupStyle$1 = (token2) => {
      const {
        componentCls,
        avatarGroupBorderColor,
        avatarGroupSpace
      } = token2;
      return {
        [`${componentCls}-group`]: {
          display: "inline-flex",
          [`${componentCls}`]: {
            borderColor: avatarGroupBorderColor
          },
          [`> *:not(:first-child)`]: {
            marginInlineStart: avatarGroupSpace
          }
        }
      };
    };
    const useStyle$t = genComponentStyleHook("Avatar", (token2) => {
      const {
        colorTextLightSolid,
        controlHeight,
        controlHeightLG,
        controlHeightSM,
        fontSize,
        fontSizeLG,
        fontSizeXL,
        fontSizeHeading3,
        marginXS,
        colorBorderBg,
        colorTextPlaceholder
      } = token2;
      const avatarToken = merge$4(token2, {
        avatarBg: colorTextPlaceholder,
        avatarColor: colorTextLightSolid,
        avatarSizeBase: controlHeight,
        avatarSizeLG: controlHeightLG,
        avatarSizeSM: controlHeightSM,
        avatarFontSizeBase: Math.round((fontSizeLG + fontSizeXL) / 2),
        avatarFontSizeLG: fontSizeHeading3,
        avatarFontSizeSM: fontSize,
        avatarGroupSpace: -marginXS,
        avatarGroupBorderColor: colorBorderBg
      });
      return [genBaseStyle$9(avatarToken), genGroupStyle$1(avatarToken)];
    });
    var __rest$V = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const InternalAvatar = (props, ref) => {
      const groupSize = reactExports.useContext(SizeContext);
      const [scale, setScale] = reactExports.useState(1);
      const [mounted, setMounted] = reactExports.useState(false);
      const [isImgExist, setIsImgExist] = reactExports.useState(true);
      const avatarNodeRef = reactExports.useRef(null);
      const avatarChildrenRef = reactExports.useRef(null);
      const avatarNodeMergeRef = composeRef(ref, avatarNodeRef);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const setScaleParam = () => {
        if (!avatarChildrenRef.current || !avatarNodeRef.current) {
          return;
        }
        const childrenWidth = avatarChildrenRef.current.offsetWidth;
        const nodeWidth = avatarNodeRef.current.offsetWidth;
        if (childrenWidth !== 0 && nodeWidth !== 0) {
          const {
            gap = 4
          } = props;
          if (gap * 2 < nodeWidth) {
            setScale(nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1);
          }
        }
      };
      reactExports.useEffect(() => {
        setMounted(true);
      }, []);
      reactExports.useEffect(() => {
        setIsImgExist(true);
        setScale(1);
      }, [props.src]);
      reactExports.useEffect(() => {
        setScaleParam();
      }, [props.gap]);
      const handleImgLoadError = () => {
        const {
          onError
        } = props;
        const errorFlag = onError ? onError() : void 0;
        if (errorFlag !== false) {
          setIsImgExist(false);
        }
      };
      const {
        prefixCls: customizePrefixCls,
        shape = "circle",
        size: customSize = "default",
        src: src2,
        srcSet,
        icon,
        className,
        rootClassName,
        alt,
        draggable,
        children,
        crossOrigin
      } = props, others = __rest$V(props, ["prefixCls", "shape", "size", "src", "srcSet", "icon", "className", "rootClassName", "alt", "draggable", "children", "crossOrigin"]);
      const size = customSize === "default" ? groupSize : customSize;
      const needResponsive = Object.keys(typeof size === "object" ? size || {} : {}).some((key) => ["xs", "sm", "md", "lg", "xl", "xxl"].includes(key));
      const screens = useBreakpoint$3(needResponsive);
      const responsiveSizeStyle = reactExports.useMemo(() => {
        if (typeof size !== "object") {
          return {};
        }
        const currentBreakpoint = responsiveArray.find((screen) => screens[screen]);
        const currentSize = size[currentBreakpoint];
        return currentSize ? {
          width: currentSize,
          height: currentSize,
          lineHeight: `${currentSize}px`,
          fontSize: icon ? currentSize / 2 : 18
        } : {};
      }, [screens, size]);
      const prefixCls = getPrefixCls("avatar", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$t(prefixCls);
      const sizeCls = classNames({
        [`${prefixCls}-lg`]: size === "large",
        [`${prefixCls}-sm`]: size === "small"
      });
      const hasImageElement = /* @__PURE__ */ reactExports.isValidElement(src2);
      const classString = classNames(prefixCls, sizeCls, {
        [`${prefixCls}-${shape}`]: !!shape,
        [`${prefixCls}-image`]: hasImageElement || src2 && isImgExist,
        [`${prefixCls}-icon`]: !!icon
      }, className, rootClassName, hashId);
      const sizeStyle = typeof size === "number" ? {
        width: size,
        height: size,
        lineHeight: `${size}px`,
        fontSize: icon ? size / 2 : 18
      } : {};
      let childrenToRender;
      if (typeof src2 === "string" && isImgExist) {
        childrenToRender = /* @__PURE__ */ reactExports.createElement("img", {
          src: src2,
          draggable,
          srcSet,
          onError: handleImgLoadError,
          alt,
          crossOrigin
        });
      } else if (hasImageElement) {
        childrenToRender = src2;
      } else if (icon) {
        childrenToRender = icon;
      } else if (mounted || scale !== 1) {
        const transformString = `scale(${scale}) translateX(-50%)`;
        const childrenStyle = {
          msTransform: transformString,
          WebkitTransform: transformString,
          transform: transformString
        };
        const sizeChildrenStyle = typeof size === "number" ? {
          lineHeight: `${size}px`
        } : {};
        childrenToRender = /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
          onResize: setScaleParam
        }, /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-string`,
          ref: avatarChildrenRef,
          style: Object.assign(Object.assign({}, sizeChildrenStyle), childrenStyle)
        }, children));
      } else {
        childrenToRender = /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-string`,
          style: {
            opacity: 0
          },
          ref: avatarChildrenRef
        }, children);
      }
      delete others.onError;
      delete others.gap;
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("span", Object.assign({}, others, {
        style: Object.assign(Object.assign(Object.assign({}, sizeStyle), responsiveSizeStyle), others.style),
        className: classString,
        ref: avatarNodeMergeRef
      }), childrenToRender));
    };
    const Avatar$2 = /* @__PURE__ */ reactExports.forwardRef(InternalAvatar);
    const InternalAvatar$1 = Avatar$2;
    var autoAdjustOverflowTopBottom = {
      shiftX: 64,
      adjustY: 1
    };
    var autoAdjustOverflowLeftRight = {
      adjustX: 1,
      shiftY: true
    };
    var targetOffset$1 = [0, 0];
    var placements$2 = {
      left: {
        points: ["cr", "cl"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [-4, 0],
        targetOffset: targetOffset$1
      },
      right: {
        points: ["cl", "cr"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [4, 0],
        targetOffset: targetOffset$1
      },
      top: {
        points: ["bc", "tc"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, -4],
        targetOffset: targetOffset$1
      },
      bottom: {
        points: ["tc", "bc"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, 4],
        targetOffset: targetOffset$1
      },
      topLeft: {
        points: ["bl", "tl"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, -4],
        targetOffset: targetOffset$1
      },
      leftTop: {
        points: ["tr", "tl"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [-4, 0],
        targetOffset: targetOffset$1
      },
      topRight: {
        points: ["br", "tr"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, -4],
        targetOffset: targetOffset$1
      },
      rightTop: {
        points: ["tl", "tr"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [4, 0],
        targetOffset: targetOffset$1
      },
      bottomRight: {
        points: ["tr", "br"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, 4],
        targetOffset: targetOffset$1
      },
      rightBottom: {
        points: ["bl", "br"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [4, 0],
        targetOffset: targetOffset$1
      },
      bottomLeft: {
        points: ["tl", "bl"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, 4],
        targetOffset: targetOffset$1
      },
      leftBottom: {
        points: ["br", "bl"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [-4, 0],
        targetOffset: targetOffset$1
      }
    };
    function Popup$1(props) {
      var children = props.children, prefixCls = props.prefixCls, id2 = props.id, overlayInnerStyle = props.overlayInnerStyle, className = props.className, style2 = props.style;
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-content"), className),
        style: style2
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-inner"),
        id: id2,
        role: "tooltip",
        style: overlayInnerStyle
      }, typeof children === "function" ? children() : children));
    }
    var _excluded$x = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"];
    var Tooltip$1 = function Tooltip2(props, ref) {
      var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, motion2 = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle;
      props.arrowContent;
      var overlay = props.overlay, id2 = props.id, _props$showArrow = props.showArrow, showArrow = _props$showArrow === void 0 ? true : _props$showArrow, restProps = _objectWithoutProperties$1(props, _excluded$x);
      var triggerRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, function() {
        return triggerRef.current;
      });
      var extraProps = _objectSpread2$3({}, restProps);
      if ("visible" in props) {
        extraProps.popupVisible = props.visible;
      }
      var getPopupElement = function getPopupElement2() {
        return /* @__PURE__ */ reactExports.createElement(Popup$1, {
          key: "content",
          prefixCls,
          id: id2,
          overlayInnerStyle
        }, overlay);
      };
      return /* @__PURE__ */ reactExports.createElement(Trigger$1, _extends$2({
        popupClassName: overlayClassName,
        prefixCls,
        popup: getPopupElement,
        action: trigger,
        builtinPlacements: placements$2,
        popupPlacement: placement,
        ref: triggerRef,
        popupAlign: align,
        getPopupContainer: getTooltipContainer,
        onPopupVisibleChange: onVisibleChange,
        afterPopupVisibleChange: afterVisibleChange,
        popupTransitionName: transitionName,
        popupAnimation: animation,
        popupMotion: motion2,
        defaultPopupVisible: defaultVisible,
        autoDestroy: destroyTooltipOnHide,
        mouseLeaveDelay,
        popupStyle: overlayStyle,
        mouseEnterDelay,
        arrow: showArrow
      }, extraProps), children);
    };
    const Tooltip$2 = /* @__PURE__ */ reactExports.forwardRef(Tooltip$1);
    const getAlphaColor = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
    const getSolidColor = (baseColor, brightness) => {
      const instance = new TinyColor(baseColor);
      return instance.lighten(brightness).toHexString();
    };
    const generateColorPalettes = (baseColor) => {
      const colors = generate$3(baseColor, {
        theme: "dark"
      });
      return {
        1: colors[0],
        2: colors[1],
        3: colors[2],
        4: colors[3],
        5: colors[6],
        6: colors[5],
        7: colors[4],
        8: colors[6],
        9: colors[5],
        10: colors[4]
        // 8: colors[9],
        // 9: colors[8],
        // 10: colors[7],
      };
    };
    const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
      const colorBgBase = bgBaseColor || "#000";
      const colorTextBase = textBaseColor || "#fff";
      return {
        colorBgBase,
        colorTextBase,
        colorText: getAlphaColor(colorTextBase, 0.85),
        colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
        colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
        colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
        colorFill: getAlphaColor(colorTextBase, 0.18),
        colorFillSecondary: getAlphaColor(colorTextBase, 0.12),
        colorFillTertiary: getAlphaColor(colorTextBase, 0.08),
        colorFillQuaternary: getAlphaColor(colorTextBase, 0.04),
        colorBgElevated: getSolidColor(colorBgBase, 12),
        colorBgContainer: getSolidColor(colorBgBase, 8),
        colorBgLayout: getSolidColor(colorBgBase, 0),
        colorBgSpotlight: getSolidColor(colorBgBase, 26),
        colorBorder: getSolidColor(colorBgBase, 26),
        colorBorderSecondary: getSolidColor(colorBgBase, 19)
      };
    };
    const derivative$1 = (token2, mapToken) => {
      const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
        const colors = generate$3(token2[colorKey], {
          theme: "dark"
        });
        return new Array(10).fill(1).reduce((prev2, _, i2) => {
          prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
          prev2[`${colorKey}${i2 + 1}`] = colors[i2];
          return prev2;
        }, {});
      }).reduce((prev2, cur) => {
        prev2 = Object.assign(Object.assign({}, prev2), cur);
        return prev2;
      }, {});
      const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$2(token2);
      return Object.assign(Object.assign(Object.assign({}, mergedMapToken), colorPalettes), genColorMapToken(token2, {
        generateColorPalettes,
        generateNeutralColorPalettes
      }));
    };
    const darkAlgorithm = derivative$1;
    function genSizeMapToken(token2) {
      const {
        sizeUnit,
        sizeStep
      } = token2;
      const compactSizeStep = sizeStep - 2;
      return {
        sizeXXL: sizeUnit * (compactSizeStep + 10),
        sizeXL: sizeUnit * (compactSizeStep + 6),
        sizeLG: sizeUnit * (compactSizeStep + 2),
        sizeMD: sizeUnit * (compactSizeStep + 2),
        sizeMS: sizeUnit * (compactSizeStep + 1),
        size: sizeUnit * compactSizeStep,
        sizeSM: sizeUnit * compactSizeStep,
        sizeXS: sizeUnit * (compactSizeStep - 1),
        sizeXXS: sizeUnit * (compactSizeStep - 1)
      };
    }
    const derivative = (token2, mapToken) => {
      const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$2(token2);
      const fontSize = mergedMapToken.fontSizeSM;
      const controlHeight = mergedMapToken.controlHeight - 4;
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, mergedMapToken), genSizeMapToken(mapToken !== null && mapToken !== void 0 ? mapToken : token2)), genFontMapToken$1(fontSize)), {
        // controlHeight
        controlHeight
      }), genControlHeight$1(Object.assign(Object.assign({}, mergedMapToken), {
        controlHeight
      })));
    };
    const compactAlgorithm = derivative;
    function useToken$2() {
      const [theme2, token2, hashId] = useToken$3();
      return {
        theme: theme2,
        token: token2,
        hashId
      };
    }
    const theme = {
      /** @private Test Usage. Do not use in production. */
      defaultConfig,
      /** Default seedToken */
      defaultSeed: defaultConfig.token,
      useToken: useToken$2,
      defaultAlgorithm: derivative$2,
      darkAlgorithm,
      compactAlgorithm
    };
    const MAX_VERTICAL_CONTENT_RADIUS = 8;
    function getArrowOffset(options) {
      const maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS;
      const {
        contentRadius,
        limitVerticalRadius
      } = options;
      const dropdownArrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
      const dropdownArrowOffsetVertical = limitVerticalRadius ? maxVerticalContentRadius : dropdownArrowOffset;
      return {
        dropdownArrowOffset,
        dropdownArrowOffsetVertical
      };
    }
    function isInject(valid, code2) {
      if (!valid)
        return {};
      return code2;
    }
    function getArrowStyle(token2, options) {
      const {
        componentCls,
        sizePopupArrow,
        borderRadiusXS,
        borderRadiusOuter,
        boxShadowPopoverArrow
      } = token2;
      const {
        colorBg,
        contentRadius = token2.borderRadiusLG,
        limitVerticalRadius,
        arrowDistance = 0,
        arrowPlacement = {
          left: true,
          right: true,
          top: true,
          bottom: true
        }
      } = options;
      const {
        dropdownArrowOffsetVertical,
        dropdownArrowOffset
      } = getArrowOffset({
        contentRadius,
        limitVerticalRadius
      });
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({
          // ============================ Basic ============================
          [`${componentCls}-arrow`]: [Object.assign(Object.assign({
            position: "absolute",
            zIndex: 1,
            display: "block"
          }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
            "&:before": {
              background: colorBg
            }
          })]
        }, isInject(!!arrowPlacement.top, {
          [[`&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow`].join(",")]: {
            bottom: arrowDistance,
            transform: "translateY(100%) rotate(180deg)"
          },
          [`&-placement-top ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateX(-50%) translateY(100%) rotate(180deg)"
          },
          [`&-placement-topLeft ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: dropdownArrowOffset
            }
          },
          [`&-placement-topRight ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: dropdownArrowOffset
            }
          }
        })), isInject(!!arrowPlacement.bottom, {
          [[`&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow`].join(",")]: {
            top: arrowDistance,
            transform: `translateY(-100%)`
          },
          [`&-placement-bottom ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: `translateX(-50%) translateY(-100%)`
          },
          [`&-placement-bottomLeft ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: dropdownArrowOffset
            }
          },
          [`&-placement-bottomRight ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: dropdownArrowOffset
            }
          }
        })), isInject(!!arrowPlacement.left, {
          [[`&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow`].join(",")]: {
            right: {
              _skip_check_: true,
              value: arrowDistance
            },
            transform: "translateX(100%) rotate(90deg)"
          },
          [`&-placement-left ${componentCls}-arrow`]: {
            top: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateY(-50%) translateX(100%) rotate(90deg)"
          },
          [`&-placement-leftTop ${componentCls}-arrow`]: {
            top: dropdownArrowOffsetVertical
          },
          [`&-placement-leftBottom ${componentCls}-arrow`]: {
            bottom: dropdownArrowOffsetVertical
          }
        })), isInject(!!arrowPlacement.right, {
          [[`&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow`].join(",")]: {
            left: {
              _skip_check_: true,
              value: arrowDistance
            },
            transform: "translateX(-100%) rotate(-90deg)"
          },
          [`&-placement-right ${componentCls}-arrow`]: {
            top: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
          },
          [`&-placement-rightTop ${componentCls}-arrow`]: {
            top: dropdownArrowOffsetVertical
          },
          [`&-placement-rightBottom ${componentCls}-arrow`]: {
            bottom: dropdownArrowOffsetVertical
          }
        }))
      };
    }
    function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow2) {
      if (autoAdjustOverflow2 === false) {
        return {
          adjustX: false,
          adjustY: false
        };
      }
      const overflow = autoAdjustOverflow2 && typeof autoAdjustOverflow2 === "object" ? autoAdjustOverflow2 : {};
      const baseOverflow = {};
      switch (placement) {
        case "top":
        case "bottom":
          baseOverflow.shiftX = arrowOffset.dropdownArrowOffset * 2 + arrowWidth;
          break;
        case "left":
        case "right":
          baseOverflow.shiftY = arrowOffset.dropdownArrowOffsetVertical * 2 + arrowWidth;
          break;
      }
      const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);
      if (!mergedOverflow.shiftX) {
        mergedOverflow.adjustX = true;
      }
      if (!mergedOverflow.shiftY) {
        mergedOverflow.adjustY = true;
      }
      return mergedOverflow;
    }
    const PlacementAlignMap = {
      left: {
        points: ["cr", "cl"]
      },
      right: {
        points: ["cl", "cr"]
      },
      top: {
        points: ["bc", "tc"]
      },
      bottom: {
        points: ["tc", "bc"]
      },
      topLeft: {
        points: ["bl", "tl"]
      },
      leftTop: {
        points: ["tr", "tl"]
      },
      topRight: {
        points: ["br", "tr"]
      },
      rightTop: {
        points: ["tl", "tr"]
      },
      bottomRight: {
        points: ["tr", "br"]
      },
      rightBottom: {
        points: ["bl", "br"]
      },
      bottomLeft: {
        points: ["tl", "bl"]
      },
      leftBottom: {
        points: ["br", "bl"]
      }
    };
    const ArrowCenterPlacementAlignMap = {
      topLeft: {
        points: ["bl", "tc"]
      },
      leftTop: {
        points: ["tr", "cl"]
      },
      topRight: {
        points: ["br", "tc"]
      },
      rightTop: {
        points: ["tl", "cr"]
      },
      bottomRight: {
        points: ["tr", "bc"]
      },
      rightBottom: {
        points: ["bl", "cr"]
      },
      bottomLeft: {
        points: ["tl", "bc"]
      },
      leftBottom: {
        points: ["br", "cl"]
      }
    };
    const DisableAutoArrowList = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
    function getPlacements(config) {
      const {
        arrowWidth,
        autoAdjustOverflow: autoAdjustOverflow2,
        arrowPointAtCenter,
        offset: offset2,
        borderRadius
      } = config;
      const halfArrowWidth = arrowWidth / 2;
      const placementMap = {};
      Object.keys(PlacementAlignMap).forEach((key) => {
        const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
        const placementInfo = Object.assign(Object.assign({}, template), {
          offset: [0, 0]
        });
        placementMap[key] = placementInfo;
        if (DisableAutoArrowList.has(key)) {
          placementInfo.autoArrow = false;
        }
        switch (key) {
          case "top":
          case "topLeft":
          case "topRight":
            placementInfo.offset[1] = -halfArrowWidth - offset2;
            break;
          case "bottom":
          case "bottomLeft":
          case "bottomRight":
            placementInfo.offset[1] = halfArrowWidth + offset2;
            break;
          case "left":
          case "leftTop":
          case "leftBottom":
            placementInfo.offset[0] = -halfArrowWidth - offset2;
            break;
          case "right":
          case "rightTop":
          case "rightBottom":
            placementInfo.offset[0] = halfArrowWidth + offset2;
            break;
        }
        const arrowOffset = getArrowOffset({
          contentRadius: borderRadius,
          limitVerticalRadius: true
        });
        if (arrowPointAtCenter) {
          switch (key) {
            case "topLeft":
            case "bottomLeft":
              placementInfo.offset[0] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
              break;
            case "topRight":
            case "bottomRight":
              placementInfo.offset[0] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
              break;
            case "leftTop":
            case "rightTop":
              placementInfo.offset[1] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
              break;
            case "leftBottom":
            case "rightBottom":
              placementInfo.offset[1] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
              break;
          }
        }
        placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow2);
      });
      return placementMap;
    }
    const genTooltipStyle = (token2) => {
      const {
        componentCls,
        // ant-tooltip
        tooltipMaxWidth,
        tooltipColor,
        tooltipBg,
        tooltipBorderRadius,
        zIndexPopup,
        controlHeight,
        boxShadowSecondary,
        paddingSM,
        paddingXS,
        tooltipRadiusOuter
      } = token2;
      return [
        {
          [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), {
            position: "absolute",
            zIndex: zIndexPopup,
            display: "block",
            width: "max-content",
            maxWidth: tooltipMaxWidth,
            visibility: "visible",
            "&-hidden": {
              display: "none"
            },
            "--antd-arrow-background-color": tooltipBg,
            // Wrapper for the tooltip content
            [`${componentCls}-inner`]: {
              minWidth: controlHeight,
              minHeight: controlHeight,
              padding: `${paddingSM / 2}px ${paddingXS}px`,
              color: tooltipColor,
              textAlign: "start",
              textDecoration: "none",
              wordWrap: "break-word",
              backgroundColor: tooltipBg,
              borderRadius: tooltipBorderRadius,
              boxShadow: boxShadowSecondary
            },
            // Limit left and right placement radius
            [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
              [`${componentCls}-inner`]: {
                borderRadius: Math.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
              }
            },
            [`${componentCls}-content`]: {
              position: "relative"
            }
          }), genPresetColor(token2, (colorKey, _ref) => {
            let {
              darkColor
            } = _ref;
            return {
              [`&${componentCls}-${colorKey}`]: {
                [`${componentCls}-inner`]: {
                  backgroundColor: darkColor
                },
                [`${componentCls}-arrow`]: {
                  "--antd-arrow-background-color": darkColor
                }
              }
            };
          })), {
            // RTL
            "&-rtl": {
              direction: "rtl"
            }
          })
        },
        // Arrow Style
        getArrowStyle(merge$4(token2, {
          borderRadiusOuter: tooltipRadiusOuter
        }), {
          colorBg: "var(--antd-arrow-background-color)",
          contentRadius: tooltipBorderRadius,
          limitVerticalRadius: true
        }),
        // Pure Render
        {
          [`${componentCls}-pure`]: {
            position: "relative",
            maxWidth: "none",
            margin: token2.sizePopupArrow
          }
        }
      ];
    };
    const useStyle$s = (prefixCls, injectStyle) => {
      const useOriginHook = genComponentStyleHook("Tooltip", (token2) => {
        if (injectStyle === false) {
          return [];
        }
        const {
          borderRadius,
          colorTextLightSolid,
          colorBgDefault,
          borderRadiusOuter
        } = token2;
        const TooltipToken = merge$4(token2, {
          // default variables
          tooltipMaxWidth: 250,
          tooltipColor: colorTextLightSolid,
          tooltipBorderRadius: borderRadius,
          tooltipBg: colorBgDefault,
          tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
        });
        return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
      }, (_ref2) => {
        let {
          zIndexPopupBase,
          colorBgSpotlight
        } = _ref2;
        return {
          zIndexPopup: zIndexPopupBase + 70,
          colorBgDefault: colorBgSpotlight
        };
      });
      return useOriginHook(prefixCls);
    };
    const inverseColors = PresetColors.map((color2) => `${color2}-inverse`);
    const PresetStatusColorTypes = ["success", "processing", "error", "default", "warning"];
    function isPresetColor(color2) {
      let includeInverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (includeInverse) {
        return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color2);
      }
      return PresetColors.includes(color2);
    }
    function isPresetStatusColor(color2) {
      return PresetStatusColorTypes.includes(color2);
    }
    function parseColor(prefixCls, color2) {
      const isInternalColor = isPresetColor(color2);
      const className = classNames({
        [`${prefixCls}-${color2}`]: color2 && isInternalColor
      });
      const overlayStyle = {};
      const arrowStyle = {};
      if (color2 && !isInternalColor) {
        overlayStyle.background = color2;
        arrowStyle["--antd-arrow-background-color"] = color2;
      }
      return {
        className,
        overlayStyle,
        arrowStyle
      };
    }
    function PurePanel$6(props) {
      const {
        prefixCls: customizePrefixCls,
        className,
        placement = "top",
        title,
        color: color2,
        overlayInnerStyle
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$s(prefixCls, true);
      const colorInfo = parseColor(prefixCls, color2);
      const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
      const arrowContentStyle = colorInfo.arrowStyle;
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className),
        style: arrowContentStyle
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-arrow`
      }), /* @__PURE__ */ reactExports.createElement(Popup$1, Object.assign({}, props, {
        className: hashId,
        prefixCls,
        overlayInnerStyle: formattedOverlayInnerStyle
      }), title)));
    }
    var __rest$U = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const {
      useToken: useToken$1
    } = theme;
    const splitObject = (obj, keys2) => {
      const picked = {};
      const omitted = Object.assign({}, obj);
      keys2.forEach((key) => {
        if (obj && key in obj) {
          picked[key] = obj[key];
          delete omitted[key];
        }
      });
      return {
        picked,
        omitted
      };
    };
    function getDisabledCompatibleChildren(element, prefixCls) {
      const elementType = element.type;
      if ((elementType.__ANT_BUTTON === true || element.type === "button") && element.props.disabled || elementType.__ANT_SWITCH === true && (element.props.disabled || element.props.loading) || elementType.__ANT_RADIO === true && element.props.disabled) {
        const {
          picked,
          omitted
        } = splitObject(element.props.style, ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]);
        const spanStyle = Object.assign(Object.assign({
          display: "inline-block"
        }, picked), {
          cursor: "not-allowed",
          width: element.props.block ? "100%" : void 0
        });
        const buttonStyle = Object.assign(Object.assign({}, omitted), {
          pointerEvents: "none"
        });
        const child = cloneElement(element, {
          style: buttonStyle,
          className: null
        });
        return /* @__PURE__ */ reactExports.createElement("span", {
          style: spanStyle,
          className: classNames(element.props.className, `${prefixCls}-disabled-compatible-wrapper`)
        }, child);
      }
      return element;
    }
    const Tooltip = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a, _b;
      const {
        prefixCls: customizePrefixCls,
        openClassName,
        getTooltipContainer,
        overlayClassName,
        color: color2,
        overlayInnerStyle,
        children,
        afterOpenChange,
        afterVisibleChange,
        destroyTooltipOnHide,
        arrow = true
      } = props;
      const mergedShowArrow = !!arrow;
      const {
        token: token2
      } = useToken$1();
      const {
        getPopupContainer: getContextPopupContainer,
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const tooltipRef = reactExports.useRef(null);
      const forceAlign = () => {
        var _a2;
        (_a2 = tooltipRef.current) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
      };
      reactExports.useImperativeHandle(ref, () => ({
        forceAlign,
        forcePopupAlign: () => {
          forceAlign();
        }
      }));
      const [open2, setOpen] = useMergedState(false, {
        value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
        defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
      });
      const isNoTitle = () => {
        const {
          title,
          overlay
        } = props;
        return !title && !overlay && title !== 0;
      };
      const onOpenChange = (vis) => {
        var _a2, _b2;
        setOpen(isNoTitle() ? false : vis);
        if (!isNoTitle()) {
          (_a2 = props.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, vis);
          (_b2 = props.onVisibleChange) === null || _b2 === void 0 ? void 0 : _b2.call(props, vis);
        }
      };
      const getTooltipPlacements = () => {
        var _a2, _b2;
        const {
          builtinPlacements,
          arrowPointAtCenter = false,
          autoAdjustOverflow: autoAdjustOverflow2 = true
        } = props;
        let mergedArrowPointAtCenter = arrowPointAtCenter;
        if (typeof arrow === "object") {
          mergedArrowPointAtCenter = (_b2 = (_a2 = arrow.pointAtCenter) !== null && _a2 !== void 0 ? _a2 : arrow.arrowPointAtCenter) !== null && _b2 !== void 0 ? _b2 : arrowPointAtCenter;
        }
        return builtinPlacements || getPlacements({
          arrowPointAtCenter: mergedArrowPointAtCenter,
          autoAdjustOverflow: autoAdjustOverflow2,
          arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
          borderRadius: token2.borderRadius,
          offset: token2.marginXXS
        });
      };
      const onPopupAlign = (domNode, align) => {
        const placements2 = getTooltipPlacements();
        const placement2 = Object.keys(placements2).find((key) => {
          var _a2, _b2;
          return placements2[key].points[0] === ((_a2 = align.points) === null || _a2 === void 0 ? void 0 : _a2[0]) && placements2[key].points[1] === ((_b2 = align.points) === null || _b2 === void 0 ? void 0 : _b2[1]);
        });
        if (placement2) {
          const rect = domNode.getBoundingClientRect();
          const transformOrigin = {
            top: "50%",
            left: "50%"
          };
          if (/top|Bottom/.test(placement2)) {
            transformOrigin.top = `${rect.height - align.offset[1]}px`;
          } else if (/Top|bottom/.test(placement2)) {
            transformOrigin.top = `${-align.offset[1]}px`;
          }
          if (/left|Right/.test(placement2)) {
            transformOrigin.left = `${rect.width - align.offset[0]}px`;
          } else if (/right|Left/.test(placement2)) {
            transformOrigin.left = `${-align.offset[0]}px`;
          }
          domNode.style.transformOrigin = `${transformOrigin.left} ${transformOrigin.top}`;
        }
      };
      const getOverlay2 = () => {
        const {
          title,
          overlay
        } = props;
        if (title === 0) {
          return title;
        }
        return overlay || title || "";
      };
      const {
        getPopupContainer,
        placement = "top",
        mouseEnterDelay = 0.1,
        mouseLeaveDelay = 0.1,
        overlayStyle,
        rootClassName
      } = props, otherProps = __rest$U(props, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]);
      const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
      const rootPrefixCls = getPrefixCls();
      const injectFromPopover = props["data-popover-inject"];
      let tempOpen = open2;
      if (!("open" in props) && !("visible" in props) && isNoTitle()) {
        tempOpen = false;
      }
      const child = getDisabledCompatibleChildren(isValidElement(children) && !isFragment(children) ? children : /* @__PURE__ */ reactExports.createElement("span", null, children), prefixCls);
      const childProps = child.props;
      const childCls = !childProps.className || typeof childProps.className === "string" ? classNames(childProps.className, {
        [openClassName || `${prefixCls}-open`]: true
      }) : childProps.className;
      const [wrapSSR, hashId] = useStyle$s(prefixCls, !injectFromPopover);
      const colorInfo = parseColor(prefixCls, color2);
      const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
      const arrowContentStyle = colorInfo.arrowStyle;
      const customOverlayClassName = classNames(overlayClassName, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, colorInfo.className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(Tooltip$2, Object.assign({}, otherProps, {
        showArrow: mergedShowArrow,
        placement,
        mouseEnterDelay,
        mouseLeaveDelay,
        prefixCls,
        overlayClassName: customOverlayClassName,
        overlayStyle: Object.assign(Object.assign({}, arrowContentStyle), overlayStyle),
        getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
        ref: tooltipRef,
        builtinPlacements: getTooltipPlacements(),
        overlay: getOverlay2(),
        visible: tempOpen,
        onVisibleChange: onOpenChange,
        afterVisibleChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
        onPopupAlign,
        overlayInnerStyle: formattedOverlayInnerStyle,
        arrowContent: /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-arrow-content`
        }),
        motion: {
          motionName: getTransitionName$1(rootPrefixCls, "zoom-big-fast", props.transitionName),
          motionDeadline: 1e3
        },
        destroyTooltipOnHide: !!destroyTooltipOnHide
      }), tempOpen ? cloneElement(child, {
        className: childCls
      }) : child));
    });
    Tooltip._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$6;
    const pn = Tooltip;
    const getRenderPropValue = (propValue) => {
      if (!propValue) {
        return null;
      }
      if (typeof propValue === "function") {
        return propValue();
      }
      return propValue;
    };
    const genBaseStyle$8 = (token2) => {
      const {
        componentCls,
        popoverBg,
        popoverColor,
        width,
        fontWeightStrong,
        popoverPadding,
        boxShadowSecondary,
        colorTextHeading,
        borderRadiusLG: borderRadius,
        zIndexPopup,
        marginXS,
        colorBgElevated
      } = token2;
      return [
        {
          [componentCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
            position: "absolute",
            top: 0,
            // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
            left: {
              _skip_check_: true,
              value: 0
            },
            zIndex: zIndexPopup,
            fontWeight: "normal",
            whiteSpace: "normal",
            textAlign: "start",
            cursor: "auto",
            userSelect: "text",
            "--antd-arrow-background-color": colorBgElevated,
            "&-rtl": {
              direction: "rtl"
            },
            "&-hidden": {
              display: "none"
            },
            [`${componentCls}-content`]: {
              position: "relative"
            },
            [`${componentCls}-inner`]: {
              backgroundColor: popoverBg,
              backgroundClip: "padding-box",
              borderRadius,
              boxShadow: boxShadowSecondary,
              padding: popoverPadding
            },
            [`${componentCls}-title`]: {
              minWidth: width,
              marginBottom: marginXS,
              color: colorTextHeading,
              fontWeight: fontWeightStrong
            },
            [`${componentCls}-inner-content`]: {
              color: popoverColor
            }
          })
        },
        // Arrow Style
        getArrowStyle(token2, {
          colorBg: "var(--antd-arrow-background-color)"
        }),
        // Pure Render
        {
          [`${componentCls}-pure`]: {
            position: "relative",
            maxWidth: "none",
            margin: token2.sizePopupArrow,
            display: "inline-block",
            [`${componentCls}-content`]: {
              display: "inline-block"
            }
          }
        }
      ];
    };
    const genColorStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: PresetColors.map((colorKey) => {
          const lightColor = token2[`${colorKey}6`];
          return {
            [`&${componentCls}-${colorKey}`]: {
              "--antd-arrow-background-color": lightColor,
              [`${componentCls}-inner`]: {
                backgroundColor: lightColor
              },
              [`${componentCls}-arrow`]: {
                background: "transparent"
              }
            }
          };
        })
      };
    };
    const genWireframeStyle = (token2) => {
      const {
        componentCls,
        lineWidth,
        lineType,
        colorSplit,
        paddingSM,
        controlHeight,
        fontSize,
        lineHeight,
        padding
      } = token2;
      const titlePaddingBlockDist = controlHeight - Math.round(fontSize * lineHeight);
      const popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2;
      const popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth;
      const popoverPaddingHorizontal = padding;
      return {
        [componentCls]: {
          [`${componentCls}-inner`]: {
            padding: 0
          },
          [`${componentCls}-title`]: {
            margin: 0,
            padding: `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px`,
            borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`
          },
          [`${componentCls}-inner-content`]: {
            padding: `${paddingSM}px ${popoverPaddingHorizontal}px`
          }
        }
      };
    };
    const useStyle$r = genComponentStyleHook("Popover", (token2) => {
      const {
        colorBgElevated,
        colorText,
        wireframe
      } = token2;
      const popoverToken = merge$4(token2, {
        popoverBg: colorBgElevated,
        popoverColor: colorText,
        popoverPadding: 12
        // Fixed Value
      });
      return [genBaseStyle$8(popoverToken), genColorStyle(popoverToken), wireframe && genWireframeStyle(popoverToken), initZoomMotion(popoverToken, "zoom-big")];
    }, (_ref) => {
      let {
        zIndexPopupBase
      } = _ref;
      return {
        zIndexPopup: zIndexPopupBase + 30,
        width: 177
      };
    });
    var __rest$T = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const getOverlay = (prefixCls, title, content2) => {
      if (!title && !content2)
        return void 0;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, title && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-title`
      }, getRenderPropValue(title)), /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-inner-content`
      }, getRenderPropValue(content2)));
    };
    function RawPurePanel(props) {
      const {
        hashId,
        prefixCls,
        className,
        style: style2,
        placement = "top",
        title,
        content: content2,
        children
      } = props;
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className),
        style: style2
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-arrow`
      }), /* @__PURE__ */ reactExports.createElement(Popup$1, Object.assign({}, props, {
        className: hashId,
        prefixCls
      }), children || getOverlay(prefixCls, title, content2)));
    }
    function PurePanel$5(props) {
      const {
        prefixCls: customizePrefixCls
      } = props, restProps = __rest$T(props, ["prefixCls"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("popover", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$r(prefixCls);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(RawPurePanel, Object.assign({}, restProps, {
        prefixCls,
        hashId
      })));
    }
    var __rest$S = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Overlay$1 = (_ref) => {
      let {
        title,
        content: content2,
        prefixCls
      } = _ref;
      if (!title && !content2) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, title && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-title`
      }, getRenderPropValue(title)), /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-inner-content`
      }, getRenderPropValue(content2)));
    };
    const Popover = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        title,
        content: content2,
        overlayClassName,
        placement = "top",
        trigger = "hover",
        mouseEnterDelay = 0.1,
        mouseLeaveDelay = 0.1,
        overlayStyle = {}
      } = props, otherProps = __rest$S(props, ["prefixCls", "title", "content", "overlayClassName", "placement", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("popover", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$r(prefixCls);
      const rootPrefixCls = getPrefixCls();
      const overlayCls = classNames(overlayClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(pn, Object.assign({
        placement,
        trigger,
        mouseEnterDelay,
        mouseLeaveDelay,
        overlayStyle
      }, otherProps, {
        prefixCls,
        overlayClassName: overlayCls,
        ref,
        overlay: /* @__PURE__ */ reactExports.createElement(Overlay$1, {
          prefixCls,
          title,
          content: content2
        }),
        transitionName: getTransitionName$1(rootPrefixCls, "zoom-big", otherProps.transitionName),
        "data-popover-inject": true
      })));
    });
    Popover._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$5;
    const Popover$1 = Popover;
    const Group$4 = (props) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        maxCount,
        maxStyle,
        size
      } = props;
      const prefixCls = getPrefixCls("avatar", customizePrefixCls);
      const groupPrefixCls = `${prefixCls}-group`;
      const [wrapSSR, hashId] = useStyle$t(prefixCls);
      const cls = classNames(groupPrefixCls, {
        [`${groupPrefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      const {
        children,
        maxPopoverPlacement = "top",
        maxPopoverTrigger = "hover"
      } = props;
      const childrenWithProps = toArray$8(children).map((child, index2) => cloneElement(child, {
        key: `avatar-key-${index2}`
      }));
      const numOfChildren = childrenWithProps.length;
      if (maxCount && maxCount < numOfChildren) {
        const childrenShow = childrenWithProps.slice(0, maxCount);
        const childrenHidden = childrenWithProps.slice(maxCount, numOfChildren);
        childrenShow.push(/* @__PURE__ */ reactExports.createElement(Popover$1, {
          key: "avatar-popover-key",
          content: childrenHidden,
          trigger: maxPopoverTrigger,
          placement: maxPopoverPlacement,
          overlayClassName: `${groupPrefixCls}-popover`
        }, /* @__PURE__ */ reactExports.createElement(InternalAvatar$1, {
          style: maxStyle
        }, `+${numOfChildren - maxCount}`)));
        return wrapSSR(/* @__PURE__ */ reactExports.createElement(SizeContextProvider, {
          size
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: cls,
          style: props.style
        }, childrenShow)));
      }
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(SizeContextProvider, {
        size
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: cls,
        style: props.style
      }, childrenWithProps)));
    };
    const Group$5 = Group$4;
    const Avatar = InternalAvatar$1;
    Avatar.Group = Group$5;
    const Avatar$1 = Avatar;
    var RightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
    const RightOutlinedSvg = RightOutlined$2;
    var RightOutlined = function RightOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: RightOutlinedSvg
      }));
    };
    RightOutlined.displayName = "RightOutlined";
    const RightOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(RightOutlined);
    var Portal = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var didUpdate = props.didUpdate, getContainer2 = props.getContainer, children = props.children;
      var parentRef = reactExports.useRef();
      var containerRef = reactExports.useRef();
      reactExports.useImperativeHandle(ref, function() {
        return {};
      });
      var initRef = reactExports.useRef(false);
      if (!initRef.current && canUseDom$2()) {
        containerRef.current = getContainer2();
        parentRef.current = containerRef.current.parentNode;
        initRef.current = true;
      }
      reactExports.useEffect(function() {
        didUpdate === null || didUpdate === void 0 ? void 0 : didUpdate(props);
      });
      reactExports.useEffect(function() {
        if (containerRef.current.parentNode === null && parentRef.current !== null) {
          parentRef.current.appendChild(containerRef.current);
        }
        return function() {
          var _containerRef$current, _containerRef$current2;
          (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.parentNode) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.removeChild(containerRef.current);
        };
      }, []);
      return containerRef.current ? /* @__PURE__ */ ReactDOM.createPortal(children, containerRef.current) : null;
    });
    function isPointsEq(a1, a2, isAlignPoint) {
      if (isAlignPoint) {
        return a1[0] === a2[0];
      }
      return a1[0] === a2[0] && a1[1] === a2[1];
    }
    function getAlignFromPlacement(builtinPlacements, placementStr, align) {
      var baseAlign = builtinPlacements[placementStr] || {};
      return _objectSpread2$3(_objectSpread2$3({}, baseAlign), align);
    }
    function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
      var points = align.points;
      var placements2 = Object.keys(builtinPlacements);
      for (var i2 = 0; i2 < placements2.length; i2 += 1) {
        var placement = placements2[i2];
        if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
          return "".concat(prefixCls, "-placement-").concat(placement);
        }
      }
      return "";
    }
    function getMotion$1(_ref) {
      var prefixCls = _ref.prefixCls, motion2 = _ref.motion, animation = _ref.animation, transitionName = _ref.transitionName;
      if (motion2) {
        return motion2;
      }
      if (animation) {
        return {
          motionName: "".concat(prefixCls, "-").concat(animation)
        };
      }
      if (transitionName) {
        return {
          motionName: transitionName
        };
      }
      return null;
    }
    function Mask(props) {
      var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, mask = props.mask, maskMotion = props.maskMotion, maskAnimation = props.maskAnimation, maskTransitionName = props.maskTransitionName;
      if (!mask) {
        return null;
      }
      var motion2 = {};
      if (maskMotion || maskTransitionName || maskAnimation) {
        motion2 = _objectSpread2$3({
          motionAppear: true
        }, getMotion$1({
          motion: maskMotion,
          prefixCls,
          transitionName: maskTransitionName,
          animation: maskAnimation
        }));
      }
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$2({}, motion2, {
        visible,
        removeOnLeave: true
      }), function(_ref) {
        var className = _ref.className;
        return /* @__PURE__ */ reactExports.createElement("div", {
          style: {
            zIndex
          },
          className: classNames("".concat(prefixCls, "-mask"), className)
        });
      });
    }
    function ownKeys$1(object2, enumerableOnly) {
      var keys2 = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread2$2(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
          _defineProperty$6(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _typeof$3(obj) {
      "@babel/helpers - typeof";
      return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$3(obj);
    }
    function _defineProperty$6(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var vendorPrefix;
    var jsCssMap = {
      Webkit: "-webkit-",
      Moz: "-moz-",
      // IE did it wrong again ...
      ms: "-ms-",
      O: "-o-"
    };
    function getVendorPrefix() {
      if (vendorPrefix !== void 0) {
        return vendorPrefix;
      }
      vendorPrefix = "";
      var style2 = document.createElement("p").style;
      var testProp = "Transform";
      for (var key in jsCssMap) {
        if (key + testProp in style2) {
          vendorPrefix = key;
        }
      }
      return vendorPrefix;
    }
    function getTransitionName() {
      return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
    }
    function getTransformName() {
      return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
    }
    function setTransitionProperty(node2, value) {
      var name = getTransitionName();
      if (name) {
        node2.style[name] = value;
        if (name !== "transitionProperty") {
          node2.style.transitionProperty = value;
        }
      }
    }
    function setTransform(node2, value) {
      var name = getTransformName();
      if (name) {
        node2.style[name] = value;
        if (name !== "transform") {
          node2.style.transform = value;
        }
      }
    }
    function getTransitionProperty(node2) {
      return node2.style.transitionProperty || node2.style[getTransitionName()];
    }
    function getTransformXY(node2) {
      var style2 = window.getComputedStyle(node2, null);
      var transform = style2.getPropertyValue("transform") || style2.getPropertyValue(getTransformName());
      if (transform && transform !== "none") {
        var matrix = transform.replace(/[^0-9\-.,]/g, "").split(",");
        return {
          x: parseFloat(matrix[12] || matrix[4], 0),
          y: parseFloat(matrix[13] || matrix[5], 0)
        };
      }
      return {
        x: 0,
        y: 0
      };
    }
    var matrix2d = /matrix\((.*)\)/;
    var matrix3d = /matrix3d\((.*)\)/;
    function setTransformXY(node2, xy) {
      var style2 = window.getComputedStyle(node2, null);
      var transform = style2.getPropertyValue("transform") || style2.getPropertyValue(getTransformName());
      if (transform && transform !== "none") {
        var arr;
        var match2d = transform.match(matrix2d);
        if (match2d) {
          match2d = match2d[1];
          arr = match2d.split(",").map(function(item) {
            return parseFloat(item, 10);
          });
          arr[4] = xy.x;
          arr[5] = xy.y;
          setTransform(node2, "matrix(".concat(arr.join(","), ")"));
        } else {
          var match3d = transform.match(matrix3d)[1];
          arr = match3d.split(",").map(function(item) {
            return parseFloat(item, 10);
          });
          arr[12] = xy.x;
          arr[13] = xy.y;
          setTransform(node2, "matrix3d(".concat(arr.join(","), ")"));
        }
      } else {
        setTransform(node2, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
      }
    }
    var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
    var getComputedStyleX;
    function forceRelayout(elem) {
      var originalStyle = elem.style.display;
      elem.style.display = "none";
      elem.offsetHeight;
      elem.style.display = originalStyle;
    }
    function css(el2, name, v2) {
      var value = v2;
      if (_typeof$3(name) === "object") {
        for (var i2 in name) {
          if (name.hasOwnProperty(i2)) {
            css(el2, i2, name[i2]);
          }
        }
        return void 0;
      }
      if (typeof value !== "undefined") {
        if (typeof value === "number") {
          value = "".concat(value, "px");
        }
        el2.style[name] = value;
        return void 0;
      }
      return getComputedStyleX(el2, name);
    }
    function getClientPosition(elem) {
      var box2;
      var x2;
      var y2;
      var doc = elem.ownerDocument;
      var body = doc.body;
      var docElem = doc && doc.documentElement;
      box2 = elem.getBoundingClientRect();
      x2 = Math.floor(box2.left);
      y2 = Math.floor(box2.top);
      x2 -= docElem.clientLeft || body.clientLeft || 0;
      y2 -= docElem.clientTop || body.clientTop || 0;
      return {
        left: x2,
        top: y2
      };
    }
    function getScroll(w2, top) {
      var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
      var method2 = "scroll".concat(top ? "Top" : "Left");
      if (typeof ret !== "number") {
        var d2 = w2.document;
        ret = d2.documentElement[method2];
        if (typeof ret !== "number") {
          ret = d2.body[method2];
        }
      }
      return ret;
    }
    function getScrollLeft(w2) {
      return getScroll(w2);
    }
    function getScrollTop(w2) {
      return getScroll(w2, true);
    }
    function getOffset$2(el2) {
      var pos = getClientPosition(el2);
      var doc = el2.ownerDocument;
      var w2 = doc.defaultView || doc.parentWindow;
      pos.left += getScrollLeft(w2);
      pos.top += getScrollTop(w2);
      return pos;
    }
    function isWindow(obj) {
      return obj !== null && obj !== void 0 && obj == obj.window;
    }
    function getDocument(node2) {
      if (isWindow(node2)) {
        return node2.document;
      }
      if (node2.nodeType === 9) {
        return node2;
      }
      return node2.ownerDocument;
    }
    function _getComputedStyle(elem, name, cs) {
      var computedStyle = cs;
      var val = "";
      var d2 = getDocument(elem);
      computedStyle = computedStyle || d2.defaultView.getComputedStyle(elem, null);
      if (computedStyle) {
        val = computedStyle.getPropertyValue(name) || computedStyle[name];
      }
      return val;
    }
    var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i");
    var RE_POS = /^(top|right|bottom|left)$/;
    var CURRENT_STYLE = "currentStyle";
    var RUNTIME_STYLE = "runtimeStyle";
    var LEFT$1 = "left";
    var PX = "px";
    function _getComputedStyleIE(elem, name) {
      var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];
      if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
        var style2 = elem.style;
        var left = style2[LEFT$1];
        var rsLeft = elem[RUNTIME_STYLE][LEFT$1];
        elem[RUNTIME_STYLE][LEFT$1] = elem[CURRENT_STYLE][LEFT$1];
        style2[LEFT$1] = name === "fontSize" ? "1em" : ret || 0;
        ret = style2.pixelLeft + PX;
        style2[LEFT$1] = left;
        elem[RUNTIME_STYLE][LEFT$1] = rsLeft;
      }
      return ret === "" ? "auto" : ret;
    }
    if (typeof window !== "undefined") {
      getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
    }
    function getOffsetDirection(dir, option) {
      if (dir === "left") {
        return option.useCssRight ? "right" : dir;
      }
      return option.useCssBottom ? "bottom" : dir;
    }
    function oppositeOffsetDirection(dir) {
      if (dir === "left") {
        return "right";
      } else if (dir === "right") {
        return "left";
      } else if (dir === "top") {
        return "bottom";
      } else if (dir === "bottom") {
        return "top";
      }
    }
    function setLeftTop(elem, offset2, option) {
      if (css(elem, "position") === "static") {
        elem.style.position = "relative";
      }
      var presetH = -999;
      var presetV = -999;
      var horizontalProperty = getOffsetDirection("left", option);
      var verticalProperty = getOffsetDirection("top", option);
      var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
      var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
      if (horizontalProperty !== "left") {
        presetH = 999;
      }
      if (verticalProperty !== "top") {
        presetV = 999;
      }
      var originalTransition = "";
      var originalOffset = getOffset$2(elem);
      if ("left" in offset2 || "top" in offset2) {
        originalTransition = getTransitionProperty(elem) || "";
        setTransitionProperty(elem, "none");
      }
      if ("left" in offset2) {
        elem.style[oppositeHorizontalProperty] = "";
        elem.style[horizontalProperty] = "".concat(presetH, "px");
      }
      if ("top" in offset2) {
        elem.style[oppositeVerticalProperty] = "";
        elem.style[verticalProperty] = "".concat(presetV, "px");
      }
      forceRelayout(elem);
      var old = getOffset$2(elem);
      var originalStyle = {};
      for (var key in offset2) {
        if (offset2.hasOwnProperty(key)) {
          var dir = getOffsetDirection(key, option);
          var preset2 = key === "left" ? presetH : presetV;
          var off = originalOffset[key] - old[key];
          if (dir === key) {
            originalStyle[dir] = preset2 + off;
          } else {
            originalStyle[dir] = preset2 - off;
          }
        }
      }
      css(elem, originalStyle);
      forceRelayout(elem);
      if ("left" in offset2 || "top" in offset2) {
        setTransitionProperty(elem, originalTransition);
      }
      var ret = {};
      for (var _key in offset2) {
        if (offset2.hasOwnProperty(_key)) {
          var _dir = getOffsetDirection(_key, option);
          var _off = offset2[_key] - originalOffset[_key];
          if (_key === _dir) {
            ret[_dir] = originalStyle[_dir] + _off;
          } else {
            ret[_dir] = originalStyle[_dir] - _off;
          }
        }
      }
      css(elem, ret);
    }
    function setTransform$1(elem, offset2) {
      var originalOffset = getOffset$2(elem);
      var originalXY = getTransformXY(elem);
      var resultXY = {
        x: originalXY.x,
        y: originalXY.y
      };
      if ("left" in offset2) {
        resultXY.x = originalXY.x + offset2.left - originalOffset.left;
      }
      if ("top" in offset2) {
        resultXY.y = originalXY.y + offset2.top - originalOffset.top;
      }
      setTransformXY(elem, resultXY);
    }
    function setOffset(elem, offset2, option) {
      if (option.ignoreShake) {
        var oriOffset = getOffset$2(elem);
        var oLeft = oriOffset.left.toFixed(0);
        var oTop = oriOffset.top.toFixed(0);
        var tLeft = offset2.left.toFixed(0);
        var tTop = offset2.top.toFixed(0);
        if (oLeft === tLeft && oTop === tTop) {
          return;
        }
      }
      if (option.useCssRight || option.useCssBottom) {
        setLeftTop(elem, offset2, option);
      } else if (option.useCssTransform && getTransformName() in document.body.style) {
        setTransform$1(elem, offset2);
      } else {
        setLeftTop(elem, offset2, option);
      }
    }
    function each(arr, fn) {
      for (var i2 = 0; i2 < arr.length; i2++) {
        fn(arr[i2]);
      }
    }
    function isBorderBoxFn(elem) {
      return getComputedStyleX(elem, "boxSizing") === "border-box";
    }
    var BOX_MODELS = ["margin", "border", "padding"];
    var CONTENT_INDEX = -1;
    var PADDING_INDEX = 2;
    var BORDER_INDEX = 1;
    var MARGIN_INDEX = 0;
    function swap(elem, options, callback) {
      var old = {};
      var style2 = elem.style;
      var name;
      for (name in options) {
        if (options.hasOwnProperty(name)) {
          old[name] = style2[name];
          style2[name] = options[name];
        }
      }
      callback.call(elem);
      for (name in options) {
        if (options.hasOwnProperty(name)) {
          style2[name] = old[name];
        }
      }
    }
    function getPBMWidth(elem, props, which) {
      var value = 0;
      var prop;
      var j;
      var i2;
      for (j = 0; j < props.length; j++) {
        prop = props[j];
        if (prop) {
          for (i2 = 0; i2 < which.length; i2++) {
            var cssProp = void 0;
            if (prop === "border") {
              cssProp = "".concat(prop).concat(which[i2], "Width");
            } else {
              cssProp = prop + which[i2];
            }
            value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
          }
        }
      }
      return value;
    }
    var domUtils = {
      getParent: function getParent2(element) {
        var parent = element;
        do {
          if (parent.nodeType === 11 && parent.host) {
            parent = parent.host;
          } else {
            parent = parent.parentNode;
          }
        } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);
        return parent;
      }
    };
    each(["Width", "Height"], function(name) {
      domUtils["doc".concat(name)] = function(refWin) {
        var d2 = refWin.document;
        return Math.max(
          // firefox chrome documentElement.scrollHeight< body.scrollHeight
          // ie standard mode : documentElement.scrollHeight> body.scrollHeight
          d2.documentElement["scroll".concat(name)],
          // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
          d2.body["scroll".concat(name)],
          domUtils["viewport".concat(name)](d2)
        );
      };
      domUtils["viewport".concat(name)] = function(win) {
        var prop = "client".concat(name);
        var doc = win.document;
        var body = doc.body;
        var documentElement = doc.documentElement;
        var documentElementProp = documentElement[prop];
        return doc.compatMode === "CSS1Compat" && documentElementProp || body && body[prop] || documentElementProp;
      };
    });
    function getWH(elem, name, ex) {
      var extra = ex;
      if (isWindow(elem)) {
        return name === "width" ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
      } else if (elem.nodeType === 9) {
        return name === "width" ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
      }
      var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
      var borderBoxValue = name === "width" ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
      var isBorderBox = isBorderBoxFn(elem);
      var cssBoxValue = 0;
      if (borderBoxValue === null || borderBoxValue === void 0 || borderBoxValue <= 0) {
        borderBoxValue = void 0;
        cssBoxValue = getComputedStyleX(elem, name);
        if (cssBoxValue === null || cssBoxValue === void 0 || Number(cssBoxValue) < 0) {
          cssBoxValue = elem.style[name] || 0;
        }
        cssBoxValue = Math.floor(parseFloat(cssBoxValue)) || 0;
      }
      if (extra === void 0) {
        extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
      }
      var borderBoxValueOrIsBorderBox = borderBoxValue !== void 0 || isBorderBox;
      var val = borderBoxValue || cssBoxValue;
      if (extra === CONTENT_INDEX) {
        if (borderBoxValueOrIsBorderBox) {
          return val - getPBMWidth(elem, ["border", "padding"], which);
        }
        return cssBoxValue;
      } else if (borderBoxValueOrIsBorderBox) {
        if (extra === BORDER_INDEX) {
          return val;
        }
        return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ["border"], which) : getPBMWidth(elem, ["margin"], which));
      }
      return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
    }
    var cssShow = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    };
    function getWHIgnoreDisplay() {
      for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
        args[_key2] = arguments[_key2];
      }
      var val;
      var elem = args[0];
      if (elem.offsetWidth !== 0) {
        val = getWH.apply(void 0, args);
      } else {
        swap(elem, cssShow, function() {
          val = getWH.apply(void 0, args);
        });
      }
      return val;
    }
    each(["width", "height"], function(name) {
      var first = name.charAt(0).toUpperCase() + name.slice(1);
      domUtils["outer".concat(first)] = function(el2, includeMargin) {
        return el2 && getWHIgnoreDisplay(el2, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
      };
      var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
      domUtils[name] = function(elem, v2) {
        var val = v2;
        if (val !== void 0) {
          if (elem) {
            var isBorderBox = isBorderBoxFn(elem);
            if (isBorderBox) {
              val += getPBMWidth(elem, ["padding", "border"], which);
            }
            return css(elem, name, val);
          }
          return void 0;
        }
        return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
      };
    });
    function mix$1(to, from2) {
      for (var i2 in from2) {
        if (from2.hasOwnProperty(i2)) {
          to[i2] = from2[i2];
        }
      }
      return to;
    }
    var utils$c = {
      getWindow: function getWindow(node2) {
        if (node2 && node2.document && node2.setTimeout) {
          return node2;
        }
        var doc = node2.ownerDocument || node2;
        return doc.defaultView || doc.parentWindow;
      },
      getDocument,
      offset: function offset2(el2, value, option) {
        if (typeof value !== "undefined") {
          setOffset(el2, value, option || {});
        } else {
          return getOffset$2(el2);
        }
      },
      isWindow,
      each,
      css,
      clone: function clone(obj) {
        var i2;
        var ret = {};
        for (i2 in obj) {
          if (obj.hasOwnProperty(i2)) {
            ret[i2] = obj[i2];
          }
        }
        var overflow = obj.overflow;
        if (overflow) {
          for (i2 in obj) {
            if (obj.hasOwnProperty(i2)) {
              ret.overflow[i2] = obj.overflow[i2];
            }
          }
        }
        return ret;
      },
      mix: mix$1,
      getWindowScrollLeft: function getWindowScrollLeft(w2) {
        return getScrollLeft(w2);
      },
      getWindowScrollTop: function getWindowScrollTop(w2) {
        return getScrollTop(w2);
      },
      merge: function merge2() {
        var ret = {};
        for (var i2 = 0; i2 < arguments.length; i2++) {
          utils$c.mix(ret, i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]);
        }
        return ret;
      },
      viewportWidth: 0,
      viewportHeight: 0
    };
    mix$1(utils$c, domUtils);
    var getParent = utils$c.getParent;
    function getOffsetParent(element) {
      if (utils$c.isWindow(element) || element.nodeType === 9) {
        return null;
      }
      var doc = utils$c.getDocument(element);
      var body = doc.body;
      var parent;
      var positionStyle = utils$c.css(element, "position");
      var skipStatic = positionStyle === "fixed" || positionStyle === "absolute";
      if (!skipStatic) {
        return element.nodeName.toLowerCase() === "html" ? null : getParent(element);
      }
      for (parent = getParent(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent(parent)) {
        positionStyle = utils$c.css(parent, "position");
        if (positionStyle !== "static") {
          return parent;
        }
      }
      return null;
    }
    var getParent$1 = utils$c.getParent;
    function isAncestorFixed(element) {
      if (utils$c.isWindow(element) || element.nodeType === 9) {
        return false;
      }
      var doc = utils$c.getDocument(element);
      var body = doc.body;
      var parent = null;
      for (
        parent = getParent$1(element);
        // 修复元素位于 document.documentElement 下导致崩溃问题
        parent && parent !== body && parent !== doc;
        parent = getParent$1(parent)
      ) {
        var positionStyle = utils$c.css(parent, "position");
        if (positionStyle === "fixed") {
          return true;
        }
      }
      return false;
    }
    function getVisibleRectForElement(element, alwaysByViewport) {
      var visibleRect = {
        left: 0,
        right: Infinity,
        top: 0,
        bottom: Infinity
      };
      var el2 = getOffsetParent(element);
      var doc = utils$c.getDocument(element);
      var win = doc.defaultView || doc.parentWindow;
      var body = doc.body;
      var documentElement = doc.documentElement;
      while (el2) {
        if ((navigator.userAgent.indexOf("MSIE") === -1 || el2.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
        // viewport. In some browsers, el.offsetParent may be
        // document.documentElement, so check for that too.
        el2 !== body && el2 !== documentElement && utils$c.css(el2, "overflow") !== "visible") {
          var pos = utils$c.offset(el2);
          pos.left += el2.clientLeft;
          pos.top += el2.clientTop;
          visibleRect.top = Math.max(visibleRect.top, pos.top);
          visibleRect.right = Math.min(
            visibleRect.right,
            // consider area without scrollBar
            pos.left + el2.clientWidth
          );
          visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el2.clientHeight);
          visibleRect.left = Math.max(visibleRect.left, pos.left);
        } else if (el2 === body || el2 === documentElement) {
          break;
        }
        el2 = getOffsetParent(el2);
      }
      var originalPosition = null;
      if (!utils$c.isWindow(element) && element.nodeType !== 9) {
        originalPosition = element.style.position;
        var position2 = utils$c.css(element, "position");
        if (position2 === "absolute") {
          element.style.position = "fixed";
        }
      }
      var scrollX = utils$c.getWindowScrollLeft(win);
      var scrollY = utils$c.getWindowScrollTop(win);
      var viewportWidth = utils$c.viewportWidth(win);
      var viewportHeight = utils$c.viewportHeight(win);
      var documentWidth = documentElement.scrollWidth;
      var documentHeight = documentElement.scrollHeight;
      var bodyStyle = window.getComputedStyle(body);
      if (bodyStyle.overflowX === "hidden") {
        documentWidth = win.innerWidth;
      }
      if (bodyStyle.overflowY === "hidden") {
        documentHeight = win.innerHeight;
      }
      if (element.style) {
        element.style.position = originalPosition;
      }
      if (alwaysByViewport || isAncestorFixed(element)) {
        visibleRect.left = Math.max(visibleRect.left, scrollX);
        visibleRect.top = Math.max(visibleRect.top, scrollY);
        visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
        visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
      } else {
        var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
        visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
        var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
        visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
      }
      return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
    }
    function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
      var pos = utils$c.clone(elFuturePos);
      var size = {
        width: elRegion.width,
        height: elRegion.height
      };
      if (overflow.adjustX && pos.left < visibleRect.left) {
        pos.left = visibleRect.left;
      }
      if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
        size.width -= pos.left + size.width - visibleRect.right;
      }
      if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
        pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
      }
      if (overflow.adjustY && pos.top < visibleRect.top) {
        pos.top = visibleRect.top;
      }
      if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
        size.height -= pos.top + size.height - visibleRect.bottom;
      }
      if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
        pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
      }
      return utils$c.mix(pos, size);
    }
    function getRegion(node2) {
      var offset2;
      var w2;
      var h2;
      if (!utils$c.isWindow(node2) && node2.nodeType !== 9) {
        offset2 = utils$c.offset(node2);
        w2 = utils$c.outerWidth(node2);
        h2 = utils$c.outerHeight(node2);
      } else {
        var win = utils$c.getWindow(node2);
        offset2 = {
          left: utils$c.getWindowScrollLeft(win),
          top: utils$c.getWindowScrollTop(win)
        };
        w2 = utils$c.viewportWidth(win);
        h2 = utils$c.viewportHeight(win);
      }
      offset2.width = w2;
      offset2.height = h2;
      return offset2;
    }
    function getAlignOffset(region, align) {
      var V2 = align.charAt(0);
      var H2 = align.charAt(1);
      var w2 = region.width;
      var h2 = region.height;
      var x2 = region.left;
      var y2 = region.top;
      if (V2 === "c") {
        y2 += h2 / 2;
      } else if (V2 === "b") {
        y2 += h2;
      }
      if (H2 === "c") {
        x2 += w2 / 2;
      } else if (H2 === "r") {
        x2 += w2;
      }
      return {
        left: x2,
        top: y2
      };
    }
    function getElFuturePos(elRegion, refNodeRegion, points, offset2, targetOffset2) {
      var p1 = getAlignOffset(refNodeRegion, points[1]);
      var p2 = getAlignOffset(elRegion, points[0]);
      var diff = [p2.left - p1.left, p2.top - p1.top];
      return {
        left: Math.round(elRegion.left - diff[0] + offset2[0] - targetOffset2[0]),
        top: Math.round(elRegion.top - diff[1] + offset2[1] - targetOffset2[1])
      };
    }
    function isFailX(elFuturePos, elRegion, visibleRect) {
      return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
    }
    function isFailY(elFuturePos, elRegion, visibleRect) {
      return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
    }
    function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
      return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
    }
    function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
      return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
    }
    function flip(points, reg, map) {
      var ret = [];
      utils$c.each(points, function(p2) {
        ret.push(p2.replace(reg, function(m2) {
          return map[m2];
        }));
      });
      return ret;
    }
    function flipOffset(offset2, index2) {
      offset2[index2] = -offset2[index2];
      return offset2;
    }
    function convertOffset(str, offsetLen) {
      var n2;
      if (/%$/.test(str)) {
        n2 = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
      } else {
        n2 = parseInt(str, 10);
      }
      return n2 || 0;
    }
    function normalizeOffset(offset2, el2) {
      offset2[0] = convertOffset(offset2[0], el2.width);
      offset2[1] = convertOffset(offset2[1], el2.height);
    }
    function doAlign(el2, tgtRegion, align, isTgtRegionVisible) {
      var points = align.points;
      var offset2 = align.offset || [0, 0];
      var targetOffset2 = align.targetOffset || [0, 0];
      var overflow = align.overflow;
      var source = align.source || el2;
      offset2 = [].concat(offset2);
      targetOffset2 = [].concat(targetOffset2);
      overflow = overflow || {};
      var newOverflowCfg = {};
      var fail2 = 0;
      var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
      var visibleRect = getVisibleRectForElement(source, alwaysByViewport);
      var elRegion = getRegion(source);
      normalizeOffset(offset2, elRegion);
      normalizeOffset(targetOffset2, tgtRegion);
      var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset2, targetOffset2);
      var newElRegion = utils$c.merge(elRegion, elFuturePos);
      if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
        if (overflow.adjustX) {
          if (isFailX(elFuturePos, elRegion, visibleRect)) {
            var newPoints = flip(points, /[lr]/gi, {
              l: "r",
              r: "l"
            });
            var newOffset = flipOffset(offset2, 0);
            var newTargetOffset = flipOffset(targetOffset2, 0);
            var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
            if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
              fail2 = 1;
              points = newPoints;
              offset2 = newOffset;
              targetOffset2 = newTargetOffset;
            }
          }
        }
        if (overflow.adjustY) {
          if (isFailY(elFuturePos, elRegion, visibleRect)) {
            var _newPoints = flip(points, /[tb]/gi, {
              t: "b",
              b: "t"
            });
            var _newOffset = flipOffset(offset2, 1);
            var _newTargetOffset = flipOffset(targetOffset2, 1);
            var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
            if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
              fail2 = 1;
              points = _newPoints;
              offset2 = _newOffset;
              targetOffset2 = _newTargetOffset;
            }
          }
        }
        if (fail2) {
          elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset2, targetOffset2);
          utils$c.mix(newElRegion, elFuturePos);
        }
        var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
        var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
        if (isStillFailX || isStillFailY) {
          var _newPoints2 = points;
          if (isStillFailX) {
            _newPoints2 = flip(points, /[lr]/gi, {
              l: "r",
              r: "l"
            });
          }
          if (isStillFailY) {
            _newPoints2 = flip(points, /[tb]/gi, {
              t: "b",
              b: "t"
            });
          }
          points = _newPoints2;
          offset2 = align.offset || [0, 0];
          targetOffset2 = align.targetOffset || [0, 0];
        }
        newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
        newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;
        if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
          newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
        }
      }
      if (newElRegion.width !== elRegion.width) {
        utils$c.css(source, "width", utils$c.width(source) + newElRegion.width - elRegion.width);
      }
      if (newElRegion.height !== elRegion.height) {
        utils$c.css(source, "height", utils$c.height(source) + newElRegion.height - elRegion.height);
      }
      utils$c.offset(source, {
        left: newElRegion.left,
        top: newElRegion.top
      }, {
        useCssRight: align.useCssRight,
        useCssBottom: align.useCssBottom,
        useCssTransform: align.useCssTransform,
        ignoreShake: align.ignoreShake
      });
      return {
        points,
        offset: offset2,
        targetOffset: targetOffset2,
        overflow: newOverflowCfg
      };
    }
    function isOutOfVisibleRect(target, alwaysByViewport) {
      var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
      var targetRegion = getRegion(target);
      return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
    }
    function alignElement(el2, refNode, align) {
      var target = align.target || refNode;
      var refNodeRegion = getRegion(target);
      var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
      return doAlign(el2, refNodeRegion, align, isTargetNotOutOfVisible);
    }
    alignElement.__getOffsetParent = getOffsetParent;
    alignElement.__getVisibleRectForElement = getVisibleRectForElement;
    function alignPoint(el2, tgtPoint, align) {
      var pageX;
      var pageY;
      var doc = utils$c.getDocument(el2);
      var win = doc.defaultView || doc.parentWindow;
      var scrollX = utils$c.getWindowScrollLeft(win);
      var scrollY = utils$c.getWindowScrollTop(win);
      var viewportWidth = utils$c.viewportWidth(win);
      var viewportHeight = utils$c.viewportHeight(win);
      if ("pageX" in tgtPoint) {
        pageX = tgtPoint.pageX;
      } else {
        pageX = scrollX + tgtPoint.clientX;
      }
      if ("pageY" in tgtPoint) {
        pageY = tgtPoint.pageY;
      } else {
        pageY = scrollY + tgtPoint.clientY;
      }
      var tgtRegion = {
        left: pageX,
        top: pageY,
        width: 0,
        height: 0
      };
      var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;
      var points = [align.points[0], "cc"];
      return doAlign(el2, tgtRegion, _objectSpread2$2(_objectSpread2$2({}, align), {}, {
        points
      }), pointInView);
    }
    const useBuffer = function(callback, buffer2) {
      var calledRef = React$3.useRef(false);
      var timeoutRef = React$3.useRef(null);
      function cancelTrigger() {
        window.clearTimeout(timeoutRef.current);
      }
      function trigger(force) {
        cancelTrigger();
        if (!calledRef.current || force === true) {
          if (callback(force) === false) {
            return;
          }
          calledRef.current = true;
          timeoutRef.current = window.setTimeout(function() {
            calledRef.current = false;
          }, buffer2);
        } else {
          timeoutRef.current = window.setTimeout(function() {
            calledRef.current = false;
            trigger();
          }, buffer2);
        }
      }
      return [trigger, function() {
        calledRef.current = false;
        cancelTrigger();
      }];
    };
    function isSamePoint(prev2, next2) {
      if (prev2 === next2)
        return true;
      if (!prev2 || !next2)
        return false;
      if ("pageX" in next2 && "pageY" in next2) {
        return prev2.pageX === next2.pageX && prev2.pageY === next2.pageY;
      }
      if ("clientX" in next2 && "clientY" in next2) {
        return prev2.clientX === next2.clientX && prev2.clientY === next2.clientY;
      }
      return false;
    }
    function restoreFocus(activeElement, container2) {
      if (activeElement !== document.activeElement && contains$2(container2, activeElement) && typeof activeElement.focus === "function") {
        activeElement.focus();
      }
    }
    function monitorResize(element, callback) {
      var prevWidth = null;
      var prevHeight = null;
      function onResize2(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), target = _ref2[0].target;
        if (!document.documentElement.contains(target))
          return;
        var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
        var fixedWidth = Math.floor(width);
        var fixedHeight = Math.floor(height);
        if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
          Promise.resolve().then(function() {
            callback({
              width: fixedWidth,
              height: fixedHeight
            });
          });
        }
        prevWidth = fixedWidth;
        prevHeight = fixedHeight;
      }
      var resizeObserver2 = new index$3(onResize2);
      if (element) {
        resizeObserver2.observe(element);
      }
      return function() {
        resizeObserver2.disconnect();
      };
    }
    function getElement(func) {
      if (typeof func !== "function")
        return null;
      return func();
    }
    function getPoint(point2) {
      if (_typeof$4(point2) !== "object" || !point2)
        return null;
      return point2;
    }
    var Align = function Align2(_ref, ref) {
      var children = _ref.children, disabled = _ref.disabled, target = _ref.target, align = _ref.align, onAlign = _ref.onAlign, monitorWindowResize = _ref.monitorWindowResize, _ref$monitorBufferTim = _ref.monitorBufferTime, monitorBufferTime = _ref$monitorBufferTim === void 0 ? 0 : _ref$monitorBufferTim;
      var cacheRef = React$3.useRef({});
      var nodeRef = React$3.useRef();
      var childNode = React$3.Children.only(children);
      var forceAlignPropsRef = React$3.useRef({});
      forceAlignPropsRef.current.disabled = disabled;
      forceAlignPropsRef.current.target = target;
      forceAlignPropsRef.current.align = align;
      forceAlignPropsRef.current.onAlign = onAlign;
      var _useBuffer = useBuffer(function() {
        var _forceAlignPropsRef$c = forceAlignPropsRef.current, latestDisabled = _forceAlignPropsRef$c.disabled, latestTarget = _forceAlignPropsRef$c.target, latestAlign = _forceAlignPropsRef$c.align, latestOnAlign = _forceAlignPropsRef$c.onAlign;
        var source = nodeRef.current;
        if (!latestDisabled && latestTarget && source) {
          var _result;
          var _element = getElement(latestTarget);
          var _point = getPoint(latestTarget);
          cacheRef.current.element = _element;
          cacheRef.current.point = _point;
          cacheRef.current.align = latestAlign;
          var _document = document, activeElement = _document.activeElement;
          if (_element && isVisible$1(_element)) {
            _result = alignElement(source, _element, latestAlign);
          } else if (_point) {
            _result = alignPoint(source, _point, latestAlign);
          }
          restoreFocus(activeElement, source);
          if (latestOnAlign && _result) {
            latestOnAlign(source, _result);
          }
          return true;
        }
        return false;
      }, monitorBufferTime), _useBuffer2 = _slicedToArray(_useBuffer, 2), _forceAlign = _useBuffer2[0], cancelForceAlign = _useBuffer2[1];
      var _React$useState = React$3.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), element = _React$useState2[0], setElement = _React$useState2[1];
      var _React$useState3 = React$3.useState(), _React$useState4 = _slicedToArray(_React$useState3, 2), point2 = _React$useState4[0], setPoint = _React$useState4[1];
      useLayoutEffect$1(function() {
        setElement(getElement(target));
        setPoint(getPoint(target));
      });
      React$3.useEffect(function() {
        if (cacheRef.current.element !== element || !isSamePoint(cacheRef.current.point, point2) || !isEqual$1(cacheRef.current.align, align)) {
          _forceAlign();
        }
      });
      React$3.useEffect(function() {
        var cancelFn = monitorResize(nodeRef.current, _forceAlign);
        return cancelFn;
      }, [nodeRef.current]);
      React$3.useEffect(function() {
        var cancelFn = monitorResize(element, _forceAlign);
        return cancelFn;
      }, [element]);
      React$3.useEffect(function() {
        if (!disabled) {
          _forceAlign();
        } else {
          cancelForceAlign();
        }
      }, [disabled]);
      React$3.useEffect(function() {
        if (monitorWindowResize) {
          var cancelFn = addEventListenerWrap(window, "resize", _forceAlign);
          return cancelFn.remove;
        }
      }, [monitorWindowResize]);
      React$3.useEffect(function() {
        return function() {
          cancelForceAlign();
        };
      }, []);
      React$3.useImperativeHandle(ref, function() {
        return {
          forceAlign: function forceAlign() {
            return _forceAlign(true);
          }
        };
      });
      if (/* @__PURE__ */ React$3.isValidElement(childNode)) {
        childNode = /* @__PURE__ */ React$3.cloneElement(childNode, {
          ref: composeRef(childNode.ref, nodeRef)
        });
      }
      return childNode;
    };
    var RcAlign = /* @__PURE__ */ React$3.forwardRef(Align);
    RcAlign.displayName = "Align";
    var StatusQueue = ["measure", "alignPre", "align", null, "motion"];
    const useVisibleStatus = function(visible, doMeasure) {
      var _useState = useSafeState(null), _useState2 = _slicedToArray(_useState, 2), status = _useState2[0], setInternalStatus = _useState2[1];
      var rafRef = reactExports.useRef();
      function setStatus(nextStatus) {
        setInternalStatus(nextStatus, true);
      }
      function cancelRaf() {
        wrapperRaf.cancel(rafRef.current);
      }
      function goNextStatus(callback) {
        cancelRaf();
        rafRef.current = wrapperRaf(function() {
          setStatus(function(prev2) {
            switch (status) {
              case "align":
                return "motion";
              case "motion":
                return "stable";
            }
            return prev2;
          });
          callback === null || callback === void 0 ? void 0 : callback();
        });
      }
      reactExports.useEffect(function() {
        setStatus("measure");
      }, [visible]);
      reactExports.useEffect(function() {
        switch (status) {
          case "measure":
            doMeasure();
            break;
        }
        if (status) {
          rafRef.current = wrapperRaf(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
            var index2, nextStatus;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    index2 = StatusQueue.indexOf(status);
                    nextStatus = StatusQueue[index2 + 1];
                    if (nextStatus && index2 !== -1) {
                      setStatus(nextStatus);
                    }
                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          })));
        }
      }, [status]);
      reactExports.useEffect(function() {
        return function() {
          cancelRaf();
        };
      }, []);
      return [status, goNextStatus];
    };
    const useStretchStyle = function(stretch) {
      var _React$useState = reactExports.useState({
        width: 0,
        height: 0
      }), _React$useState2 = _slicedToArray(_React$useState, 2), targetSize = _React$useState2[0], setTargetSize = _React$useState2[1];
      function measureStretch(element) {
        var tgtWidth = element.offsetWidth, tgtHeight = element.offsetHeight;
        var _element$getBoundingC = element.getBoundingClientRect(), width = _element$getBoundingC.width, height = _element$getBoundingC.height;
        if (Math.abs(tgtWidth - width) < 1 && Math.abs(tgtHeight - height) < 1) {
          tgtWidth = width;
          tgtHeight = height;
        }
        setTargetSize({
          width: tgtWidth,
          height: tgtHeight
        });
      }
      var style2 = reactExports.useMemo(function() {
        var sizeStyle = {};
        if (stretch) {
          var width = targetSize.width, height = targetSize.height;
          if (stretch.indexOf("height") !== -1 && height) {
            sizeStyle.height = height;
          } else if (stretch.indexOf("minHeight") !== -1 && height) {
            sizeStyle.minHeight = height;
          }
          if (stretch.indexOf("width") !== -1 && width) {
            sizeStyle.width = width;
          } else if (stretch.indexOf("minWidth") !== -1 && width) {
            sizeStyle.minWidth = width;
          }
        }
        return sizeStyle;
      }, [stretch, targetSize]);
      return [style2, measureStretch];
    };
    var PopupInner = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var visible = props.visible, prefixCls = props.prefixCls, className = props.className, style2 = props.style, children = props.children, zIndex = props.zIndex, stretch = props.stretch, destroyPopupOnHide = props.destroyPopupOnHide, forceRender = props.forceRender, align = props.align, point2 = props.point, getRootDomNode = props.getRootDomNode, getClassNameFromAlign = props.getClassNameFromAlign, onAlign = props.onAlign, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onMouseDown = props.onMouseDown, onTouchStart = props.onTouchStart, onClick = props.onClick;
      var alignRef = reactExports.useRef();
      var elementRef = reactExports.useRef();
      var _useState = reactExports.useState(), _useState2 = _slicedToArray(_useState, 2), alignedClassName = _useState2[0], setAlignedClassName = _useState2[1];
      var _useStretchStyle = useStretchStyle(stretch), _useStretchStyle2 = _slicedToArray(_useStretchStyle, 2), stretchStyle = _useStretchStyle2[0], measureStretchStyle = _useStretchStyle2[1];
      function doMeasure() {
        if (stretch) {
          measureStretchStyle(getRootDomNode());
        }
      }
      var _useVisibleStatus = useVisibleStatus(visible, doMeasure), _useVisibleStatus2 = _slicedToArray(_useVisibleStatus, 2), status = _useVisibleStatus2[0], goNextStatus = _useVisibleStatus2[1];
      var _useState3 = reactExports.useState(0), _useState4 = _slicedToArray(_useState3, 2), alignTimes = _useState4[0], setAlignTimes = _useState4[1];
      var prepareResolveRef = reactExports.useRef();
      useLayoutEffect$1(function() {
        if (status === "alignPre") {
          setAlignTimes(0);
        }
      }, [status]);
      function getAlignTarget() {
        if (point2) {
          return point2;
        }
        return getRootDomNode;
      }
      function forceAlign() {
        var _alignRef$current;
        (_alignRef$current = alignRef.current) === null || _alignRef$current === void 0 ? void 0 : _alignRef$current.forceAlign();
      }
      function onInternalAlign(popupDomNode, matchAlign) {
        var nextAlignedClassName = getClassNameFromAlign(matchAlign);
        if (alignedClassName !== nextAlignedClassName) {
          setAlignedClassName(nextAlignedClassName);
        }
        setAlignTimes(function(val) {
          return val + 1;
        });
        if (status === "align") {
          onAlign === null || onAlign === void 0 ? void 0 : onAlign(popupDomNode, matchAlign);
        }
      }
      useLayoutEffect$1(function() {
        if (status === "align") {
          if (alignTimes < 3) {
            forceAlign();
          } else {
            goNextStatus(function() {
              var _prepareResolveRef$cu;
              (_prepareResolveRef$cu = prepareResolveRef.current) === null || _prepareResolveRef$cu === void 0 ? void 0 : _prepareResolveRef$cu.call(prepareResolveRef);
            });
          }
        }
      }, [alignTimes]);
      var motion2 = _objectSpread2$3({}, getMotion$1(props));
      ["onAppearEnd", "onEnterEnd", "onLeaveEnd"].forEach(function(eventName) {
        var originHandler = motion2[eventName];
        motion2[eventName] = function(element, event) {
          goNextStatus();
          return originHandler === null || originHandler === void 0 ? void 0 : originHandler(element, event);
        };
      });
      function onShowPrepare() {
        return new Promise(function(resolve) {
          prepareResolveRef.current = resolve;
        });
      }
      reactExports.useEffect(function() {
        if (!motion2.motionName && status === "motion") {
          goNextStatus();
        }
      }, [motion2.motionName, status]);
      reactExports.useImperativeHandle(ref, function() {
        return {
          forceAlign,
          getElement: function getElement2() {
            return elementRef.current;
          }
        };
      });
      var mergedStyle = _objectSpread2$3(_objectSpread2$3({}, stretchStyle), {}, {
        zIndex,
        opacity: status === "motion" || status === "stable" || !visible ? void 0 : 0,
        // Cannot interact with disappearing elements
        // https://github.com/ant-design/ant-design/issues/35051#issuecomment-1101340714
        pointerEvents: !visible && status !== "stable" ? "none" : void 0
      }, style2);
      var alignDisabled = true;
      if (align !== null && align !== void 0 && align.points && (status === "align" || status === "stable")) {
        alignDisabled = false;
      }
      var childNode = children;
      if (reactExports.Children.count(children) > 1) {
        childNode = /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(prefixCls, "-content")
        }, children);
      }
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$2({
        visible,
        ref: elementRef,
        leavedClassName: "".concat(prefixCls, "-hidden")
      }, motion2, {
        onAppearPrepare: onShowPrepare,
        onEnterPrepare: onShowPrepare,
        removeOnLeave: destroyPopupOnHide,
        forceRender
      }), function(_ref, motionRef) {
        var motionClassName = _ref.className, motionStyle = _ref.style;
        var mergedClassName = classNames(prefixCls, className, alignedClassName, motionClassName);
        return /* @__PURE__ */ reactExports.createElement(RcAlign, {
          target: getAlignTarget(),
          key: "popup",
          ref: alignRef,
          monitorWindowResize: true,
          disabled: alignDisabled,
          align,
          onAlign: onInternalAlign
        }, /* @__PURE__ */ reactExports.createElement("div", {
          ref: motionRef,
          className: mergedClassName,
          onMouseEnter,
          onMouseLeave,
          onMouseDownCapture: onMouseDown,
          onTouchStartCapture: onTouchStart,
          onClick,
          style: _objectSpread2$3(_objectSpread2$3({}, motionStyle), mergedStyle)
        }, childNode));
      });
    });
    PopupInner.displayName = "PopupInner";
    var MobilePopupInner = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, children = props.children, _props$mobile = props.mobile;
      _props$mobile = _props$mobile === void 0 ? {} : _props$mobile;
      var popupClassName = _props$mobile.popupClassName, popupStyle = _props$mobile.popupStyle, _props$mobile$popupMo = _props$mobile.popupMotion, popupMotion = _props$mobile$popupMo === void 0 ? {} : _props$mobile$popupMo, popupRender = _props$mobile.popupRender, onClick = props.onClick;
      var elementRef = reactExports.useRef();
      reactExports.useImperativeHandle(ref, function() {
        return {
          forceAlign: function forceAlign() {
          },
          getElement: function getElement2() {
            return elementRef.current;
          }
        };
      });
      var mergedStyle = _objectSpread2$3({
        zIndex
      }, popupStyle);
      var childNode = children;
      if (reactExports.Children.count(children) > 1) {
        childNode = /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(prefixCls, "-content")
        }, children);
      }
      if (popupRender) {
        childNode = popupRender(childNode);
      }
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$2({
        visible,
        ref: elementRef,
        removeOnLeave: true
      }, popupMotion), function(_ref, motionRef) {
        var motionClassName = _ref.className, motionStyle = _ref.style;
        var mergedClassName = classNames(prefixCls, popupClassName, motionClassName);
        return /* @__PURE__ */ reactExports.createElement("div", {
          ref: motionRef,
          className: mergedClassName,
          onClick,
          style: _objectSpread2$3(_objectSpread2$3({}, motionStyle), mergedStyle)
        }, childNode);
      });
    });
    MobilePopupInner.displayName = "MobilePopupInner";
    var _excluded$w = ["visible", "mobile"];
    var Popup = /* @__PURE__ */ reactExports.forwardRef(function(_ref, ref) {
      var visible = _ref.visible, mobile = _ref.mobile, props = _objectWithoutProperties$1(_ref, _excluded$w);
      var _useState = reactExports.useState(visible), _useState2 = _slicedToArray(_useState, 2), innerVisible = _useState2[0], serInnerVisible = _useState2[1];
      var _useState3 = reactExports.useState(false), _useState4 = _slicedToArray(_useState3, 2), inMobile = _useState4[0], setInMobile = _useState4[1];
      var cloneProps = _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        visible: innerVisible
      });
      reactExports.useEffect(function() {
        serInnerVisible(visible);
        if (visible && mobile) {
          setInMobile(isMobile());
        }
      }, [visible, mobile]);
      var popupNode = inMobile ? /* @__PURE__ */ reactExports.createElement(MobilePopupInner, _extends$2({}, cloneProps, {
        mobile,
        ref
      })) : /* @__PURE__ */ reactExports.createElement(PopupInner, _extends$2({}, cloneProps, {
        ref
      }));
      return /* @__PURE__ */ reactExports.createElement("div", null, /* @__PURE__ */ reactExports.createElement(Mask, cloneProps), popupNode);
    });
    Popup.displayName = "Popup";
    var TriggerContext = /* @__PURE__ */ reactExports.createContext(null);
    function noop$3() {
    }
    function returnEmptyString() {
      return "";
    }
    function returnDocument(element) {
      if (element) {
        return element.ownerDocument;
      }
      return window.document;
    }
    var ALL_HANDLERS = ["onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur", "onContextMenu"];
    function generateTrigger(PortalComponent) {
      var Trigger2 = /* @__PURE__ */ function(_React$Component) {
        _inherits(Trigger3, _React$Component);
        var _super = _createSuper(Trigger3);
        function Trigger3(props) {
          var _this;
          _classCallCheck(this, Trigger3);
          _this = _super.call(this, props);
          _defineProperty$7(_assertThisInitialized(_this), "popupRef", /* @__PURE__ */ reactExports.createRef());
          _defineProperty$7(_assertThisInitialized(_this), "triggerRef", /* @__PURE__ */ reactExports.createRef());
          _defineProperty$7(_assertThisInitialized(_this), "portalContainer", void 0);
          _defineProperty$7(_assertThisInitialized(_this), "attachId", void 0);
          _defineProperty$7(_assertThisInitialized(_this), "clickOutsideHandler", void 0);
          _defineProperty$7(_assertThisInitialized(_this), "touchOutsideHandler", void 0);
          _defineProperty$7(_assertThisInitialized(_this), "contextMenuOutsideHandler1", void 0);
          _defineProperty$7(_assertThisInitialized(_this), "contextMenuOutsideHandler2", void 0);
          _defineProperty$7(_assertThisInitialized(_this), "mouseDownTimeout", void 0);
          _defineProperty$7(_assertThisInitialized(_this), "focusTime", void 0);
          _defineProperty$7(_assertThisInitialized(_this), "preClickTime", void 0);
          _defineProperty$7(_assertThisInitialized(_this), "preTouchTime", void 0);
          _defineProperty$7(_assertThisInitialized(_this), "delayTimer", void 0);
          _defineProperty$7(_assertThisInitialized(_this), "hasPopupMouseDown", void 0);
          _defineProperty$7(_assertThisInitialized(_this), "onMouseEnter", function(e2) {
            var mouseEnterDelay = _this.props.mouseEnterDelay;
            _this.fireEvents("onMouseEnter", e2);
            _this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e2);
          });
          _defineProperty$7(_assertThisInitialized(_this), "onMouseMove", function(e2) {
            _this.fireEvents("onMouseMove", e2);
            _this.setPoint(e2);
          });
          _defineProperty$7(_assertThisInitialized(_this), "onMouseLeave", function(e2) {
            _this.fireEvents("onMouseLeave", e2);
            _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
          });
          _defineProperty$7(_assertThisInitialized(_this), "onPopupMouseEnter", function() {
            _this.clearDelayTimer();
          });
          _defineProperty$7(_assertThisInitialized(_this), "onPopupMouseLeave", function(e2) {
            var _this$popupRef$curren;
            if (e2.relatedTarget && !e2.relatedTarget.setTimeout && contains$2((_this$popupRef$curren = _this.popupRef.current) === null || _this$popupRef$curren === void 0 ? void 0 : _this$popupRef$curren.getElement(), e2.relatedTarget)) {
              return;
            }
            _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
          });
          _defineProperty$7(_assertThisInitialized(_this), "onFocus", function(e2) {
            _this.fireEvents("onFocus", e2);
            _this.clearDelayTimer();
            if (_this.isFocusToShow()) {
              _this.focusTime = Date.now();
              _this.delaySetPopupVisible(true, _this.props.focusDelay);
            }
          });
          _defineProperty$7(_assertThisInitialized(_this), "onMouseDown", function(e2) {
            _this.fireEvents("onMouseDown", e2);
            _this.preClickTime = Date.now();
          });
          _defineProperty$7(_assertThisInitialized(_this), "onTouchStart", function(e2) {
            _this.fireEvents("onTouchStart", e2);
            _this.preTouchTime = Date.now();
          });
          _defineProperty$7(_assertThisInitialized(_this), "onBlur", function(e2) {
            _this.fireEvents("onBlur", e2);
            _this.clearDelayTimer();
            if (_this.isBlurToHide()) {
              _this.delaySetPopupVisible(false, _this.props.blurDelay);
            }
          });
          _defineProperty$7(_assertThisInitialized(_this), "onContextMenu", function(e2) {
            e2.preventDefault();
            _this.fireEvents("onContextMenu", e2);
            _this.setPopupVisible(true, e2);
          });
          _defineProperty$7(_assertThisInitialized(_this), "onContextMenuClose", function() {
            if (_this.isContextMenuToShow()) {
              _this.close();
            }
          });
          _defineProperty$7(_assertThisInitialized(_this), "onClick", function(event) {
            _this.fireEvents("onClick", event);
            if (_this.focusTime) {
              var preTime;
              if (_this.preClickTime && _this.preTouchTime) {
                preTime = Math.min(_this.preClickTime, _this.preTouchTime);
              } else if (_this.preClickTime) {
                preTime = _this.preClickTime;
              } else if (_this.preTouchTime) {
                preTime = _this.preTouchTime;
              }
              if (Math.abs(preTime - _this.focusTime) < 20) {
                return;
              }
              _this.focusTime = 0;
            }
            _this.preClickTime = 0;
            _this.preTouchTime = 0;
            if (_this.isClickToShow() && (_this.isClickToHide() || _this.isBlurToHide()) && event && event.preventDefault) {
              event.preventDefault();
            }
            var nextVisible = !_this.state.popupVisible;
            if (_this.isClickToHide() && !nextVisible || nextVisible && _this.isClickToShow()) {
              _this.setPopupVisible(!_this.state.popupVisible, event);
            }
          });
          _defineProperty$7(_assertThisInitialized(_this), "onPopupMouseDown", function() {
            _this.hasPopupMouseDown = true;
            clearTimeout(_this.mouseDownTimeout);
            _this.mouseDownTimeout = window.setTimeout(function() {
              _this.hasPopupMouseDown = false;
            }, 0);
            if (_this.context) {
              var _this$context;
              (_this$context = _this.context).onPopupMouseDown.apply(_this$context, arguments);
            }
          });
          _defineProperty$7(_assertThisInitialized(_this), "onDocumentClick", function(event) {
            if (_this.props.mask && !_this.props.maskClosable) {
              return;
            }
            var target = event.target;
            var root2 = _this.getRootDomNode();
            var popupNode = _this.getPopupDomNode();
            if (
              // mousedown on the target should also close popup when action is contextMenu.
              // https://github.com/ant-design/ant-design/issues/29853
              (!contains$2(root2, target) || _this.isContextMenuOnly()) && !contains$2(popupNode, target) && !_this.hasPopupMouseDown
            ) {
              _this.close();
            }
          });
          _defineProperty$7(_assertThisInitialized(_this), "getRootDomNode", function() {
            var getTriggerDOMNode = _this.props.getTriggerDOMNode;
            if (getTriggerDOMNode) {
              return getTriggerDOMNode(_this.triggerRef.current);
            }
            try {
              var domNode = findDOMNode(_this.triggerRef.current);
              if (domNode) {
                return domNode;
              }
            } catch (err) {
            }
            return ReactDOM.findDOMNode(_assertThisInitialized(_this));
          });
          _defineProperty$7(_assertThisInitialized(_this), "getPopupClassNameFromAlign", function(align) {
            var className = [];
            var _this$props = _this.props, popupPlacement = _this$props.popupPlacement, builtinPlacements = _this$props.builtinPlacements, prefixCls = _this$props.prefixCls, alignPoint2 = _this$props.alignPoint, getPopupClassNameFromAlign = _this$props.getPopupClassNameFromAlign;
            if (popupPlacement && builtinPlacements) {
              className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint2));
            }
            if (getPopupClassNameFromAlign) {
              className.push(getPopupClassNameFromAlign(align));
            }
            return className.join(" ");
          });
          _defineProperty$7(_assertThisInitialized(_this), "getComponent", function() {
            var _this$props2 = _this.props, prefixCls = _this$props2.prefixCls, destroyPopupOnHide = _this$props2.destroyPopupOnHide, popupClassName = _this$props2.popupClassName, onPopupAlign = _this$props2.onPopupAlign, popupMotion = _this$props2.popupMotion, popupAnimation = _this$props2.popupAnimation, popupTransitionName = _this$props2.popupTransitionName, popupStyle = _this$props2.popupStyle, mask = _this$props2.mask, maskAnimation = _this$props2.maskAnimation, maskTransitionName = _this$props2.maskTransitionName, maskMotion = _this$props2.maskMotion, zIndex = _this$props2.zIndex, popup = _this$props2.popup, stretch = _this$props2.stretch, alignPoint2 = _this$props2.alignPoint, mobile = _this$props2.mobile, forceRender = _this$props2.forceRender, onPopupClick = _this$props2.onPopupClick;
            var _this$state = _this.state, popupVisible = _this$state.popupVisible, point2 = _this$state.point;
            var align = _this.getPopupAlign();
            var mouseProps = {};
            if (_this.isMouseEnterToShow()) {
              mouseProps.onMouseEnter = _this.onPopupMouseEnter;
            }
            if (_this.isMouseLeaveToHide()) {
              mouseProps.onMouseLeave = _this.onPopupMouseLeave;
            }
            mouseProps.onMouseDown = _this.onPopupMouseDown;
            mouseProps.onTouchStart = _this.onPopupMouseDown;
            return /* @__PURE__ */ reactExports.createElement(Popup, _extends$2({
              prefixCls,
              destroyPopupOnHide,
              visible: popupVisible,
              point: alignPoint2 && point2,
              className: popupClassName,
              align,
              onAlign: onPopupAlign,
              animation: popupAnimation,
              getClassNameFromAlign: _this.getPopupClassNameFromAlign
            }, mouseProps, {
              stretch,
              getRootDomNode: _this.getRootDomNode,
              style: popupStyle,
              mask,
              zIndex,
              transitionName: popupTransitionName,
              maskAnimation,
              maskTransitionName,
              maskMotion,
              ref: _this.popupRef,
              motion: popupMotion,
              mobile,
              forceRender,
              onClick: onPopupClick
            }), typeof popup === "function" ? popup() : popup);
          });
          _defineProperty$7(_assertThisInitialized(_this), "attachParent", function(popupContainer) {
            wrapperRaf.cancel(_this.attachId);
            var _this$props3 = _this.props, getPopupContainer = _this$props3.getPopupContainer, getDocument2 = _this$props3.getDocument;
            var domNode = _this.getRootDomNode();
            var mountNode;
            if (!getPopupContainer) {
              mountNode = getDocument2(_this.getRootDomNode()).body;
            } else if (domNode || getPopupContainer.length === 0) {
              mountNode = getPopupContainer(domNode);
            }
            if (mountNode) {
              mountNode.appendChild(popupContainer);
            } else {
              _this.attachId = wrapperRaf(function() {
                _this.attachParent(popupContainer);
              });
            }
          });
          _defineProperty$7(_assertThisInitialized(_this), "getContainer", function() {
            if (!_this.portalContainer) {
              var getDocument2 = _this.props.getDocument;
              var popupContainer = getDocument2(_this.getRootDomNode()).createElement("div");
              popupContainer.style.position = "absolute";
              popupContainer.style.top = "0";
              popupContainer.style.left = "0";
              popupContainer.style.width = "100%";
              _this.portalContainer = popupContainer;
            }
            _this.attachParent(_this.portalContainer);
            return _this.portalContainer;
          });
          _defineProperty$7(_assertThisInitialized(_this), "setPoint", function(point2) {
            var alignPoint2 = _this.props.alignPoint;
            if (!alignPoint2 || !point2)
              return;
            _this.setState({
              point: {
                pageX: point2.pageX,
                pageY: point2.pageY
              }
            });
          });
          _defineProperty$7(_assertThisInitialized(_this), "handlePortalUpdate", function() {
            if (_this.state.prevPopupVisible !== _this.state.popupVisible) {
              _this.props.afterPopupVisibleChange(_this.state.popupVisible);
            }
          });
          _defineProperty$7(_assertThisInitialized(_this), "triggerContextValue", {
            onPopupMouseDown: _this.onPopupMouseDown
          });
          var _popupVisible;
          if ("popupVisible" in props) {
            _popupVisible = !!props.popupVisible;
          } else {
            _popupVisible = !!props.defaultPopupVisible;
          }
          _this.state = {
            prevPopupVisible: _popupVisible,
            popupVisible: _popupVisible
          };
          ALL_HANDLERS.forEach(function(h2) {
            _this["fire".concat(h2)] = function(e2) {
              _this.fireEvents(h2, e2);
            };
          });
          return _this;
        }
        _createClass(Trigger3, [{
          key: "componentDidMount",
          value: function componentDidMount() {
            this.componentDidUpdate();
          }
        }, {
          key: "componentDidUpdate",
          value: function componentDidUpdate() {
            var props = this.props;
            var state = this.state;
            if (state.popupVisible) {
              var currentDocument;
              if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow())) {
                currentDocument = props.getDocument(this.getRootDomNode());
                this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick);
              }
              if (!this.touchOutsideHandler) {
                currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
                this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick);
              }
              if (!this.contextMenuOutsideHandler1 && this.isContextMenuToShow()) {
                currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
                this.contextMenuOutsideHandler1 = addEventListenerWrap(currentDocument, "scroll", this.onContextMenuClose);
              }
              if (!this.contextMenuOutsideHandler2 && this.isContextMenuToShow()) {
                this.contextMenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextMenuClose);
              }
              return;
            }
            this.clearOutsideHandler();
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.clearDelayTimer();
            this.clearOutsideHandler();
            clearTimeout(this.mouseDownTimeout);
            wrapperRaf.cancel(this.attachId);
          }
        }, {
          key: "getPopupDomNode",
          value: function getPopupDomNode() {
            var _this$popupRef$curren2;
            return ((_this$popupRef$curren2 = this.popupRef.current) === null || _this$popupRef$curren2 === void 0 ? void 0 : _this$popupRef$curren2.getElement()) || null;
          }
        }, {
          key: "getPopupAlign",
          value: function getPopupAlign() {
            var props = this.props;
            var popupPlacement = props.popupPlacement, popupAlign = props.popupAlign, builtinPlacements = props.builtinPlacements;
            if (popupPlacement && builtinPlacements) {
              return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
            }
            return popupAlign;
          }
        }, {
          key: "setPopupVisible",
          value: (
            /**
             * @param popupVisible    Show or not the popup element
             * @param event           SyntheticEvent, used for `pointAlign`
             */
            function setPopupVisible(popupVisible, event) {
              var alignPoint2 = this.props.alignPoint;
              var prevPopupVisible = this.state.popupVisible;
              this.clearDelayTimer();
              if (prevPopupVisible !== popupVisible) {
                if (!("popupVisible" in this.props)) {
                  this.setState({
                    popupVisible,
                    prevPopupVisible
                  });
                }
                this.props.onPopupVisibleChange(popupVisible);
              }
              if (alignPoint2 && event && popupVisible) {
                this.setPoint(event);
              }
            }
          )
        }, {
          key: "delaySetPopupVisible",
          value: function delaySetPopupVisible(visible, delayS, event) {
            var _this2 = this;
            var delay = delayS * 1e3;
            this.clearDelayTimer();
            if (delay) {
              var point2 = event ? {
                pageX: event.pageX,
                pageY: event.pageY
              } : null;
              this.delayTimer = window.setTimeout(function() {
                _this2.setPopupVisible(visible, point2);
                _this2.clearDelayTimer();
              }, delay);
            } else {
              this.setPopupVisible(visible, event);
            }
          }
        }, {
          key: "clearDelayTimer",
          value: function clearDelayTimer() {
            if (this.delayTimer) {
              clearTimeout(this.delayTimer);
              this.delayTimer = null;
            }
          }
        }, {
          key: "clearOutsideHandler",
          value: function clearOutsideHandler() {
            if (this.clickOutsideHandler) {
              this.clickOutsideHandler.remove();
              this.clickOutsideHandler = null;
            }
            if (this.contextMenuOutsideHandler1) {
              this.contextMenuOutsideHandler1.remove();
              this.contextMenuOutsideHandler1 = null;
            }
            if (this.contextMenuOutsideHandler2) {
              this.contextMenuOutsideHandler2.remove();
              this.contextMenuOutsideHandler2 = null;
            }
            if (this.touchOutsideHandler) {
              this.touchOutsideHandler.remove();
              this.touchOutsideHandler = null;
            }
          }
        }, {
          key: "createTwoChains",
          value: function createTwoChains(event) {
            var childPros = this.props.children.props;
            var props = this.props;
            if (childPros[event] && props[event]) {
              return this["fire".concat(event)];
            }
            return childPros[event] || props[event];
          }
        }, {
          key: "isClickToShow",
          value: function isClickToShow() {
            var _this$props4 = this.props, action = _this$props4.action, showAction = _this$props4.showAction;
            return action.indexOf("click") !== -1 || showAction.indexOf("click") !== -1;
          }
        }, {
          key: "isContextMenuOnly",
          value: function isContextMenuOnly() {
            var action = this.props.action;
            return action === "contextMenu" || action.length === 1 && action[0] === "contextMenu";
          }
        }, {
          key: "isContextMenuToShow",
          value: function isContextMenuToShow() {
            var _this$props5 = this.props, action = _this$props5.action, showAction = _this$props5.showAction;
            return action.indexOf("contextMenu") !== -1 || showAction.indexOf("contextMenu") !== -1;
          }
        }, {
          key: "isClickToHide",
          value: function isClickToHide() {
            var _this$props6 = this.props, action = _this$props6.action, hideAction = _this$props6.hideAction;
            return action.indexOf("click") !== -1 || hideAction.indexOf("click") !== -1;
          }
        }, {
          key: "isMouseEnterToShow",
          value: function isMouseEnterToShow() {
            var _this$props7 = this.props, action = _this$props7.action, showAction = _this$props7.showAction;
            return action.indexOf("hover") !== -1 || showAction.indexOf("mouseEnter") !== -1;
          }
        }, {
          key: "isMouseLeaveToHide",
          value: function isMouseLeaveToHide() {
            var _this$props8 = this.props, action = _this$props8.action, hideAction = _this$props8.hideAction;
            return action.indexOf("hover") !== -1 || hideAction.indexOf("mouseLeave") !== -1;
          }
        }, {
          key: "isFocusToShow",
          value: function isFocusToShow() {
            var _this$props9 = this.props, action = _this$props9.action, showAction = _this$props9.showAction;
            return action.indexOf("focus") !== -1 || showAction.indexOf("focus") !== -1;
          }
        }, {
          key: "isBlurToHide",
          value: function isBlurToHide() {
            var _this$props10 = this.props, action = _this$props10.action, hideAction = _this$props10.hideAction;
            return action.indexOf("focus") !== -1 || hideAction.indexOf("blur") !== -1;
          }
        }, {
          key: "forcePopupAlign",
          value: function forcePopupAlign() {
            if (this.state.popupVisible) {
              var _this$popupRef$curren3;
              (_this$popupRef$curren3 = this.popupRef.current) === null || _this$popupRef$curren3 === void 0 ? void 0 : _this$popupRef$curren3.forceAlign();
            }
          }
        }, {
          key: "fireEvents",
          value: function fireEvents(type2, e2) {
            var childCallback = this.props.children.props[type2];
            if (childCallback) {
              childCallback(e2);
            }
            var callback = this.props[type2];
            if (callback) {
              callback(e2);
            }
          }
        }, {
          key: "close",
          value: function close() {
            this.setPopupVisible(false);
          }
        }, {
          key: "render",
          value: function render2() {
            var popupVisible = this.state.popupVisible;
            var _this$props11 = this.props, children = _this$props11.children, forceRender = _this$props11.forceRender, alignPoint2 = _this$props11.alignPoint, className = _this$props11.className, autoDestroy = _this$props11.autoDestroy;
            var child = reactExports.Children.only(children);
            var newChildProps = {
              key: "trigger"
            };
            if (this.isContextMenuToShow()) {
              newChildProps.onContextMenu = this.onContextMenu;
            } else {
              newChildProps.onContextMenu = this.createTwoChains("onContextMenu");
            }
            if (this.isClickToHide() || this.isClickToShow()) {
              newChildProps.onClick = this.onClick;
              newChildProps.onMouseDown = this.onMouseDown;
              newChildProps.onTouchStart = this.onTouchStart;
            } else {
              newChildProps.onClick = this.createTwoChains("onClick");
              newChildProps.onMouseDown = this.createTwoChains("onMouseDown");
              newChildProps.onTouchStart = this.createTwoChains("onTouchStart");
            }
            if (this.isMouseEnterToShow()) {
              newChildProps.onMouseEnter = this.onMouseEnter;
              if (alignPoint2) {
                newChildProps.onMouseMove = this.onMouseMove;
              }
            } else {
              newChildProps.onMouseEnter = this.createTwoChains("onMouseEnter");
            }
            if (this.isMouseLeaveToHide()) {
              newChildProps.onMouseLeave = this.onMouseLeave;
            } else {
              newChildProps.onMouseLeave = this.createTwoChains("onMouseLeave");
            }
            if (this.isFocusToShow() || this.isBlurToHide()) {
              newChildProps.onFocus = this.onFocus;
              newChildProps.onBlur = this.onBlur;
            } else {
              newChildProps.onFocus = this.createTwoChains("onFocus");
              newChildProps.onBlur = this.createTwoChains("onBlur");
            }
            var childrenClassName = classNames(child && child.props && child.props.className, className);
            if (childrenClassName) {
              newChildProps.className = childrenClassName;
            }
            var cloneProps = _objectSpread2$3({}, newChildProps);
            if (supportRef(child)) {
              cloneProps.ref = composeRef(this.triggerRef, child.ref);
            }
            var trigger = /* @__PURE__ */ reactExports.cloneElement(child, cloneProps);
            var portal;
            if (popupVisible || this.popupRef.current || forceRender) {
              portal = /* @__PURE__ */ reactExports.createElement(PortalComponent, {
                key: "portal",
                getContainer: this.getContainer,
                didUpdate: this.handlePortalUpdate
              }, this.getComponent());
            }
            if (!popupVisible && autoDestroy) {
              portal = null;
            }
            return /* @__PURE__ */ reactExports.createElement(TriggerContext.Provider, {
              value: this.triggerContextValue
            }, trigger, portal);
          }
        }], [{
          key: "getDerivedStateFromProps",
          value: function getDerivedStateFromProps(_ref, prevState) {
            var popupVisible = _ref.popupVisible;
            var newState = {};
            if (popupVisible !== void 0 && prevState.popupVisible !== popupVisible) {
              newState.popupVisible = popupVisible;
              newState.prevPopupVisible = prevState.popupVisible;
            }
            return newState;
          }
        }]);
        return Trigger3;
      }(reactExports.Component);
      _defineProperty$7(Trigger2, "contextType", TriggerContext);
      _defineProperty$7(Trigger2, "defaultProps", {
        prefixCls: "rc-trigger-popup",
        getPopupClassNameFromAlign: returnEmptyString,
        getDocument: returnDocument,
        onPopupVisibleChange: noop$3,
        afterPopupVisibleChange: noop$3,
        onPopupAlign: noop$3,
        popupClassName: "",
        mouseEnterDelay: 0,
        mouseLeaveDelay: 0.1,
        focusDelay: 0,
        blurDelay: 0.15,
        popupStyle: {},
        destroyPopupOnHide: false,
        popupAlign: {},
        defaultPopupVisible: false,
        mask: false,
        maskClosable: true,
        action: [],
        showAction: [],
        hideAction: [],
        autoDestroy: false
      });
      return Trigger2;
    }
    const Trigger = generateTrigger(Portal);
    var autoAdjustOverflow$1 = {
      adjustX: 1,
      adjustY: 1
    };
    var targetOffset = [0, 0];
    var placements$1 = {
      topLeft: {
        points: ["bl", "tl"],
        overflow: autoAdjustOverflow$1,
        offset: [0, -4],
        targetOffset
      },
      topCenter: {
        points: ["bc", "tc"],
        overflow: autoAdjustOverflow$1,
        offset: [0, -4],
        targetOffset
      },
      topRight: {
        points: ["br", "tr"],
        overflow: autoAdjustOverflow$1,
        offset: [0, -4],
        targetOffset
      },
      bottomLeft: {
        points: ["tl", "bl"],
        overflow: autoAdjustOverflow$1,
        offset: [0, 4],
        targetOffset
      },
      bottomCenter: {
        points: ["tc", "bc"],
        overflow: autoAdjustOverflow$1,
        offset: [0, 4],
        targetOffset
      },
      bottomRight: {
        points: ["tr", "br"],
        overflow: autoAdjustOverflow$1,
        offset: [0, 4],
        targetOffset
      }
    };
    function focusable(node2) {
      var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (isVisible$1(node2)) {
        var nodeName = node2.nodeName.toLowerCase();
        var isFocusableElement = (
          // Focusable element
          ["input", "select", "textarea", "button"].includes(nodeName) || // Editable element
          node2.isContentEditable || // Anchor with href element
          nodeName === "a" && !!node2.getAttribute("href")
        );
        var tabIndexAttr = node2.getAttribute("tabindex");
        var tabIndexNum = Number(tabIndexAttr);
        var tabIndex = null;
        if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
          tabIndex = tabIndexNum;
        } else if (isFocusableElement && tabIndex === null) {
          tabIndex = 0;
        }
        if (isFocusableElement && node2.disabled) {
          tabIndex = null;
        }
        return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
      }
      return false;
    }
    function getFocusNodeList(node2) {
      var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var res = _toConsumableArray(node2.querySelectorAll("*")).filter(function(child) {
        return focusable(child, includePositive);
      });
      if (focusable(node2, includePositive)) {
        res.unshift(node2);
      }
      return res;
    }
    var ESC$1 = KeyCode.ESC, TAB = KeyCode.TAB;
    function useAccessibility$1(_ref) {
      var visible = _ref.visible, setTriggerVisible = _ref.setTriggerVisible, triggerRef = _ref.triggerRef, onVisibleChange = _ref.onVisibleChange, autoFocus = _ref.autoFocus;
      var focusMenuRef = reactExports.useRef(false);
      var handleCloseMenuAndReturnFocus = function handleCloseMenuAndReturnFocus2() {
        if (visible && triggerRef.current) {
          var _triggerRef$current, _triggerRef$current$t, _triggerRef$current$t2, _triggerRef$current$t3;
          (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : (_triggerRef$current$t = _triggerRef$current.triggerRef) === null || _triggerRef$current$t === void 0 ? void 0 : (_triggerRef$current$t2 = _triggerRef$current$t.current) === null || _triggerRef$current$t2 === void 0 ? void 0 : (_triggerRef$current$t3 = _triggerRef$current$t2.focus) === null || _triggerRef$current$t3 === void 0 ? void 0 : _triggerRef$current$t3.call(_triggerRef$current$t2);
          setTriggerVisible(false);
          if (typeof onVisibleChange === "function") {
            onVisibleChange(false);
          }
        }
      };
      var focusMenu = function focusMenu2() {
        var _triggerRef$current2, _triggerRef$current2$, _triggerRef$current2$2, _triggerRef$current2$3;
        var elements = getFocusNodeList((_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : (_triggerRef$current2$ = _triggerRef$current2.popupRef) === null || _triggerRef$current2$ === void 0 ? void 0 : (_triggerRef$current2$2 = _triggerRef$current2$.current) === null || _triggerRef$current2$2 === void 0 ? void 0 : (_triggerRef$current2$3 = _triggerRef$current2$2.getElement) === null || _triggerRef$current2$3 === void 0 ? void 0 : _triggerRef$current2$3.call(_triggerRef$current2$2));
        var firstElement = elements[0];
        if (firstElement === null || firstElement === void 0 ? void 0 : firstElement.focus) {
          firstElement.focus();
          focusMenuRef.current = true;
          return true;
        }
        return false;
      };
      var handleKeyDown = function handleKeyDown2(event) {
        switch (event.keyCode) {
          case ESC$1:
            handleCloseMenuAndReturnFocus();
            break;
          case TAB: {
            var focusResult = false;
            if (!focusMenuRef.current) {
              focusResult = focusMenu();
            }
            if (focusResult) {
              event.preventDefault();
            } else {
              handleCloseMenuAndReturnFocus();
            }
            break;
          }
        }
      };
      reactExports.useEffect(function() {
        if (visible) {
          window.addEventListener("keydown", handleKeyDown);
          if (autoFocus) {
            wrapperRaf(focusMenu, 3);
          }
          return function() {
            window.removeEventListener("keydown", handleKeyDown);
            focusMenuRef.current = false;
          };
        }
        return function() {
          focusMenuRef.current = false;
        };
      }, [visible]);
    }
    var _excluded$v = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus"];
    function Dropdown$2(props, ref) {
      var _props$arrow = props.arrow, arrow = _props$arrow === void 0 ? false : _props$arrow, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dropdown" : _props$prefixCls, transitionName = props.transitionName, animation = props.animation, align = props.align, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomLeft" : _props$placement, _props$placements = props.placements, placements2 = _props$placements === void 0 ? placements$1 : _props$placements, getPopupContainer = props.getPopupContainer, showAction = props.showAction, hideAction = props.hideAction, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, visible = props.visible, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, autoFocus = props.autoFocus, otherProps = _objectWithoutProperties$1(props, _excluded$v);
      var _React$useState = reactExports.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), triggerVisible = _React$useState2[0], setTriggerVisible = _React$useState2[1];
      var mergedVisible = "visible" in props ? visible : triggerVisible;
      var triggerRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, function() {
        return triggerRef.current;
      });
      useAccessibility$1({
        visible: mergedVisible,
        setTriggerVisible,
        triggerRef,
        onVisibleChange: props.onVisibleChange,
        autoFocus
      });
      var getOverlayElement = function getOverlayElement2() {
        var overlay = props.overlay;
        var overlayElement;
        if (typeof overlay === "function") {
          overlayElement = overlay();
        } else {
          overlayElement = overlay;
        }
        return overlayElement;
      };
      var onClick = function onClick2(e2) {
        var onOverlayClick = props.onOverlayClick;
        setTriggerVisible(false);
        if (onOverlayClick) {
          onOverlayClick(e2);
        }
      };
      var onVisibleChange = function onVisibleChange2(newVisible) {
        var onVisibleChangeProp = props.onVisibleChange;
        setTriggerVisible(newVisible);
        if (typeof onVisibleChangeProp === "function") {
          onVisibleChangeProp(newVisible);
        }
      };
      var getMenuElement = function getMenuElement2() {
        var overlayElement = getOverlayElement();
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, arrow && /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(prefixCls, "-arrow")
        }), overlayElement);
      };
      var getMenuElementOrLambda = function getMenuElementOrLambda2() {
        var overlay = props.overlay;
        if (typeof overlay === "function") {
          return getMenuElement;
        }
        return getMenuElement();
      };
      var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger2() {
        var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger, alignPoint2 = props.alignPoint;
        if ("minOverlayWidthMatchTrigger" in props) {
          return minOverlayWidthMatchTrigger;
        }
        return !alignPoint2;
      };
      var getOpenClassName = function getOpenClassName2() {
        var openClassName = props.openClassName;
        if (openClassName !== void 0) {
          return openClassName;
        }
        return "".concat(prefixCls, "-open");
      };
      var renderChildren2 = function renderChildren3() {
        var children = props.children;
        var childrenProps = children.props ? children.props : {};
        var childClassName = classNames(childrenProps.className, getOpenClassName());
        return mergedVisible && children ? /* @__PURE__ */ reactExports.cloneElement(children, {
          className: childClassName
        }) : children;
      };
      var triggerHideAction = hideAction;
      if (!triggerHideAction && trigger.indexOf("contextMenu") !== -1) {
        triggerHideAction = ["click"];
      }
      return /* @__PURE__ */ reactExports.createElement(Trigger, _objectSpread2$3(_objectSpread2$3({
        builtinPlacements: placements2
      }, otherProps), {}, {
        prefixCls,
        ref: triggerRef,
        popupClassName: classNames(overlayClassName, _defineProperty$7({}, "".concat(prefixCls, "-show-arrow"), arrow)),
        popupStyle: overlayStyle,
        action: trigger,
        showAction,
        hideAction: triggerHideAction || [],
        popupPlacement: placement,
        popupAlign: align,
        popupTransitionName: transitionName,
        popupAnimation: animation,
        popupVisible: mergedVisible,
        stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
        popup: getMenuElementOrLambda(),
        onPopupVisibleChange: onVisibleChange,
        onPopupClick: onClick,
        getPopupContainer
      }), renderChildren2());
    }
    const Dropdown$3 = /* @__PURE__ */ reactExports.forwardRef(Dropdown$2);
    var IdContext = /* @__PURE__ */ reactExports.createContext(null);
    function getMenuId(uuid2, eventKey) {
      if (uuid2 === void 0) {
        return null;
      }
      return "".concat(uuid2, "-").concat(eventKey);
    }
    function useMenuId(eventKey) {
      var id2 = reactExports.useContext(IdContext);
      return getMenuId(id2, eventKey);
    }
    var _excluded$u = ["children", "locked"];
    var MenuContext$2 = /* @__PURE__ */ reactExports.createContext(null);
    function mergeProps(origin, target) {
      var clone = _objectSpread2$3({}, origin);
      Object.keys(target).forEach(function(key) {
        var value = target[key];
        if (value !== void 0) {
          clone[key] = value;
        }
      });
      return clone;
    }
    function InheritableContextProvider(_ref) {
      var children = _ref.children, locked = _ref.locked, restProps = _objectWithoutProperties$1(_ref, _excluded$u);
      var context = reactExports.useContext(MenuContext$2);
      var inheritableContext = useMemo(function() {
        return mergeProps(context, restProps);
      }, [context, restProps], function(prev2, next2) {
        return !locked && (prev2[0] !== next2[0] || !isEqual$1(prev2[1], next2[1], true));
      });
      return /* @__PURE__ */ reactExports.createElement(MenuContext$2.Provider, {
        value: inheritableContext
      }, children);
    }
    var EmptyList = [];
    var PathRegisterContext = /* @__PURE__ */ reactExports.createContext(null);
    function useMeasure() {
      return reactExports.useContext(PathRegisterContext);
    }
    var PathTrackerContext = /* @__PURE__ */ reactExports.createContext(EmptyList);
    function useFullPath(eventKey) {
      var parentKeyPath = reactExports.useContext(PathTrackerContext);
      return reactExports.useMemo(function() {
        return eventKey !== void 0 ? [].concat(_toConsumableArray(parentKeyPath), [eventKey]) : parentKeyPath;
      }, [parentKeyPath, eventKey]);
    }
    var PathUserContext = /* @__PURE__ */ reactExports.createContext(null);
    var PrivateContext = /* @__PURE__ */ reactExports.createContext({});
    var LEFT = KeyCode.LEFT, RIGHT = KeyCode.RIGHT, UP = KeyCode.UP, DOWN = KeyCode.DOWN, ENTER = KeyCode.ENTER, ESC = KeyCode.ESC, HOME = KeyCode.HOME, END = KeyCode.END;
    var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
    function getOffset$1(mode, isRootLevel, isRtl, which) {
      var _inline, _horizontal, _vertical, _offsets;
      var prev2 = "prev";
      var next2 = "next";
      var children = "children";
      var parent = "parent";
      if (mode === "inline" && which === ENTER) {
        return {
          inlineTrigger: true
        };
      }
      var inline2 = (_inline = {}, _defineProperty$7(_inline, UP, prev2), _defineProperty$7(_inline, DOWN, next2), _inline);
      var horizontal = (_horizontal = {}, _defineProperty$7(_horizontal, LEFT, isRtl ? next2 : prev2), _defineProperty$7(_horizontal, RIGHT, isRtl ? prev2 : next2), _defineProperty$7(_horizontal, DOWN, children), _defineProperty$7(_horizontal, ENTER, children), _horizontal);
      var vertical = (_vertical = {}, _defineProperty$7(_vertical, UP, prev2), _defineProperty$7(_vertical, DOWN, next2), _defineProperty$7(_vertical, ENTER, children), _defineProperty$7(_vertical, ESC, parent), _defineProperty$7(_vertical, LEFT, isRtl ? children : parent), _defineProperty$7(_vertical, RIGHT, isRtl ? parent : children), _vertical);
      var offsets = {
        inline: inline2,
        horizontal,
        vertical,
        inlineSub: inline2,
        horizontalSub: vertical,
        verticalSub: vertical
      };
      var type2 = (_offsets = offsets["".concat(mode).concat(isRootLevel ? "" : "Sub")]) === null || _offsets === void 0 ? void 0 : _offsets[which];
      switch (type2) {
        case prev2:
          return {
            offset: -1,
            sibling: true
          };
        case next2:
          return {
            offset: 1,
            sibling: true
          };
        case parent:
          return {
            offset: -1,
            sibling: false
          };
        case children:
          return {
            offset: 1,
            sibling: false
          };
        default:
          return null;
      }
    }
    function findContainerUL(element) {
      var current = element;
      while (current) {
        if (current.getAttribute("data-menu-list")) {
          return current;
        }
        current = current.parentElement;
      }
      return null;
    }
    function getFocusElement(activeElement, elements) {
      var current = activeElement || document.activeElement;
      while (current) {
        if (elements.has(current)) {
          return current;
        }
        current = current.parentElement;
      }
      return null;
    }
    function getFocusableElements(container2, elements) {
      var list2 = getFocusNodeList(container2, true);
      return list2.filter(function(ele) {
        return elements.has(ele);
      });
    }
    function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
      var offset2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
      if (!parentQueryContainer) {
        return null;
      }
      var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
      var count = sameLevelFocusableMenuElementList.length;
      var focusIndex = sameLevelFocusableMenuElementList.findIndex(function(ele) {
        return focusMenuElement === ele;
      });
      if (offset2 < 0) {
        if (focusIndex === -1) {
          focusIndex = count - 1;
        } else {
          focusIndex -= 1;
        }
      } else if (offset2 > 0) {
        focusIndex += 1;
      }
      focusIndex = (focusIndex + count) % count;
      return sameLevelFocusableMenuElementList[focusIndex];
    }
    function useAccessibility(mode, activeKey, isRtl, id2, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
      var rafRef = reactExports.useRef();
      var activeRef = reactExports.useRef();
      activeRef.current = activeKey;
      var cleanRaf = function cleanRaf2() {
        wrapperRaf.cancel(rafRef.current);
      };
      reactExports.useEffect(function() {
        return function() {
          cleanRaf();
        };
      }, []);
      return function(e2) {
        var which = e2.which;
        if ([].concat(ArrowKeys, [ENTER, ESC, HOME, END]).includes(which)) {
          var elements;
          var key2element;
          var element2key;
          var refreshElements = function refreshElements2() {
            elements = /* @__PURE__ */ new Set();
            key2element = /* @__PURE__ */ new Map();
            element2key = /* @__PURE__ */ new Map();
            var keys2 = getKeys();
            keys2.forEach(function(key) {
              var element = document.querySelector("[data-menu-id='".concat(getMenuId(id2, key), "']"));
              if (element) {
                elements.add(element);
                element2key.set(element, key);
                key2element.set(key, element);
              }
            });
            return elements;
          };
          refreshElements();
          var activeElement = key2element.get(activeKey);
          var focusMenuElement = getFocusElement(activeElement, elements);
          var focusMenuKey = element2key.get(focusMenuElement);
          var offsetObj = getOffset$1(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
          if (!offsetObj && which !== HOME && which !== END) {
            return;
          }
          if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
            e2.preventDefault();
          }
          var tryFocus = function tryFocus2(menuElement) {
            if (menuElement) {
              var focusTargetElement = menuElement;
              var link2 = menuElement.querySelector("a");
              if (link2 !== null && link2 !== void 0 && link2.getAttribute("href")) {
                focusTargetElement = link2;
              }
              var targetKey = element2key.get(menuElement);
              triggerActiveKey(targetKey);
              cleanRaf();
              rafRef.current = wrapperRaf(function() {
                if (activeRef.current === targetKey) {
                  focusTargetElement.focus();
                }
              });
            }
          };
          if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
            var parentQueryContainer;
            if (!focusMenuElement || mode === "inline") {
              parentQueryContainer = containerRef.current;
            } else {
              parentQueryContainer = findContainerUL(focusMenuElement);
            }
            var targetElement;
            var focusableElements = getFocusableElements(parentQueryContainer, elements);
            if (which === HOME) {
              targetElement = focusableElements[0];
            } else if (which === END) {
              targetElement = focusableElements[focusableElements.length - 1];
            } else {
              targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
            }
            tryFocus(targetElement);
          } else if (offsetObj.inlineTrigger) {
            triggerAccessibilityOpen(focusMenuKey);
          } else if (offsetObj.offset > 0) {
            triggerAccessibilityOpen(focusMenuKey, true);
            cleanRaf();
            rafRef.current = wrapperRaf(function() {
              refreshElements();
              var controlId = focusMenuElement.getAttribute("aria-controls");
              var subQueryContainer = document.getElementById(controlId);
              var targetElement2 = getNextFocusElement(subQueryContainer, elements);
              tryFocus(targetElement2);
            }, 5);
          } else if (offsetObj.offset < 0) {
            var keyPath = getKeyPath(focusMenuKey, true);
            var parentKey = keyPath[keyPath.length - 2];
            var parentMenuElement = key2element.get(parentKey);
            triggerAccessibilityOpen(parentKey, false);
            tryFocus(parentMenuElement);
          }
        }
        originOnKeyDown === null || originOnKeyDown === void 0 ? void 0 : originOnKeyDown(e2);
      };
    }
    function nextSlice(callback) {
      Promise.resolve().then(callback);
    }
    var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
    var getPathStr = function getPathStr2(keyPath) {
      return keyPath.join(PATH_SPLIT);
    };
    var getPathKeys = function getPathKeys2(keyPathStr) {
      return keyPathStr.split(PATH_SPLIT);
    };
    var OVERFLOW_KEY = "rc-menu-more";
    function useKeyRecords() {
      var _React$useState = reactExports.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), internalForceUpdate = _React$useState2[1];
      var key2pathRef = reactExports.useRef(/* @__PURE__ */ new Map());
      var path2keyRef = reactExports.useRef(/* @__PURE__ */ new Map());
      var _React$useState3 = reactExports.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), overflowKeys = _React$useState4[0], setOverflowKeys = _React$useState4[1];
      var updateRef = reactExports.useRef(0);
      var destroyRef = reactExports.useRef(false);
      var forceUpdate = function forceUpdate2() {
        if (!destroyRef.current) {
          internalForceUpdate({});
        }
      };
      var registerPath = reactExports.useCallback(function(key, keyPath) {
        var connectedPath = getPathStr(keyPath);
        path2keyRef.current.set(connectedPath, key);
        key2pathRef.current.set(key, connectedPath);
        updateRef.current += 1;
        var id2 = updateRef.current;
        nextSlice(function() {
          if (id2 === updateRef.current) {
            forceUpdate();
          }
        });
      }, []);
      var unregisterPath = reactExports.useCallback(function(key, keyPath) {
        var connectedPath = getPathStr(keyPath);
        path2keyRef.current.delete(connectedPath);
        key2pathRef.current.delete(key);
      }, []);
      var refreshOverflowKeys = reactExports.useCallback(function(keys2) {
        setOverflowKeys(keys2);
      }, []);
      var getKeyPath = reactExports.useCallback(function(eventKey, includeOverflow) {
        var fullPath = key2pathRef.current.get(eventKey) || "";
        var keys2 = getPathKeys(fullPath);
        if (includeOverflow && overflowKeys.includes(keys2[0])) {
          keys2.unshift(OVERFLOW_KEY);
        }
        return keys2;
      }, [overflowKeys]);
      var isSubPathKey = reactExports.useCallback(function(pathKeys, eventKey) {
        return pathKeys.some(function(pathKey) {
          var pathKeyList = getKeyPath(pathKey, true);
          return pathKeyList.includes(eventKey);
        });
      }, [getKeyPath]);
      var getKeys = function getKeys2() {
        var keys2 = _toConsumableArray(key2pathRef.current.keys());
        if (overflowKeys.length) {
          keys2.push(OVERFLOW_KEY);
        }
        return keys2;
      };
      var getSubPathKeys = reactExports.useCallback(function(key) {
        var connectedPath = "".concat(key2pathRef.current.get(key)).concat(PATH_SPLIT);
        var pathKeys = /* @__PURE__ */ new Set();
        _toConsumableArray(path2keyRef.current.keys()).forEach(function(pathKey) {
          if (pathKey.startsWith(connectedPath)) {
            pathKeys.add(path2keyRef.current.get(pathKey));
          }
        });
        return pathKeys;
      }, []);
      reactExports.useEffect(function() {
        return function() {
          destroyRef.current = true;
        };
      }, []);
      return {
        // Register
        registerPath,
        unregisterPath,
        refreshOverflowKeys,
        // Util
        isSubPathKey,
        getKeyPath,
        getKeys,
        getSubPathKeys
      };
    }
    function useMemoCallback(func) {
      var funRef = reactExports.useRef(func);
      funRef.current = func;
      var callback = reactExports.useCallback(function() {
        var _funRef$current;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
      }, []);
      return func ? callback : void 0;
    }
    var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
    var internalId = 0;
    function useUUID(id2) {
      var _useMergedState = useMergedState(id2, {
        value: id2
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), uuid2 = _useMergedState2[0], setUUID = _useMergedState2[1];
      reactExports.useEffect(function() {
        internalId += 1;
        var newId = "".concat(uniquePrefix, "-").concat(internalId);
        setUUID("rc-menu-uuid-".concat(newId));
      }, []);
      return uuid2;
    }
    function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
      var _React$useContext = reactExports.useContext(MenuContext$2), activeKey = _React$useContext.activeKey, onActive = _React$useContext.onActive, onInactive = _React$useContext.onInactive;
      var ret = {
        active: activeKey === eventKey
      };
      if (!disabled) {
        ret.onMouseEnter = function(domEvent) {
          onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
            key: eventKey,
            domEvent
          });
          onActive(eventKey);
        };
        ret.onMouseLeave = function(domEvent) {
          onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
            key: eventKey,
            domEvent
          });
          onInactive(eventKey);
        };
      }
      return ret;
    }
    var _excluded$t = ["item"];
    function warnItemProp(_ref) {
      var item = _ref.item, restInfo = _objectWithoutProperties$1(_ref, _excluded$t);
      Object.defineProperty(restInfo, "item", {
        get: function get2() {
          warningOnce$1(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
          return item;
        }
      });
      return restInfo;
    }
    function Icon$6(_ref) {
      var icon = _ref.icon, props = _ref.props, children = _ref.children;
      var iconNode;
      if (typeof icon === "function") {
        iconNode = /* @__PURE__ */ reactExports.createElement(icon, _objectSpread2$3({}, props));
      } else {
        iconNode = icon;
      }
      return iconNode || children || null;
    }
    function useDirectionStyle(level) {
      var _React$useContext = reactExports.useContext(MenuContext$2), mode = _React$useContext.mode, rtl = _React$useContext.rtl, inlineIndent = _React$useContext.inlineIndent;
      if (mode !== "inline") {
        return null;
      }
      var len = level;
      return rtl ? {
        paddingRight: len * inlineIndent
      } : {
        paddingLeft: len * inlineIndent
      };
    }
    var _excluded$s = ["title", "attribute", "elementRef"], _excluded2$4 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"], _excluded3 = ["active"];
    var LegacyMenuItem = /* @__PURE__ */ function(_React$Component) {
      _inherits(LegacyMenuItem2, _React$Component);
      var _super = _createSuper(LegacyMenuItem2);
      function LegacyMenuItem2() {
        _classCallCheck(this, LegacyMenuItem2);
        return _super.apply(this, arguments);
      }
      _createClass(LegacyMenuItem2, [{
        key: "render",
        value: function render2() {
          var _this$props = this.props, title = _this$props.title, attribute = _this$props.attribute, elementRef = _this$props.elementRef, restProps = _objectWithoutProperties$1(_this$props, _excluded$s);
          var passedProps = omit(restProps, ["eventKey"]);
          warningOnce$1(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
          return /* @__PURE__ */ reactExports.createElement(ForwardOverflow.Item, _extends$2({}, attribute, {
            title: typeof title === "string" ? title : void 0
          }, passedProps, {
            ref: elementRef
          }));
        }
      }]);
      return LegacyMenuItem2;
    }(reactExports.Component);
    var InternalMenuItem = function InternalMenuItem2(props) {
      var _classNames;
      var style2 = props.style, className = props.className, eventKey = props.eventKey;
      props.warnKey;
      var disabled = props.disabled, itemIcon = props.itemIcon, children = props.children, role = props.role, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown2 = props.onKeyDown, onFocus = props.onFocus, restProps = _objectWithoutProperties$1(props, _excluded2$4);
      var domDataId = useMenuId(eventKey);
      var _React$useContext = reactExports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, onItemClick = _React$useContext.onItemClick, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, contextItemIcon = _React$useContext.itemIcon, selectedKeys = _React$useContext.selectedKeys, onActive = _React$useContext.onActive;
      var _React$useContext2 = reactExports.useContext(PrivateContext), _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
      var itemCls = "".concat(prefixCls, "-item");
      var legacyMenuItemRef = reactExports.useRef();
      var elementRef = reactExports.useRef();
      var mergedDisabled = contextDisabled || disabled;
      var connectedKeys = useFullPath(eventKey);
      var getEventInfo = function getEventInfo2(e2) {
        return {
          key: eventKey,
          // Note: For legacy code is reversed which not like other antd component
          keyPath: _toConsumableArray(connectedKeys).reverse(),
          item: legacyMenuItemRef.current,
          domEvent: e2
        };
      };
      var mergedItemIcon = itemIcon || contextItemIcon;
      var _useActive = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties$1(_useActive, _excluded3);
      var selected = selectedKeys.includes(eventKey);
      var directionStyle = useDirectionStyle(connectedKeys.length);
      var onInternalClick = function onInternalClick2(e2) {
        if (mergedDisabled) {
          return;
        }
        var info2 = getEventInfo(e2);
        onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info2));
        onItemClick(info2);
      };
      var onInternalKeyDown = function onInternalKeyDown2(e2) {
        onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(e2);
        if (e2.which === KeyCode.ENTER) {
          var info2 = getEventInfo(e2);
          onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info2));
          onItemClick(info2);
        }
      };
      var onInternalFocus = function onInternalFocus2(e2) {
        onActive(eventKey);
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
      };
      var optionRoleProps = {};
      if (props.role === "option") {
        optionRoleProps["aria-selected"] = selected;
      }
      var renderNode = /* @__PURE__ */ reactExports.createElement(LegacyMenuItem, _extends$2({
        ref: legacyMenuItemRef,
        elementRef,
        role: role === null ? "none" : role || "menuitem",
        tabIndex: disabled ? null : -1,
        "data-menu-id": overflowDisabled && domDataId ? null : domDataId
      }, restProps, activeProps, optionRoleProps, {
        component: "li",
        "aria-disabled": disabled,
        style: _objectSpread2$3(_objectSpread2$3({}, directionStyle), style2),
        className: classNames(itemCls, (_classNames = {}, _defineProperty$7(_classNames, "".concat(itemCls, "-active"), active), _defineProperty$7(_classNames, "".concat(itemCls, "-selected"), selected), _defineProperty$7(_classNames, "".concat(itemCls, "-disabled"), mergedDisabled), _classNames), className),
        onClick: onInternalClick,
        onKeyDown: onInternalKeyDown,
        onFocus: onInternalFocus
      }), children, /* @__PURE__ */ reactExports.createElement(Icon$6, {
        props: _objectSpread2$3(_objectSpread2$3({}, props), {}, {
          isSelected: selected
        }),
        icon: mergedItemIcon
      }));
      if (_internalRenderMenuItem) {
        renderNode = _internalRenderMenuItem(renderNode, props, {
          selected
        });
      }
      return renderNode;
    };
    function MenuItem$1(props) {
      var eventKey = props.eventKey;
      var measure = useMeasure();
      var connectedKeyPath = useFullPath(eventKey);
      reactExports.useEffect(function() {
        if (measure) {
          measure.registerPath(eventKey, connectedKeyPath);
          return function() {
            measure.unregisterPath(eventKey, connectedKeyPath);
          };
        }
      }, [connectedKeyPath]);
      if (measure) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(InternalMenuItem, props);
    }
    var _excluded$r = ["className", "children"];
    var InternalSubMenuList = function InternalSubMenuList2(_ref, ref) {
      var className = _ref.className, children = _ref.children, restProps = _objectWithoutProperties$1(_ref, _excluded$r);
      var _React$useContext = reactExports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, rtl = _React$useContext.rtl;
      return /* @__PURE__ */ reactExports.createElement("ul", _extends$2({
        className: classNames(prefixCls, rtl && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === "inline" ? "inline" : "vertical"), className),
        role: "menu"
      }, restProps, {
        "data-menu-list": true,
        ref
      }), children);
    };
    var SubMenuList = /* @__PURE__ */ reactExports.forwardRef(InternalSubMenuList);
    SubMenuList.displayName = "SubMenuList";
    var _excluded$q = ["label", "children", "key", "type"];
    function parseChildren(children, keyPath) {
      return toArray$8(children).map(function(child, index2) {
        if (/* @__PURE__ */ reactExports.isValidElement(child)) {
          var _eventKey, _child$props;
          var key = child.key;
          var eventKey = (_eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _eventKey !== void 0 ? _eventKey : key;
          var emptyKey = eventKey === null || eventKey === void 0;
          if (emptyKey) {
            eventKey = "tmp_key-".concat([].concat(_toConsumableArray(keyPath), [index2]).join("-"));
          }
          var cloneProps = {
            key: eventKey,
            eventKey
          };
          return /* @__PURE__ */ reactExports.cloneElement(child, cloneProps);
        }
        return child;
      });
    }
    function convertItemsToNodes$1(list2) {
      return (list2 || []).map(function(opt, index2) {
        if (opt && _typeof$4(opt) === "object") {
          var _ref = opt, label = _ref.label, children = _ref.children, key = _ref.key, type2 = _ref.type, restProps = _objectWithoutProperties$1(_ref, _excluded$q);
          var mergedKey = key !== null && key !== void 0 ? key : "tmp-".concat(index2);
          if (children || type2 === "group") {
            if (type2 === "group") {
              return /* @__PURE__ */ reactExports.createElement(MenuItemGroup, _extends$2({
                key: mergedKey
              }, restProps, {
                title: label
              }), convertItemsToNodes$1(children));
            }
            return /* @__PURE__ */ reactExports.createElement(SubMenu$3, _extends$2({
              key: mergedKey
            }, restProps, {
              title: label
            }), convertItemsToNodes$1(children));
          }
          if (type2 === "divider") {
            return /* @__PURE__ */ reactExports.createElement(Divider$2, _extends$2({
              key: mergedKey
            }, restProps));
          }
          return /* @__PURE__ */ reactExports.createElement(MenuItem$1, _extends$2({
            key: mergedKey
          }, restProps), label);
        }
        return null;
      }).filter(function(opt) {
        return opt;
      });
    }
    function parseItems(children, items, keyPath) {
      var childNodes = children;
      if (items) {
        childNodes = convertItemsToNodes$1(items);
      }
      return parseChildren(childNodes, keyPath);
    }
    var autoAdjustOverflow = {
      adjustX: 1,
      adjustY: 1
    };
    var placements = {
      topLeft: {
        points: ["bl", "tl"],
        overflow: autoAdjustOverflow,
        offset: [0, -7]
      },
      bottomLeft: {
        points: ["tl", "bl"],
        overflow: autoAdjustOverflow,
        offset: [0, 7]
      },
      leftTop: {
        points: ["tr", "tl"],
        overflow: autoAdjustOverflow,
        offset: [-4, 0]
      },
      rightTop: {
        points: ["tl", "tr"],
        overflow: autoAdjustOverflow,
        offset: [4, 0]
      }
    };
    var placementsRtl = {
      topLeft: {
        points: ["bl", "tl"],
        overflow: autoAdjustOverflow,
        offset: [0, -7]
      },
      bottomLeft: {
        points: ["tl", "bl"],
        overflow: autoAdjustOverflow,
        offset: [0, 7]
      },
      rightTop: {
        points: ["tr", "tl"],
        overflow: autoAdjustOverflow,
        offset: [-4, 0]
      },
      leftTop: {
        points: ["tl", "tr"],
        overflow: autoAdjustOverflow,
        offset: [4, 0]
      }
    };
    function getMotion(mode, motion2, defaultMotions) {
      if (motion2) {
        return motion2;
      }
      if (defaultMotions) {
        return defaultMotions[mode] || defaultMotions.other;
      }
      return void 0;
    }
    var popupPlacementMap = {
      horizontal: "bottomLeft",
      vertical: "rightTop",
      "vertical-left": "rightTop",
      "vertical-right": "leftTop"
    };
    function PopupTrigger(_ref) {
      var prefixCls = _ref.prefixCls, visible = _ref.visible, children = _ref.children, popup = _ref.popup, popupClassName = _ref.popupClassName, popupOffset = _ref.popupOffset, disabled = _ref.disabled, mode = _ref.mode, onVisibleChange = _ref.onVisibleChange;
      var _React$useContext = reactExports.useContext(MenuContext$2), getPopupContainer = _React$useContext.getPopupContainer, rtl = _React$useContext.rtl, subMenuOpenDelay = _React$useContext.subMenuOpenDelay, subMenuCloseDelay = _React$useContext.subMenuCloseDelay, builtinPlacements = _React$useContext.builtinPlacements, triggerSubMenuAction = _React$useContext.triggerSubMenuAction, forceSubMenuRender = _React$useContext.forceSubMenuRender, rootClassName = _React$useContext.rootClassName, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), innerVisible = _React$useState2[0], setInnerVisible = _React$useState2[1];
      var placement = rtl ? _objectSpread2$3(_objectSpread2$3({}, placementsRtl), builtinPlacements) : _objectSpread2$3(_objectSpread2$3({}, placements), builtinPlacements);
      var popupPlacement = popupPlacementMap[mode];
      var targetMotion = getMotion(mode, motion2, defaultMotions);
      var targetMotionRef = reactExports.useRef(targetMotion);
      if (mode !== "inline") {
        targetMotionRef.current = targetMotion;
      }
      var mergedMotion = _objectSpread2$3(_objectSpread2$3({}, targetMotionRef.current), {}, {
        leavedClassName: "".concat(prefixCls, "-hidden"),
        removeOnLeave: false,
        motionAppear: true
      });
      var visibleRef = reactExports.useRef();
      reactExports.useEffect(function() {
        visibleRef.current = wrapperRaf(function() {
          setInnerVisible(visible);
        });
        return function() {
          wrapperRaf.cancel(visibleRef.current);
        };
      }, [visible]);
      return /* @__PURE__ */ reactExports.createElement(Trigger, {
        prefixCls,
        popupClassName: classNames("".concat(prefixCls, "-popup"), _defineProperty$7({}, "".concat(prefixCls, "-rtl"), rtl), popupClassName, rootClassName),
        stretch: mode === "horizontal" ? "minWidth" : null,
        getPopupContainer,
        builtinPlacements: placement,
        popupPlacement,
        popupVisible: innerVisible,
        popup,
        popupAlign: popupOffset && {
          offset: popupOffset
        },
        action: disabled ? [] : [triggerSubMenuAction],
        mouseEnterDelay: subMenuOpenDelay,
        mouseLeaveDelay: subMenuCloseDelay,
        onPopupVisibleChange: onVisibleChange,
        forceRender: forceSubMenuRender,
        popupMotion: mergedMotion
      }, children);
    }
    function InlineSubMenuList(_ref) {
      var id2 = _ref.id, open2 = _ref.open, keyPath = _ref.keyPath, children = _ref.children;
      var fixedMode = "inline";
      var _React$useContext = reactExports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, forceSubMenuRender = _React$useContext.forceSubMenuRender, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions, mode = _React$useContext.mode;
      var sameModeRef = reactExports.useRef(false);
      sameModeRef.current = mode === fixedMode;
      var _React$useState = reactExports.useState(!sameModeRef.current), _React$useState2 = _slicedToArray(_React$useState, 2), destroy2 = _React$useState2[0], setDestroy = _React$useState2[1];
      var mergedOpen = sameModeRef.current ? open2 : false;
      reactExports.useEffect(function() {
        if (sameModeRef.current) {
          setDestroy(false);
        }
      }, [mode]);
      var mergedMotion = _objectSpread2$3({}, getMotion(fixedMode, motion2, defaultMotions));
      if (keyPath.length > 1) {
        mergedMotion.motionAppear = false;
      }
      var originOnVisibleChanged = mergedMotion.onVisibleChanged;
      mergedMotion.onVisibleChanged = function(newVisible) {
        if (!sameModeRef.current && !newVisible) {
          setDestroy(true);
        }
        return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
      };
      if (destroy2) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(InheritableContextProvider, {
        mode: fixedMode,
        locked: !sameModeRef.current
      }, /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$2({
        visible: mergedOpen
      }, mergedMotion, {
        forceRender: forceSubMenuRender,
        removeOnLeave: false,
        leavedClassName: "".concat(prefixCls, "-hidden")
      }), function(_ref2) {
        var motionClassName = _ref2.className, motionStyle = _ref2.style;
        return /* @__PURE__ */ reactExports.createElement(SubMenuList, {
          id: id2,
          className: motionClassName,
          style: motionStyle
        }, children);
      }));
    }
    var _excluded$p = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"], _excluded2$3 = ["active"];
    var InternalSubMenu = function InternalSubMenu2(props) {
      var _classNames;
      var style2 = props.style, className = props.className, title = props.title, eventKey = props.eventKey;
      props.warnKey;
      var disabled = props.disabled, internalPopupClose = props.internalPopupClose, children = props.children, itemIcon = props.itemIcon, expandIcon = props.expandIcon, popupClassName = props.popupClassName, popupOffset = props.popupOffset, onClick = props.onClick, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onTitleClick = props.onTitleClick, onTitleMouseEnter = props.onTitleMouseEnter, onTitleMouseLeave = props.onTitleMouseLeave, restProps = _objectWithoutProperties$1(props, _excluded$p);
      var domDataId = useMenuId(eventKey);
      var _React$useContext = reactExports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, openKeys = _React$useContext.openKeys, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, activeKey = _React$useContext.activeKey, selectedKeys = _React$useContext.selectedKeys, contextItemIcon = _React$useContext.itemIcon, contextExpandIcon = _React$useContext.expandIcon, onItemClick = _React$useContext.onItemClick, onOpenChange = _React$useContext.onOpenChange, onActive = _React$useContext.onActive;
      var _React$useContext2 = reactExports.useContext(PrivateContext), _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
      var _React$useContext3 = reactExports.useContext(PathUserContext), isSubPathKey = _React$useContext3.isSubPathKey;
      var connectedPath = useFullPath();
      var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
      var mergedDisabled = contextDisabled || disabled;
      var elementRef = reactExports.useRef();
      var popupRef = reactExports.useRef();
      var mergedItemIcon = itemIcon || contextItemIcon;
      var mergedExpandIcon = expandIcon || contextExpandIcon;
      var originOpen = openKeys.includes(eventKey);
      var open2 = !overflowDisabled && originOpen;
      var childrenSelected = isSubPathKey(selectedKeys, eventKey);
      var _useActive = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties$1(_useActive, _excluded2$3);
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), childrenActive = _React$useState2[0], setChildrenActive = _React$useState2[1];
      var triggerChildrenActive = function triggerChildrenActive2(newActive) {
        if (!mergedDisabled) {
          setChildrenActive(newActive);
        }
      };
      var onInternalMouseEnter = function onInternalMouseEnter2(domEvent) {
        triggerChildrenActive(true);
        onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
          key: eventKey,
          domEvent
        });
      };
      var onInternalMouseLeave = function onInternalMouseLeave2(domEvent) {
        triggerChildrenActive(false);
        onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
          key: eventKey,
          domEvent
        });
      };
      var mergedActive = reactExports.useMemo(function() {
        if (active) {
          return active;
        }
        if (mode !== "inline") {
          return childrenActive || isSubPathKey([activeKey], eventKey);
        }
        return false;
      }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
      var directionStyle = useDirectionStyle(connectedPath.length);
      var onInternalTitleClick = function onInternalTitleClick2(e2) {
        if (mergedDisabled) {
          return;
        }
        onTitleClick === null || onTitleClick === void 0 ? void 0 : onTitleClick({
          key: eventKey,
          domEvent: e2
        });
        if (mode === "inline") {
          onOpenChange(eventKey, !originOpen);
        }
      };
      var onMergedItemClick = useMemoCallback(function(info2) {
        onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info2));
        onItemClick(info2);
      });
      var onPopupVisibleChange = function onPopupVisibleChange2(newVisible) {
        if (mode !== "inline") {
          onOpenChange(eventKey, newVisible);
        }
      };
      var onInternalFocus = function onInternalFocus2() {
        onActive(eventKey);
      };
      var popupId = domDataId && "".concat(domDataId, "-popup");
      var titleNode = /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        role: "menuitem",
        style: directionStyle,
        className: "".concat(subMenuPrefixCls, "-title"),
        tabIndex: mergedDisabled ? null : -1,
        ref: elementRef,
        title: typeof title === "string" ? title : null,
        "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
        "aria-expanded": open2,
        "aria-haspopup": true,
        "aria-controls": popupId,
        "aria-disabled": mergedDisabled,
        onClick: onInternalTitleClick,
        onFocus: onInternalFocus
      }, activeProps), title, /* @__PURE__ */ reactExports.createElement(Icon$6, {
        icon: mode !== "horizontal" ? mergedExpandIcon : null,
        props: _objectSpread2$3(_objectSpread2$3({}, props), {}, {
          isOpen: open2,
          // [Legacy] Not sure why need this mark
          isSubMenu: true
        })
      }, /* @__PURE__ */ reactExports.createElement("i", {
        className: "".concat(subMenuPrefixCls, "-arrow")
      })));
      var triggerModeRef = reactExports.useRef(mode);
      if (mode !== "inline" && connectedPath.length > 1) {
        triggerModeRef.current = "vertical";
      } else {
        triggerModeRef.current = mode;
      }
      if (!overflowDisabled) {
        var triggerMode = triggerModeRef.current;
        titleNode = /* @__PURE__ */ reactExports.createElement(PopupTrigger, {
          mode: triggerMode,
          prefixCls: subMenuPrefixCls,
          visible: !internalPopupClose && open2 && mode !== "inline",
          popupClassName,
          popupOffset,
          popup: /* @__PURE__ */ reactExports.createElement(
            InheritableContextProvider,
            {
              mode: triggerMode === "horizontal" ? "vertical" : triggerMode
            },
            /* @__PURE__ */ reactExports.createElement(SubMenuList, {
              id: popupId,
              ref: popupRef
            }, children)
          ),
          disabled: mergedDisabled,
          onVisibleChange: onPopupVisibleChange
        }, titleNode);
      }
      var listNode = /* @__PURE__ */ reactExports.createElement(ForwardOverflow.Item, _extends$2({
        role: "none"
      }, restProps, {
        component: "li",
        style: style2,
        className: classNames(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, (_classNames = {}, _defineProperty$7(_classNames, "".concat(subMenuPrefixCls, "-open"), open2), _defineProperty$7(_classNames, "".concat(subMenuPrefixCls, "-active"), mergedActive), _defineProperty$7(_classNames, "".concat(subMenuPrefixCls, "-selected"), childrenSelected), _defineProperty$7(_classNames, "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled), _classNames)),
        onMouseEnter: onInternalMouseEnter,
        onMouseLeave: onInternalMouseLeave
      }), titleNode, !overflowDisabled && /* @__PURE__ */ reactExports.createElement(InlineSubMenuList, {
        id: popupId,
        open: open2,
        keyPath: connectedPath
      }, children));
      if (_internalRenderSubMenuItem) {
        listNode = _internalRenderSubMenuItem(listNode, props, {
          selected: childrenSelected,
          active: mergedActive,
          open: open2,
          disabled: mergedDisabled
        });
      }
      return /* @__PURE__ */ reactExports.createElement(InheritableContextProvider, {
        onItemClick: onMergedItemClick,
        mode: mode === "horizontal" ? "vertical" : mode,
        itemIcon: mergedItemIcon,
        expandIcon: mergedExpandIcon
      }, listNode);
    };
    function SubMenu$3(props) {
      var eventKey = props.eventKey, children = props.children;
      var connectedKeyPath = useFullPath(eventKey);
      var childList = parseChildren(children, connectedKeyPath);
      var measure = useMeasure();
      reactExports.useEffect(function() {
        if (measure) {
          measure.registerPath(eventKey, connectedKeyPath);
          return function() {
            measure.unregisterPath(eventKey, connectedKeyPath);
          };
        }
      }, [connectedKeyPath]);
      var renderNode;
      if (measure) {
        renderNode = childList;
      } else {
        renderNode = /* @__PURE__ */ reactExports.createElement(InternalSubMenu, props, childList);
      }
      return /* @__PURE__ */ reactExports.createElement(PathTrackerContext.Provider, {
        value: connectedKeyPath
      }, renderNode);
    }
    var _excluded$o = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem"];
    var EMPTY_LIST$3 = [];
    var Menu$2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _childList$, _classNames;
      var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-menu" : _ref$prefixCls, rootClassName = _ref.rootClassName, style2 = _ref.style, className = _ref.className, _ref$tabIndex = _ref.tabIndex, tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, items = _ref.items, children = _ref.children, direction = _ref.direction, id2 = _ref.id, _ref$mode = _ref.mode, mode = _ref$mode === void 0 ? "vertical" : _ref$mode, inlineCollapsed = _ref.inlineCollapsed, disabled = _ref.disabled, disabledOverflow = _ref.disabledOverflow, _ref$subMenuOpenDelay = _ref.subMenuOpenDelay, subMenuOpenDelay = _ref$subMenuOpenDelay === void 0 ? 0.1 : _ref$subMenuOpenDelay, _ref$subMenuCloseDela = _ref.subMenuCloseDelay, subMenuCloseDelay = _ref$subMenuCloseDela === void 0 ? 0.1 : _ref$subMenuCloseDela, forceSubMenuRender = _ref.forceSubMenuRender, defaultOpenKeys = _ref.defaultOpenKeys, openKeys = _ref.openKeys, activeKey = _ref.activeKey, defaultActiveFirst = _ref.defaultActiveFirst, _ref$selectable = _ref.selectable, selectable = _ref$selectable === void 0 ? true : _ref$selectable, _ref$multiple = _ref.multiple, multiple = _ref$multiple === void 0 ? false : _ref$multiple, defaultSelectedKeys = _ref.defaultSelectedKeys, selectedKeys = _ref.selectedKeys, onSelect = _ref.onSelect, onDeselect = _ref.onDeselect, _ref$inlineIndent = _ref.inlineIndent, inlineIndent = _ref$inlineIndent === void 0 ? 24 : _ref$inlineIndent, motion2 = _ref.motion, defaultMotions = _ref.defaultMotions, _ref$triggerSubMenuAc = _ref.triggerSubMenuAction, triggerSubMenuAction = _ref$triggerSubMenuAc === void 0 ? "hover" : _ref$triggerSubMenuAc, builtinPlacements = _ref.builtinPlacements, itemIcon = _ref.itemIcon, expandIcon = _ref.expandIcon, _ref$overflowedIndica = _ref.overflowedIndicator, overflowedIndicator = _ref$overflowedIndica === void 0 ? "..." : _ref$overflowedIndica, overflowedIndicatorPopupClassName = _ref.overflowedIndicatorPopupClassName, getPopupContainer = _ref.getPopupContainer, onClick = _ref.onClick, onOpenChange = _ref.onOpenChange, onKeyDown2 = _ref.onKeyDown;
      _ref.openAnimation;
      _ref.openTransitionName;
      var _internalRenderMenuItem = _ref._internalRenderMenuItem, _internalRenderSubMenuItem = _ref._internalRenderSubMenuItem, restProps = _objectWithoutProperties$1(_ref, _excluded$o);
      var childList = reactExports.useMemo(function() {
        return parseItems(children, items, EMPTY_LIST$3);
      }, [children, items]);
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mounted = _React$useState2[0], setMounted = _React$useState2[1];
      var containerRef = reactExports.useRef();
      var uuid2 = useUUID(id2);
      var isRtl = direction === "rtl";
      var _useMergedState = useMergedState(defaultOpenKeys, {
        value: openKeys,
        postState: function postState(keys2) {
          return keys2 || EMPTY_LIST$3;
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedOpenKeys = _useMergedState2[0], setMergedOpenKeys = _useMergedState2[1];
      var triggerOpenKeys = function triggerOpenKeys2(keys2) {
        var forceFlush = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        function doUpdate() {
          setMergedOpenKeys(keys2);
          onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(keys2);
        }
        if (forceFlush) {
          reactDomExports.flushSync(doUpdate);
        } else {
          doUpdate();
        }
      };
      var _React$useState3 = reactExports.useState(mergedOpenKeys), _React$useState4 = _slicedToArray(_React$useState3, 2), inlineCacheOpenKeys = _React$useState4[0], setInlineCacheOpenKeys = _React$useState4[1];
      var mountRef = reactExports.useRef(false);
      var _React$useMemo = reactExports.useMemo(function() {
        if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
          return ["vertical", inlineCollapsed];
        }
        return [mode, false];
      }, [mode, inlineCollapsed]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), mergedMode = _React$useMemo2[0], mergedInlineCollapsed = _React$useMemo2[1];
      var isInlineMode = mergedMode === "inline";
      var _React$useState5 = reactExports.useState(mergedMode), _React$useState6 = _slicedToArray(_React$useState5, 2), internalMode = _React$useState6[0], setInternalMode = _React$useState6[1];
      var _React$useState7 = reactExports.useState(mergedInlineCollapsed), _React$useState8 = _slicedToArray(_React$useState7, 2), internalInlineCollapsed = _React$useState8[0], setInternalInlineCollapsed = _React$useState8[1];
      reactExports.useEffect(function() {
        setInternalMode(mergedMode);
        setInternalInlineCollapsed(mergedInlineCollapsed);
        if (!mountRef.current) {
          return;
        }
        if (isInlineMode) {
          setMergedOpenKeys(inlineCacheOpenKeys);
        } else {
          triggerOpenKeys(EMPTY_LIST$3);
        }
      }, [mergedMode, mergedInlineCollapsed]);
      var _React$useState9 = reactExports.useState(0), _React$useState10 = _slicedToArray(_React$useState9, 2), lastVisibleIndex = _React$useState10[0], setLastVisibleIndex = _React$useState10[1];
      var allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
      reactExports.useEffect(function() {
        if (isInlineMode) {
          setInlineCacheOpenKeys(mergedOpenKeys);
        }
      }, [mergedOpenKeys]);
      reactExports.useEffect(function() {
        mountRef.current = true;
        return function() {
          mountRef.current = false;
        };
      }, []);
      var _useKeyRecords = useKeyRecords(), registerPath = _useKeyRecords.registerPath, unregisterPath = _useKeyRecords.unregisterPath, refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys, isSubPathKey = _useKeyRecords.isSubPathKey, getKeyPath = _useKeyRecords.getKeyPath, getKeys = _useKeyRecords.getKeys, getSubPathKeys = _useKeyRecords.getSubPathKeys;
      var registerPathContext = reactExports.useMemo(function() {
        return {
          registerPath,
          unregisterPath
        };
      }, [registerPath, unregisterPath]);
      var pathUserContext = reactExports.useMemo(function() {
        return {
          isSubPathKey
        };
      }, [isSubPathKey]);
      reactExports.useEffect(function() {
        refreshOverflowKeys(allVisible ? EMPTY_LIST$3 : childList.slice(lastVisibleIndex + 1).map(function(child) {
          return child.key;
        }));
      }, [lastVisibleIndex, allVisible]);
      var _useMergedState3 = useMergedState(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
        value: activeKey
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedActiveKey = _useMergedState4[0], setMergedActiveKey = _useMergedState4[1];
      var onActive = useMemoCallback(function(key) {
        setMergedActiveKey(key);
      });
      var onInactive = useMemoCallback(function() {
        setMergedActiveKey(void 0);
      });
      reactExports.useImperativeHandle(ref, function() {
        return {
          list: containerRef.current,
          focus: function focus(options) {
            var _childList$find;
            var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : (_childList$find = childList.find(function(node2) {
              return !node2.props.disabled;
            })) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
            if (shouldFocusKey) {
              var _containerRef$current, _containerRef$current2, _containerRef$current3;
              (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.querySelector("li[data-menu-id='".concat(getMenuId(uuid2, shouldFocusKey), "']"))) === null || _containerRef$current2 === void 0 ? void 0 : (_containerRef$current3 = _containerRef$current2.focus) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.call(_containerRef$current2, options);
            }
          }
        };
      });
      var _useMergedState5 = useMergedState(defaultSelectedKeys || [], {
        value: selectedKeys,
        // Legacy convert key to array
        postState: function postState(keys2) {
          if (Array.isArray(keys2)) {
            return keys2;
          }
          if (keys2 === null || keys2 === void 0) {
            return EMPTY_LIST$3;
          }
          return [keys2];
        }
      }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedSelectKeys = _useMergedState6[0], setMergedSelectKeys = _useMergedState6[1];
      var triggerSelection = function triggerSelection2(info2) {
        if (selectable) {
          var targetKey = info2.key;
          var exist = mergedSelectKeys.includes(targetKey);
          var newSelectKeys;
          if (multiple) {
            if (exist) {
              newSelectKeys = mergedSelectKeys.filter(function(key) {
                return key !== targetKey;
              });
            } else {
              newSelectKeys = [].concat(_toConsumableArray(mergedSelectKeys), [targetKey]);
            }
          } else {
            newSelectKeys = [targetKey];
          }
          setMergedSelectKeys(newSelectKeys);
          var selectInfo = _objectSpread2$3(_objectSpread2$3({}, info2), {}, {
            selectedKeys: newSelectKeys
          });
          if (exist) {
            onDeselect === null || onDeselect === void 0 ? void 0 : onDeselect(selectInfo);
          } else {
            onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectInfo);
          }
        }
        if (!multiple && mergedOpenKeys.length && internalMode !== "inline") {
          triggerOpenKeys(EMPTY_LIST$3);
        }
      };
      var onInternalClick = useMemoCallback(function(info2) {
        onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info2));
        triggerSelection(info2);
      });
      var onInternalOpenChange = useMemoCallback(function(key, open2) {
        var newOpenKeys = mergedOpenKeys.filter(function(k2) {
          return k2 !== key;
        });
        if (open2) {
          newOpenKeys.push(key);
        } else if (internalMode !== "inline") {
          var subPathKeys = getSubPathKeys(key);
          newOpenKeys = newOpenKeys.filter(function(k2) {
            return !subPathKeys.has(k2);
          });
        }
        if (!isEqual$1(mergedOpenKeys, newOpenKeys, true)) {
          triggerOpenKeys(newOpenKeys, true);
        }
      });
      var getInternalPopupContainer = useMemoCallback(getPopupContainer);
      var triggerAccessibilityOpen = function triggerAccessibilityOpen2(key, open2) {
        var nextOpen = open2 !== null && open2 !== void 0 ? open2 : !mergedOpenKeys.includes(key);
        onInternalOpenChange(key, nextOpen);
      };
      var onInternalKeyDown = useAccessibility(internalMode, mergedActiveKey, isRtl, uuid2, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown2);
      reactExports.useEffect(function() {
        setMounted(true);
      }, []);
      var privateContext = reactExports.useMemo(function() {
        return {
          _internalRenderMenuItem,
          _internalRenderSubMenuItem
        };
      }, [_internalRenderMenuItem, _internalRenderSubMenuItem]);
      var wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : (
        // Need wrap for overflow dropdown that do not response for open
        childList.map(function(child, index2) {
          return (
            // Always wrap provider to avoid sub node re-mount
            /* @__PURE__ */ reactExports.createElement(InheritableContextProvider, {
              key: child.key,
              overflowDisabled: index2 > lastVisibleIndex
            }, child)
          );
        })
      );
      var container2 = /* @__PURE__ */ reactExports.createElement(ForwardOverflow, _extends$2({
        id: id2,
        ref: containerRef,
        prefixCls: "".concat(prefixCls, "-overflow"),
        component: "ul",
        itemComponent: MenuItem$1,
        className: classNames(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(internalMode), className, (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-inline-collapsed"), internalInlineCollapsed), _defineProperty$7(_classNames, "".concat(prefixCls, "-rtl"), isRtl), _classNames), rootClassName),
        dir: direction,
        style: style2,
        role: "menu",
        tabIndex,
        data: wrappedChildList,
        renderRawItem: function renderRawItem(node2) {
          return node2;
        },
        renderRawRest: function renderRawRest(omitItems) {
          var len = omitItems.length;
          var originOmitItems = len ? childList.slice(-len) : null;
          return /* @__PURE__ */ reactExports.createElement(SubMenu$3, {
            eventKey: OVERFLOW_KEY,
            title: overflowedIndicator,
            disabled: allVisible,
            internalPopupClose: len === 0,
            popupClassName: overflowedIndicatorPopupClassName
          }, originOmitItems);
        },
        maxCount: internalMode !== "horizontal" || disabledOverflow ? ForwardOverflow.INVALIDATE : ForwardOverflow.RESPONSIVE,
        ssr: "full",
        "data-menu-list": true,
        onVisibleChange: function onVisibleChange(newLastIndex) {
          setLastVisibleIndex(newLastIndex);
        },
        onKeyDown: onInternalKeyDown
      }, restProps));
      return /* @__PURE__ */ reactExports.createElement(PrivateContext.Provider, {
        value: privateContext
      }, /* @__PURE__ */ reactExports.createElement(IdContext.Provider, {
        value: uuid2
      }, /* @__PURE__ */ reactExports.createElement(InheritableContextProvider, {
        prefixCls,
        rootClassName,
        mode: internalMode,
        openKeys: mergedOpenKeys,
        rtl: isRtl,
        disabled,
        motion: mounted ? motion2 : null,
        defaultMotions: mounted ? defaultMotions : null,
        activeKey: mergedActiveKey,
        onActive,
        onInactive,
        selectedKeys: mergedSelectKeys,
        inlineIndent,
        subMenuOpenDelay,
        subMenuCloseDelay,
        forceSubMenuRender,
        builtinPlacements,
        triggerSubMenuAction,
        getPopupContainer: getInternalPopupContainer,
        itemIcon,
        expandIcon,
        onItemClick: onInternalClick,
        onOpenChange: onInternalOpenChange
      }, /* @__PURE__ */ reactExports.createElement(PathUserContext.Provider, {
        value: pathUserContext
      }, container2), /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          display: "none"
        },
        "aria-hidden": true
      }, /* @__PURE__ */ reactExports.createElement(PathRegisterContext.Provider, {
        value: registerPathContext
      }, childList)))));
    });
    var _excluded$n = ["className", "title", "eventKey", "children"], _excluded2$2 = ["children"];
    var InternalMenuItemGroup = function InternalMenuItemGroup2(_ref) {
      var className = _ref.className, title = _ref.title;
      _ref.eventKey;
      var children = _ref.children, restProps = _objectWithoutProperties$1(_ref, _excluded$n);
      var _React$useContext = reactExports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls;
      var groupPrefixCls = "".concat(prefixCls, "-item-group");
      return /* @__PURE__ */ reactExports.createElement("li", _extends$2({
        role: "presentation"
      }, restProps, {
        onClick: function onClick(e2) {
          return e2.stopPropagation();
        },
        className: classNames(groupPrefixCls, className)
      }), /* @__PURE__ */ reactExports.createElement("div", {
        role: "presentation",
        className: "".concat(groupPrefixCls, "-title"),
        title: typeof title === "string" ? title : void 0
      }, title), /* @__PURE__ */ reactExports.createElement("ul", {
        role: "group",
        className: "".concat(groupPrefixCls, "-list")
      }, children));
    };
    function MenuItemGroup(_ref2) {
      var children = _ref2.children, props = _objectWithoutProperties$1(_ref2, _excluded2$2);
      var connectedKeyPath = useFullPath(props.eventKey);
      var childList = parseChildren(children, connectedKeyPath);
      var measure = useMeasure();
      if (measure) {
        return childList;
      }
      return /* @__PURE__ */ reactExports.createElement(InternalMenuItemGroup, omit(props, ["warnKey"]), childList);
    }
    function Divider$2(_ref) {
      var className = _ref.className, style2 = _ref.style;
      var _React$useContext = reactExports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls;
      var measure = useMeasure();
      if (measure) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("li", {
        className: classNames("".concat(prefixCls, "-item-divider"), className),
        style: style2
      });
    }
    var ExportMenu = Menu$2;
    ExportMenu.Item = MenuItem$1;
    ExportMenu.SubMenu = SubMenu$3;
    ExportMenu.ItemGroup = MenuItemGroup;
    ExportMenu.Divider = Divider$2;
    var EllipsisOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
    const EllipsisOutlinedSvg = EllipsisOutlined$2;
    var EllipsisOutlined = function EllipsisOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: EllipsisOutlinedSvg
      }));
    };
    EllipsisOutlined.displayName = "EllipsisOutlined";
    const EllipsisOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(EllipsisOutlined);
    const getHorizontalStyle = (token2) => {
      const {
        componentCls,
        motionDurationSlow,
        menuHorizontalHeight,
        colorSplit,
        lineWidth,
        lineType,
        menuItemPaddingInline
      } = token2;
      return {
        [`${componentCls}-horizontal`]: {
          lineHeight: `${menuHorizontalHeight}px`,
          border: 0,
          borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
          boxShadow: "none",
          "&::after": {
            display: "block",
            clear: "both",
            height: 0,
            content: '"\\20"'
          },
          // ======================= Item =======================
          [`${componentCls}-item, ${componentCls}-submenu`]: {
            position: "relative",
            display: "inline-block",
            verticalAlign: "bottom",
            paddingInline: menuItemPaddingInline
          },
          [`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: {
            backgroundColor: "transparent"
          },
          [`${componentCls}-item, ${componentCls}-submenu-title`]: {
            transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(",")
          },
          // ===================== Sub Menu =====================
          [`${componentCls}-submenu-arrow`]: {
            display: "none"
          }
        }
      };
    };
    const getHorizontalStyle$1 = getHorizontalStyle;
    const getRTLStyle = (_ref) => {
      let {
        componentCls,
        menuArrowOffset
      } = _ref;
      return {
        [`${componentCls}-rtl`]: {
          direction: "rtl"
        },
        [`${componentCls}-submenu-rtl`]: {
          transformOrigin: "100% 0"
        },
        // Vertical Arrow
        [`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: {
          [`${componentCls}-submenu-arrow`]: {
            "&::before": {
              transform: `rotate(-45deg) translateY(-${menuArrowOffset})`
            },
            "&::after": {
              transform: `rotate(45deg) translateY(${menuArrowOffset})`
            }
          }
        }
      };
    };
    const getRTLStyle$1 = getRTLStyle;
    const accessibilityFocus = (token2) => Object.assign({}, genFocusOutline(token2));
    const getThemeStyle = (token2, themeSuffix) => {
      const {
        componentCls,
        colorItemText,
        colorItemTextSelected,
        colorGroupTitle,
        colorItemBg,
        colorSubItemBg,
        colorItemBgSelected,
        colorActiveBarHeight,
        colorActiveBarWidth,
        colorActiveBarBorderSize,
        motionDurationSlow,
        motionEaseInOut,
        motionEaseOut,
        menuItemPaddingInline,
        motionDurationMid,
        colorItemTextHover,
        lineType,
        colorSplit,
        // Disabled
        colorItemTextDisabled,
        // Danger
        colorDangerItemText,
        colorDangerItemTextHover,
        colorDangerItemTextSelected,
        colorDangerItemBgActive,
        colorDangerItemBgSelected,
        colorItemBgHover,
        menuSubMenuBg,
        // Horizontal
        colorItemTextSelectedHorizontal,
        colorItemBgSelectedHorizontal
      } = token2;
      return {
        [`${componentCls}-${themeSuffix}`]: {
          color: colorItemText,
          background: colorItemBg,
          [`&${componentCls}-root:focus-visible`]: Object.assign({}, accessibilityFocus(token2)),
          // ======================== Item ========================
          [`${componentCls}-item-group-title`]: {
            color: colorGroupTitle
          },
          [`${componentCls}-submenu-selected`]: {
            [`> ${componentCls}-submenu-title`]: {
              color: colorItemTextSelected
            }
          },
          // Disabled
          [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
            color: `${colorItemTextDisabled} !important`
          },
          // Hover
          [`${componentCls}-item:hover, ${componentCls}-submenu-title:hover`]: {
            [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
              color: colorItemTextHover
            }
          },
          [`&:not(${componentCls}-horizontal)`]: {
            [`${componentCls}-item:not(${componentCls}-item-selected)`]: {
              "&:hover": {
                backgroundColor: colorItemBgHover
              },
              "&:active": {
                backgroundColor: colorItemBgSelected
              }
            },
            [`${componentCls}-submenu-title`]: {
              "&:hover": {
                backgroundColor: colorItemBgHover
              },
              "&:active": {
                backgroundColor: colorItemBgSelected
              }
            }
          },
          // Danger - only Item has
          [`${componentCls}-item-danger`]: {
            color: colorDangerItemText,
            [`&${componentCls}-item:hover`]: {
              [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
                color: colorDangerItemTextHover
              }
            },
            [`&${componentCls}-item:active`]: {
              background: colorDangerItemBgActive
            }
          },
          [`${componentCls}-item a`]: {
            "&, &:hover": {
              color: "inherit"
            }
          },
          [`${componentCls}-item-selected`]: {
            color: colorItemTextSelected,
            // Danger
            [`&${componentCls}-item-danger`]: {
              color: colorDangerItemTextSelected
            },
            [`a, a:hover`]: {
              color: "inherit"
            }
          },
          [`& ${componentCls}-item-selected`]: {
            backgroundColor: colorItemBgSelected,
            // Danger
            [`&${componentCls}-item-danger`]: {
              backgroundColor: colorDangerItemBgSelected
            }
          },
          [`${componentCls}-item, ${componentCls}-submenu-title`]: {
            [`&:not(${componentCls}-item-disabled):focus-visible`]: Object.assign({}, accessibilityFocus(token2))
          },
          [`&${componentCls}-submenu > ${componentCls}`]: {
            backgroundColor: menuSubMenuBg
          },
          [`&${componentCls}-popup > ${componentCls}`]: {
            backgroundColor: colorItemBg
          },
          // ====================== Horizontal ======================
          [`&${componentCls}-horizontal`]: Object.assign(Object.assign({}, themeSuffix === "dark" ? {
            borderBottom: 0
          } : {}), {
            [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
              top: colorActiveBarBorderSize,
              marginTop: -colorActiveBarBorderSize,
              marginBottom: 0,
              borderRadius: 0,
              "&::after": {
                position: "absolute",
                insetInline: menuItemPaddingInline,
                bottom: 0,
                borderBottom: `${colorActiveBarHeight}px solid transparent`,
                transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
                content: '""'
              },
              [`&:hover, &-active, &-open`]: {
                "&::after": {
                  borderBottomWidth: colorActiveBarHeight,
                  borderBottomColor: colorItemTextSelectedHorizontal
                }
              },
              [`&-selected`]: {
                color: colorItemTextSelectedHorizontal,
                backgroundColor: colorItemBgSelectedHorizontal,
                "&::after": {
                  borderBottomWidth: colorActiveBarHeight,
                  borderBottomColor: colorItemTextSelectedHorizontal
                }
              }
            }
          }),
          // ================== Inline & Vertical ===================
          //
          [`&${componentCls}-root`]: {
            [`&${componentCls}-inline, &${componentCls}-vertical`]: {
              borderInlineEnd: `${colorActiveBarBorderSize}px ${lineType} ${colorSplit}`
            }
          },
          // ======================== Inline ========================
          [`&${componentCls}-inline`]: {
            // Sub
            [`${componentCls}-sub${componentCls}-inline`]: {
              background: colorSubItemBg
            },
            // Item
            [`${componentCls}-item, ${componentCls}-submenu-title`]: colorActiveBarBorderSize && colorActiveBarWidth ? {
              width: `calc(100% + ${colorActiveBarBorderSize}px)`
            } : {},
            [`${componentCls}-item`]: {
              position: "relative",
              "&::after": {
                position: "absolute",
                insetBlock: 0,
                insetInlineEnd: 0,
                borderInlineEnd: `${colorActiveBarWidth}px solid ${colorItemTextSelected}`,
                transform: "scaleY(0.0001)",
                opacity: 0,
                transition: [`transform ${motionDurationMid} ${motionEaseOut}`, `opacity ${motionDurationMid} ${motionEaseOut}`].join(","),
                content: '""'
              },
              // Danger
              [`&${componentCls}-item-danger`]: {
                "&::after": {
                  borderInlineEndColor: colorDangerItemTextSelected
                }
              }
            },
            [`${componentCls}-selected, ${componentCls}-item-selected`]: {
              "&::after": {
                transform: "scaleY(1)",
                opacity: 1,
                transition: [`transform ${motionDurationMid} ${motionEaseInOut}`, `opacity ${motionDurationMid} ${motionEaseInOut}`].join(",")
              }
            }
          }
        }
      };
    };
    const getThemeStyle$1 = getThemeStyle;
    const getVerticalInlineStyle = (token2) => {
      const {
        componentCls,
        menuItemHeight,
        itemMarginInline,
        padding,
        menuArrowSize,
        marginXS,
        marginXXS
      } = token2;
      const paddingWithArrow = padding + menuArrowSize + marginXS;
      return {
        [`${componentCls}-item`]: {
          position: "relative"
        },
        [`${componentCls}-item, ${componentCls}-submenu-title`]: {
          height: menuItemHeight,
          lineHeight: `${menuItemHeight}px`,
          paddingInline: padding,
          overflow: "hidden",
          textOverflow: "ellipsis",
          marginInline: itemMarginInline,
          marginBlock: marginXXS,
          width: `calc(100% - ${itemMarginInline * 2}px)`
        },
        // disable margin collapsed
        [`${componentCls}-submenu`]: {
          paddingBottom: 0.02
        },
        [`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
          height: menuItemHeight,
          lineHeight: `${menuItemHeight}px`
        },
        [`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: {
          paddingInlineEnd: paddingWithArrow
        }
      };
    };
    const getVerticalStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        menuItemHeight,
        colorTextLightSolid,
        dropdownWidth,
        controlHeightLG,
        motionDurationMid,
        motionEaseOut,
        paddingXL,
        fontSizeSM,
        fontSizeLG,
        motionDurationSlow,
        paddingXS,
        boxShadowSecondary
      } = token2;
      const inlineItemStyle = {
        height: menuItemHeight,
        lineHeight: `${menuItemHeight}px`,
        listStylePosition: "inside",
        listStyleType: "disc"
      };
      return [
        {
          [componentCls]: {
            [`&-inline, &-vertical`]: Object.assign({
              [`&${componentCls}-root`]: {
                boxShadow: "none"
              }
            }, getVerticalInlineStyle(token2))
          },
          [`${componentCls}-submenu-popup`]: {
            [`${componentCls}-vertical`]: Object.assign(Object.assign({}, getVerticalInlineStyle(token2)), {
              boxShadow: boxShadowSecondary
            })
          }
        },
        // Vertical only
        {
          [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
            minWidth: dropdownWidth,
            maxHeight: `calc(100vh - ${controlHeightLG * 2.5}px)`,
            padding: "0",
            overflow: "hidden",
            borderInlineEnd: 0,
            // https://github.com/ant-design/ant-design/issues/22244
            // https://github.com/ant-design/ant-design/issues/26812
            "&:not([class*='-active'])": {
              overflowX: "hidden",
              overflowY: "auto"
            }
          }
        },
        // Inline Only
        {
          [`${componentCls}-inline`]: {
            width: "100%",
            // Motion enhance for first level
            [`&${componentCls}-root`]: {
              [`${componentCls}-item, ${componentCls}-submenu-title`]: {
                display: "flex",
                alignItems: "center",
                transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationMid} ${motionEaseOut}`].join(","),
                [`> ${componentCls}-title-content`]: {
                  flex: "auto",
                  minWidth: 0,
                  overflow: "hidden",
                  textOverflow: "ellipsis"
                },
                "> *": {
                  flex: "none"
                }
              }
            },
            // >>>>> Sub
            [`${componentCls}-sub${componentCls}-inline`]: {
              padding: 0,
              border: 0,
              borderRadius: 0,
              boxShadow: "none",
              [`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
              [`& ${componentCls}-item-group-title`]: {
                paddingInlineStart: paddingXL
              }
            },
            // >>>>> Item
            [`${componentCls}-item`]: inlineItemStyle
          }
        },
        // Inline Collapse Only
        {
          [`${componentCls}-inline-collapsed`]: {
            width: menuItemHeight * 2,
            [`&${componentCls}-root`]: {
              [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: {
                [`> ${componentCls}-inline-collapsed-noicon`]: {
                  fontSize: fontSizeLG,
                  textAlign: "center"
                }
              }
            },
            [`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
              insetInlineStart: 0,
              paddingInline: `calc(50% - ${fontSizeSM}px)`,
              textOverflow: "clip",
              [`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: {
                opacity: 0
              },
              [`${componentCls}-item-icon, ${iconCls}`]: {
                margin: 0,
                fontSize: fontSizeLG,
                lineHeight: `${menuItemHeight}px`,
                "+ span": {
                  display: "inline-block",
                  opacity: 0
                }
              }
            },
            [`${componentCls}-item-icon, ${iconCls}`]: {
              display: "inline-block"
            },
            "&-tooltip": {
              pointerEvents: "none",
              [`${componentCls}-item-icon, ${iconCls}`]: {
                display: "none"
              },
              "a, a:hover": {
                color: colorTextLightSolid
              }
            },
            [`${componentCls}-item-group-title`]: Object.assign(Object.assign({}, textEllipsis), {
              paddingInline: paddingXS
            })
          }
        }
      ];
    };
    const getVerticalStyle$1 = getVerticalStyle;
    const genMenuItemStyle = (token2) => {
      const {
        componentCls,
        fontSize,
        motionDurationSlow,
        motionDurationMid,
        motionEaseInOut,
        motionEaseOut,
        iconCls,
        controlHeightSM
      } = token2;
      return {
        // >>>>> Item
        [`${componentCls}-item, ${componentCls}-submenu-title`]: {
          position: "relative",
          display: "block",
          margin: 0,
          whiteSpace: "nowrap",
          cursor: "pointer",
          transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(","),
          [`${componentCls}-item-icon, ${iconCls}`]: {
            minWidth: fontSize,
            fontSize,
            transition: [`font-size ${motionDurationMid} ${motionEaseOut}`, `margin ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow}`].join(","),
            "+ span": {
              marginInlineStart: controlHeightSM - fontSize,
              opacity: 1,
              transition: [`opacity ${motionDurationSlow} ${motionEaseInOut}`, `margin ${motionDurationSlow}`, `color ${motionDurationSlow}`].join(",")
            }
          },
          [`${componentCls}-item-icon`]: Object.assign({}, resetIcon()),
          [`&${componentCls}-item-only-child`]: {
            [`> ${iconCls}, > ${componentCls}-item-icon`]: {
              marginInlineEnd: 0
            }
          }
        },
        // Disabled state sets text to gray and nukes hover/tab effects
        [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
          background: "none !important",
          cursor: "not-allowed",
          "&::after": {
            borderColor: "transparent !important"
          },
          a: {
            color: "inherit !important"
          },
          [`> ${componentCls}-submenu-title`]: {
            color: "inherit !important",
            cursor: "not-allowed"
          }
        }
      };
    };
    const genSubMenuArrowStyle = (token2) => {
      const {
        componentCls,
        motionDurationSlow,
        motionEaseInOut,
        borderRadius,
        menuArrowSize,
        menuArrowOffset
      } = token2;
      return {
        [`${componentCls}-submenu`]: {
          [`&-expand-icon, &-arrow`]: {
            position: "absolute",
            top: "50%",
            insetInlineEnd: token2.margin,
            width: menuArrowSize,
            color: "currentcolor",
            transform: "translateY(-50%)",
            transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
          },
          "&-arrow": {
            // →
            "&::before, &::after": {
              position: "absolute",
              width: menuArrowSize * 0.6,
              height: menuArrowSize * 0.15,
              backgroundColor: "currentcolor",
              borderRadius,
              transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `transform ${motionDurationSlow} ${motionEaseInOut}`, `top ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow} ${motionEaseInOut}`].join(","),
              content: '""'
            },
            "&::before": {
              transform: `rotate(45deg) translateY(-${menuArrowOffset})`
            },
            "&::after": {
              transform: `rotate(-45deg) translateY(${menuArrowOffset})`
            }
          }
        }
      };
    };
    const getBaseStyle = (token2) => {
      const {
        antCls,
        componentCls,
        fontSize,
        motionDurationSlow,
        motionDurationMid,
        motionEaseInOut,
        lineHeight,
        paddingXS,
        padding,
        colorSplit,
        lineWidth,
        zIndexPopup,
        borderRadiusLG,
        radiusSubMenuItem,
        menuArrowSize,
        menuArrowOffset,
        lineType,
        menuPanelMaskInset
      } = token2;
      return [
        // Misc
        {
          "": {
            [`${componentCls}`]: Object.assign(Object.assign({}, clearFix()), {
              // Hidden
              [`&-hidden`]: {
                display: "none"
              }
            })
          },
          [`${componentCls}-submenu-hidden`]: {
            display: "none"
          }
        },
        {
          [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), clearFix()), {
            marginBottom: 0,
            paddingInlineStart: 0,
            // Override default ul/ol
            fontSize,
            lineHeight: 0,
            listStyle: "none",
            outline: "none",
            transition: [
              `background ${motionDurationSlow}`,
              // Magic cubic here but smooth transition
              `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`
            ].join(","),
            [`ul, ol`]: {
              margin: 0,
              padding: 0,
              listStyle: "none"
            },
            // Overflow ellipsis
            [`&-overflow`]: {
              display: "flex",
              [`${componentCls}-item`]: {
                flex: "none"
              }
            },
            [`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: {
              borderRadius: token2.radiusItem
            },
            [`${componentCls}-item-group-title`]: {
              padding: `${paddingXS}px ${padding}px`,
              fontSize,
              lineHeight,
              transition: `all ${motionDurationSlow}`
            },
            [`&-horizontal ${componentCls}-submenu`]: {
              transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`].join(",")
            },
            [`${componentCls}-submenu, ${componentCls}-submenu-inline`]: {
              transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationMid} ${motionEaseInOut}`].join(",")
            },
            [`${componentCls}-submenu ${componentCls}-sub`]: {
              cursor: "initial",
              transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(",")
            },
            [`${componentCls}-title-content`]: {
              transition: `color ${motionDurationSlow}`
            },
            [`${componentCls}-item a`]: {
              "&::before": {
                position: "absolute",
                inset: 0,
                backgroundColor: "transparent",
                content: '""'
              }
            },
            // Removed a Badge related style seems it's safe
            // https://github.com/ant-design/ant-design/issues/19809
            // >>>>> Divider
            [`${componentCls}-item-divider`]: {
              overflow: "hidden",
              lineHeight: 0,
              borderColor: colorSplit,
              borderStyle: lineType,
              borderWidth: 0,
              borderTopWidth: lineWidth,
              marginBlock: lineWidth,
              padding: 0,
              "&-dashed": {
                borderStyle: "dashed"
              }
            }
          }), genMenuItemStyle(token2)), {
            [`${componentCls}-item-group`]: {
              [`${componentCls}-item-group-list`]: {
                margin: 0,
                padding: 0,
                [`${componentCls}-item, ${componentCls}-submenu-title`]: {
                  paddingInline: `${fontSize * 2}px ${padding}px`
                }
              }
            },
            // ======================= Sub Menu =======================
            "&-submenu": {
              "&-popup": {
                position: "absolute",
                zIndex: zIndexPopup,
                background: "transparent",
                borderRadius: borderRadiusLG,
                boxShadow: "none",
                transformOrigin: "0 0",
                // https://github.com/ant-design/ant-design/issues/13955
                "&::before": {
                  position: "absolute",
                  inset: `${menuPanelMaskInset}px 0 0`,
                  zIndex: -1,
                  width: "100%",
                  height: "100%",
                  opacity: 0,
                  content: '""'
                }
              },
              // https://github.com/ant-design/ant-design/issues/13955
              "&-placement-rightTop::before": {
                top: 0,
                insetInlineStart: menuPanelMaskInset
              },
              [`> ${componentCls}`]: Object.assign(Object.assign(Object.assign({
                borderRadius: borderRadiusLG
              }, genMenuItemStyle(token2)), genSubMenuArrowStyle(token2)), {
                [`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
                  borderRadius: radiusSubMenuItem
                },
                [`${componentCls}-submenu-title::after`]: {
                  transition: `transform ${motionDurationSlow} ${motionEaseInOut}`
                }
              })
            }
          }), genSubMenuArrowStyle(token2)), {
            [`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
              // ↓
              "&::before": {
                transform: `rotate(-45deg) translateX(${menuArrowOffset})`
              },
              "&::after": {
                transform: `rotate(45deg) translateX(-${menuArrowOffset})`
              }
            },
            [`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
              // ↑
              transform: `translateY(-${menuArrowSize * 0.2}px)`,
              "&::after": {
                transform: `rotate(-45deg) translateX(-${menuArrowOffset})`
              },
              "&::before": {
                transform: `rotate(45deg) translateX(${menuArrowOffset})`
              }
            }
          })
        },
        // Integration with header element so menu items have the same height
        {
          [`${antCls}-layout-header`]: {
            [componentCls]: {
              lineHeight: "inherit"
            }
          }
        }
      ];
    };
    const useStyle$q = (prefixCls, injectStyle) => {
      const useOriginHook = genComponentStyleHook("Menu", (token2, _ref) => {
        let {
          overrideComponentToken
        } = _ref;
        if (injectStyle === false) {
          return [];
        }
        const {
          colorBgElevated,
          colorPrimary,
          colorError,
          colorErrorHover,
          colorTextLightSolid
        } = token2;
        const {
          controlHeightLG,
          fontSize
        } = token2;
        const menuArrowSize = fontSize / 7 * 5;
        const menuToken = merge$4(token2, {
          menuItemHeight: controlHeightLG,
          menuItemPaddingInline: token2.margin,
          menuArrowSize,
          menuHorizontalHeight: controlHeightLG * 1.15,
          menuArrowOffset: `${menuArrowSize * 0.25}px`,
          menuPanelMaskInset: -7,
          menuSubMenuBg: colorBgElevated
        });
        const colorTextDark = new TinyColor(colorTextLightSolid).setAlpha(0.65).toRgbString();
        const menuDarkToken = merge$4(menuToken, {
          colorItemText: colorTextDark,
          colorItemTextHover: colorTextLightSolid,
          colorGroupTitle: colorTextDark,
          colorItemTextSelected: colorTextLightSolid,
          colorItemBg: "#001529",
          colorSubItemBg: "#000c17",
          colorItemBgActive: "transparent",
          colorItemBgSelected: colorPrimary,
          colorActiveBarWidth: 0,
          colorActiveBarHeight: 0,
          colorActiveBarBorderSize: 0,
          // Disabled
          colorItemTextDisabled: new TinyColor(colorTextLightSolid).setAlpha(0.25).toRgbString(),
          // Danger
          colorDangerItemText: colorError,
          colorDangerItemTextHover: colorErrorHover,
          colorDangerItemTextSelected: colorTextLightSolid,
          colorDangerItemBgActive: colorError,
          colorDangerItemBgSelected: colorError,
          menuSubMenuBg: "#001529",
          // Horizontal
          colorItemTextSelectedHorizontal: colorTextLightSolid,
          colorItemBgSelectedHorizontal: colorPrimary
        }, Object.assign({}, overrideComponentToken));
        return [
          // Basic
          getBaseStyle(menuToken),
          // Horizontal
          getHorizontalStyle$1(menuToken),
          // Vertical
          getVerticalStyle$1(menuToken),
          // Theme
          getThemeStyle$1(menuToken, "light"),
          getThemeStyle$1(menuDarkToken, "dark"),
          // RTL
          getRTLStyle$1(menuToken),
          // Motion
          genCollapseMotion$1(menuToken),
          initSlideMotion(menuToken, "slide-up"),
          initSlideMotion(menuToken, "slide-down"),
          initZoomMotion(menuToken, "zoom-big")
        ];
      }, (token2) => {
        const {
          colorPrimary,
          colorError,
          colorTextDisabled,
          colorErrorBg,
          colorText,
          colorTextDescription,
          colorBgContainer,
          colorFillAlter,
          colorFillContent,
          lineWidth,
          lineWidthBold,
          controlItemBgActive,
          colorBgTextHover
        } = token2;
        return {
          dropdownWidth: 160,
          zIndexPopup: token2.zIndexPopupBase + 50,
          radiusItem: token2.borderRadiusLG,
          radiusSubMenuItem: token2.borderRadiusSM,
          colorItemText: colorText,
          colorItemTextHover: colorText,
          colorItemTextHoverHorizontal: colorPrimary,
          colorGroupTitle: colorTextDescription,
          colorItemTextSelected: colorPrimary,
          colorItemTextSelectedHorizontal: colorPrimary,
          colorItemBg: colorBgContainer,
          colorItemBgHover: colorBgTextHover,
          colorItemBgActive: colorFillContent,
          colorSubItemBg: colorFillAlter,
          colorItemBgSelected: controlItemBgActive,
          colorItemBgSelectedHorizontal: "transparent",
          colorActiveBarWidth: 0,
          colorActiveBarHeight: lineWidthBold,
          colorActiveBarBorderSize: lineWidth,
          // Disabled
          colorItemTextDisabled: colorTextDisabled,
          // Danger
          colorDangerItemText: colorError,
          colorDangerItemTextHover: colorError,
          colorDangerItemTextSelected: colorError,
          colorDangerItemBgActive: colorErrorBg,
          colorDangerItemBgSelected: colorErrorBg,
          itemMarginInline: token2.marginXXS
        };
      });
      return useOriginHook(prefixCls);
    };
    var __rest$R = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const OverrideContext = /* @__PURE__ */ reactExports.createContext(null);
    const OverrideProvider = (props) => {
      const {
        children
      } = props, restProps = __rest$R(props, ["children"]);
      const override = reactExports.useContext(OverrideContext);
      const context = reactExports.useMemo(() => Object.assign(Object.assign({}, override), restProps), [
        override,
        restProps.prefixCls,
        // restProps.expandIcon, Not mark as deps since this is a ReactNode
        restProps.mode,
        restProps.selectable
        // restProps.validator, Not mark as deps since this is a function
      ]);
      return /* @__PURE__ */ reactExports.createElement(OverrideContext.Provider, {
        value: context
      }, children);
    };
    const OverrideContext$1 = OverrideContext;
    var __rest$Q = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const MenuDivider = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        dashed
      } = props, restProps = __rest$Q(props, ["prefixCls", "className", "dashed"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("menu", customizePrefixCls);
      const classString = classNames({
        [`${prefixCls}-item-divider-dashed`]: !!dashed
      }, className);
      return /* @__PURE__ */ reactExports.createElement(Divider$2, Object.assign({
        className: classString
      }, restProps));
    };
    const MenuDivider$1 = MenuDivider;
    var BarsOutlined$3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "bars", "theme": "outlined" };
    const BarsOutlinedSvg = BarsOutlined$3;
    var BarsOutlined$1 = function BarsOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: BarsOutlinedSvg
      }));
    };
    BarsOutlined$1.displayName = "BarsOutlined";
    const BarsOutlined$2 = /* @__PURE__ */ reactExports.forwardRef(BarsOutlined$1);
    var LeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
    const LeftOutlinedSvg = LeftOutlined$2;
    var LeftOutlined = function LeftOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: LeftOutlinedSvg
      }));
    };
    LeftOutlined.displayName = "LeftOutlined";
    const LeftOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(LeftOutlined);
    const isNumeric = (value) => !isNaN(parseFloat(value)) && isFinite(value);
    const isNumeric$1 = isNumeric;
    const genLayoutLightStyle = (token2) => {
      const {
        componentCls,
        colorBgContainer,
        colorBgBody,
        colorText
      } = token2;
      return {
        [`${componentCls}-sider-light`]: {
          background: colorBgContainer,
          [`${componentCls}-sider-trigger`]: {
            color: colorText,
            background: colorBgContainer
          },
          [`${componentCls}-sider-zero-width-trigger`]: {
            color: colorText,
            background: colorBgContainer,
            border: `1px solid ${colorBgBody}`,
            borderInlineStart: 0
          }
        }
      };
    };
    const genLayoutLightStyle$1 = genLayoutLightStyle;
    const genLayoutStyle = (token2) => {
      const {
        antCls,
        // .ant
        componentCls,
        // .ant-layout
        colorText,
        colorTextLightSolid,
        colorBgHeader,
        colorBgBody,
        colorBgTrigger,
        layoutHeaderHeight,
        layoutHeaderPaddingInline,
        layoutHeaderColor,
        layoutFooterPadding,
        layoutTriggerHeight,
        layoutZeroTriggerSize,
        motionDurationMid,
        motionDurationSlow,
        fontSize,
        borderRadius
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign({
          display: "flex",
          flex: "auto",
          flexDirection: "column",
          /* fix firefox can't set height smaller than content on flex item */
          minHeight: 0,
          background: colorBgBody,
          "&, *": {
            boxSizing: "border-box"
          },
          [`&${componentCls}-has-sider`]: {
            flexDirection: "row",
            [`> ${componentCls}, > ${componentCls}-content`]: {
              // https://segmentfault.com/a/1190000019498300
              width: 0
            }
          },
          [`${componentCls}-header, &${componentCls}-footer`]: {
            flex: "0 0 auto"
          },
          [`${componentCls}-sider`]: {
            position: "relative",
            // fix firefox can't set width smaller than content on flex item
            minWidth: 0,
            background: colorBgHeader,
            transition: `all ${motionDurationMid}`,
            "&-children": {
              height: "100%",
              // Hack for fixing margin collapse bug
              // https://github.com/ant-design/ant-design/issues/7967
              // solution from https://stackoverflow.com/a/33132624/3040605
              marginTop: -0.1,
              paddingTop: 0.1,
              [`${antCls}-menu${antCls}-menu-inline-collapsed`]: {
                width: "auto"
              }
            },
            "&-has-trigger": {
              paddingBottom: layoutTriggerHeight
            },
            "&-right": {
              order: 1
            },
            "&-trigger": {
              position: "fixed",
              bottom: 0,
              zIndex: 1,
              height: layoutTriggerHeight,
              color: colorTextLightSolid,
              lineHeight: `${layoutTriggerHeight}px`,
              textAlign: "center",
              background: colorBgTrigger,
              cursor: "pointer",
              transition: `all ${motionDurationMid}`
            },
            "&-zero-width": {
              "> *": {
                overflow: "hidden"
              },
              "&-trigger": {
                position: "absolute",
                top: layoutHeaderHeight,
                insetInlineEnd: -layoutZeroTriggerSize,
                zIndex: 1,
                width: layoutZeroTriggerSize,
                height: layoutZeroTriggerSize,
                color: colorTextLightSolid,
                fontSize: token2.fontSizeXL,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                background: colorBgHeader,
                borderStartStartRadius: 0,
                borderStartEndRadius: borderRadius,
                borderEndEndRadius: borderRadius,
                borderEndStartRadius: 0,
                cursor: "pointer",
                transition: `background ${motionDurationSlow} ease`,
                "&::after": {
                  position: "absolute",
                  inset: 0,
                  background: "transparent",
                  transition: `all ${motionDurationSlow}`,
                  content: '""'
                },
                "&:hover::after": {
                  // FIXME: Hardcode, but seems no need to create a token for this
                  background: `rgba(255, 255, 255, 0.2)`
                },
                "&-right": {
                  insetInlineStart: -layoutZeroTriggerSize,
                  borderStartStartRadius: borderRadius,
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0,
                  borderEndStartRadius: borderRadius
                }
              }
            }
          }
        }, genLayoutLightStyle$1(token2)), {
          // RTL
          "&-rtl": {
            direction: "rtl"
          }
        }),
        // ==================== Header ====================
        [`${componentCls}-header`]: {
          height: layoutHeaderHeight,
          paddingInline: layoutHeaderPaddingInline,
          color: layoutHeaderColor,
          lineHeight: `${layoutHeaderHeight}px`,
          background: colorBgHeader,
          // Other components/menu/style/index.less line:686
          // Integration with header element so menu items have the same height
          [`${antCls}-menu`]: {
            lineHeight: "inherit"
          }
        },
        // ==================== Footer ====================
        [`${componentCls}-footer`]: {
          padding: layoutFooterPadding,
          color: colorText,
          fontSize,
          background: colorBgBody
        },
        // =================== Content ====================
        [`${componentCls}-content`]: {
          flex: "auto",
          // fix firefox can't set height smaller than content on flex item
          minHeight: 0
        }
      };
    };
    const useStyle$p = genComponentStyleHook("Layout", (token2) => {
      const {
        colorText,
        controlHeightSM,
        controlHeight,
        controlHeightLG,
        marginXXS
      } = token2;
      const layoutHeaderPaddingInline = controlHeightLG * 1.25;
      const layoutToken = merge$4(token2, {
        // Layout
        layoutHeaderHeight: controlHeight * 2,
        layoutHeaderPaddingInline,
        layoutHeaderColor: colorText,
        layoutFooterPadding: `${controlHeightSM}px ${layoutHeaderPaddingInline}px`,
        layoutTriggerHeight: controlHeightLG + marginXXS * 2,
        layoutZeroTriggerSize: controlHeightLG
      });
      return [genLayoutStyle(layoutToken)];
    }, (token2) => {
      const {
        colorBgLayout
      } = token2;
      return {
        colorBgHeader: "#001529",
        colorBgBody: colorBgLayout,
        colorBgTrigger: "#002140"
      };
    });
    var __rest$P = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const LayoutContext = /* @__PURE__ */ reactExports.createContext({
      siderHook: {
        addSider: () => null,
        removeSider: () => null
      }
    });
    function generator(_ref) {
      let {
        suffixCls,
        tagName,
        displayName
      } = _ref;
      return (BasicComponent) => {
        const Adapter = /* @__PURE__ */ reactExports.forwardRef((props, ref) => /* @__PURE__ */ reactExports.createElement(BasicComponent, Object.assign({
          ref,
          suffixCls,
          tagName
        }, props)));
        return Adapter;
      };
    }
    const Basic = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        suffixCls,
        className,
        tagName: TagName
      } = props, others = __rest$P(props, ["prefixCls", "suffixCls", "className", "tagName"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("layout", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$p(prefixCls);
      const prefixWithSuffixCls = suffixCls ? `${prefixCls}-${suffixCls}` : prefixCls;
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(TagName, Object.assign({
        className: classNames(customizePrefixCls || prefixWithSuffixCls, className, hashId),
        ref
      }, others)));
    });
    const BasicLayout = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        direction
      } = reactExports.useContext(ConfigContext);
      const [siders, setSiders] = reactExports.useState([]);
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        children,
        hasSider,
        tagName: Tag2
      } = props, others = __rest$P(props, ["prefixCls", "className", "rootClassName", "children", "hasSider", "tagName"]);
      const passedProps = omit(others, ["suffixCls"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("layout", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$p(prefixCls);
      const classString = classNames(prefixCls, {
        [`${prefixCls}-has-sider`]: typeof hasSider === "boolean" ? hasSider : siders.length > 0,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      const contextValue = reactExports.useMemo(() => ({
        siderHook: {
          addSider: (id2) => {
            setSiders((prev2) => [].concat(_toConsumableArray(prev2), [id2]));
          },
          removeSider: (id2) => {
            setSiders((prev2) => prev2.filter((currentId) => currentId !== id2));
          }
        }
      }), []);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(LayoutContext.Provider, {
        value: contextValue
      }, /* @__PURE__ */ reactExports.createElement(Tag2, Object.assign({
        ref,
        className: classString
      }, passedProps), children)));
    });
    const Layout$1 = generator({
      tagName: "section",
      displayName: "Layout"
    })(BasicLayout);
    const Header$4 = generator({
      suffixCls: "header",
      tagName: "header",
      displayName: "Header"
    })(Basic);
    const Footer$2 = generator({
      suffixCls: "footer",
      tagName: "footer",
      displayName: "Footer"
    })(Basic);
    const Content = generator({
      suffixCls: "content",
      tagName: "main",
      displayName: "Content"
    })(Basic);
    const InternalLayout = Layout$1;
    var __rest$O = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const dimensionMaxMap = {
      xs: "479.98px",
      sm: "575.98px",
      md: "767.98px",
      lg: "991.98px",
      xl: "1199.98px",
      xxl: "1599.98px"
    };
    const SiderContext = /* @__PURE__ */ reactExports.createContext({});
    const generateId = (() => {
      let i2 = 0;
      return function() {
        let prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        i2 += 1;
        return `${prefix}${i2}`;
      };
    })();
    const Sider = /* @__PURE__ */ reactExports.forwardRef((_a, ref) => {
      var {
        prefixCls: customizePrefixCls,
        className,
        trigger,
        children,
        defaultCollapsed = false,
        theme: theme2 = "dark",
        style: style2 = {},
        collapsible = false,
        reverseArrow = false,
        width = 200,
        collapsedWidth = 80,
        zeroWidthTriggerStyle,
        breakpoint,
        onCollapse,
        onBreakpoint
      } = _a, props = __rest$O(_a, ["prefixCls", "className", "trigger", "children", "defaultCollapsed", "theme", "style", "collapsible", "reverseArrow", "width", "collapsedWidth", "zeroWidthTriggerStyle", "breakpoint", "onCollapse", "onBreakpoint"]);
      const {
        siderHook
      } = reactExports.useContext(LayoutContext);
      const [collapsed, setCollapsed] = reactExports.useState("collapsed" in props ? props.collapsed : defaultCollapsed);
      const [below, setBelow] = reactExports.useState(false);
      reactExports.useEffect(() => {
        if ("collapsed" in props) {
          setCollapsed(props.collapsed);
        }
      }, [props.collapsed]);
      const handleSetCollapsed = (value, type2) => {
        if (!("collapsed" in props)) {
          setCollapsed(value);
        }
        onCollapse === null || onCollapse === void 0 ? void 0 : onCollapse(value, type2);
      };
      const responsiveHandlerRef = reactExports.useRef();
      responsiveHandlerRef.current = (mql) => {
        setBelow(mql.matches);
        onBreakpoint === null || onBreakpoint === void 0 ? void 0 : onBreakpoint(mql.matches);
        if (collapsed !== mql.matches) {
          handleSetCollapsed(mql.matches, "responsive");
        }
      };
      reactExports.useEffect(() => {
        function responsiveHandler(mql2) {
          return responsiveHandlerRef.current(mql2);
        }
        let mql;
        if (typeof window !== "undefined") {
          const {
            matchMedia
          } = window;
          if (matchMedia && breakpoint && breakpoint in dimensionMaxMap) {
            mql = matchMedia(`(max-width: ${dimensionMaxMap[breakpoint]})`);
            try {
              mql.addEventListener("change", responsiveHandler);
            } catch (error) {
              mql.addListener(responsiveHandler);
            }
            responsiveHandler(mql);
          }
        }
        return () => {
          try {
            mql === null || mql === void 0 ? void 0 : mql.removeEventListener("change", responsiveHandler);
          } catch (error) {
            mql === null || mql === void 0 ? void 0 : mql.removeListener(responsiveHandler);
          }
        };
      }, [breakpoint]);
      reactExports.useEffect(() => {
        const uniqueId = generateId("ant-sider-");
        siderHook.addSider(uniqueId);
        return () => siderHook.removeSider(uniqueId);
      }, []);
      const toggle = () => {
        handleSetCollapsed(!collapsed, "clickTrigger");
      };
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const renderSider = () => {
        const prefixCls = getPrefixCls("layout-sider", customizePrefixCls);
        const divProps = omit(props, ["collapsed"]);
        const rawWidth = collapsed ? collapsedWidth : width;
        const siderWidth = isNumeric$1(rawWidth) ? `${rawWidth}px` : String(rawWidth);
        const zeroWidthTrigger = parseFloat(String(collapsedWidth || 0)) === 0 ? /* @__PURE__ */ reactExports.createElement("span", {
          onClick: toggle,
          className: classNames(`${prefixCls}-zero-width-trigger`, `${prefixCls}-zero-width-trigger-${reverseArrow ? "right" : "left"}`),
          style: zeroWidthTriggerStyle
        }, trigger || /* @__PURE__ */ reactExports.createElement(BarsOutlined$2, null)) : null;
        const iconObj = {
          expanded: reverseArrow ? /* @__PURE__ */ reactExports.createElement(RightOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(LeftOutlined$1, null),
          collapsed: reverseArrow ? /* @__PURE__ */ reactExports.createElement(LeftOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(RightOutlined$1, null)
        };
        const status = collapsed ? "collapsed" : "expanded";
        const defaultTrigger = iconObj[status];
        const triggerDom = trigger !== null ? zeroWidthTrigger || /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-trigger`,
          onClick: toggle,
          style: {
            width: siderWidth
          }
        }, trigger || defaultTrigger) : null;
        const divStyle = Object.assign(Object.assign({}, style2), {
          flex: `0 0 ${siderWidth}`,
          maxWidth: siderWidth,
          minWidth: siderWidth,
          width: siderWidth
        });
        const siderCls = classNames(prefixCls, `${prefixCls}-${theme2}`, {
          [`${prefixCls}-collapsed`]: !!collapsed,
          [`${prefixCls}-has-trigger`]: collapsible && trigger !== null && !zeroWidthTrigger,
          [`${prefixCls}-below`]: !!below,
          [`${prefixCls}-zero-width`]: parseFloat(siderWidth) === 0
        }, className);
        return /* @__PURE__ */ reactExports.createElement("aside", Object.assign({
          className: siderCls
        }, divProps, {
          style: divStyle,
          ref
        }), /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-children`
        }, children), collapsible || below && zeroWidthTrigger ? triggerDom : null);
      };
      const contextValue = reactExports.useMemo(() => ({
        siderCollapsed: collapsed
      }), [collapsed]);
      return /* @__PURE__ */ reactExports.createElement(SiderContext.Provider, {
        value: contextValue
      }, renderSider());
    });
    const Sider$1 = Sider;
    const MenuContext = /* @__PURE__ */ reactExports.createContext({
      prefixCls: "",
      firstLevel: true,
      inlineCollapsed: false
    });
    const MenuContext$1 = MenuContext;
    const MenuItem = (props) => {
      var _a;
      const {
        className,
        children,
        icon,
        title,
        danger
      } = props;
      const {
        prefixCls,
        firstLevel,
        direction,
        disableMenuItemTitleTooltip,
        inlineCollapsed: isInlineCollapsed
      } = reactExports.useContext(MenuContext$1);
      const renderItemChildren = (inlineCollapsed) => {
        const wrapNode = /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-title-content`
        }, children);
        if (!icon || isValidElement(children) && children.type === "span") {
          if (children && inlineCollapsed && firstLevel && typeof children === "string") {
            return /* @__PURE__ */ reactExports.createElement("div", {
              className: `${prefixCls}-inline-collapsed-noicon`
            }, children.charAt(0));
          }
        }
        return wrapNode;
      };
      const {
        siderCollapsed
      } = reactExports.useContext(SiderContext);
      let tooltipTitle = title;
      if (typeof title === "undefined") {
        tooltipTitle = firstLevel ? children : "";
      } else if (title === false) {
        tooltipTitle = "";
      }
      const tooltipProps = {
        title: tooltipTitle
      };
      if (!siderCollapsed && !isInlineCollapsed) {
        tooltipProps.title = null;
        tooltipProps.open = false;
      }
      const childrenLength = toArray$8(children).length;
      let returnNode = /* @__PURE__ */ reactExports.createElement(MenuItem$1, Object.assign({}, omit(props, ["title", "icon", "danger"]), {
        className: classNames({
          [`${prefixCls}-item-danger`]: danger,
          [`${prefixCls}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
        }, className),
        title: typeof title === "string" ? title : void 0
      }), cloneElement(icon, {
        className: classNames(isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : "", `${prefixCls}-item-icon`)
      }), renderItemChildren(isInlineCollapsed));
      if (!disableMenuItemTitleTooltip) {
        returnNode = /* @__PURE__ */ reactExports.createElement(pn, Object.assign({}, tooltipProps, {
          placement: direction === "rtl" ? "left" : "right",
          overlayClassName: `${prefixCls}-inline-collapsed-tooltip`
        }), returnNode);
      }
      return returnNode;
    };
    const Item$2 = MenuItem;
    const SubMenu$1 = (props) => {
      var _a;
      const {
        popupClassName,
        icon,
        title,
        theme: customTheme
      } = props;
      const context = reactExports.useContext(MenuContext$1);
      const {
        prefixCls,
        inlineCollapsed,
        theme: contextTheme,
        mode
      } = context;
      const parentPath = useFullPath();
      let titleNode;
      if (!icon) {
        titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-inline-collapsed-noicon`
        }, title.charAt(0)) : /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-title-content`
        }, title);
      } else {
        const titleIsSpan = isValidElement(title) && title.type === "span";
        titleNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, cloneElement(icon, {
          className: classNames(isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : "", `${prefixCls}-item-icon`)
        }), titleIsSpan ? title : /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-title-content`
        }, title));
      }
      const contextValue = reactExports.useMemo(() => Object.assign(Object.assign({}, context), {
        firstLevel: false
      }), [context]);
      const popupOffset = mode === "horizontal" ? [0, 8] : [10, 0];
      return /* @__PURE__ */ reactExports.createElement(MenuContext$1.Provider, {
        value: contextValue
      }, /* @__PURE__ */ reactExports.createElement(SubMenu$3, Object.assign({
        popupOffset
      }, omit(props, ["icon"]), {
        title: titleNode,
        popupClassName: classNames(prefixCls, popupClassName, `${prefixCls}-${customTheme || contextTheme}`)
      })));
    };
    const SubMenu$2 = SubMenu$1;
    var __rest$N = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function convertItemsToNodes(list2) {
      return (list2 || []).map((opt, index2) => {
        if (opt && typeof opt === "object") {
          const _a = opt, {
            label,
            children,
            key,
            type: type2
          } = _a, restProps = __rest$N(_a, ["label", "children", "key", "type"]);
          const mergedKey = key !== null && key !== void 0 ? key : `tmp-${index2}`;
          if (children || type2 === "group") {
            if (type2 === "group") {
              return /* @__PURE__ */ reactExports.createElement(MenuItemGroup, Object.assign({
                key: mergedKey
              }, restProps, {
                title: label
              }), convertItemsToNodes(children));
            }
            return /* @__PURE__ */ reactExports.createElement(SubMenu$2, Object.assign({
              key: mergedKey
            }, restProps, {
              title: label
            }), convertItemsToNodes(children));
          }
          if (type2 === "divider") {
            return /* @__PURE__ */ reactExports.createElement(MenuDivider$1, Object.assign({
              key: mergedKey
            }, restProps));
          }
          return /* @__PURE__ */ reactExports.createElement(Item$2, Object.assign({
            key: mergedKey
          }, restProps), label);
        }
        return null;
      }).filter((opt) => opt);
    }
    function useItems$1(items) {
      return reactExports.useMemo(() => {
        if (!items) {
          return items;
        }
        return convertItemsToNodes(items);
      }, [items]);
    }
    var __rest$M = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const InternalMenu = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a, _b;
      const override = reactExports.useContext(OverrideContext$1);
      const overrideObj = override || {};
      const {
        getPrefixCls,
        getPopupContainer,
        direction
      } = reactExports.useContext(ConfigContext);
      const rootPrefixCls = getPrefixCls();
      const {
        prefixCls: customizePrefixCls,
        className,
        theme: theme2 = "light",
        expandIcon,
        _internalDisableMenuItemTitleTooltip,
        inlineCollapsed,
        siderCollapsed,
        items,
        children,
        rootClassName,
        mode,
        selectable,
        onClick
      } = props, restProps = __rest$M(props, ["prefixCls", "className", "theme", "expandIcon", "_internalDisableMenuItemTitleTooltip", "inlineCollapsed", "siderCollapsed", "items", "children", "rootClassName", "mode", "selectable", "onClick"]);
      const passedProps = omit(restProps, ["collapsedWidth"]);
      const mergedChildren = useItems$1(items) || children;
      (_a = overrideObj.validator) === null || _a === void 0 ? void 0 : _a.call(overrideObj, {
        mode
      });
      const onItemClick = useEvent(function() {
        var _a2;
        onClick === null || onClick === void 0 ? void 0 : onClick.apply(void 0, arguments);
        (_a2 = overrideObj.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(overrideObj);
      });
      const mergedMode = overrideObj.mode || mode;
      const mergedSelectable = selectable !== null && selectable !== void 0 ? selectable : overrideObj.selectable;
      const mergedInlineCollapsed = reactExports.useMemo(() => {
        if (siderCollapsed !== void 0) {
          return siderCollapsed;
        }
        return inlineCollapsed;
      }, [inlineCollapsed, siderCollapsed]);
      const defaultMotions = {
        horizontal: {
          motionName: `${rootPrefixCls}-slide-up`
        },
        inline: initCollapseMotion$1(rootPrefixCls),
        other: {
          motionName: `${rootPrefixCls}-zoom-big`
        }
      };
      const prefixCls = getPrefixCls("menu", customizePrefixCls || overrideObj.prefixCls);
      const [wrapSSR, hashId] = useStyle$q(prefixCls, !override);
      const menuClassName = classNames(`${prefixCls}-${theme2}`, className);
      let mergedExpandIcon;
      if (typeof expandIcon === "function") {
        mergedExpandIcon = expandIcon;
      } else {
        const beClone = expandIcon || overrideObj.expandIcon;
        mergedExpandIcon = cloneElement(beClone, {
          className: classNames(`${prefixCls}-submenu-expand-icon`, (_b = beClone === null || beClone === void 0 ? void 0 : beClone.props) === null || _b === void 0 ? void 0 : _b.className)
        });
      }
      const contextValue = reactExports.useMemo(() => ({
        prefixCls,
        inlineCollapsed: mergedInlineCollapsed || false,
        direction,
        firstLevel: true,
        theme: theme2,
        mode: mergedMode,
        disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip
      }), [prefixCls, mergedInlineCollapsed, direction, _internalDisableMenuItemTitleTooltip, theme2]);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(OverrideContext$1.Provider, {
        value: null
      }, /* @__PURE__ */ reactExports.createElement(MenuContext$1.Provider, {
        value: contextValue
      }, /* @__PURE__ */ reactExports.createElement(ExportMenu, Object.assign({
        getPopupContainer,
        overflowedIndicator: /* @__PURE__ */ reactExports.createElement(EllipsisOutlined$1, null),
        overflowedIndicatorPopupClassName: `${prefixCls}-${theme2}`,
        mode: mergedMode,
        selectable: mergedSelectable,
        onClick: onItemClick
      }, passedProps, {
        inlineCollapsed: mergedInlineCollapsed,
        className: menuClassName,
        prefixCls,
        direction,
        defaultMotions,
        expandIcon: mergedExpandIcon,
        ref,
        rootClassName: classNames(rootClassName, hashId)
      }), mergedChildren))));
    });
    const InternalMenu$1 = InternalMenu;
    const Menu = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const menuRef = reactExports.useRef(null);
      const context = reactExports.useContext(SiderContext);
      reactExports.useImperativeHandle(ref, () => ({
        menu: menuRef.current,
        focus: (options) => {
          var _a;
          (_a = menuRef.current) === null || _a === void 0 ? void 0 : _a.focus(options);
        }
      }));
      return /* @__PURE__ */ reactExports.createElement(InternalMenu$1, Object.assign({
        ref: menuRef
      }, props, context));
    });
    Menu.Item = Item$2;
    Menu.SubMenu = SubMenu$2;
    Menu.Divider = MenuDivider$1;
    Menu.ItemGroup = MenuItemGroup;
    const Menu$1 = Menu;
    const useFlexGapSupport = () => {
      const [flexible, setFlexible] = reactExports.useState(false);
      reactExports.useEffect(() => {
        setFlexible(detectFlexGapSupported());
      }, []);
      return flexible;
    };
    function Item$1(_ref) {
      let {
        className,
        direction,
        index: index2,
        marginDirection,
        children,
        split,
        wrap: wrap2
      } = _ref;
      const {
        horizontalSize,
        verticalSize,
        latestIndex,
        supportFlexGap
      } = reactExports.useContext(SpaceContext);
      let style2 = {};
      if (!supportFlexGap) {
        if (direction === "vertical") {
          if (index2 < latestIndex) {
            style2 = {
              marginBottom: horizontalSize / (split ? 2 : 1)
            };
          }
        } else {
          style2 = Object.assign(Object.assign({}, index2 < latestIndex && {
            [marginDirection]: horizontalSize / (split ? 2 : 1)
          }), wrap2 && {
            paddingBottom: verticalSize
          });
        }
      }
      if (children === null || children === void 0) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("div", {
        className,
        style: style2
      }, children), index2 < latestIndex && split && /* @__PURE__ */ reactExports.createElement("span", {
        className: `${className}-split`,
        style: style2
      }, split));
    }
    var __rest$L = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const SpaceContext = /* @__PURE__ */ reactExports.createContext({
      latestIndex: 0,
      horizontalSize: 0,
      verticalSize: 0,
      supportFlexGap: false
    });
    const spaceSize = {
      small: 8,
      middle: 16,
      large: 24
    };
    function getNumberSize(size) {
      return typeof size === "string" ? spaceSize[size] : size || 0;
    }
    const Space = (props) => {
      const {
        getPrefixCls,
        space,
        direction: directionConfig
      } = reactExports.useContext(ConfigContext);
      const {
        size = (space === null || space === void 0 ? void 0 : space.size) || "small",
        align,
        className,
        rootClassName,
        children,
        direction = "horizontal",
        prefixCls: customizePrefixCls,
        split,
        style: style2,
        wrap: wrap2 = false
      } = props, otherProps = __rest$L(props, ["size", "align", "className", "rootClassName", "children", "direction", "prefixCls", "split", "style", "wrap"]);
      const supportFlexGap = useFlexGapSupport();
      const [horizontalSize, verticalSize] = reactExports.useMemo(() => (Array.isArray(size) ? size : [size, size]).map((item) => getNumberSize(item)), [size]);
      const childNodes = toArray$8(children, {
        keepEmpty: true
      });
      const mergedAlign = align === void 0 && direction === "horizontal" ? "center" : align;
      const prefixCls = getPrefixCls("space", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$z(prefixCls);
      const cn = classNames(prefixCls, hashId, `${prefixCls}-${direction}`, {
        [`${prefixCls}-rtl`]: directionConfig === "rtl",
        [`${prefixCls}-align-${mergedAlign}`]: mergedAlign
      }, className, rootClassName);
      const itemClassName = `${prefixCls}-item`;
      const marginDirection = directionConfig === "rtl" ? "marginLeft" : "marginRight";
      let latestIndex = 0;
      const nodes = childNodes.map((child, i2) => {
        if (child !== null && child !== void 0) {
          latestIndex = i2;
        }
        const key = child && child.key || `${itemClassName}-${i2}`;
        return /* @__PURE__ */ reactExports.createElement(Item$1, {
          className: itemClassName,
          key,
          direction,
          index: i2,
          marginDirection,
          split,
          wrap: wrap2
        }, child);
      });
      const spaceContext = reactExports.useMemo(() => ({
        horizontalSize,
        verticalSize,
        latestIndex,
        supportFlexGap
      }), [horizontalSize, verticalSize, latestIndex, supportFlexGap]);
      if (childNodes.length === 0) {
        return null;
      }
      const gapStyle = {};
      if (wrap2) {
        gapStyle.flexWrap = "wrap";
        if (!supportFlexGap) {
          gapStyle.marginBottom = -verticalSize;
        }
      }
      if (supportFlexGap) {
        gapStyle.columnGap = horizontalSize;
        gapStyle.rowGap = verticalSize;
      }
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        className: cn,
        style: Object.assign(Object.assign({}, gapStyle), style2)
      }, otherProps), /* @__PURE__ */ reactExports.createElement(SpaceContext.Provider, {
        value: spaceContext
      }, nodes)));
    };
    const CompoundedSpace = Space;
    CompoundedSpace.Compact = Compact;
    const Space$1 = CompoundedSpace;
    const genButtonStyle = (token2) => {
      const {
        componentCls,
        antCls,
        paddingXS,
        opacityLoading
      } = token2;
      return {
        [`${componentCls}-button`]: {
          whiteSpace: "nowrap",
          [`&${antCls}-btn-group > ${antCls}-btn`]: {
            [`&-loading, &-loading + ${antCls}-btn`]: {
              cursor: "default",
              pointerEvents: "none",
              opacity: opacityLoading
            },
            [`&:last-child:not(:first-child):not(${antCls}-btn-icon-only)`]: {
              paddingInline: paddingXS
            }
          }
        }
      };
    };
    const genButtonStyle$1 = genButtonStyle;
    const genStatusStyle$1 = (token2) => {
      const {
        componentCls,
        menuCls,
        colorError,
        colorTextLightSolid
      } = token2;
      const itemCls = `${menuCls}-item`;
      return {
        [`${componentCls}, ${componentCls}-menu-submenu`]: {
          [`${menuCls} ${itemCls}`]: {
            [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
              color: colorError,
              "&:hover": {
                color: colorTextLightSolid,
                backgroundColor: colorError
              }
            }
          }
        }
      };
    };
    const genStatusStyle$2 = genStatusStyle$1;
    const genBaseStyle$7 = (token2) => {
      const {
        componentCls,
        menuCls,
        zIndexPopup,
        dropdownArrowDistance,
        sizePopupArrow,
        antCls,
        iconCls,
        motionDurationMid,
        dropdownPaddingVertical,
        fontSize,
        dropdownEdgeChildPadding,
        colorTextDisabled,
        fontSizeIcon,
        controlPaddingHorizontal,
        colorBgElevated
      } = token2;
      return [
        {
          [componentCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
            position: "absolute",
            top: -9999,
            left: {
              _skip_check_: true,
              value: -9999
            },
            zIndex: zIndexPopup,
            display: "block",
            // A placeholder out of dropdown visible range to avoid close when user moving
            "&::before": {
              position: "absolute",
              insetBlock: -dropdownArrowDistance + sizePopupArrow / 2,
              // insetInlineStart: -7, // FIXME: Seems not work for hidden element
              zIndex: -9999,
              opacity: 1e-4,
              content: '""'
            },
            [`${componentCls}-wrap`]: {
              position: "relative",
              [`${antCls}-btn > ${iconCls}-down`]: {
                fontSize: fontSizeIcon
              },
              [`${iconCls}-down::before`]: {
                transition: `transform ${motionDurationMid}`
              }
            },
            [`${componentCls}-wrap-open`]: {
              [`${iconCls}-down::before`]: {
                transform: `rotate(180deg)`
              }
            },
            [`
        &-hidden,
        &-menu-hidden,
        &-menu-submenu-hidden
      `]: {
              display: "none"
            },
            // =============================================================
            // ==                         Motion                          ==
            // =============================================================
            // When position is not enough for dropdown, the placement will revert.
            // We will handle this with revert motion name.
            [`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: {
              animationName: slideUpIn
            },
            [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: {
              animationName: slideDownIn
            },
            [`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: {
              animationName: slideUpOut
            },
            [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: {
              animationName: slideDownOut
            }
          })
        },
        // =============================================================
        // ==                        Arrow style                      ==
        // =============================================================
        getArrowStyle(token2, {
          colorBg: colorBgElevated,
          limitVerticalRadius: true,
          arrowPlacement: {
            top: true,
            bottom: true
          }
        }),
        {
          // =============================================================
          // ==                          Menu                           ==
          // =============================================================
          [`${componentCls} ${menuCls}`]: {
            position: "relative",
            margin: 0
          },
          [`${menuCls}-submenu-popup`]: {
            position: "absolute",
            zIndex: zIndexPopup,
            background: "transparent",
            boxShadow: "none",
            transformOrigin: "0 0",
            "ul, li": {
              listStyle: "none",
              margin: 0
            }
          },
          [`${componentCls}, ${componentCls}-menu-submenu`]: {
            [menuCls]: Object.assign(Object.assign({
              padding: dropdownEdgeChildPadding,
              listStyleType: "none",
              backgroundColor: colorBgElevated,
              backgroundClip: "padding-box",
              borderRadius: token2.borderRadiusLG,
              outline: "none",
              boxShadow: token2.boxShadowSecondary
            }, genFocusStyle(token2)), {
              [`${menuCls}-item-group-title`]: {
                padding: `${dropdownPaddingVertical}px ${controlPaddingHorizontal}px`,
                color: token2.colorTextDescription,
                transition: `all ${motionDurationMid}`
              },
              // ======================= Item Content =======================
              [`${menuCls}-item`]: {
                position: "relative",
                display: "flex",
                alignItems: "center"
              },
              [`${menuCls}-item-icon`]: {
                minWidth: fontSize,
                marginInlineEnd: token2.marginXS,
                fontSize: token2.fontSizeSM
              },
              [`${menuCls}-title-content`]: {
                flex: "auto",
                "> a": {
                  color: "inherit",
                  transition: `all ${motionDurationMid}`,
                  "&:hover": {
                    color: "inherit"
                  },
                  "&::after": {
                    position: "absolute",
                    inset: 0,
                    content: '""'
                  }
                }
              },
              // =========================== Item ===========================
              [`${menuCls}-item, ${menuCls}-submenu-title`]: Object.assign(Object.assign({
                clear: "both",
                margin: 0,
                padding: `${dropdownPaddingVertical}px ${controlPaddingHorizontal}px`,
                color: token2.colorText,
                fontWeight: "normal",
                fontSize,
                lineHeight: token2.lineHeight,
                cursor: "pointer",
                transition: `all ${motionDurationMid}`,
                borderRadius: token2.borderRadiusSM,
                [`&:hover, &-active`]: {
                  backgroundColor: token2.controlItemBgHover
                }
              }, genFocusStyle(token2)), {
                "&-selected": {
                  color: token2.colorPrimary,
                  backgroundColor: token2.controlItemBgActive,
                  "&:hover, &-active": {
                    backgroundColor: token2.controlItemBgActiveHover
                  }
                },
                "&-disabled": {
                  color: colorTextDisabled,
                  cursor: "not-allowed",
                  "&:hover": {
                    color: colorTextDisabled,
                    backgroundColor: colorBgElevated,
                    cursor: "not-allowed"
                  },
                  a: {
                    pointerEvents: "none"
                  }
                },
                "&-divider": {
                  height: 1,
                  margin: `${token2.marginXXS}px 0`,
                  overflow: "hidden",
                  lineHeight: 0,
                  backgroundColor: token2.colorSplit
                },
                [`${componentCls}-menu-submenu-expand-icon`]: {
                  position: "absolute",
                  insetInlineEnd: token2.paddingXS,
                  [`${componentCls}-menu-submenu-arrow-icon`]: {
                    marginInlineEnd: "0 !important",
                    color: token2.colorTextDescription,
                    fontSize: fontSizeIcon,
                    fontStyle: "normal"
                  }
                }
              }),
              [`${menuCls}-item-group-list`]: {
                margin: `0 ${token2.marginXS}px`,
                padding: 0,
                listStyle: "none"
              },
              [`${menuCls}-submenu-title`]: {
                paddingInlineEnd: controlPaddingHorizontal + token2.fontSizeSM
              },
              [`${menuCls}-submenu-vertical`]: {
                position: "relative"
              },
              [`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: {
                [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
                  color: colorTextDisabled,
                  backgroundColor: colorBgElevated,
                  cursor: "not-allowed"
                }
              },
              // https://github.com/ant-design/ant-design/issues/19264
              [`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: {
                color: token2.colorPrimary
              }
            })
          }
        },
        // Follow code may reuse in other components
        [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down"), initMoveMotion(token2, "move-up"), initMoveMotion(token2, "move-down"), initZoomMotion(token2, "zoom-big")]
      ];
    };
    const useStyle$o = genComponentStyleHook("Dropdown", (token2, _ref) => {
      let {
        rootPrefixCls
      } = _ref;
      const {
        marginXXS,
        sizePopupArrow,
        controlHeight,
        fontSize,
        lineHeight,
        paddingXXS,
        componentCls,
        borderRadiusLG
      } = token2;
      const dropdownPaddingVertical = (controlHeight - fontSize * lineHeight) / 2;
      const {
        dropdownArrowOffset
      } = getArrowOffset({
        contentRadius: borderRadiusLG
      });
      const dropdownToken = merge$4(token2, {
        menuCls: `${componentCls}-menu`,
        rootPrefixCls,
        dropdownArrowDistance: sizePopupArrow / 2 + marginXXS,
        dropdownArrowOffset,
        dropdownPaddingVertical,
        dropdownEdgeChildPadding: paddingXXS
      });
      return [genBaseStyle$7(dropdownToken), genButtonStyle$1(dropdownToken), genStatusStyle$2(dropdownToken)];
    }, (token2) => ({
      zIndexPopup: token2.zIndexPopupBase + 50
    }));
    var __rest$K = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const DropdownButton = (props) => {
      const {
        getPopupContainer: getContextPopupContainer,
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        type: type2 = "default",
        danger,
        disabled,
        loading,
        onClick,
        htmlType,
        children,
        className,
        menu,
        arrow,
        autoFocus,
        overlay,
        trigger,
        align,
        open: open2,
        onOpenChange,
        placement,
        getPopupContainer,
        href,
        icon = /* @__PURE__ */ reactExports.createElement(EllipsisOutlined$1, null),
        title,
        buttonsRender = (buttons) => buttons,
        mouseEnterDelay,
        mouseLeaveDelay,
        overlayClassName,
        overlayStyle,
        destroyPopupOnHide,
        dropdownRender
      } = props, restProps = __rest$K(props, ["prefixCls", "type", "danger", "disabled", "loading", "onClick", "htmlType", "children", "className", "menu", "arrow", "autoFocus", "overlay", "trigger", "align", "open", "onOpenChange", "placement", "getPopupContainer", "href", "icon", "title", "buttonsRender", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "dropdownRender"]);
      const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
      const buttonPrefixCls = `${prefixCls}-button`;
      const [wrapSSR, hashId] = useStyle$o(prefixCls);
      const dropdownProps = {
        menu,
        arrow,
        autoFocus,
        align,
        disabled,
        trigger: disabled ? [] : trigger,
        onOpenChange,
        getPopupContainer: getPopupContainer || getContextPopupContainer,
        mouseEnterDelay,
        mouseLeaveDelay,
        overlayClassName,
        overlayStyle,
        destroyPopupOnHide,
        dropdownRender
      };
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const classes = classNames(buttonPrefixCls, compactItemClassnames, className, hashId);
      if ("overlay" in props) {
        dropdownProps.overlay = overlay;
      }
      if ("open" in props) {
        dropdownProps.open = open2;
      }
      if ("placement" in props) {
        dropdownProps.placement = placement;
      } else {
        dropdownProps.placement = direction === "rtl" ? "bottomLeft" : "bottomRight";
      }
      const leftButton = /* @__PURE__ */ reactExports.createElement(Button$2, {
        type: type2,
        danger,
        disabled,
        loading,
        onClick,
        htmlType,
        href,
        title
      }, children);
      const rightButton = /* @__PURE__ */ reactExports.createElement(Button$2, {
        type: type2,
        danger,
        icon
      });
      const [leftButtonToRender, rightButtonToRender] = buttonsRender([leftButton, rightButton]);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(Space$1.Compact, Object.assign({
        className: classes,
        size: compactSize,
        block: true
      }, restProps), leftButtonToRender, /* @__PURE__ */ reactExports.createElement(Dropdown$1, Object.assign({}, dropdownProps), rightButtonToRender)));
    };
    DropdownButton.__ANT_BUTTON = true;
    const DropdownButton$1 = DropdownButton;
    const Dropdown = (props) => {
      const {
        getPopupContainer: getContextPopupContainer,
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const getTransitionName2 = () => {
        const rootPrefixCls = getPrefixCls();
        const {
          placement = "",
          transitionName
        } = props;
        if (transitionName !== void 0) {
          return transitionName;
        }
        if (placement.includes("top")) {
          return `${rootPrefixCls}-slide-down`;
        }
        return `${rootPrefixCls}-slide-up`;
      };
      const getPlacement = () => {
        const {
          placement
        } = props;
        if (!placement) {
          return direction === "rtl" ? "bottomRight" : "bottomLeft";
        }
        if (placement.includes("Center")) {
          const newPlacement = placement.slice(0, placement.indexOf("Center"));
          return newPlacement;
        }
        return placement;
      };
      const {
        menu,
        arrow,
        prefixCls: customizePrefixCls,
        children,
        trigger,
        disabled,
        dropdownRender,
        getPopupContainer,
        overlayClassName,
        rootClassName,
        open: open2,
        onOpenChange,
        // Deprecated
        visible,
        onVisibleChange,
        mouseEnterDelay = 0.15,
        mouseLeaveDelay = 0.1,
        autoAdjustOverflow: autoAdjustOverflow2 = true
      } = props;
      const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$o(prefixCls);
      const {
        token: token2
      } = theme.useToken();
      const child = reactExports.Children.only(children);
      const dropdownTrigger = cloneElement(child, {
        className: classNames(`${prefixCls}-trigger`, {
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, child.props.className),
        disabled
      });
      const triggerActions = disabled ? [] : trigger;
      let alignPoint2;
      if (triggerActions && triggerActions.includes("contextMenu")) {
        alignPoint2 = true;
      }
      const [mergedOpen, setOpen] = useMergedState(false, {
        value: open2 !== null && open2 !== void 0 ? open2 : visible
      });
      const onInnerOpenChange = useEvent((nextOpen) => {
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(nextOpen);
        onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(nextOpen);
        setOpen(nextOpen);
      });
      const overlayClassNameCustomized = classNames(overlayClassName, rootClassName, hashId, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      });
      const builtinPlacements = getPlacements({
        arrowPointAtCenter: typeof arrow === "object" && arrow.pointAtCenter,
        autoAdjustOverflow: autoAdjustOverflow2,
        offset: token2.marginXXS,
        arrowWidth: arrow ? token2.sizePopupArrow : 0,
        borderRadius: token2.borderRadius
      });
      const onMenuClick = reactExports.useCallback(() => {
        setOpen(false);
      }, []);
      const renderOverlay = () => {
        const {
          overlay
        } = props;
        let overlayNode;
        if (menu === null || menu === void 0 ? void 0 : menu.items) {
          overlayNode = /* @__PURE__ */ reactExports.createElement(Menu$1, Object.assign({}, menu));
        } else if (typeof overlay === "function") {
          overlayNode = overlay();
        } else {
          overlayNode = overlay;
        }
        if (dropdownRender) {
          overlayNode = dropdownRender(overlayNode);
        }
        overlayNode = reactExports.Children.only(typeof overlayNode === "string" ? /* @__PURE__ */ reactExports.createElement("span", null, overlayNode) : overlayNode);
        return /* @__PURE__ */ reactExports.createElement(OverrideProvider, {
          prefixCls: `${prefixCls}-menu`,
          expandIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-menu-submenu-arrow`
          }, /* @__PURE__ */ reactExports.createElement(RightOutlined$1, {
            className: `${prefixCls}-menu-submenu-arrow-icon`
          })),
          mode: "vertical",
          selectable: false,
          onClick: onMenuClick,
          validator: (_ref3) => {
          }
        }, /* @__PURE__ */ reactExports.createElement(NoCompactStyle, null, overlayNode));
      };
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(Dropdown$3, Object.assign({
        alignPoint: alignPoint2
      }, omit(props, ["rootClassName"]), {
        mouseEnterDelay,
        mouseLeaveDelay,
        visible: mergedOpen,
        builtinPlacements,
        arrow: !!arrow,
        overlayClassName: overlayClassNameCustomized,
        prefixCls,
        getPopupContainer: getPopupContainer || getContextPopupContainer,
        transitionName: getTransitionName2(),
        trigger: triggerActions,
        overlay: renderOverlay,
        placement: getPlacement(),
        onVisibleChange: onInnerOpenChange
      }), dropdownTrigger));
    };
    Dropdown.Button = DropdownButton$1;
    const PurePanel$4 = genPurePanel(Dropdown, "dropdown", (prefixCls) => prefixCls);
    const WrapPurePanel = (props) => /* @__PURE__ */ reactExports.createElement(PurePanel$4, Object.assign({}, props), /* @__PURE__ */ reactExports.createElement("span", null));
    Dropdown._InternalPanelDoNotUseOrYouWillBeFired = WrapPurePanel;
    const Dropdown$1 = Dropdown;
    const BreadcrumbSeparator = (_ref) => {
      let {
        children
      } = _ref;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("breadcrumb");
      return /* @__PURE__ */ reactExports.createElement("li", {
        className: `${prefixCls}-separator`,
        "aria-hidden": "true"
      }, children === "" ? children : children || "/");
    };
    BreadcrumbSeparator.__ANT_BREADCRUMB_SEPARATOR = true;
    const BreadcrumbSeparator$1 = BreadcrumbSeparator;
    var __rest$J = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const BreadcrumbItem = (props) => {
      const {
        prefixCls: customizePrefixCls,
        separator = "/",
        children,
        menu,
        overlay,
        dropdownProps,
        href
      } = props, restProps = __rest$J(props, ["prefixCls", "separator", "children", "menu", "overlay", "dropdownProps", "href"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
      const renderBreadcrumbNode = (breadcrumbItem) => {
        if (menu || overlay) {
          const mergeDropDownProps = Object.assign({}, dropdownProps);
          if (menu) {
            const _a = menu || {}, {
              items
            } = _a, menuProps = __rest$J(_a, ["items"]);
            mergeDropDownProps.menu = Object.assign(Object.assign({}, menuProps), {
              items: items === null || items === void 0 ? void 0 : items.map((_a2, index2) => {
                var {
                  title,
                  label,
                  path: path2
                } = _a2, itemProps = __rest$J(_a2, ["title", "label", "path"]);
                let mergedLabel = label !== null && label !== void 0 ? label : title;
                if (path2) {
                  mergedLabel = /* @__PURE__ */ reactExports.createElement("a", {
                    href: `${href}${path2}`
                  }, mergedLabel);
                }
                return Object.assign(Object.assign({}, itemProps), {
                  key: index2,
                  label: mergedLabel
                });
              })
            });
          } else if (overlay) {
            mergeDropDownProps.overlay = overlay;
          }
          return /* @__PURE__ */ reactExports.createElement(Dropdown$1, Object.assign({
            placement: "bottom"
          }, mergeDropDownProps), /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-overlay-link`
          }, breadcrumbItem, /* @__PURE__ */ reactExports.createElement(DownOutlined$3, null)));
        }
        return breadcrumbItem;
      };
      let link2;
      if (href !== void 0) {
        link2 = /* @__PURE__ */ reactExports.createElement("a", Object.assign({
          className: `${prefixCls}-link`,
          href
        }, restProps), children);
      } else {
        link2 = /* @__PURE__ */ reactExports.createElement("span", Object.assign({
          className: `${prefixCls}-link`
        }, restProps), children);
      }
      link2 = renderBreadcrumbNode(link2);
      if (children !== void 0 && children !== null) {
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("li", null, link2), separator && /* @__PURE__ */ reactExports.createElement(BreadcrumbSeparator$1, null, separator));
      }
      return null;
    };
    BreadcrumbItem.__ANT_BREADCRUMB_ITEM = true;
    const BreadcrumbItem$1 = BreadcrumbItem;
    const genBreadcrumbStyle = (token2) => {
      const {
        componentCls,
        iconCls
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
          color: token2.breadcrumbBaseColor,
          fontSize: token2.breadcrumbFontSize,
          [iconCls]: {
            fontSize: token2.breadcrumbIconFontSize
          },
          ol: {
            display: "flex",
            flexWrap: "wrap",
            margin: 0,
            padding: 0,
            listStyle: "none"
          },
          a: Object.assign({
            color: token2.breadcrumbLinkColor,
            transition: `color ${token2.motionDurationMid}`,
            padding: `0 ${token2.paddingXXS}px`,
            borderRadius: token2.borderRadiusSM,
            height: token2.lineHeight * token2.fontSize,
            display: "inline-block",
            marginInline: -token2.marginXXS,
            "&:hover": {
              color: token2.breadcrumbLinkColorHover,
              backgroundColor: token2.colorBgTextHover
            }
          }, genFocusStyle(token2)),
          [`li:last-child`]: {
            color: token2.breadcrumbLastItemColor
          },
          [`${componentCls}-separator`]: {
            marginInline: token2.breadcrumbSeparatorMargin,
            color: token2.breadcrumbSeparatorColor
          },
          [`${componentCls}-link`]: {
            [`
          > ${iconCls} + span,
          > ${iconCls} + a
        `]: {
              marginInlineStart: token2.marginXXS
            }
          },
          [`${componentCls}-overlay-link`]: {
            borderRadius: token2.borderRadiusSM,
            height: token2.lineHeight * token2.fontSize,
            display: "inline-block",
            padding: `0 ${token2.paddingXXS}px`,
            marginInline: -token2.marginXXS,
            [`> ${iconCls}`]: {
              marginInlineStart: token2.marginXXS,
              fontSize: token2.fontSizeIcon
            },
            "&:hover": {
              color: token2.breadcrumbLinkColorHover,
              backgroundColor: token2.colorBgTextHover,
              a: {
                color: token2.breadcrumbLinkColorHover
              }
            },
            a: {
              "&:hover": {
                backgroundColor: "transparent"
              }
            }
          },
          // rtl style
          [`&${token2.componentCls}-rtl`]: {
            direction: "rtl"
          }
        })
      };
    };
    const useStyle$n = genComponentStyleHook("Breadcrumb", (token2) => {
      const BreadcrumbToken = merge$4(token2, {
        breadcrumbBaseColor: token2.colorTextDescription,
        breadcrumbFontSize: token2.fontSize,
        breadcrumbIconFontSize: token2.fontSize,
        breadcrumbLinkColor: token2.colorTextDescription,
        breadcrumbLinkColorHover: token2.colorText,
        breadcrumbLastItemColor: token2.colorText,
        breadcrumbSeparatorMargin: token2.marginXS,
        breadcrumbSeparatorColor: token2.colorTextDescription
      });
      return [genBreadcrumbStyle(BreadcrumbToken)];
    });
    var __rest$I = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function route2item(route) {
      const {
        breadcrumbName,
        children
      } = route, rest = __rest$I(route, ["breadcrumbName", "children"]);
      const clone = Object.assign({
        title: breadcrumbName
      }, rest);
      if (children) {
        clone.menu = {
          items: children.map((_a) => {
            var {
              breadcrumbName: itemBreadcrumbName
            } = _a, itemProps = __rest$I(_a, ["breadcrumbName"]);
            return Object.assign(Object.assign({}, itemProps), {
              title: itemBreadcrumbName
            });
          })
        };
      }
      return clone;
    }
    function useItems(items, routes) {
      return reactExports.useMemo(() => {
        if (items) {
          return items;
        }
        if (routes) {
          return routes.map(route2item);
        }
        return null;
      }, [items, routes]);
    }
    var __rest$H = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function getBreadcrumbName(route, params) {
      if (route.title === void 0) {
        return null;
      }
      const paramsKeys = Object.keys(params).join("|");
      return typeof route.title === "object" ? route.title : String(route.title).replace(new RegExp(`:(${paramsKeys})`, "g"), (replacement, key) => params[key] || replacement);
    }
    const getPath$1 = (params, path2) => {
      if (path2 === void 0) {
        return path2;
      }
      let mergedPath = (path2 || "").replace(/^\//, "");
      Object.keys(params).forEach((key) => {
        mergedPath = mergedPath.replace(`:${key}`, params[key]);
      });
      return mergedPath;
    };
    const Breadcrumb = (props) => {
      const _a = props, {
        prefixCls: customizePrefixCls,
        separator = "/",
        style: style2,
        className,
        rootClassName,
        routes: legacyRoutes,
        items,
        children,
        itemRender,
        params = {}
      } = _a, restProps = __rest$H(_a, ["prefixCls", "separator", "style", "className", "rootClassName", "routes", "items", "children", "itemRender", "params"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      let crumbs;
      const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$n(prefixCls);
      const mergedItems = useItems(items, legacyRoutes);
      const mergedItemRender = itemRender || ((route) => {
        const name = getBreadcrumbName(route, params);
        return name;
      });
      if (mergedItems && mergedItems.length > 0) {
        const paths = [];
        const itemRenderRoutes = items || legacyRoutes;
        crumbs = mergedItems.map((item, index2) => {
          const {
            path: path2,
            key,
            type: type2,
            menu,
            overlay,
            separator: itemSeparator
          } = item;
          const mergedPath = getPath$1(params, path2);
          if (mergedPath !== void 0) {
            paths.push(mergedPath);
          }
          const mergedKey = key !== null && key !== void 0 ? key : index2;
          if (type2 === "separator") {
            return /* @__PURE__ */ reactExports.createElement(BreadcrumbSeparator$1, {
              key: mergedKey
            }, itemSeparator);
          }
          const itemProps = {};
          const isLastItem = index2 === mergedItems.length - 1;
          if (menu) {
            itemProps.menu = menu;
          } else if (overlay) {
            itemProps.overlay = overlay;
          }
          let {
            href
          } = item;
          if (paths.length && mergedPath !== void 0) {
            href = `#/${paths.join("/")}`;
          }
          return /* @__PURE__ */ reactExports.createElement(BreadcrumbItem$1, Object.assign({
            key: mergedKey
          }, itemProps, pickAttrs(item, {
            data: true,
            aria: true
          }), {
            href,
            separator: isLastItem ? "" : separator
          }), mergedItemRender(item, params, itemRenderRoutes, paths));
        });
      } else if (children) {
        const childrenLength = toArray$8(children).length;
        crumbs = toArray$8(children).map((element, index2) => {
          if (!element) {
            return element;
          }
          const isLastItem = index2 === childrenLength - 1;
          return cloneElement(element, {
            separator: isLastItem ? "" : separator,
            key: index2
          });
        });
      }
      const breadcrumbClassName = classNames(prefixCls, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("nav", Object.assign({
        className: breadcrumbClassName,
        style: style2
      }, restProps), /* @__PURE__ */ reactExports.createElement("ol", null, crumbs)));
    };
    Breadcrumb.Item = BreadcrumbItem$1;
    Breadcrumb.Separator = BreadcrumbSeparator$1;
    const Breadcrumb$1 = Breadcrumb;
    var dayjs_minExports = {};
    var dayjs_min = {
      get exports() {
        return dayjs_minExports;
      },
      set exports(v2) {
        dayjs_minExports = v2;
      }
    };
    (function(module2, exports2) {
      !function(t2, e2) {
        module2.exports = e2();
      }(commonjsGlobal, function() {
        var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s = "minute", u2 = "hour", a = "day", o2 = "week", f2 = "month", h2 = "quarter", c2 = "year", d2 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
          var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
          return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
        } }, m2 = function(t3, e3, n3) {
          var r3 = String(t3);
          return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
        }, v2 = { s: m2, z: function(t3) {
          var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
          return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
        }, m: function t3(e3, n3) {
          if (e3.date() < n3.date())
            return -t3(n3, e3);
          var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, f2), s2 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s2 ? -1 : 1), f2);
          return +(-(r3 + (n3 - i3) / (s2 ? i3 - u3 : u3 - i3)) || 0);
        }, a: function(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function(t3) {
          return { M: f2, y: c2, w: o2, d: a, D: d2, h: u2, m: s, s: i2, ms: r2, Q: h2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t3) {
          return void 0 === t3;
        } }, g2 = "en", D2 = {};
        D2[g2] = M2;
        var p2 = function(t3) {
          return t3 instanceof _;
        }, S2 = function t3(e3, n3, r3) {
          var i3;
          if (!e3)
            return g2;
          if ("string" == typeof e3) {
            var s2 = e3.toLowerCase();
            D2[s2] && (i3 = s2), n3 && (D2[s2] = n3, i3 = s2);
            var u3 = e3.split("-");
            if (!i3 && u3.length > 1)
              return t3(u3[0]);
          } else {
            var a2 = e3.name;
            D2[a2] = e3, i3 = a2;
          }
          return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
        }, w2 = function(t3, e3) {
          if (p2(t3))
            return t3.clone();
          var n3 = "object" == typeof e3 ? e3 : {};
          return n3.date = t3, n3.args = arguments, new _(n3);
        }, O2 = v2;
        O2.l = S2, O2.i = p2, O2.w = function(t3, e3) {
          return w2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
        };
        var _ = function() {
          function M3(t3) {
            this.$L = S2(t3.locale, null, true), this.parse(t3);
          }
          var m3 = M3.prototype;
          return m3.parse = function(t3) {
            this.$d = function(t4) {
              var e3 = t4.date, n3 = t4.utc;
              if (null === e3)
                return new Date(NaN);
              if (O2.u(e3))
                return new Date();
              if (e3 instanceof Date)
                return new Date(e3);
              if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                var r3 = e3.match($2);
                if (r3) {
                  var i3 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                  return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
                }
              }
              return new Date(e3);
            }(t3), this.$x = t3.x || {}, this.init();
          }, m3.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, m3.$utils = function() {
            return O2;
          }, m3.isValid = function() {
            return !(this.$d.toString() === l2);
          }, m3.isSame = function(t3, e3) {
            var n3 = w2(t3);
            return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
          }, m3.isAfter = function(t3, e3) {
            return w2(t3) < this.startOf(e3);
          }, m3.isBefore = function(t3, e3) {
            return this.endOf(e3) < w2(t3);
          }, m3.$g = function(t3, e3, n3) {
            return O2.u(t3) ? this[e3] : this.set(n3, t3);
          }, m3.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m3.valueOf = function() {
            return this.$d.getTime();
          }, m3.startOf = function(t3, e3) {
            var n3 = this, r3 = !!O2.u(e3) || e3, h3 = O2.p(t3), l3 = function(t4, e4) {
              var i3 = O2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
              return r3 ? i3 : i3.endOf(a);
            }, $3 = function(t4, e4) {
              return O2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
            }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
            switch (h3) {
              case c2:
                return r3 ? l3(1, 0) : l3(31, 11);
              case f2:
                return r3 ? l3(1, M4) : l3(0, M4 + 1);
              case o2:
                var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
                return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
              case a:
              case d2:
                return $3(v3 + "Hours", 0);
              case u2:
                return $3(v3 + "Minutes", 1);
              case s:
                return $3(v3 + "Seconds", 2);
              case i2:
                return $3(v3 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m3.endOf = function(t3) {
            return this.startOf(t3, false);
          }, m3.$set = function(t3, e3) {
            var n3, o3 = O2.p(t3), h3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a] = h3 + "Date", n3[d2] = h3 + "Date", n3[f2] = h3 + "Month", n3[c2] = h3 + "FullYear", n3[u2] = h3 + "Hours", n3[s] = h3 + "Minutes", n3[i2] = h3 + "Seconds", n3[r2] = h3 + "Milliseconds", n3)[o3], $3 = o3 === a ? this.$D + (e3 - this.$W) : e3;
            if (o3 === f2 || o3 === c2) {
              var y3 = this.clone().set(d2, 1);
              y3.$d[l3]($3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
            } else
              l3 && this.$d[l3]($3);
            return this.init(), this;
          }, m3.set = function(t3, e3) {
            return this.clone().$set(t3, e3);
          }, m3.get = function(t3) {
            return this[O2.p(t3)]();
          }, m3.add = function(r3, h3) {
            var d3, l3 = this;
            r3 = Number(r3);
            var $3 = O2.p(h3), y3 = function(t3) {
              var e3 = w2(l3);
              return O2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
            };
            if ($3 === f2)
              return this.set(f2, this.$M + r3);
            if ($3 === c2)
              return this.set(c2, this.$y + r3);
            if ($3 === a)
              return y3(1);
            if ($3 === o2)
              return y3(7);
            var M4 = (d3 = {}, d3[s] = e2, d3[u2] = n2, d3[i2] = t2, d3)[$3] || 1, m4 = this.$d.getTime() + r3 * M4;
            return O2.w(m4, this);
          }, m3.subtract = function(t3, e3) {
            return this.add(-1 * t3, e3);
          }, m3.format = function(t3) {
            var e3 = this, n3 = this.$locale();
            if (!this.isValid())
              return n3.invalidDate || l2;
            var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O2.z(this), s2 = this.$H, u3 = this.$m, a2 = this.$M, o3 = n3.weekdays, f3 = n3.months, h3 = function(t4, n4, i4, s3) {
              return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s3);
            }, c3 = function(t4) {
              return O2.s(s2 % 12 || 12, t4, "0");
            }, d3 = n3.meridiem || function(t4, e4, n4) {
              var r4 = t4 < 12 ? "AM" : "PM";
              return n4 ? r4.toLowerCase() : r4;
            }, $3 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O2.s(a2 + 1, 2, "0"), MMM: h3(n3.monthsShort, a2, f3, 3), MMMM: h3(f3, a2), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n3.weekdaysMin, this.$W, o3, 2), ddd: h3(n3.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s2), HH: O2.s(s2, 2, "0"), h: c3(1), hh: c3(2), a: d3(s2, u3, true), A: d3(s2, u3, false), m: String(u3), mm: O2.s(u3, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i3 };
            return r3.replace(y2, function(t4, e4) {
              return e4 || $3[t4] || i3.replace(":", "");
            });
          }, m3.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m3.diff = function(r3, d3, l3) {
            var $3, y3 = O2.p(d3), M4 = w2(r3), m4 = (M4.utcOffset() - this.utcOffset()) * e2, v3 = this - M4, g3 = O2.m(this, M4);
            return g3 = ($3 = {}, $3[c2] = g3 / 12, $3[f2] = g3, $3[h2] = g3 / 3, $3[o2] = (v3 - m4) / 6048e5, $3[a] = (v3 - m4) / 864e5, $3[u2] = v3 / n2, $3[s] = v3 / e2, $3[i2] = v3 / t2, $3)[y3] || v3, l3 ? g3 : O2.a(g3);
          }, m3.daysInMonth = function() {
            return this.endOf(f2).$D;
          }, m3.$locale = function() {
            return D2[this.$L];
          }, m3.locale = function(t3, e3) {
            if (!t3)
              return this.$L;
            var n3 = this.clone(), r3 = S2(t3, e3, true);
            return r3 && (n3.$L = r3), n3;
          }, m3.clone = function() {
            return O2.w(this.$d, this);
          }, m3.toDate = function() {
            return new Date(this.valueOf());
          }, m3.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m3.toISOString = function() {
            return this.$d.toISOString();
          }, m3.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), T2 = _.prototype;
        return w2.prototype = T2, [["$ms", r2], ["$s", i2], ["$m", s], ["$H", u2], ["$W", a], ["$M", f2], ["$y", c2], ["$D", d2]].forEach(function(t3) {
          T2[t3[1]] = function(e3) {
            return this.$g(e3, t3[0], t3[1]);
          };
        }), w2.extend = function(t3, e3) {
          return t3.$i || (t3(e3, _, w2), t3.$i = true), w2;
        }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t3) {
          return w2(1e3 * t3);
        }, w2.en = D2[g2], w2.Ls = D2, w2.p = {}, w2;
      });
    })(dayjs_min);
    const dayjs = dayjs_minExports;
    var weekdayExports = {};
    var weekday$1 = {
      get exports() {
        return weekdayExports;
      },
      set exports(v2) {
        weekdayExports = v2;
      }
    };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        return function(e2, t2) {
          t2.prototype.weekday = function(e3) {
            var t3 = this.$locale().weekStart || 0, i2 = this.$W, n2 = (i2 < t3 ? i2 + 7 : i2) - t3;
            return this.$utils().u(e3) ? n2 : this.subtract(n2, "day").add(e3, "day");
          };
        };
      });
    })(weekday$1);
    const weekday = weekdayExports;
    var localeDataExports = {};
    var localeData$1 = {
      get exports() {
        return localeDataExports;
      },
      set exports(v2) {
        localeDataExports = v2;
      }
    };
    (function(module2, exports2) {
      !function(n2, e2) {
        module2.exports = e2();
      }(commonjsGlobal, function() {
        return function(n2, e2, t2) {
          var r2 = e2.prototype, o2 = function(n3) {
            return n3 && (n3.indexOf ? n3 : n3.s);
          }, u2 = function(n3, e3, t3, r3, u3) {
            var i3 = n3.name ? n3 : n3.$locale(), a2 = o2(i3[e3]), s2 = o2(i3[t3]), f2 = a2 || s2.map(function(n4) {
              return n4.slice(0, r3);
            });
            if (!u3)
              return f2;
            var d2 = i3.weekStart;
            return f2.map(function(n4, e4) {
              return f2[(e4 + (d2 || 0)) % 7];
            });
          }, i2 = function() {
            return t2.Ls[t2.locale()];
          }, a = function(n3, e3) {
            return n3.formats[e3] || function(n4) {
              return n4.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n5, e4, t3) {
                return e4 || t3.slice(1);
              });
            }(n3.formats[e3.toUpperCase()]);
          }, s = function() {
            var n3 = this;
            return { months: function(e3) {
              return e3 ? e3.format("MMMM") : u2(n3, "months");
            }, monthsShort: function(e3) {
              return e3 ? e3.format("MMM") : u2(n3, "monthsShort", "months", 3);
            }, firstDayOfWeek: function() {
              return n3.$locale().weekStart || 0;
            }, weekdays: function(e3) {
              return e3 ? e3.format("dddd") : u2(n3, "weekdays");
            }, weekdaysMin: function(e3) {
              return e3 ? e3.format("dd") : u2(n3, "weekdaysMin", "weekdays", 2);
            }, weekdaysShort: function(e3) {
              return e3 ? e3.format("ddd") : u2(n3, "weekdaysShort", "weekdays", 3);
            }, longDateFormat: function(e3) {
              return a(n3.$locale(), e3);
            }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
          };
          r2.localeData = function() {
            return s.bind(this)();
          }, t2.localeData = function() {
            var n3 = i2();
            return { firstDayOfWeek: function() {
              return n3.weekStart || 0;
            }, weekdays: function() {
              return t2.weekdays();
            }, weekdaysShort: function() {
              return t2.weekdaysShort();
            }, weekdaysMin: function() {
              return t2.weekdaysMin();
            }, months: function() {
              return t2.months();
            }, monthsShort: function() {
              return t2.monthsShort();
            }, longDateFormat: function(e3) {
              return a(n3, e3);
            }, meridiem: n3.meridiem, ordinal: n3.ordinal };
          }, t2.months = function() {
            return u2(i2(), "months");
          }, t2.monthsShort = function() {
            return u2(i2(), "monthsShort", "months", 3);
          }, t2.weekdays = function(n3) {
            return u2(i2(), "weekdays", null, null, n3);
          }, t2.weekdaysShort = function(n3) {
            return u2(i2(), "weekdaysShort", "weekdays", 3, n3);
          }, t2.weekdaysMin = function(n3) {
            return u2(i2(), "weekdaysMin", "weekdays", 2, n3);
          };
        };
      });
    })(localeData$1);
    const localeData = localeDataExports;
    var weekOfYearExports = {};
    var weekOfYear$1 = {
      get exports() {
        return weekOfYearExports;
      },
      set exports(v2) {
        weekOfYearExports = v2;
      }
    };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        var e2 = "week", t2 = "year";
        return function(i2, n2, r2) {
          var f2 = n2.prototype;
          f2.week = function(i3) {
            if (void 0 === i3 && (i3 = null), null !== i3)
              return this.add(7 * (i3 - this.week()), "day");
            var n3 = this.$locale().yearStart || 1;
            if (11 === this.month() && this.date() > 25) {
              var f3 = r2(this).startOf(t2).add(1, t2).date(n3), s = r2(this).endOf(e2);
              if (f3.isBefore(s))
                return 1;
            }
            var a = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o2 = this.diff(a, e2, true);
            return o2 < 0 ? r2(this).startOf("week").week() : Math.ceil(o2);
          }, f2.weeks = function(e3) {
            return void 0 === e3 && (e3 = null), this.week(e3);
          };
        };
      });
    })(weekOfYear$1);
    const weekOfYear = weekOfYearExports;
    var weekYearExports = {};
    var weekYear$1 = {
      get exports() {
        return weekYearExports;
      },
      set exports(v2) {
        weekYearExports = v2;
      }
    };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        return function(e2, t2) {
          t2.prototype.weekYear = function() {
            var e3 = this.month(), t3 = this.week(), n2 = this.year();
            return 1 === t3 && 11 === e3 ? n2 + 1 : 0 === e3 && t3 >= 52 ? n2 - 1 : n2;
          };
        };
      });
    })(weekYear$1);
    const weekYear = weekYearExports;
    var advancedFormatExports = {};
    var advancedFormat$1 = {
      get exports() {
        return advancedFormatExports;
      },
      set exports(v2) {
        advancedFormatExports = v2;
      }
    };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        return function(e2, t2) {
          var r2 = t2.prototype, n2 = r2.format;
          r2.format = function(e3) {
            var t3 = this, r3 = this.$locale();
            if (!this.isValid())
              return n2.bind(this)(e3);
            var s = this.$utils(), a = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
              switch (e4) {
                case "Q":
                  return Math.ceil((t3.$M + 1) / 3);
                case "Do":
                  return r3.ordinal(t3.$D);
                case "gggg":
                  return t3.weekYear();
                case "GGGG":
                  return t3.isoWeekYear();
                case "wo":
                  return r3.ordinal(t3.week(), "W");
                case "w":
                case "ww":
                  return s.s(t3.week(), "w" === e4 ? 1 : 2, "0");
                case "W":
                case "WW":
                  return s.s(t3.isoWeek(), "W" === e4 ? 1 : 2, "0");
                case "k":
                case "kk":
                  return s.s(String(0 === t3.$H ? 24 : t3.$H), "k" === e4 ? 1 : 2, "0");
                case "X":
                  return Math.floor(t3.$d.getTime() / 1e3);
                case "x":
                  return t3.$d.getTime();
                case "z":
                  return "[" + t3.offsetName() + "]";
                case "zzz":
                  return "[" + t3.offsetName("long") + "]";
                default:
                  return e4;
              }
            });
            return n2.bind(this)(a);
          };
        };
      });
    })(advancedFormat$1);
    const advancedFormat = advancedFormatExports;
    var customParseFormatExports = {};
    var customParseFormat$1 = {
      get exports() {
        return customParseFormatExports;
      },
      set exports(v2) {
        customParseFormatExports = v2;
      }
    };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r2 = /\d\d?/, i2 = /\d*[^-_:/,()\s\d]+/, o2 = {}, s = function(e3) {
          return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
        };
        var a = function(e3) {
          return function(t3) {
            this[e3] = +t3;
          };
        }, f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
          (this.zone || (this.zone = {})).offset = function(e4) {
            if (!e4)
              return 0;
            if ("Z" === e4)
              return 0;
            var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
            return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
          }(e3);
        }], h2 = function(e3) {
          var t3 = o2[e3];
          return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
        }, u2 = function(e3, t3) {
          var n3, r3 = o2.meridiem;
          if (r3) {
            for (var i3 = 1; i3 <= 24; i3 += 1)
              if (e3.indexOf(r3(i3, 0, t3)) > -1) {
                n3 = i3 > 12;
                break;
              }
          } else
            n3 = e3 === (t3 ? "pm" : "PM");
          return n3;
        }, d2 = { A: [i2, function(e3) {
          this.afternoon = u2(e3, false);
        }], a: [i2, function(e3) {
          this.afternoon = u2(e3, true);
        }], S: [/\d/, function(e3) {
          this.milliseconds = 100 * +e3;
        }], SS: [n2, function(e3) {
          this.milliseconds = 10 * +e3;
        }], SSS: [/\d{3}/, function(e3) {
          this.milliseconds = +e3;
        }], s: [r2, a("seconds")], ss: [r2, a("seconds")], m: [r2, a("minutes")], mm: [r2, a("minutes")], H: [r2, a("hours")], h: [r2, a("hours")], HH: [r2, a("hours")], hh: [r2, a("hours")], D: [r2, a("day")], DD: [n2, a("day")], Do: [i2, function(e3) {
          var t3 = o2.ordinal, n3 = e3.match(/\d+/);
          if (this.day = n3[0], t3)
            for (var r3 = 1; r3 <= 31; r3 += 1)
              t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
        }], M: [r2, a("month")], MM: [n2, a("month")], MMM: [i2, function(e3) {
          var t3 = h2("months"), n3 = (h2("monthsShort") || t3.map(function(e4) {
            return e4.slice(0, 3);
          })).indexOf(e3) + 1;
          if (n3 < 1)
            throw new Error();
          this.month = n3 % 12 || n3;
        }], MMMM: [i2, function(e3) {
          var t3 = h2("months").indexOf(e3) + 1;
          if (t3 < 1)
            throw new Error();
          this.month = t3 % 12 || t3;
        }], Y: [/[+-]?\d+/, a("year")], YY: [n2, function(e3) {
          this.year = s(e3);
        }], YYYY: [/\d{4}/, a("year")], Z: f2, ZZ: f2 };
        function c2(n3) {
          var r3, i3;
          r3 = n3, i3 = o2 && o2.formats;
          for (var s2 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
            var o3 = r4 && r4.toUpperCase();
            return n4 || i3[r4] || e2[r4] || i3[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
              return t4 || n5.slice(1);
            });
          })).match(t2), a2 = s2.length, f3 = 0; f3 < a2; f3 += 1) {
            var h3 = s2[f3], u3 = d2[h3], c3 = u3 && u3[0], l2 = u3 && u3[1];
            s2[f3] = l2 ? { regex: c3, parser: l2 } : h3.replace(/^\[|\]$/g, "");
          }
          return function(e3) {
            for (var t3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
              var i4 = s2[n4];
              if ("string" == typeof i4)
                r4 += i4.length;
              else {
                var o3 = i4.regex, f4 = i4.parser, h4 = e3.slice(r4), u4 = o3.exec(h4)[0];
                f4.call(t3, u4), e3 = e3.replace(u4, "");
              }
            }
            return function(e4) {
              var t4 = e4.afternoon;
              if (void 0 !== t4) {
                var n5 = e4.hours;
                t4 ? n5 < 12 && (e4.hours += 12) : 12 === n5 && (e4.hours = 0), delete e4.afternoon;
              }
            }(t3), t3;
          };
        }
        return function(e3, t3, n3) {
          n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (s = e3.parseTwoDigitYear);
          var r3 = t3.prototype, i3 = r3.parse;
          r3.parse = function(e4) {
            var t4 = e4.date, r4 = e4.utc, s2 = e4.args;
            this.$u = r4;
            var a2 = s2[1];
            if ("string" == typeof a2) {
              var f3 = true === s2[2], h3 = true === s2[3], u3 = f3 || h3, d3 = s2[2];
              h3 && (d3 = s2[2]), o2 = this.$locale(), !f3 && d3 && (o2 = n3.Ls[d3]), this.$d = function(e5, t5, n4) {
                try {
                  if (["x", "X"].indexOf(t5) > -1)
                    return new Date(("X" === t5 ? 1e3 : 1) * e5);
                  var r5 = c2(t5)(e5), i4 = r5.year, o3 = r5.month, s3 = r5.day, a3 = r5.hours, f4 = r5.minutes, h4 = r5.seconds, u4 = r5.milliseconds, d4 = r5.zone, l3 = new Date(), m3 = s3 || (i4 || o3 ? 1 : l3.getDate()), M3 = i4 || l3.getFullYear(), Y2 = 0;
                  i4 && !o3 || (Y2 = o3 > 0 ? o3 - 1 : l3.getMonth());
                  var p2 = a3 || 0, v2 = f4 || 0, D2 = h4 || 0, g2 = u4 || 0;
                  return d4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2 + 60 * d4.offset * 1e3)) : n4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2)) : new Date(M3, Y2, m3, p2, v2, D2, g2);
                } catch (e6) {
                  return new Date("");
                }
              }(t4, a2, r4), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t4 != this.format(a2) && (this.$d = new Date("")), o2 = {};
            } else if (a2 instanceof Array)
              for (var l2 = a2.length, m2 = 1; m2 <= l2; m2 += 1) {
                s2[1] = a2[m2 - 1];
                var M2 = n3.apply(this, s2);
                if (M2.isValid()) {
                  this.$d = M2.$d, this.$L = M2.$L, this.init();
                  break;
                }
                m2 === l2 && (this.$d = new Date(""));
              }
            else
              i3.call(this, e4);
          };
        };
      });
    })(customParseFormat$1);
    const customParseFormat = customParseFormatExports;
    dayjs.extend(customParseFormat);
    dayjs.extend(advancedFormat);
    dayjs.extend(weekday);
    dayjs.extend(localeData);
    dayjs.extend(weekOfYear);
    dayjs.extend(weekYear);
    dayjs.extend(function(o2, c2) {
      var proto2 = c2.prototype;
      var oldFormat = proto2.format;
      proto2.format = function f2(formatStr) {
        var str = (formatStr || "").replace("Wo", "wo");
        return oldFormat.bind(this)(str);
      };
    });
    var localeMap = {
      // ar_EG:
      // az_AZ:
      // bg_BG:
      bn_BD: "bn-bd",
      by_BY: "be",
      // ca_ES:
      // cs_CZ:
      // da_DK:
      // de_DE:
      // el_GR:
      en_GB: "en-gb",
      en_US: "en",
      // es_ES:
      // et_EE:
      // fa_IR:
      // fi_FI:
      fr_BE: "fr",
      // todo: dayjs has no fr_BE locale, use fr at present
      fr_CA: "fr-ca",
      // fr_FR:
      // ga_IE:
      // gl_ES:
      // he_IL:
      // hi_IN:
      // hr_HR:
      // hu_HU:
      hy_AM: "hy-am",
      // id_ID:
      // is_IS:
      // it_IT:
      // ja_JP:
      // ka_GE:
      // kk_KZ:
      // km_KH:
      kmr_IQ: "ku",
      // kn_IN:
      // ko_KR:
      // ku_IQ: // previous ku in antd
      // lt_LT:
      // lv_LV:
      // mk_MK:
      // ml_IN:
      // mn_MN:
      // ms_MY:
      // nb_NO:
      // ne_NP:
      nl_BE: "nl-be",
      // nl_NL:
      // pl_PL:
      pt_BR: "pt-br",
      // pt_PT:
      // ro_RO:
      // ru_RU:
      // sk_SK:
      // sl_SI:
      // sr_RS:
      // sv_SE:
      // ta_IN:
      // th_TH:
      // tr_TR:
      // uk_UA:
      // ur_PK:
      // vi_VN:
      zh_CN: "zh-cn",
      zh_HK: "zh-hk",
      zh_TW: "zh-tw"
    };
    var parseLocale = function parseLocale2(locale2) {
      var mapLocale = localeMap[locale2];
      return mapLocale || locale2.split("_")[0];
    };
    var parseNoMatchNotice = function parseNoMatchNotice2() {
      noteOnce$1(false, "Not match any format. Please help to fire a issue about this.");
    };
    var generateConfig = {
      // get
      getNow: function getNow() {
        return dayjs();
      },
      getFixedDate: function getFixedDate(string2) {
        return dayjs(string2, ["YYYY-M-DD", "YYYY-MM-DD"]);
      },
      getEndDate: function getEndDate(date2) {
        return date2.endOf("month");
      },
      getWeekDay: function getWeekDay(date2) {
        var clone = date2.locale("en");
        return clone.weekday() + clone.localeData().firstDayOfWeek();
      },
      getYear: function getYear(date2) {
        return date2.year();
      },
      getMonth: function getMonth(date2) {
        return date2.month();
      },
      getDate: function getDate(date2) {
        return date2.date();
      },
      getHour: function getHour(date2) {
        return date2.hour();
      },
      getMinute: function getMinute(date2) {
        return date2.minute();
      },
      getSecond: function getSecond(date2) {
        return date2.second();
      },
      // set
      addYear: function addYear(date2, diff) {
        return date2.add(diff, "year");
      },
      addMonth: function addMonth(date2, diff) {
        return date2.add(diff, "month");
      },
      addDate: function addDate(date2, diff) {
        return date2.add(diff, "day");
      },
      setYear: function setYear(date2, year) {
        return date2.year(year);
      },
      setMonth: function setMonth(date2, month) {
        return date2.month(month);
      },
      setDate: function setDate(date2, num) {
        return date2.date(num);
      },
      setHour: function setHour(date2, hour) {
        return date2.hour(hour);
      },
      setMinute: function setMinute(date2, minute) {
        return date2.minute(minute);
      },
      setSecond: function setSecond(date2, second) {
        return date2.second(second);
      },
      // Compare
      isAfter: function isAfter(date1, date2) {
        return date1.isAfter(date2);
      },
      isValidate: function isValidate(date2) {
        return date2.isValid();
      },
      locale: {
        getWeekFirstDay: function getWeekFirstDay(locale2) {
          return dayjs().locale(parseLocale(locale2)).localeData().firstDayOfWeek();
        },
        getWeekFirstDate: function getWeekFirstDate(locale2, date2) {
          return date2.locale(parseLocale(locale2)).weekday(0);
        },
        getWeek: function getWeek(locale2, date2) {
          return date2.locale(parseLocale(locale2)).week();
        },
        getShortWeekDays: function getShortWeekDays(locale2) {
          return dayjs().locale(parseLocale(locale2)).localeData().weekdaysMin();
        },
        getShortMonths: function getShortMonths(locale2) {
          return dayjs().locale(parseLocale(locale2)).localeData().monthsShort();
        },
        format: function format2(locale2, date2, _format) {
          return date2.locale(parseLocale(locale2)).format(_format);
        },
        parse: function parse2(locale2, text2, formats2) {
          var localeStr = parseLocale(locale2);
          for (var i2 = 0; i2 < formats2.length; i2 += 1) {
            var format2 = formats2[i2];
            var formatText = text2;
            if (format2.includes("wo") || format2.includes("Wo")) {
              var year = formatText.split("-")[0];
              var weekStr = formatText.split("-")[1];
              var firstWeek = dayjs(year, "YYYY").startOf("year").locale(localeStr);
              for (var j = 0; j <= 52; j += 1) {
                var nextWeek = firstWeek.add(j, "week");
                if (nextWeek.format("Wo") === weekStr) {
                  return nextWeek;
                }
              }
              parseNoMatchNotice();
              return null;
            }
            var date2 = dayjs(formatText, format2, true).locale(localeStr);
            if (date2.isValid()) {
              return date2;
            }
          }
          if (text2) {
            parseNoMatchNotice();
          }
          return null;
        }
      }
    };
    var PanelContext = /* @__PURE__ */ reactExports.createContext({});
    var HIDDEN_STYLE$1 = {
      visibility: "hidden"
    };
    function Header$3(_ref) {
      var prefixCls = _ref.prefixCls, _ref$prevIcon = _ref.prevIcon, prevIcon = _ref$prevIcon === void 0 ? "‹" : _ref$prevIcon, _ref$nextIcon = _ref.nextIcon, nextIcon = _ref$nextIcon === void 0 ? "›" : _ref$nextIcon, _ref$superPrevIcon = _ref.superPrevIcon, superPrevIcon = _ref$superPrevIcon === void 0 ? "«" : _ref$superPrevIcon, _ref$superNextIcon = _ref.superNextIcon, superNextIcon = _ref$superNextIcon === void 0 ? "»" : _ref$superNextIcon, onSuperPrev = _ref.onSuperPrev, onSuperNext = _ref.onSuperNext, onPrev = _ref.onPrev, onNext = _ref.onNext, children = _ref.children;
      var _React$useContext = reactExports.useContext(PanelContext), hideNextBtn = _React$useContext.hideNextBtn, hidePrevBtn = _React$useContext.hidePrevBtn;
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: prefixCls
      }, onSuperPrev && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onSuperPrev,
        tabIndex: -1,
        className: "".concat(prefixCls, "-super-prev-btn"),
        style: hidePrevBtn ? HIDDEN_STYLE$1 : {}
      }, superPrevIcon), onPrev && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onPrev,
        tabIndex: -1,
        className: "".concat(prefixCls, "-prev-btn"),
        style: hidePrevBtn ? HIDDEN_STYLE$1 : {}
      }, prevIcon), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-view")
      }, children), onNext && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onNext,
        tabIndex: -1,
        className: "".concat(prefixCls, "-next-btn"),
        style: hideNextBtn ? HIDDEN_STYLE$1 : {}
      }, nextIcon), onSuperNext && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onSuperNext,
        tabIndex: -1,
        className: "".concat(prefixCls, "-super-next-btn"),
        style: hideNextBtn ? HIDDEN_STYLE$1 : {}
      }, superNextIcon));
    }
    function DecadeHeader(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, viewDate = props.viewDate, onPrevDecades = props.onPrevDecades, onNextDecades = props.onNextDecades;
      var _React$useContext = reactExports.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
      if (hideHeader) {
        return null;
      }
      var headerPrefixCls = "".concat(prefixCls, "-header");
      var yearNumber = generateConfig2.getYear(viewDate);
      var startYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
      var endYear = startYear + DECADE_DISTANCE_COUNT - 1;
      return /* @__PURE__ */ reactExports.createElement(Header$3, _extends$2({}, props, {
        prefixCls: headerPrefixCls,
        onSuperPrev: onPrevDecades,
        onSuperNext: onNextDecades
      }), startYear, "-", endYear);
    }
    function setTime(generateConfig2, date2, hour, minute, second) {
      var nextTime = generateConfig2.setHour(date2, hour);
      nextTime = generateConfig2.setMinute(nextTime, minute);
      nextTime = generateConfig2.setSecond(nextTime, second);
      return nextTime;
    }
    function setDateTime(generateConfig2, date2, defaultDate) {
      if (!defaultDate) {
        return date2;
      }
      var newDate = date2;
      newDate = generateConfig2.setHour(newDate, generateConfig2.getHour(defaultDate));
      newDate = generateConfig2.setMinute(newDate, generateConfig2.getMinute(defaultDate));
      newDate = generateConfig2.setSecond(newDate, generateConfig2.getSecond(defaultDate));
      return newDate;
    }
    function getLowerBoundTime(hour, minute, second, hourStep, minuteStep, secondStep) {
      var lowerBoundHour = Math.floor(hour / hourStep) * hourStep;
      if (lowerBoundHour < hour) {
        return [lowerBoundHour, 60 - minuteStep, 60 - secondStep];
      }
      var lowerBoundMinute = Math.floor(minute / minuteStep) * minuteStep;
      if (lowerBoundMinute < minute) {
        return [lowerBoundHour, lowerBoundMinute, 60 - secondStep];
      }
      var lowerBoundSecond = Math.floor(second / secondStep) * secondStep;
      return [lowerBoundHour, lowerBoundMinute, lowerBoundSecond];
    }
    function getLastDay(generateConfig2, date2) {
      var year = generateConfig2.getYear(date2);
      var month = generateConfig2.getMonth(date2) + 1;
      var endDate = generateConfig2.getEndDate(generateConfig2.getFixedDate("".concat(year, "-").concat(month, "-01")));
      var lastDay = generateConfig2.getDate(endDate);
      var monthShow = month < 10 ? "0".concat(month) : "".concat(month);
      return "".concat(year, "-").concat(monthShow, "-").concat(lastDay);
    }
    function PanelBody(_ref) {
      var prefixCls = _ref.prefixCls, disabledDate = _ref.disabledDate, onSelect = _ref.onSelect, picker = _ref.picker, rowNum = _ref.rowNum, colNum = _ref.colNum, prefixColumn = _ref.prefixColumn, rowClassName = _ref.rowClassName, baseDate = _ref.baseDate, getCellClassName = _ref.getCellClassName, getCellText = _ref.getCellText, getCellNode = _ref.getCellNode, getCellDate = _ref.getCellDate, generateConfig2 = _ref.generateConfig, titleCell = _ref.titleCell, headerCells = _ref.headerCells;
      var _React$useContext = reactExports.useContext(PanelContext), onDateMouseEnter = _React$useContext.onDateMouseEnter, onDateMouseLeave = _React$useContext.onDateMouseLeave, mode = _React$useContext.mode;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var rows = [];
      for (var i2 = 0; i2 < rowNum; i2 += 1) {
        var row = [];
        var rowStartDate = void 0;
        var _loop = function _loop2() {
          var _objectSpread22;
          var offset2 = i2 * colNum + j;
          var currentDate = getCellDate(baseDate, offset2);
          var disabled = getCellDateDisabled({
            cellDate: currentDate,
            mode,
            disabledDate,
            generateConfig: generateConfig2
          });
          if (j === 0) {
            rowStartDate = currentDate;
            if (prefixColumn) {
              row.push(prefixColumn(rowStartDate));
            }
          }
          var title = titleCell && titleCell(currentDate);
          row.push(/* @__PURE__ */ reactExports.createElement("td", {
            key: j,
            title,
            className: classNames(cellPrefixCls, _objectSpread2$3((_objectSpread22 = {}, _defineProperty$7(_objectSpread22, "".concat(cellPrefixCls, "-disabled"), disabled), _defineProperty$7(_objectSpread22, "".concat(cellPrefixCls, "-start"), getCellText(currentDate) === 1 || picker === "year" && Number(title) % 10 === 0), _defineProperty$7(_objectSpread22, "".concat(cellPrefixCls, "-end"), title === getLastDay(generateConfig2, currentDate) || picker === "year" && Number(title) % 10 === 9), _objectSpread22), getCellClassName(currentDate))),
            onClick: function onClick() {
              if (!disabled) {
                onSelect(currentDate);
              }
            },
            onMouseEnter: function onMouseEnter() {
              if (!disabled && onDateMouseEnter) {
                onDateMouseEnter(currentDate);
              }
            },
            onMouseLeave: function onMouseLeave() {
              if (!disabled && onDateMouseLeave) {
                onDateMouseLeave(currentDate);
              }
            }
          }, getCellNode ? getCellNode(currentDate) : /* @__PURE__ */ reactExports.createElement("div", {
            className: "".concat(cellPrefixCls, "-inner")
          }, getCellText(currentDate))));
        };
        for (var j = 0; j < colNum; j += 1) {
          _loop();
        }
        rows.push(/* @__PURE__ */ reactExports.createElement("tr", {
          key: i2,
          className: rowClassName && rowClassName(rowStartDate)
        }, row));
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-body")
      }, /* @__PURE__ */ reactExports.createElement("table", {
        className: "".concat(prefixCls, "-content")
      }, headerCells && /* @__PURE__ */ reactExports.createElement("thead", null, /* @__PURE__ */ reactExports.createElement("tr", null, headerCells)), /* @__PURE__ */ reactExports.createElement("tbody", null, rows)));
    }
    var DECADE_COL_COUNT = 3;
    var DECADE_ROW_COUNT = 4;
    function DecadeBody(props) {
      var DECADE_UNIT_DIFF_DES = DECADE_UNIT_DIFF - 1;
      var prefixCls = props.prefixCls, viewDate = props.viewDate, generateConfig2 = props.generateConfig;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var yearNumber = generateConfig2.getYear(viewDate);
      var decadeYearNumber = Math.floor(yearNumber / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
      var startDecadeYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
      var endDecadeYear = startDecadeYear + DECADE_DISTANCE_COUNT - 1;
      var baseDecadeYear = generateConfig2.setYear(viewDate, startDecadeYear - Math.ceil((DECADE_COL_COUNT * DECADE_ROW_COUNT * DECADE_UNIT_DIFF - DECADE_DISTANCE_COUNT) / 2));
      var getCellClassName = function getCellClassName2(date2) {
        var _ref;
        var startDecadeNumber = generateConfig2.getYear(date2);
        var endDecadeNumber = startDecadeNumber + DECADE_UNIT_DIFF_DES;
        return _ref = {}, _defineProperty$7(_ref, "".concat(cellPrefixCls, "-in-view"), startDecadeYear <= startDecadeNumber && endDecadeNumber <= endDecadeYear), _defineProperty$7(_ref, "".concat(cellPrefixCls, "-selected"), startDecadeNumber === decadeYearNumber), _ref;
      };
      return /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$2({}, props, {
        rowNum: DECADE_ROW_COUNT,
        colNum: DECADE_COL_COUNT,
        baseDate: baseDecadeYear,
        getCellText: function getCellText(date2) {
          var startDecadeNumber = generateConfig2.getYear(date2);
          return "".concat(startDecadeNumber, "-").concat(startDecadeNumber + DECADE_UNIT_DIFF_DES);
        },
        getCellClassName,
        getCellDate: function getCellDate(date2, offset2) {
          return generateConfig2.addYear(date2, offset2 * DECADE_UNIT_DIFF);
        }
      }));
    }
    var scrollIds = /* @__PURE__ */ new Map();
    function waitElementReady(element, callback) {
      var id2;
      function tryOrNextFrame() {
        if (isVisible$1(element)) {
          callback();
        } else {
          id2 = wrapperRaf(function() {
            tryOrNextFrame();
          });
        }
      }
      tryOrNextFrame();
      return function() {
        wrapperRaf.cancel(id2);
      };
    }
    function scrollTo(element, to, duration) {
      if (scrollIds.get(element)) {
        cancelAnimationFrame(scrollIds.get(element));
      }
      if (duration <= 0) {
        scrollIds.set(element, requestAnimationFrame(function() {
          element.scrollTop = to;
        }));
        return;
      }
      var difference = to - element.scrollTop;
      var perTick = difference / duration * 10;
      scrollIds.set(element, requestAnimationFrame(function() {
        element.scrollTop += perTick;
        if (element.scrollTop !== to) {
          scrollTo(element, to, duration - 10);
        }
      }));
    }
    function createKeyDownHandler(event, _ref) {
      var onLeftRight = _ref.onLeftRight, onCtrlLeftRight = _ref.onCtrlLeftRight, onUpDown = _ref.onUpDown, onPageUpDown = _ref.onPageUpDown, onEnter = _ref.onEnter;
      var which = event.which, ctrlKey = event.ctrlKey, metaKey = event.metaKey;
      switch (which) {
        case KeyCode.LEFT:
          if (ctrlKey || metaKey) {
            if (onCtrlLeftRight) {
              onCtrlLeftRight(-1);
              return true;
            }
          } else if (onLeftRight) {
            onLeftRight(-1);
            return true;
          }
          break;
        case KeyCode.RIGHT:
          if (ctrlKey || metaKey) {
            if (onCtrlLeftRight) {
              onCtrlLeftRight(1);
              return true;
            }
          } else if (onLeftRight) {
            onLeftRight(1);
            return true;
          }
          break;
        case KeyCode.UP:
          if (onUpDown) {
            onUpDown(-1);
            return true;
          }
          break;
        case KeyCode.DOWN:
          if (onUpDown) {
            onUpDown(1);
            return true;
          }
          break;
        case KeyCode.PAGE_UP:
          if (onPageUpDown) {
            onPageUpDown(-1);
            return true;
          }
          break;
        case KeyCode.PAGE_DOWN:
          if (onPageUpDown) {
            onPageUpDown(1);
            return true;
          }
          break;
        case KeyCode.ENTER:
          if (onEnter) {
            onEnter();
            return true;
          }
          break;
      }
      return false;
    }
    function getDefaultFormat(format2, picker, showTime, use12Hours) {
      var mergedFormat = format2;
      if (!mergedFormat) {
        switch (picker) {
          case "time":
            mergedFormat = use12Hours ? "hh:mm:ss a" : "HH:mm:ss";
            break;
          case "week":
            mergedFormat = "gggg-wo";
            break;
          case "month":
            mergedFormat = "YYYY-MM";
            break;
          case "quarter":
            mergedFormat = "YYYY-[Q]Q";
            break;
          case "year":
            mergedFormat = "YYYY";
            break;
          default:
            mergedFormat = showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
        }
      }
      return mergedFormat;
    }
    function getInputSize(picker, format2, generateConfig2) {
      var defaultSize = picker === "time" ? 8 : 10;
      var length2 = typeof format2 === "function" ? format2(generateConfig2.getNow()).length : format2.length;
      return Math.max(defaultSize, length2) + 2;
    }
    var globalClickFunc = null;
    var clickCallbacks = /* @__PURE__ */ new Set();
    function addGlobalMouseDownEvent(callback) {
      if (!globalClickFunc && typeof window !== "undefined" && window.addEventListener) {
        globalClickFunc = function globalClickFunc2(e2) {
          _toConsumableArray(clickCallbacks).forEach(function(queueFunc) {
            queueFunc(e2);
          });
        };
        window.addEventListener("mousedown", globalClickFunc);
      }
      clickCallbacks.add(callback);
      return function() {
        clickCallbacks.delete(callback);
        if (clickCallbacks.size === 0) {
          window.removeEventListener("mousedown", globalClickFunc);
          globalClickFunc = null;
        }
      };
    }
    function getTargetFromEvent(e2) {
      var target = e2.target;
      if (e2.composed && target.shadowRoot) {
        var _e$composedPath;
        return ((_e$composedPath = e2.composedPath) === null || _e$composedPath === void 0 ? void 0 : _e$composedPath.call(e2)[0]) || target;
      }
      return target;
    }
    var getYearNextMode = function getYearNextMode2(next2) {
      if (next2 === "month" || next2 === "date") {
        return "year";
      }
      return next2;
    };
    var getMonthNextMode = function getMonthNextMode2(next2) {
      if (next2 === "date") {
        return "month";
      }
      return next2;
    };
    var getQuarterNextMode = function getQuarterNextMode2(next2) {
      if (next2 === "month" || next2 === "date") {
        return "quarter";
      }
      return next2;
    };
    var getWeekNextMode = function getWeekNextMode2(next2) {
      if (next2 === "date") {
        return "week";
      }
      return next2;
    };
    var PickerModeMap = {
      year: getYearNextMode,
      month: getMonthNextMode,
      quarter: getQuarterNextMode,
      week: getWeekNextMode,
      time: null,
      date: null
    };
    function elementsContains(elements, target) {
      return elements.some(function(ele) {
        return ele && ele.contains(target);
      });
    }
    var DECADE_UNIT_DIFF = 10;
    var DECADE_DISTANCE_COUNT = DECADE_UNIT_DIFF * 10;
    function DecadePanel(props) {
      var prefixCls = props.prefixCls, onViewDateChange = props.onViewDateChange, generateConfig2 = props.generateConfig, viewDate = props.viewDate, operationRef = props.operationRef, onSelect = props.onSelect, onPanelChange = props.onPanelChange;
      var panelPrefixCls = "".concat(prefixCls, "-decade-panel");
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          return createKeyDownHandler(event, {
            onLeftRight: function onLeftRight(diff) {
              onSelect(generateConfig2.addYear(viewDate, diff * DECADE_UNIT_DIFF), "key");
            },
            onCtrlLeftRight: function onCtrlLeftRight(diff) {
              onSelect(generateConfig2.addYear(viewDate, diff * DECADE_DISTANCE_COUNT), "key");
            },
            onUpDown: function onUpDown(diff) {
              onSelect(generateConfig2.addYear(viewDate, diff * DECADE_UNIT_DIFF * DECADE_COL_COUNT), "key");
            },
            onEnter: function onEnter() {
              onPanelChange("year", viewDate);
            }
          });
        }
      };
      var onDecadesChange = function onDecadesChange2(diff) {
        var newDate = generateConfig2.addYear(viewDate, diff * DECADE_DISTANCE_COUNT);
        onViewDateChange(newDate);
        onPanelChange(null, newDate);
      };
      var onInternalSelect = function onInternalSelect2(date2) {
        onSelect(date2, "mouse");
        onPanelChange("year", date2);
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: panelPrefixCls
      }, /* @__PURE__ */ reactExports.createElement(DecadeHeader, _extends$2({}, props, {
        prefixCls,
        onPrevDecades: function onPrevDecades() {
          onDecadesChange(-1);
        },
        onNextDecades: function onNextDecades() {
          onDecadesChange(1);
        }
      })), /* @__PURE__ */ reactExports.createElement(DecadeBody, _extends$2({}, props, {
        prefixCls,
        onSelect: onInternalSelect
      })));
    }
    var WEEK_DAY_COUNT = 7;
    function isNullEqual(value1, value2) {
      if (!value1 && !value2) {
        return true;
      }
      if (!value1 || !value2) {
        return false;
      }
      return void 0;
    }
    function isSameDecade(generateConfig2, decade1, decade2) {
      var equal = isNullEqual(decade1, decade2);
      if (typeof equal === "boolean") {
        return equal;
      }
      var num1 = Math.floor(generateConfig2.getYear(decade1) / 10);
      var num2 = Math.floor(generateConfig2.getYear(decade2) / 10);
      return num1 === num2;
    }
    function isSameYear(generateConfig2, year1, year2) {
      var equal = isNullEqual(year1, year2);
      if (typeof equal === "boolean") {
        return equal;
      }
      return generateConfig2.getYear(year1) === generateConfig2.getYear(year2);
    }
    function getQuarter(generateConfig2, date2) {
      var quota = Math.floor(generateConfig2.getMonth(date2) / 3);
      return quota + 1;
    }
    function isSameQuarter(generateConfig2, quarter1, quarter2) {
      var equal = isNullEqual(quarter1, quarter2);
      if (typeof equal === "boolean") {
        return equal;
      }
      return isSameYear(generateConfig2, quarter1, quarter2) && getQuarter(generateConfig2, quarter1) === getQuarter(generateConfig2, quarter2);
    }
    function isSameMonth(generateConfig2, month1, month2) {
      var equal = isNullEqual(month1, month2);
      if (typeof equal === "boolean") {
        return equal;
      }
      return isSameYear(generateConfig2, month1, month2) && generateConfig2.getMonth(month1) === generateConfig2.getMonth(month2);
    }
    function isSameDate(generateConfig2, date1, date2) {
      var equal = isNullEqual(date1, date2);
      if (typeof equal === "boolean") {
        return equal;
      }
      return generateConfig2.getYear(date1) === generateConfig2.getYear(date2) && generateConfig2.getMonth(date1) === generateConfig2.getMonth(date2) && generateConfig2.getDate(date1) === generateConfig2.getDate(date2);
    }
    function isSameTime(generateConfig2, time1, time2) {
      var equal = isNullEqual(time1, time2);
      if (typeof equal === "boolean") {
        return equal;
      }
      return generateConfig2.getHour(time1) === generateConfig2.getHour(time2) && generateConfig2.getMinute(time1) === generateConfig2.getMinute(time2) && generateConfig2.getSecond(time1) === generateConfig2.getSecond(time2);
    }
    function isSameWeek(generateConfig2, locale2, date1, date2) {
      var equal = isNullEqual(date1, date2);
      if (typeof equal === "boolean") {
        return equal;
      }
      return generateConfig2.locale.getWeek(locale2, date1) === generateConfig2.locale.getWeek(locale2, date2);
    }
    function isEqual(generateConfig2, value1, value2) {
      return isSameDate(generateConfig2, value1, value2) && isSameTime(generateConfig2, value1, value2);
    }
    function isInRange(generateConfig2, startDate, endDate, current) {
      if (!startDate || !endDate || !current) {
        return false;
      }
      return !isSameDate(generateConfig2, startDate, current) && !isSameDate(generateConfig2, endDate, current) && generateConfig2.isAfter(current, startDate) && generateConfig2.isAfter(endDate, current);
    }
    function getWeekStartDate(locale2, generateConfig2, value) {
      var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2);
      var monthStartDate = generateConfig2.setDate(value, 1);
      var startDateWeekDay = generateConfig2.getWeekDay(monthStartDate);
      var alignStartDate = generateConfig2.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
      if (generateConfig2.getMonth(alignStartDate) === generateConfig2.getMonth(value) && generateConfig2.getDate(alignStartDate) > 1) {
        alignStartDate = generateConfig2.addDate(alignStartDate, -7);
      }
      return alignStartDate;
    }
    function getClosingViewDate(viewDate, picker, generateConfig2) {
      var offset2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
      switch (picker) {
        case "year":
          return generateConfig2.addYear(viewDate, offset2 * 10);
        case "quarter":
        case "month":
          return generateConfig2.addYear(viewDate, offset2);
        default:
          return generateConfig2.addMonth(viewDate, offset2);
      }
    }
    function formatValue(value, _ref) {
      var generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, format2 = _ref.format;
      return typeof format2 === "function" ? format2(value) : generateConfig2.locale.format(locale2.locale, value, format2);
    }
    function parseValue(value, _ref2) {
      var generateConfig2 = _ref2.generateConfig, locale2 = _ref2.locale, formatList = _ref2.formatList;
      if (!value || typeof formatList[0] === "function") {
        return null;
      }
      return generateConfig2.locale.parse(locale2.locale, value, formatList);
    }
    function getCellDateDisabled(_ref3) {
      var cellDate = _ref3.cellDate, mode = _ref3.mode, disabledDate = _ref3.disabledDate, generateConfig2 = _ref3.generateConfig;
      if (!disabledDate)
        return false;
      var getDisabledFromRange = function getDisabledFromRange2(currentMode, start2, end2) {
        var current = start2;
        while (current <= end2) {
          var _date = void 0;
          switch (currentMode) {
            case "date": {
              _date = generateConfig2.setDate(cellDate, current);
              if (!disabledDate(_date)) {
                return false;
              }
              break;
            }
            case "month": {
              _date = generateConfig2.setMonth(cellDate, current);
              if (!getCellDateDisabled({
                cellDate: _date,
                mode: "month",
                generateConfig: generateConfig2,
                disabledDate
              })) {
                return false;
              }
              break;
            }
            case "year": {
              _date = generateConfig2.setYear(cellDate, current);
              if (!getCellDateDisabled({
                cellDate: _date,
                mode: "year",
                generateConfig: generateConfig2,
                disabledDate
              })) {
                return false;
              }
              break;
            }
          }
          current += 1;
        }
        return true;
      };
      switch (mode) {
        case "date":
        case "week": {
          return disabledDate(cellDate);
        }
        case "month": {
          var startDate = 1;
          var endDate = generateConfig2.getDate(generateConfig2.getEndDate(cellDate));
          return getDisabledFromRange("date", startDate, endDate);
        }
        case "quarter": {
          var startMonth = Math.floor(generateConfig2.getMonth(cellDate) / 3) * 3;
          var endMonth = startMonth + 2;
          return getDisabledFromRange("month", startMonth, endMonth);
        }
        case "year": {
          return getDisabledFromRange("month", 0, 11);
        }
        case "decade": {
          var year = generateConfig2.getYear(cellDate);
          var startYear = Math.floor(year / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
          var endYear = startYear + DECADE_UNIT_DIFF - 1;
          return getDisabledFromRange("year", startYear, endYear);
        }
      }
    }
    function useValueTexts(value, _ref) {
      var formatList = _ref.formatList, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale;
      return useMemo(function() {
        if (!value) {
          return [[""], ""];
        }
        var firstValueText = "";
        var fullValueTexts = [];
        for (var i2 = 0; i2 < formatList.length; i2 += 1) {
          var format2 = formatList[i2];
          var formatStr = formatValue(value, {
            generateConfig: generateConfig2,
            locale: locale2,
            format: format2
          });
          fullValueTexts.push(formatStr);
          if (i2 === 0) {
            firstValueText = formatStr;
          }
        }
        return [fullValueTexts, firstValueText];
      }, [value, formatList], function(prev2, next2) {
        return (
          // Not Same Date
          !isEqual(generateConfig2, prev2[0], next2[0]) || // Not Same format
          !isEqual$1(prev2[1], next2[1], true)
        );
      });
    }
    function useHoverValue(valueText, _ref) {
      var formatList = _ref.formatList, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale;
      var _useState = reactExports.useState(null), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], internalSetValue = _useState2[1];
      var raf2 = reactExports.useRef(null);
      function setValue2(val) {
        var immediately = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        cancelAnimationFrame(raf2.current);
        if (immediately) {
          internalSetValue(val);
          return;
        }
        raf2.current = requestAnimationFrame(function() {
          internalSetValue(val);
        });
      }
      var _useValueTexts = useValueTexts(value, {
        formatList,
        generateConfig: generateConfig2,
        locale: locale2
      }), _useValueTexts2 = _slicedToArray(_useValueTexts, 2), firstText = _useValueTexts2[1];
      function onEnter(date2) {
        setValue2(date2);
      }
      function onLeave() {
        var immediately = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        setValue2(null, immediately);
      }
      reactExports.useEffect(function() {
        onLeave(true);
      }, [valueText]);
      reactExports.useEffect(function() {
        return function() {
          return cancelAnimationFrame(raf2.current);
        };
      }, []);
      return [firstText, onEnter, onLeave];
    }
    function usePickerInput(_ref) {
      var open2 = _ref.open, value = _ref.value, isClickOutside = _ref.isClickOutside, triggerOpen = _ref.triggerOpen, forwardKeyDown = _ref.forwardKeyDown, _onKeyDown = _ref.onKeyDown, blurToCancel = _ref.blurToCancel, onSubmit = _ref.onSubmit, onCancel = _ref.onCancel, _onFocus = _ref.onFocus, _onBlur = _ref.onBlur;
      var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), typing = _useState2[0], setTyping = _useState2[1];
      var _useState3 = reactExports.useState(false), _useState4 = _slicedToArray(_useState3, 2), focused = _useState4[0], setFocused = _useState4[1];
      var preventBlurRef = reactExports.useRef(false);
      var valueChangedRef = reactExports.useRef(false);
      var preventDefaultRef = reactExports.useRef(false);
      var inputProps = {
        onMouseDown: function onMouseDown() {
          setTyping(true);
          triggerOpen(true);
        },
        onKeyDown: function onKeyDown2(e2) {
          var preventDefault = function preventDefault2() {
            preventDefaultRef.current = true;
          };
          _onKeyDown(e2, preventDefault);
          if (preventDefaultRef.current)
            return;
          switch (e2.which) {
            case KeyCode.ENTER: {
              if (!open2) {
                triggerOpen(true);
              } else if (onSubmit() !== false) {
                setTyping(true);
              }
              e2.preventDefault();
              return;
            }
            case KeyCode.TAB: {
              if (typing && open2 && !e2.shiftKey) {
                setTyping(false);
                e2.preventDefault();
              } else if (!typing && open2) {
                if (!forwardKeyDown(e2) && e2.shiftKey) {
                  setTyping(true);
                  e2.preventDefault();
                }
              }
              return;
            }
            case KeyCode.ESC: {
              setTyping(true);
              onCancel();
              return;
            }
          }
          if (!open2 && ![KeyCode.SHIFT].includes(e2.which)) {
            triggerOpen(true);
          } else if (!typing) {
            forwardKeyDown(e2);
          }
        },
        onFocus: function onFocus(e2) {
          setTyping(true);
          setFocused(true);
          if (_onFocus) {
            _onFocus(e2);
          }
        },
        onBlur: function onBlur(e2) {
          if (preventBlurRef.current || !isClickOutside(document.activeElement)) {
            preventBlurRef.current = false;
            return;
          }
          if (blurToCancel) {
            setTimeout(function() {
              var _document = document, activeElement = _document.activeElement;
              while (activeElement && activeElement.shadowRoot) {
                activeElement = activeElement.shadowRoot.activeElement;
              }
              if (isClickOutside(activeElement)) {
                onCancel();
              }
            }, 0);
          } else if (open2) {
            triggerOpen(false);
            if (valueChangedRef.current) {
              onSubmit();
            }
          }
          setFocused(false);
          if (_onBlur) {
            _onBlur(e2);
          }
        }
      };
      reactExports.useEffect(function() {
        valueChangedRef.current = false;
      }, [open2]);
      reactExports.useEffect(function() {
        valueChangedRef.current = true;
      }, [value]);
      reactExports.useEffect(function() {
        return addGlobalMouseDownEvent(function(e2) {
          var target = getTargetFromEvent(e2);
          if (open2) {
            var clickedOutside = isClickOutside(target);
            if (!clickedOutside) {
              preventBlurRef.current = true;
              requestAnimationFrame(function() {
                preventBlurRef.current = false;
              });
            } else if (!focused || clickedOutside) {
              triggerOpen(false);
            }
          }
        });
      });
      return [inputProps, {
        focused,
        typing
      }];
    }
    function usePresets(presets, legacyRanges) {
      return reactExports.useMemo(function() {
        if (presets) {
          return presets;
        }
        if (legacyRanges) {
          warningOnce$1(false, "`ranges` is deprecated. Please use `presets` instead.");
          var rangeLabels = Object.keys(legacyRanges);
          return rangeLabels.map(function(label) {
            var range2 = legacyRanges[label];
            var newValues = typeof range2 === "function" ? range2() : range2;
            return {
              label,
              value: newValues
            };
          });
        }
        return [];
      }, [presets, legacyRanges]);
    }
    function useTextValueMapping(_ref) {
      var valueTexts = _ref.valueTexts, onTextChange = _ref.onTextChange;
      var _React$useState = reactExports.useState(""), _React$useState2 = _slicedToArray(_React$useState, 2), text2 = _React$useState2[0], setInnerText = _React$useState2[1];
      var valueTextsRef = reactExports.useRef([]);
      valueTextsRef.current = valueTexts;
      function triggerTextChange(value) {
        setInnerText(value);
        onTextChange(value);
      }
      function resetText() {
        setInnerText(valueTextsRef.current[0]);
      }
      useLayoutEffect$1(function() {
        if (valueTexts.every(function(valText) {
          return valText !== text2;
        })) {
          resetText();
        }
      }, [valueTexts.join("||")]);
      return [text2, triggerTextChange, resetText];
    }
    function TimeHeader(props) {
      var _React$useContext = reactExports.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
      if (hideHeader) {
        return null;
      }
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, value = props.value, format2 = props.format;
      var headerPrefixCls = "".concat(prefixCls, "-header");
      return /* @__PURE__ */ reactExports.createElement(Header$3, {
        prefixCls: headerPrefixCls
      }, value ? formatValue(value, {
        locale: locale2,
        format: format2,
        generateConfig: generateConfig2
      }) : " ");
    }
    function TimeUnitColumn(props) {
      var prefixCls = props.prefixCls, units = props.units, onSelect = props.onSelect, value = props.value, active = props.active, hideDisabledOptions = props.hideDisabledOptions;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var _React$useContext = reactExports.useContext(PanelContext), open2 = _React$useContext.open;
      var ulRef = reactExports.useRef(null);
      var liRefs = reactExports.useRef(/* @__PURE__ */ new Map());
      var scrollRef = reactExports.useRef();
      reactExports.useLayoutEffect(function() {
        var li2 = liRefs.current.get(value);
        if (li2 && open2 !== false) {
          scrollTo(ulRef.current, li2.offsetTop, 120);
        }
      }, [value]);
      reactExports.useLayoutEffect(function() {
        if (open2) {
          var li2 = liRefs.current.get(value);
          if (li2) {
            scrollRef.current = waitElementReady(li2, function() {
              scrollTo(ulRef.current, li2.offsetTop, 0);
            });
          }
        }
        return function() {
          var _scrollRef$current;
          (_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 ? void 0 : _scrollRef$current.call(scrollRef);
        };
      }, [open2]);
      return /* @__PURE__ */ reactExports.createElement("ul", {
        className: classNames("".concat(prefixCls, "-column"), _defineProperty$7({}, "".concat(prefixCls, "-column-active"), active)),
        ref: ulRef,
        style: {
          position: "relative"
        }
      }, units.map(function(unit) {
        var _classNames2;
        if (hideDisabledOptions && unit.disabled) {
          return null;
        }
        return /* @__PURE__ */ reactExports.createElement("li", {
          key: unit.value,
          ref: function ref(element) {
            liRefs.current.set(unit.value, element);
          },
          className: classNames(cellPrefixCls, (_classNames2 = {}, _defineProperty$7(_classNames2, "".concat(cellPrefixCls, "-disabled"), unit.disabled), _defineProperty$7(_classNames2, "".concat(cellPrefixCls, "-selected"), value === unit.value), _classNames2)),
          onClick: function onClick() {
            if (unit.disabled) {
              return;
            }
            onSelect(unit.value);
          }
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(cellPrefixCls, "-inner")
        }, unit.label));
      }));
    }
    function leftPad(str, length2) {
      var fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
      var current = String(str);
      while (current.length < length2) {
        current = "".concat(fill).concat(str);
      }
      return current;
    }
    var tuple = function tuple2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return args;
    };
    function toArray$4(val) {
      if (val === null || val === void 0) {
        return [];
      }
      return Array.isArray(val) ? val : [val];
    }
    function getDataOrAriaProps(props) {
      var retProps = {};
      Object.keys(props).forEach(function(key) {
        if ((key.substr(0, 5) === "data-" || key.substr(0, 5) === "aria-" || key === "role" || key === "name") && key.substr(0, 7) !== "data-__") {
          retProps[key] = props[key];
        }
      });
      return retProps;
    }
    function getValue$1(values, index2) {
      return values ? values[index2] : null;
    }
    function updateValues(values, value, index2) {
      var newValues = [getValue$1(values, 0), getValue$1(values, 1)];
      newValues[index2] = typeof value === "function" ? value(newValues[index2]) : value;
      if (!newValues[0] && !newValues[1]) {
        return null;
      }
      return newValues;
    }
    function shouldUnitsUpdate(prevUnits, nextUnits) {
      if (prevUnits.length !== nextUnits.length)
        return true;
      for (var i2 = 0; i2 < prevUnits.length; i2 += 1) {
        if (prevUnits[i2].disabled !== nextUnits[i2].disabled)
          return true;
      }
      return false;
    }
    function generateUnits(start2, end2, step, disabledUnits) {
      var units = [];
      for (var i2 = start2; i2 <= end2; i2 += step) {
        units.push({
          label: leftPad(i2, 2),
          value: i2,
          disabled: (disabledUnits || []).includes(i2)
        });
      }
      return units;
    }
    function TimeBody(props) {
      var generateConfig2 = props.generateConfig, prefixCls = props.prefixCls, operationRef = props.operationRef, activeColumnIndex = props.activeColumnIndex, value = props.value, showHour = props.showHour, showMinute = props.showMinute, showSecond = props.showSecond, use12Hours = props.use12Hours, _props$hourStep = props.hourStep, hourStep = _props$hourStep === void 0 ? 1 : _props$hourStep, _props$minuteStep = props.minuteStep, minuteStep = _props$minuteStep === void 0 ? 1 : _props$minuteStep, _props$secondStep = props.secondStep, secondStep = _props$secondStep === void 0 ? 1 : _props$secondStep, disabledHours = props.disabledHours, disabledMinutes = props.disabledMinutes, disabledSeconds = props.disabledSeconds, disabledTime = props.disabledTime, hideDisabledOptions = props.hideDisabledOptions, onSelect = props.onSelect;
      var columns = [];
      var contentPrefixCls = "".concat(prefixCls, "-content");
      var columnPrefixCls = "".concat(prefixCls, "-time-panel");
      var isPM;
      var originHour = value ? generateConfig2.getHour(value) : -1;
      var hour = originHour;
      var minute = value ? generateConfig2.getMinute(value) : -1;
      var second = value ? generateConfig2.getSecond(value) : -1;
      var now2 = generateConfig2.getNow();
      var _React$useMemo = reactExports.useMemo(function() {
        if (disabledTime) {
          var disabledConfig = disabledTime(now2);
          return [disabledConfig.disabledHours, disabledConfig.disabledMinutes, disabledConfig.disabledSeconds];
        }
        return [disabledHours, disabledMinutes, disabledSeconds];
      }, [disabledHours, disabledMinutes, disabledSeconds, disabledTime, now2]), _React$useMemo2 = _slicedToArray(_React$useMemo, 3), mergedDisabledHours = _React$useMemo2[0], mergedDisabledMinutes = _React$useMemo2[1], mergedDisabledSeconds = _React$useMemo2[2];
      var setTime$1 = function setTime$12(isNewPM, newHour, newMinute, newSecond) {
        var newDate = value || generateConfig2.getNow();
        var mergedHour = Math.max(0, newHour);
        var mergedMinute = Math.max(0, newMinute);
        var mergedSecond = Math.max(0, newSecond);
        newDate = setTime(generateConfig2, newDate, !use12Hours || !isNewPM ? mergedHour : mergedHour + 12, mergedMinute, mergedSecond);
        return newDate;
      };
      var rawHours = generateUnits(0, 23, hourStep, mergedDisabledHours && mergedDisabledHours());
      var memorizedRawHours = useMemo(function() {
        return rawHours;
      }, rawHours, shouldUnitsUpdate);
      if (use12Hours) {
        isPM = hour >= 12;
        hour %= 12;
      }
      var _React$useMemo3 = reactExports.useMemo(function() {
        if (!use12Hours) {
          return [false, false];
        }
        var AMPMDisabled = [true, true];
        memorizedRawHours.forEach(function(_ref) {
          var disabled = _ref.disabled, hourValue = _ref.value;
          if (disabled)
            return;
          if (hourValue >= 12) {
            AMPMDisabled[1] = false;
          } else {
            AMPMDisabled[0] = false;
          }
        });
        return AMPMDisabled;
      }, [use12Hours, memorizedRawHours]), _React$useMemo4 = _slicedToArray(_React$useMemo3, 2), AMDisabled = _React$useMemo4[0], PMDisabled = _React$useMemo4[1];
      var hours = reactExports.useMemo(function() {
        if (!use12Hours)
          return memorizedRawHours;
        return memorizedRawHours.filter(isPM ? function(hourMeta) {
          return hourMeta.value >= 12;
        } : function(hourMeta) {
          return hourMeta.value < 12;
        }).map(function(hourMeta) {
          var hourValue = hourMeta.value % 12;
          var hourLabel = hourValue === 0 ? "12" : leftPad(hourValue, 2);
          return _objectSpread2$3(_objectSpread2$3({}, hourMeta), {}, {
            label: hourLabel,
            value: hourValue
          });
        });
      }, [use12Hours, isPM, memorizedRawHours]);
      var minutes = generateUnits(0, 59, minuteStep, mergedDisabledMinutes && mergedDisabledMinutes(originHour));
      var seconds = generateUnits(0, 59, secondStep, mergedDisabledSeconds && mergedDisabledSeconds(originHour, minute));
      operationRef.current = {
        onUpDown: function onUpDown(diff) {
          var column2 = columns[activeColumnIndex];
          if (column2) {
            var valueIndex = column2.units.findIndex(function(unit) {
              return unit.value === column2.value;
            });
            var unitLen = column2.units.length;
            for (var i2 = 1; i2 < unitLen; i2 += 1) {
              var nextUnit = column2.units[(valueIndex + diff * i2 + unitLen) % unitLen];
              if (nextUnit.disabled !== true) {
                column2.onSelect(nextUnit.value);
                break;
              }
            }
          }
        }
      };
      function addColumnNode(condition, node2, columnValue, units, onColumnSelect) {
        if (condition !== false) {
          columns.push({
            node: /* @__PURE__ */ reactExports.cloneElement(node2, {
              prefixCls: columnPrefixCls,
              value: columnValue,
              active: activeColumnIndex === columns.length,
              onSelect: onColumnSelect,
              units,
              hideDisabledOptions
            }),
            onSelect: onColumnSelect,
            value: columnValue,
            units
          });
        }
      }
      addColumnNode(showHour, /* @__PURE__ */ reactExports.createElement(TimeUnitColumn, {
        key: "hour"
      }), hour, hours, function(num) {
        onSelect(setTime$1(isPM, num, minute, second), "mouse");
      });
      addColumnNode(showMinute, /* @__PURE__ */ reactExports.createElement(TimeUnitColumn, {
        key: "minute"
      }), minute, minutes, function(num) {
        onSelect(setTime$1(isPM, hour, num, second), "mouse");
      });
      addColumnNode(showSecond, /* @__PURE__ */ reactExports.createElement(TimeUnitColumn, {
        key: "second"
      }), second, seconds, function(num) {
        onSelect(setTime$1(isPM, hour, minute, num), "mouse");
      });
      var PMIndex = -1;
      if (typeof isPM === "boolean") {
        PMIndex = isPM ? 1 : 0;
      }
      addColumnNode(use12Hours === true, /* @__PURE__ */ reactExports.createElement(TimeUnitColumn, {
        key: "12hours"
      }), PMIndex, [{
        label: "AM",
        value: 0,
        disabled: AMDisabled
      }, {
        label: "PM",
        value: 1,
        disabled: PMDisabled
      }], function(num) {
        onSelect(setTime$1(!!num, hour, minute, second), "mouse");
      });
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: contentPrefixCls
      }, columns.map(function(_ref2) {
        var node2 = _ref2.node;
        return node2;
      }));
    }
    var countBoolean = function countBoolean2(boolList) {
      return boolList.filter(function(bool) {
        return bool !== false;
      }).length;
    };
    function TimePanel(props) {
      var generateConfig2 = props.generateConfig, _props$format = props.format, format2 = _props$format === void 0 ? "HH:mm:ss" : _props$format, prefixCls = props.prefixCls, active = props.active, operationRef = props.operationRef, showHour = props.showHour, showMinute = props.showMinute, showSecond = props.showSecond, _props$use12Hours = props.use12Hours, use12Hours = _props$use12Hours === void 0 ? false : _props$use12Hours, onSelect = props.onSelect, value = props.value;
      var panelPrefixCls = "".concat(prefixCls, "-time-panel");
      var bodyOperationRef = reactExports.useRef();
      var _React$useState = reactExports.useState(-1), _React$useState2 = _slicedToArray(_React$useState, 2), activeColumnIndex = _React$useState2[0], setActiveColumnIndex = _React$useState2[1];
      var columnsCount = countBoolean([showHour, showMinute, showSecond, use12Hours]);
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          return createKeyDownHandler(event, {
            onLeftRight: function onLeftRight(diff) {
              setActiveColumnIndex((activeColumnIndex + diff + columnsCount) % columnsCount);
            },
            onUpDown: function onUpDown(diff) {
              if (activeColumnIndex === -1) {
                setActiveColumnIndex(0);
              } else if (bodyOperationRef.current) {
                bodyOperationRef.current.onUpDown(diff);
              }
            },
            onEnter: function onEnter() {
              onSelect(value || generateConfig2.getNow(), "key");
              setActiveColumnIndex(-1);
            }
          });
        },
        onBlur: function onBlur() {
          setActiveColumnIndex(-1);
        }
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(panelPrefixCls, _defineProperty$7({}, "".concat(panelPrefixCls, "-active"), active))
      }, /* @__PURE__ */ reactExports.createElement(TimeHeader, _extends$2({}, props, {
        format: format2,
        prefixCls
      })), /* @__PURE__ */ reactExports.createElement(TimeBody, _extends$2({}, props, {
        prefixCls,
        activeColumnIndex,
        operationRef: bodyOperationRef
      })));
    }
    function useCellClassName(_ref) {
      var cellPrefixCls = _ref.cellPrefixCls, generateConfig2 = _ref.generateConfig, rangedValue = _ref.rangedValue, hoverRangedValue = _ref.hoverRangedValue, isInView = _ref.isInView, isSameCell = _ref.isSameCell, offsetCell = _ref.offsetCell, today = _ref.today, value = _ref.value;
      function getClassName(currentDate) {
        var _ref2;
        var prevDate = offsetCell(currentDate, -1);
        var nextDate = offsetCell(currentDate, 1);
        var rangeStart = getValue$1(rangedValue, 0);
        var rangeEnd = getValue$1(rangedValue, 1);
        var hoverStart = getValue$1(hoverRangedValue, 0);
        var hoverEnd = getValue$1(hoverRangedValue, 1);
        var isRangeHovered = isInRange(generateConfig2, hoverStart, hoverEnd, currentDate);
        function isRangeStart(date2) {
          return isSameCell(rangeStart, date2);
        }
        function isRangeEnd(date2) {
          return isSameCell(rangeEnd, date2);
        }
        var isHoverStart = isSameCell(hoverStart, currentDate);
        var isHoverEnd = isSameCell(hoverEnd, currentDate);
        var isHoverEdgeStart = (isRangeHovered || isHoverEnd) && (!isInView(prevDate) || isRangeEnd(prevDate));
        var isHoverEdgeEnd = (isRangeHovered || isHoverStart) && (!isInView(nextDate) || isRangeStart(nextDate));
        return _ref2 = {}, _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-in-view"), isInView(currentDate)), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-in-range"), isInRange(generateConfig2, rangeStart, rangeEnd, currentDate)), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-range-start"), isRangeStart(currentDate)), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-range-end"), isRangeEnd(currentDate)), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-range-start-single"), isRangeStart(currentDate) && !rangeEnd), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-range-end-single"), isRangeEnd(currentDate) && !rangeStart), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-range-start-near-hover"), isRangeStart(currentDate) && (isSameCell(prevDate, hoverStart) || isInRange(generateConfig2, hoverStart, hoverEnd, prevDate))), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-range-end-near-hover"), isRangeEnd(currentDate) && (isSameCell(nextDate, hoverEnd) || isInRange(generateConfig2, hoverStart, hoverEnd, nextDate))), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-range-hover"), isRangeHovered), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-range-hover-start"), isHoverStart), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-range-hover-end"), isHoverEnd), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-start"), isHoverEdgeStart), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-end"), isHoverEdgeEnd), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-start-near-range"), isHoverEdgeStart && isSameCell(prevDate, rangeEnd)), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-end-near-range"), isHoverEdgeEnd && isSameCell(nextDate, rangeStart)), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-today"), isSameCell(today, currentDate)), _defineProperty$7(_ref2, "".concat(cellPrefixCls, "-selected"), isSameCell(value, currentDate)), _ref2;
      }
      return getClassName;
    }
    var RangeContext = /* @__PURE__ */ reactExports.createContext({});
    function DateBody(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, prefixColumn = props.prefixColumn, locale2 = props.locale, rowCount = props.rowCount, viewDate = props.viewDate, value = props.value, dateRender = props.dateRender, isSameCell = props.isSameCell;
      var _React$useContext = reactExports.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
      var baseDate = getWeekStartDate(locale2.locale, generateConfig2, viewDate);
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2.locale);
      var today = generateConfig2.getNow();
      var headerCells = [];
      var weekDaysLocale = locale2.shortWeekDays || (generateConfig2.locale.getShortWeekDays ? generateConfig2.locale.getShortWeekDays(locale2.locale) : []);
      if (prefixColumn) {
        headerCells.push(/* @__PURE__ */ reactExports.createElement("th", {
          key: "empty",
          "aria-label": "empty cell"
        }));
      }
      for (var i2 = 0; i2 < WEEK_DAY_COUNT; i2 += 1) {
        headerCells.push(/* @__PURE__ */ reactExports.createElement("th", {
          key: i2
        }, weekDaysLocale[(i2 + weekFirstDay) % WEEK_DAY_COUNT]));
      }
      var getCellClassName = useCellClassName({
        cellPrefixCls,
        today,
        value,
        generateConfig: generateConfig2,
        rangedValue: prefixColumn ? null : rangedValue,
        hoverRangedValue: prefixColumn ? null : hoverRangedValue,
        isSameCell: isSameCell || function(current, target) {
          return isSameDate(generateConfig2, current, target);
        },
        isInView: function isInView(date2) {
          return isSameMonth(generateConfig2, date2, viewDate);
        },
        offsetCell: function offsetCell(date2, offset2) {
          return generateConfig2.addDate(date2, offset2);
        }
      });
      var getCellNode = dateRender ? function(date2) {
        return dateRender(date2, today);
      } : void 0;
      return /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$2({}, props, {
        rowNum: rowCount,
        colNum: WEEK_DAY_COUNT,
        baseDate,
        getCellNode,
        getCellText: generateConfig2.getDate,
        getCellClassName,
        getCellDate: generateConfig2.addDate,
        titleCell: function titleCell(date2) {
          return formatValue(date2, {
            locale: locale2,
            format: "YYYY-MM-DD",
            generateConfig: generateConfig2
          });
        },
        headerCells
      }));
    }
    function DateHeader(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, viewDate = props.viewDate, onNextMonth = props.onNextMonth, onPrevMonth = props.onPrevMonth, onNextYear = props.onNextYear, onPrevYear = props.onPrevYear, onYearClick = props.onYearClick, onMonthClick = props.onMonthClick;
      var _React$useContext = reactExports.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
      if (hideHeader) {
        return null;
      }
      var headerPrefixCls = "".concat(prefixCls, "-header");
      var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
      var month = generateConfig2.getMonth(viewDate);
      var yearNode = /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        key: "year",
        onClick: onYearClick,
        tabIndex: -1,
        className: "".concat(prefixCls, "-year-btn")
      }, formatValue(viewDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      }));
      var monthNode = /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        key: "month",
        onClick: onMonthClick,
        tabIndex: -1,
        className: "".concat(prefixCls, "-month-btn")
      }, locale2.monthFormat ? formatValue(viewDate, {
        locale: locale2,
        format: locale2.monthFormat,
        generateConfig: generateConfig2
      }) : monthsLocale[month]);
      var monthYearNodes = locale2.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
      return /* @__PURE__ */ reactExports.createElement(Header$3, _extends$2({}, props, {
        prefixCls: headerPrefixCls,
        onSuperPrev: onPrevYear,
        onPrev: onPrevMonth,
        onNext: onNextMonth,
        onSuperNext: onNextYear
      }), monthYearNodes);
    }
    var DATE_ROW_COUNT = 6;
    function DatePanel(props) {
      var prefixCls = props.prefixCls, _props$panelName = props.panelName, panelName = _props$panelName === void 0 ? "date" : _props$panelName, keyboardConfig = props.keyboardConfig, active = props.active, operationRef = props.operationRef, generateConfig2 = props.generateConfig, value = props.value, viewDate = props.viewDate, onViewDateChange = props.onViewDateChange, onPanelChange = props.onPanelChange, _onSelect = props.onSelect;
      var panelPrefixCls = "".concat(prefixCls, "-").concat(panelName, "-panel");
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          return createKeyDownHandler(event, _objectSpread2$3({
            onLeftRight: function onLeftRight(diff) {
              _onSelect(generateConfig2.addDate(value || viewDate, diff), "key");
            },
            onCtrlLeftRight: function onCtrlLeftRight(diff) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
            },
            onUpDown: function onUpDown(diff) {
              _onSelect(generateConfig2.addDate(value || viewDate, diff * WEEK_DAY_COUNT), "key");
            },
            onPageUpDown: function onPageUpDown(diff) {
              _onSelect(generateConfig2.addMonth(value || viewDate, diff), "key");
            }
          }, keyboardConfig));
        }
      };
      var onYearChange = function onYearChange2(diff) {
        var newDate = generateConfig2.addYear(viewDate, diff);
        onViewDateChange(newDate);
        onPanelChange(null, newDate);
      };
      var onMonthChange = function onMonthChange2(diff) {
        var newDate = generateConfig2.addMonth(viewDate, diff);
        onViewDateChange(newDate);
        onPanelChange(null, newDate);
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(panelPrefixCls, _defineProperty$7({}, "".concat(panelPrefixCls, "-active"), active))
      }, /* @__PURE__ */ reactExports.createElement(DateHeader, _extends$2({}, props, {
        prefixCls,
        value,
        viewDate,
        onPrevYear: function onPrevYear() {
          onYearChange(-1);
        },
        onNextYear: function onNextYear() {
          onYearChange(1);
        },
        onPrevMonth: function onPrevMonth() {
          onMonthChange(-1);
        },
        onNextMonth: function onNextMonth() {
          onMonthChange(1);
        },
        onMonthClick: function onMonthClick() {
          onPanelChange("month", viewDate);
        },
        onYearClick: function onYearClick() {
          onPanelChange("year", viewDate);
        }
      })), /* @__PURE__ */ reactExports.createElement(DateBody, _extends$2({}, props, {
        onSelect: function onSelect(date2) {
          return _onSelect(date2, "mouse");
        },
        prefixCls,
        value,
        viewDate,
        rowCount: DATE_ROW_COUNT
      })));
    }
    var ACTIVE_PANEL = tuple("date", "time");
    function DatetimePanel(props) {
      var prefixCls = props.prefixCls, operationRef = props.operationRef, generateConfig2 = props.generateConfig, value = props.value, defaultValue = props.defaultValue, disabledTime = props.disabledTime, showTime = props.showTime, onSelect = props.onSelect;
      var panelPrefixCls = "".concat(prefixCls, "-datetime-panel");
      var _React$useState = reactExports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), activePanel = _React$useState2[0], setActivePanel = _React$useState2[1];
      var dateOperationRef = reactExports.useRef({});
      var timeOperationRef = reactExports.useRef({});
      var timeProps = _typeof$4(showTime) === "object" ? _objectSpread2$3({}, showTime) : {};
      function getNextActive(offset2) {
        var activeIndex = ACTIVE_PANEL.indexOf(activePanel) + offset2;
        var nextActivePanel = ACTIVE_PANEL[activeIndex] || null;
        return nextActivePanel;
      }
      var onBlur = function onBlur2(e2) {
        if (timeOperationRef.current.onBlur) {
          timeOperationRef.current.onBlur(e2);
        }
        setActivePanel(null);
      };
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          if (event.which === KeyCode.TAB) {
            var nextActivePanel = getNextActive(event.shiftKey ? -1 : 1);
            setActivePanel(nextActivePanel);
            if (nextActivePanel) {
              event.preventDefault();
            }
            return true;
          }
          if (activePanel) {
            var ref = activePanel === "date" ? dateOperationRef : timeOperationRef;
            if (ref.current && ref.current.onKeyDown) {
              ref.current.onKeyDown(event);
            }
            return true;
          }
          if ([KeyCode.LEFT, KeyCode.RIGHT, KeyCode.UP, KeyCode.DOWN].includes(event.which)) {
            setActivePanel("date");
            return true;
          }
          return false;
        },
        onBlur,
        onClose: onBlur
      };
      var onInternalSelect = function onInternalSelect2(date2, source) {
        var selectedDate = date2;
        if (source === "date" && !value && timeProps.defaultValue) {
          selectedDate = generateConfig2.setHour(selectedDate, generateConfig2.getHour(timeProps.defaultValue));
          selectedDate = generateConfig2.setMinute(selectedDate, generateConfig2.getMinute(timeProps.defaultValue));
          selectedDate = generateConfig2.setSecond(selectedDate, generateConfig2.getSecond(timeProps.defaultValue));
        } else if (source === "time" && !value && defaultValue) {
          selectedDate = generateConfig2.setYear(selectedDate, generateConfig2.getYear(defaultValue));
          selectedDate = generateConfig2.setMonth(selectedDate, generateConfig2.getMonth(defaultValue));
          selectedDate = generateConfig2.setDate(selectedDate, generateConfig2.getDate(defaultValue));
        }
        if (onSelect) {
          onSelect(selectedDate, "mouse");
        }
      };
      var disabledTimes = disabledTime ? disabledTime(value || null) : {};
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(panelPrefixCls, _defineProperty$7({}, "".concat(panelPrefixCls, "-active"), activePanel))
      }, /* @__PURE__ */ reactExports.createElement(DatePanel, _extends$2({}, props, {
        operationRef: dateOperationRef,
        active: activePanel === "date",
        onSelect: function onSelect2(date2) {
          onInternalSelect(setDateTime(generateConfig2, date2, !value && _typeof$4(showTime) === "object" ? showTime.defaultValue : null), "date");
        }
      })), /* @__PURE__ */ reactExports.createElement(TimePanel, _extends$2({}, props, {
        format: void 0
      }, timeProps, disabledTimes, {
        disabledTime: null,
        defaultValue: void 0,
        operationRef: timeOperationRef,
        active: activePanel === "time",
        onSelect: function onSelect2(date2) {
          onInternalSelect(date2, "time");
        }
      })));
    }
    function WeekPanel(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, value = props.value, disabledDate = props.disabledDate, onSelect = props.onSelect;
      var _React$useContext = reactExports.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
      var _React$useContext2 = reactExports.useContext(PanelContext), onDateMouseEnter = _React$useContext2.onDateMouseEnter, onDateMouseLeave = _React$useContext2.onDateMouseLeave;
      var rangeStart = (hoverRangedValue === null || hoverRangedValue === void 0 ? void 0 : hoverRangedValue[0]) || (rangedValue === null || rangedValue === void 0 ? void 0 : rangedValue[0]);
      var rangeEnd = (hoverRangedValue === null || hoverRangedValue === void 0 ? void 0 : hoverRangedValue[1]) || (rangedValue === null || rangedValue === void 0 ? void 0 : rangedValue[1]);
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var prefixColumn = function prefixColumn2(date2) {
        var disabled = getCellDateDisabled({
          cellDate: date2,
          mode: "week",
          disabledDate,
          generateConfig: generateConfig2
        });
        return /* @__PURE__ */ reactExports.createElement("td", {
          key: "week",
          className: classNames(cellPrefixCls, "".concat(cellPrefixCls, "-week")),
          onClick: function onClick() {
            if (!disabled) {
              onSelect(date2, "mouse");
            }
          },
          onMouseEnter: function onMouseEnter() {
            if (!disabled && onDateMouseEnter) {
              onDateMouseEnter(date2);
            }
          },
          onMouseLeave: function onMouseLeave() {
            if (!disabled && onDateMouseLeave) {
              onDateMouseLeave(date2);
            }
          }
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(cellPrefixCls, "-inner")
        }, generateConfig2.locale.getWeek(locale2.locale, date2)));
      };
      var rowPrefixCls = "".concat(prefixCls, "-week-panel-row");
      var rowClassName = function rowClassName2(date2) {
        var _classNames;
        var isRangeStart = isSameWeek(generateConfig2, locale2.locale, rangeStart, date2);
        var isRangeEnd = isSameWeek(generateConfig2, locale2.locale, rangeEnd, date2);
        return classNames(rowPrefixCls, (_classNames = {}, _defineProperty$7(_classNames, "".concat(rowPrefixCls, "-selected"), !rangedValue && isSameWeek(generateConfig2, locale2.locale, value, date2)), _defineProperty$7(_classNames, "".concat(rowPrefixCls, "-range-start"), isRangeStart), _defineProperty$7(_classNames, "".concat(rowPrefixCls, "-range-end"), isRangeEnd), _defineProperty$7(_classNames, "".concat(rowPrefixCls, "-range-hover"), !isRangeStart && !isRangeEnd && isInRange(generateConfig2, rangeStart, rangeEnd, date2)), _classNames));
      };
      return /* @__PURE__ */ reactExports.createElement(DatePanel, _extends$2({}, props, {
        panelName: "week",
        prefixColumn,
        rowClassName,
        keyboardConfig: {
          onLeftRight: null
        },
        isSameCell: function isSameCell() {
          return false;
        }
      }));
    }
    function MonthHeader(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, viewDate = props.viewDate, onNextYear = props.onNextYear, onPrevYear = props.onPrevYear, onYearClick = props.onYearClick;
      var _React$useContext = reactExports.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
      if (hideHeader) {
        return null;
      }
      var headerPrefixCls = "".concat(prefixCls, "-header");
      return /* @__PURE__ */ reactExports.createElement(Header$3, _extends$2({}, props, {
        prefixCls: headerPrefixCls,
        onSuperPrev: onPrevYear,
        onSuperNext: onNextYear
      }), /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onYearClick,
        className: "".concat(prefixCls, "-year-btn")
      }, formatValue(viewDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      })));
    }
    var MONTH_COL_COUNT = 3;
    var MONTH_ROW_COUNT = 4;
    function MonthBody(props) {
      var prefixCls = props.prefixCls, locale2 = props.locale, value = props.value, viewDate = props.viewDate, generateConfig2 = props.generateConfig, monthCellRender = props.monthCellRender;
      var _React$useContext = reactExports.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var getCellClassName = useCellClassName({
        cellPrefixCls,
        value,
        generateConfig: generateConfig2,
        rangedValue,
        hoverRangedValue,
        isSameCell: function isSameCell(current, target) {
          return isSameMonth(generateConfig2, current, target);
        },
        isInView: function isInView() {
          return true;
        },
        offsetCell: function offsetCell(date2, offset2) {
          return generateConfig2.addMonth(date2, offset2);
        }
      });
      var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
      var baseMonth = generateConfig2.setMonth(viewDate, 0);
      var getCellNode = monthCellRender ? function(date2) {
        return monthCellRender(date2, locale2);
      } : void 0;
      return /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$2({}, props, {
        rowNum: MONTH_ROW_COUNT,
        colNum: MONTH_COL_COUNT,
        baseDate: baseMonth,
        getCellNode,
        getCellText: function getCellText(date2) {
          return locale2.monthFormat ? formatValue(date2, {
            locale: locale2,
            format: locale2.monthFormat,
            generateConfig: generateConfig2
          }) : monthsLocale[generateConfig2.getMonth(date2)];
        },
        getCellClassName,
        getCellDate: generateConfig2.addMonth,
        titleCell: function titleCell(date2) {
          return formatValue(date2, {
            locale: locale2,
            format: "YYYY-MM",
            generateConfig: generateConfig2
          });
        }
      }));
    }
    function MonthPanel(props) {
      var prefixCls = props.prefixCls, operationRef = props.operationRef, onViewDateChange = props.onViewDateChange, generateConfig2 = props.generateConfig, value = props.value, viewDate = props.viewDate, onPanelChange = props.onPanelChange, _onSelect = props.onSelect;
      var panelPrefixCls = "".concat(prefixCls, "-month-panel");
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          return createKeyDownHandler(event, {
            onLeftRight: function onLeftRight(diff) {
              _onSelect(generateConfig2.addMonth(value || viewDate, diff), "key");
            },
            onCtrlLeftRight: function onCtrlLeftRight(diff) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
            },
            onUpDown: function onUpDown(diff) {
              _onSelect(generateConfig2.addMonth(value || viewDate, diff * MONTH_COL_COUNT), "key");
            },
            onEnter: function onEnter() {
              onPanelChange("date", value || viewDate);
            }
          });
        }
      };
      var onYearChange = function onYearChange2(diff) {
        var newDate = generateConfig2.addYear(viewDate, diff);
        onViewDateChange(newDate);
        onPanelChange(null, newDate);
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: panelPrefixCls
      }, /* @__PURE__ */ reactExports.createElement(MonthHeader, _extends$2({}, props, {
        prefixCls,
        onPrevYear: function onPrevYear() {
          onYearChange(-1);
        },
        onNextYear: function onNextYear() {
          onYearChange(1);
        },
        onYearClick: function onYearClick() {
          onPanelChange("year", viewDate);
        }
      })), /* @__PURE__ */ reactExports.createElement(MonthBody, _extends$2({}, props, {
        prefixCls,
        onSelect: function onSelect(date2) {
          _onSelect(date2, "mouse");
          onPanelChange("date", date2);
        }
      })));
    }
    function QuarterHeader(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, viewDate = props.viewDate, onNextYear = props.onNextYear, onPrevYear = props.onPrevYear, onYearClick = props.onYearClick;
      var _React$useContext = reactExports.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
      if (hideHeader) {
        return null;
      }
      var headerPrefixCls = "".concat(prefixCls, "-header");
      return /* @__PURE__ */ reactExports.createElement(Header$3, _extends$2({}, props, {
        prefixCls: headerPrefixCls,
        onSuperPrev: onPrevYear,
        onSuperNext: onNextYear
      }), /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onYearClick,
        className: "".concat(prefixCls, "-year-btn")
      }, formatValue(viewDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      })));
    }
    var QUARTER_COL_COUNT = 4;
    var QUARTER_ROW_COUNT = 1;
    function QuarterBody(props) {
      var prefixCls = props.prefixCls, locale2 = props.locale, value = props.value, viewDate = props.viewDate, generateConfig2 = props.generateConfig;
      var _React$useContext = reactExports.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var getCellClassName = useCellClassName({
        cellPrefixCls,
        value,
        generateConfig: generateConfig2,
        rangedValue,
        hoverRangedValue,
        isSameCell: function isSameCell(current, target) {
          return isSameQuarter(generateConfig2, current, target);
        },
        isInView: function isInView() {
          return true;
        },
        offsetCell: function offsetCell(date2, offset2) {
          return generateConfig2.addMonth(date2, offset2 * 3);
        }
      });
      var baseQuarter = generateConfig2.setDate(generateConfig2.setMonth(viewDate, 0), 1);
      return /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$2({}, props, {
        rowNum: QUARTER_ROW_COUNT,
        colNum: QUARTER_COL_COUNT,
        baseDate: baseQuarter,
        getCellText: function getCellText(date2) {
          return formatValue(date2, {
            locale: locale2,
            format: locale2.quarterFormat || "[Q]Q",
            generateConfig: generateConfig2
          });
        },
        getCellClassName,
        getCellDate: function getCellDate(date2, offset2) {
          return generateConfig2.addMonth(date2, offset2 * 3);
        },
        titleCell: function titleCell(date2) {
          return formatValue(date2, {
            locale: locale2,
            format: "YYYY-[Q]Q",
            generateConfig: generateConfig2
          });
        }
      }));
    }
    function QuarterPanel(props) {
      var prefixCls = props.prefixCls, operationRef = props.operationRef, onViewDateChange = props.onViewDateChange, generateConfig2 = props.generateConfig, value = props.value, viewDate = props.viewDate, onPanelChange = props.onPanelChange, _onSelect = props.onSelect;
      var panelPrefixCls = "".concat(prefixCls, "-quarter-panel");
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          return createKeyDownHandler(event, {
            onLeftRight: function onLeftRight(diff) {
              _onSelect(generateConfig2.addMonth(value || viewDate, diff * 3), "key");
            },
            onCtrlLeftRight: function onCtrlLeftRight(diff) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
            },
            onUpDown: function onUpDown(diff) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
            }
          });
        }
      };
      var onYearChange = function onYearChange2(diff) {
        var newDate = generateConfig2.addYear(viewDate, diff);
        onViewDateChange(newDate);
        onPanelChange(null, newDate);
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: panelPrefixCls
      }, /* @__PURE__ */ reactExports.createElement(QuarterHeader, _extends$2({}, props, {
        prefixCls,
        onPrevYear: function onPrevYear() {
          onYearChange(-1);
        },
        onNextYear: function onNextYear() {
          onYearChange(1);
        },
        onYearClick: function onYearClick() {
          onPanelChange("year", viewDate);
        }
      })), /* @__PURE__ */ reactExports.createElement(QuarterBody, _extends$2({}, props, {
        prefixCls,
        onSelect: function onSelect(date2) {
          _onSelect(date2, "mouse");
        }
      })));
    }
    function YearHeader(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, viewDate = props.viewDate, onPrevDecade = props.onPrevDecade, onNextDecade = props.onNextDecade, onDecadeClick = props.onDecadeClick;
      var _React$useContext = reactExports.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
      if (hideHeader) {
        return null;
      }
      var headerPrefixCls = "".concat(prefixCls, "-header");
      var yearNumber = generateConfig2.getYear(viewDate);
      var startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
      var endYear = startYear + YEAR_DECADE_COUNT - 1;
      return /* @__PURE__ */ reactExports.createElement(Header$3, _extends$2({}, props, {
        prefixCls: headerPrefixCls,
        onSuperPrev: onPrevDecade,
        onSuperNext: onNextDecade
      }), /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onDecadeClick,
        className: "".concat(prefixCls, "-decade-btn")
      }, startYear, "-", endYear));
    }
    var YEAR_COL_COUNT = 3;
    var YEAR_ROW_COUNT = 4;
    function YearBody(props) {
      var prefixCls = props.prefixCls, value = props.value, viewDate = props.viewDate, locale2 = props.locale, generateConfig2 = props.generateConfig;
      var _React$useContext = reactExports.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
      var yearPrefixCls = "".concat(prefixCls, "-cell");
      var yearNumber = generateConfig2.getYear(viewDate);
      var startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
      var endYear = startYear + YEAR_DECADE_COUNT - 1;
      var baseYear = generateConfig2.setYear(viewDate, startYear - Math.ceil((YEAR_COL_COUNT * YEAR_ROW_COUNT - YEAR_DECADE_COUNT) / 2));
      var isInView = function isInView2(date2) {
        var currentYearNumber = generateConfig2.getYear(date2);
        return startYear <= currentYearNumber && currentYearNumber <= endYear;
      };
      var getCellClassName = useCellClassName({
        cellPrefixCls: yearPrefixCls,
        value,
        generateConfig: generateConfig2,
        rangedValue,
        hoverRangedValue,
        isSameCell: function isSameCell(current, target) {
          return isSameYear(generateConfig2, current, target);
        },
        isInView,
        offsetCell: function offsetCell(date2, offset2) {
          return generateConfig2.addYear(date2, offset2);
        }
      });
      return /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$2({}, props, {
        rowNum: YEAR_ROW_COUNT,
        colNum: YEAR_COL_COUNT,
        baseDate: baseYear,
        getCellText: generateConfig2.getYear,
        getCellClassName,
        getCellDate: generateConfig2.addYear,
        titleCell: function titleCell(date2) {
          return formatValue(date2, {
            locale: locale2,
            format: "YYYY",
            generateConfig: generateConfig2
          });
        }
      }));
    }
    var YEAR_DECADE_COUNT = 10;
    function YearPanel(props) {
      var prefixCls = props.prefixCls, operationRef = props.operationRef, onViewDateChange = props.onViewDateChange, generateConfig2 = props.generateConfig, value = props.value, viewDate = props.viewDate, sourceMode = props.sourceMode, _onSelect = props.onSelect, onPanelChange = props.onPanelChange;
      var panelPrefixCls = "".concat(prefixCls, "-year-panel");
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          return createKeyDownHandler(event, {
            onLeftRight: function onLeftRight(diff) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
            },
            onCtrlLeftRight: function onCtrlLeftRight(diff) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff * YEAR_DECADE_COUNT), "key");
            },
            onUpDown: function onUpDown(diff) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff * YEAR_COL_COUNT), "key");
            },
            onEnter: function onEnter() {
              onPanelChange(sourceMode === "date" ? "date" : "month", value || viewDate);
            }
          });
        }
      };
      var onDecadeChange = function onDecadeChange2(diff) {
        var newDate = generateConfig2.addYear(viewDate, diff * 10);
        onViewDateChange(newDate);
        onPanelChange(null, newDate);
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: panelPrefixCls
      }, /* @__PURE__ */ reactExports.createElement(YearHeader, _extends$2({}, props, {
        prefixCls,
        onPrevDecade: function onPrevDecade() {
          onDecadeChange(-1);
        },
        onNextDecade: function onNextDecade() {
          onDecadeChange(1);
        },
        onDecadeClick: function onDecadeClick() {
          onPanelChange("decade", viewDate);
        }
      })), /* @__PURE__ */ reactExports.createElement(YearBody, _extends$2({}, props, {
        prefixCls,
        onSelect: function onSelect(date2) {
          onPanelChange(sourceMode === "date" ? "date" : "month", date2);
          _onSelect(date2, "mouse");
        }
      })));
    }
    function getExtraFooter(prefixCls, mode, renderExtraFooter) {
      if (!renderExtraFooter) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-footer-extra")
      }, renderExtraFooter(mode));
    }
    function getRanges(_ref) {
      var prefixCls = _ref.prefixCls, _ref$components = _ref.components, components = _ref$components === void 0 ? {} : _ref$components, needConfirmButton = _ref.needConfirmButton, onNow = _ref.onNow, onOk = _ref.onOk, okDisabled = _ref.okDisabled, showNow = _ref.showNow, locale2 = _ref.locale;
      var presetNode;
      var okNode;
      if (needConfirmButton) {
        var Button2 = components.button || "button";
        if (onNow && showNow !== false) {
          presetNode = /* @__PURE__ */ reactExports.createElement("li", {
            className: "".concat(prefixCls, "-now")
          }, /* @__PURE__ */ reactExports.createElement("a", {
            className: "".concat(prefixCls, "-now-btn"),
            onClick: onNow
          }, locale2.now));
        }
        okNode = needConfirmButton && /* @__PURE__ */ reactExports.createElement("li", {
          className: "".concat(prefixCls, "-ok")
        }, /* @__PURE__ */ reactExports.createElement(Button2, {
          disabled: okDisabled,
          onClick: onOk
        }, locale2.ok));
      }
      if (!presetNode && !okNode) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("ul", {
        className: "".concat(prefixCls, "-ranges")
      }, presetNode, okNode);
    }
    function PickerPanel(props) {
      var _classNames;
      var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-picker" : _ref$prefixCls, className = _ref.className, style2 = _ref.style, locale2 = _ref.locale, generateConfig2 = _ref.generateConfig, value = _ref.value, defaultValue = _ref.defaultValue, pickerValue = _ref.pickerValue, defaultPickerValue = _ref.defaultPickerValue, disabledDate = _ref.disabledDate, mode = _ref.mode, _ref$picker = _ref.picker, picker = _ref$picker === void 0 ? "date" : _ref$picker, _ref$tabIndex = _ref.tabIndex, tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, showNow = _ref.showNow, showTime = _ref.showTime, showToday = _ref.showToday, renderExtraFooter = _ref.renderExtraFooter, hideHeader = _ref.hideHeader, onSelect = _ref.onSelect, onChange = _ref.onChange, onPanelChange = _ref.onPanelChange, onMouseDown = _ref.onMouseDown, onPickerValueChange = _ref.onPickerValueChange, _onOk = _ref.onOk, components = _ref.components, direction = _ref.direction, _ref$hourStep = _ref.hourStep, hourStep = _ref$hourStep === void 0 ? 1 : _ref$hourStep, _ref$minuteStep = _ref.minuteStep, minuteStep = _ref$minuteStep === void 0 ? 1 : _ref$minuteStep, _ref$secondStep = _ref.secondStep, secondStep = _ref$secondStep === void 0 ? 1 : _ref$secondStep;
      var needConfirmButton = picker === "date" && !!showTime || picker === "time";
      var isHourStepValid = 24 % hourStep === 0;
      var isMinuteStepValid = 60 % minuteStep === 0;
      var isSecondStepValid = 60 % secondStep === 0;
      var panelContext = reactExports.useContext(PanelContext);
      var operationRef = panelContext.operationRef, onContextSelect = panelContext.onSelect, hideRanges = panelContext.hideRanges, defaultOpenValue = panelContext.defaultOpenValue;
      var _React$useContext = reactExports.useContext(RangeContext), inRange = _React$useContext.inRange, panelPosition = _React$useContext.panelPosition, rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
      var panelRef = reactExports.useRef({});
      var initRef = reactExports.useRef(true);
      var _useMergedState = useMergedState(null, {
        value,
        defaultValue,
        postState: function postState(val) {
          if (!val && defaultOpenValue && picker === "time") {
            return defaultOpenValue;
          }
          return val;
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
      var _useMergedState3 = useMergedState(null, {
        value: pickerValue,
        defaultValue: defaultPickerValue || mergedValue,
        postState: function postState(date2) {
          var now3 = generateConfig2.getNow();
          if (!date2) {
            return now3;
          }
          if (!mergedValue && showTime) {
            var defaultDateObject = _typeof$4(showTime) === "object" ? showTime.defaultValue : defaultValue;
            return setDateTime(generateConfig2, Array.isArray(date2) ? date2[0] : date2, defaultDateObject || now3);
          }
          return Array.isArray(date2) ? date2[0] : date2;
        }
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), viewDate = _useMergedState4[0], setInnerViewDate = _useMergedState4[1];
      var setViewDate = function setViewDate2(date2) {
        setInnerViewDate(date2);
        if (onPickerValueChange) {
          onPickerValueChange(date2);
        }
      };
      var getInternalNextMode = function getInternalNextMode2(nextMode) {
        var getNextMode = PickerModeMap[picker];
        if (getNextMode) {
          return getNextMode(nextMode);
        }
        return nextMode;
      };
      var _useMergedState5 = useMergedState(function() {
        if (picker === "time") {
          return "time";
        }
        return getInternalNextMode("date");
      }, {
        value: mode
      }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedMode = _useMergedState6[0], setInnerMode = _useMergedState6[1];
      reactExports.useEffect(function() {
        setInnerMode(picker);
      }, [picker]);
      var _React$useState = reactExports.useState(function() {
        return mergedMode;
      }), _React$useState2 = _slicedToArray(_React$useState, 2), sourceMode = _React$useState2[0], setSourceMode = _React$useState2[1];
      var onInternalPanelChange = function onInternalPanelChange2(newMode, viewValue) {
        var nextMode = getInternalNextMode(newMode || mergedMode);
        setSourceMode(mergedMode);
        setInnerMode(nextMode);
        if (onPanelChange && (mergedMode !== nextMode || isEqual(generateConfig2, viewDate, viewDate))) {
          onPanelChange(viewValue, nextMode);
        }
      };
      var triggerSelect = function triggerSelect2(date2, type2) {
        var forceTriggerSelect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        if (mergedMode === picker || forceTriggerSelect) {
          setInnerValue(date2);
          if (onSelect) {
            onSelect(date2);
          }
          if (onContextSelect) {
            onContextSelect(date2, type2);
          }
          if (onChange && !isEqual(generateConfig2, date2, mergedValue) && !(disabledDate !== null && disabledDate !== void 0 && disabledDate(date2))) {
            onChange(date2);
          }
        }
      };
      var onInternalKeyDown = function onInternalKeyDown2(e2) {
        if (panelRef.current && panelRef.current.onKeyDown) {
          if ([KeyCode.LEFT, KeyCode.RIGHT, KeyCode.UP, KeyCode.DOWN, KeyCode.PAGE_UP, KeyCode.PAGE_DOWN, KeyCode.ENTER].includes(e2.which)) {
            e2.preventDefault();
          }
          return panelRef.current.onKeyDown(e2);
        }
        {
          warningOnce$1(false, "Panel not correct handle keyDown event. Please help to fire issue about this.");
          return false;
        }
      };
      var onInternalBlur = function onInternalBlur2(e2) {
        if (panelRef.current && panelRef.current.onBlur) {
          panelRef.current.onBlur(e2);
        }
      };
      if (operationRef && panelPosition !== "right") {
        operationRef.current = {
          onKeyDown: onInternalKeyDown,
          onClose: function onClose() {
            if (panelRef.current && panelRef.current.onClose) {
              panelRef.current.onClose();
            }
          }
        };
      }
      reactExports.useEffect(function() {
        if (value && !initRef.current) {
          setInnerViewDate(value);
        }
      }, [value]);
      reactExports.useEffect(function() {
        initRef.current = false;
      }, []);
      var panelNode;
      var pickerProps = _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        operationRef: panelRef,
        prefixCls,
        viewDate,
        value: mergedValue,
        onViewDateChange: setViewDate,
        sourceMode,
        onPanelChange: onInternalPanelChange,
        disabledDate
      });
      delete pickerProps.onChange;
      delete pickerProps.onSelect;
      switch (mergedMode) {
        case "decade":
          panelNode = /* @__PURE__ */ reactExports.createElement(DecadePanel, _extends$2({}, pickerProps, {
            onSelect: function onSelect2(date2, type2) {
              setViewDate(date2);
              triggerSelect(date2, type2);
            }
          }));
          break;
        case "year":
          panelNode = /* @__PURE__ */ reactExports.createElement(YearPanel, _extends$2({}, pickerProps, {
            onSelect: function onSelect2(date2, type2) {
              setViewDate(date2);
              triggerSelect(date2, type2);
            }
          }));
          break;
        case "month":
          panelNode = /* @__PURE__ */ reactExports.createElement(MonthPanel, _extends$2({}, pickerProps, {
            onSelect: function onSelect2(date2, type2) {
              setViewDate(date2);
              triggerSelect(date2, type2);
            }
          }));
          break;
        case "quarter":
          panelNode = /* @__PURE__ */ reactExports.createElement(QuarterPanel, _extends$2({}, pickerProps, {
            onSelect: function onSelect2(date2, type2) {
              setViewDate(date2);
              triggerSelect(date2, type2);
            }
          }));
          break;
        case "week":
          panelNode = /* @__PURE__ */ reactExports.createElement(WeekPanel, _extends$2({}, pickerProps, {
            onSelect: function onSelect2(date2, type2) {
              setViewDate(date2);
              triggerSelect(date2, type2);
            }
          }));
          break;
        case "time":
          delete pickerProps.showTime;
          panelNode = /* @__PURE__ */ reactExports.createElement(TimePanel, _extends$2({}, pickerProps, _typeof$4(showTime) === "object" ? showTime : null, {
            onSelect: function onSelect2(date2, type2) {
              setViewDate(date2);
              triggerSelect(date2, type2);
            }
          }));
          break;
        default:
          if (showTime) {
            panelNode = /* @__PURE__ */ reactExports.createElement(DatetimePanel, _extends$2({}, pickerProps, {
              onSelect: function onSelect2(date2, type2) {
                setViewDate(date2);
                triggerSelect(date2, type2);
              }
            }));
          } else {
            panelNode = /* @__PURE__ */ reactExports.createElement(DatePanel, _extends$2({}, pickerProps, {
              onSelect: function onSelect2(date2, type2) {
                setViewDate(date2);
                triggerSelect(date2, type2);
              }
            }));
          }
      }
      var extraFooter;
      var rangesNode;
      var onNow = function onNow2() {
        var now3 = generateConfig2.getNow();
        var lowerBoundTime = getLowerBoundTime(generateConfig2.getHour(now3), generateConfig2.getMinute(now3), generateConfig2.getSecond(now3), isHourStepValid ? hourStep : 1, isMinuteStepValid ? minuteStep : 1, isSecondStepValid ? secondStep : 1);
        var adjustedNow = setTime(
          generateConfig2,
          now3,
          lowerBoundTime[0],
          // hour
          lowerBoundTime[1],
          // minute
          lowerBoundTime[2]
          // second
        );
        triggerSelect(adjustedNow, "submit");
      };
      if (!hideRanges) {
        extraFooter = getExtraFooter(prefixCls, mergedMode, renderExtraFooter);
        rangesNode = getRanges({
          prefixCls,
          components,
          needConfirmButton,
          okDisabled: !mergedValue || disabledDate && disabledDate(mergedValue),
          locale: locale2,
          showNow,
          onNow: needConfirmButton && onNow,
          onOk: function onOk() {
            if (mergedValue) {
              triggerSelect(mergedValue, "submit", true);
              if (_onOk) {
                _onOk(mergedValue);
              }
            }
          }
        });
      }
      var todayNode;
      if (showToday && mergedMode === "date" && picker === "date" && !showTime) {
        var now2 = generateConfig2.getNow();
        var todayCls = "".concat(prefixCls, "-today-btn");
        var disabled = disabledDate && disabledDate(now2);
        todayNode = /* @__PURE__ */ reactExports.createElement("a", {
          className: classNames(todayCls, disabled && "".concat(todayCls, "-disabled")),
          "aria-disabled": disabled,
          onClick: function onClick() {
            if (!disabled) {
              triggerSelect(now2, "mouse", true);
            }
          }
        }, locale2.today);
      }
      return /* @__PURE__ */ reactExports.createElement(PanelContext.Provider, {
        value: _objectSpread2$3(_objectSpread2$3({}, panelContext), {}, {
          mode: mergedMode,
          hideHeader: "hideHeader" in props ? hideHeader : panelContext.hideHeader,
          hidePrevBtn: inRange && panelPosition === "right",
          hideNextBtn: inRange && panelPosition === "left"
        })
      }, /* @__PURE__ */ reactExports.createElement("div", {
        tabIndex,
        className: classNames("".concat(prefixCls, "-panel"), className, (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-panel-has-range"), rangedValue && rangedValue[0] && rangedValue[1]), _defineProperty$7(_classNames, "".concat(prefixCls, "-panel-has-range-hover"), hoverRangedValue && hoverRangedValue[0] && hoverRangedValue[1]), _defineProperty$7(_classNames, "".concat(prefixCls, "-panel-rtl"), direction === "rtl"), _classNames)),
        style: style2,
        onKeyDown: onInternalKeyDown,
        onBlur: onInternalBlur,
        onMouseDown
      }, panelNode, extraFooter || rangesNode || todayNode ? /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-footer")
      }, extraFooter, rangesNode, todayNode) : null));
    }
    var BUILT_IN_PLACEMENTS = {
      bottomLeft: {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow: {
          adjustX: 1,
          adjustY: 1
        }
      },
      bottomRight: {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow: {
          adjustX: 1,
          adjustY: 1
        }
      },
      topLeft: {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow: {
          adjustX: 0,
          adjustY: 1
        }
      },
      topRight: {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow: {
          adjustX: 0,
          adjustY: 1
        }
      }
    };
    function PickerTrigger(_ref) {
      var _classNames;
      var prefixCls = _ref.prefixCls, popupElement = _ref.popupElement, popupStyle = _ref.popupStyle, visible = _ref.visible, dropdownClassName = _ref.dropdownClassName, dropdownAlign = _ref.dropdownAlign, transitionName = _ref.transitionName, getPopupContainer = _ref.getPopupContainer, children = _ref.children, range2 = _ref.range, popupPlacement = _ref.popupPlacement, direction = _ref.direction;
      var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
      var getPopupPlacement = function getPopupPlacement2() {
        if (popupPlacement !== void 0) {
          return popupPlacement;
        }
        return direction === "rtl" ? "bottomRight" : "bottomLeft";
      };
      return /* @__PURE__ */ reactExports.createElement(Trigger, {
        showAction: [],
        hideAction: [],
        popupPlacement: getPopupPlacement(),
        builtinPlacements: BUILT_IN_PLACEMENTS,
        prefixCls: dropdownPrefixCls,
        popupTransitionName: transitionName,
        popup: popupElement,
        popupAlign: dropdownAlign,
        popupVisible: visible,
        popupClassName: classNames(dropdownClassName, (_classNames = {}, _defineProperty$7(_classNames, "".concat(dropdownPrefixCls, "-range"), range2), _defineProperty$7(_classNames, "".concat(dropdownPrefixCls, "-rtl"), direction === "rtl"), _classNames)),
        popupStyle,
        getPopupContainer
      }, children);
    }
    function PresetPanel(props) {
      var prefixCls = props.prefixCls, presets = props.presets, _onClick = props.onClick, onHover = props.onHover;
      if (!presets.length) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-presets")
      }, /* @__PURE__ */ reactExports.createElement("ul", null, presets.map(function(_ref, index2) {
        var label = _ref.label, value = _ref.value;
        return /* @__PURE__ */ reactExports.createElement("li", {
          key: index2,
          onClick: function onClick() {
            _onClick(value);
          },
          onMouseEnter: function onMouseEnter() {
            onHover === null || onHover === void 0 ? void 0 : onHover(value);
          },
          onMouseLeave: function onMouseLeave() {
            onHover === null || onHover === void 0 ? void 0 : onHover(null);
          }
        }, label);
      })));
    }
    function InnerPicker(props) {
      var _classNames2;
      var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-picker" : _ref$prefixCls, id2 = _ref.id, tabIndex = _ref.tabIndex, style2 = _ref.style, className = _ref.className, dropdownClassName = _ref.dropdownClassName, dropdownAlign = _ref.dropdownAlign, popupStyle = _ref.popupStyle, transitionName = _ref.transitionName, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, inputReadOnly = _ref.inputReadOnly, allowClear = _ref.allowClear, autoFocus = _ref.autoFocus, showTime = _ref.showTime, _ref$picker = _ref.picker, picker = _ref$picker === void 0 ? "date" : _ref$picker, format2 = _ref.format, use12Hours = _ref.use12Hours, value = _ref.value, defaultValue = _ref.defaultValue, presets = _ref.presets, open2 = _ref.open, defaultOpen = _ref.defaultOpen, defaultOpenValue = _ref.defaultOpenValue, suffixIcon = _ref.suffixIcon, clearIcon = _ref.clearIcon, disabled = _ref.disabled, disabledDate = _ref.disabledDate, placeholder = _ref.placeholder, getPopupContainer = _ref.getPopupContainer, pickerRef = _ref.pickerRef, panelRender = _ref.panelRender, onChange = _ref.onChange, onOpenChange = _ref.onOpenChange, onFocus = _ref.onFocus, onBlur = _ref.onBlur, onMouseDown = _ref.onMouseDown, onMouseUp = _ref.onMouseUp, onMouseEnter = _ref.onMouseEnter, onMouseLeave = _ref.onMouseLeave, onContextMenu = _ref.onContextMenu, onClick = _ref.onClick, _onKeyDown = _ref.onKeyDown, _onSelect = _ref.onSelect, direction = _ref.direction, _ref$autoComplete = _ref.autoComplete, autoComplete = _ref$autoComplete === void 0 ? "off" : _ref$autoComplete, inputRender = _ref.inputRender;
      var inputRef = reactExports.useRef(null);
      var needConfirmButton = picker === "date" && !!showTime || picker === "time";
      var presetList = usePresets(presets);
      var formatList = toArray$4(getDefaultFormat(format2, picker, showTime, use12Hours));
      var panelDivRef = reactExports.useRef(null);
      var inputDivRef = reactExports.useRef(null);
      var containerRef = reactExports.useRef(null);
      var _useMergedState = useMergedState(null, {
        value,
        defaultValue
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
      var _React$useState = reactExports.useState(mergedValue), _React$useState2 = _slicedToArray(_React$useState, 2), selectedValue = _React$useState2[0], setSelectedValue = _React$useState2[1];
      var operationRef = reactExports.useRef(null);
      var _useMergedState3 = useMergedState(false, {
        value: open2,
        defaultValue: defaultOpen,
        postState: function postState(postOpen) {
          return disabled ? false : postOpen;
        },
        onChange: function onChange2(newOpen) {
          if (onOpenChange) {
            onOpenChange(newOpen);
          }
          if (!newOpen && operationRef.current && operationRef.current.onClose) {
            operationRef.current.onClose();
          }
        }
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedOpen = _useMergedState4[0], triggerInnerOpen = _useMergedState4[1];
      var _useValueTexts = useValueTexts(selectedValue, {
        formatList,
        generateConfig: generateConfig2,
        locale: locale2
      }), _useValueTexts2 = _slicedToArray(_useValueTexts, 2), valueTexts = _useValueTexts2[0], firstValueText = _useValueTexts2[1];
      var _useTextValueMapping = useTextValueMapping({
        valueTexts,
        onTextChange: function onTextChange(newText) {
          var inputDate = parseValue(newText, {
            locale: locale2,
            formatList,
            generateConfig: generateConfig2
          });
          if (inputDate && (!disabledDate || !disabledDate(inputDate))) {
            setSelectedValue(inputDate);
          }
        }
      }), _useTextValueMapping2 = _slicedToArray(_useTextValueMapping, 3), text2 = _useTextValueMapping2[0], triggerTextChange = _useTextValueMapping2[1], resetText = _useTextValueMapping2[2];
      var triggerChange = function triggerChange2(newValue) {
        setSelectedValue(newValue);
        setInnerValue(newValue);
        if (onChange && !isEqual(generateConfig2, mergedValue, newValue)) {
          onChange(newValue, newValue ? formatValue(newValue, {
            generateConfig: generateConfig2,
            locale: locale2,
            format: formatList[0]
          }) : "");
        }
      };
      var triggerOpen = function triggerOpen2(newOpen) {
        if (disabled && newOpen) {
          return;
        }
        triggerInnerOpen(newOpen);
      };
      var forwardKeyDown = function forwardKeyDown2(e2) {
        if (mergedOpen && operationRef.current && operationRef.current.onKeyDown) {
          return operationRef.current.onKeyDown(e2);
        }
        {
          warningOnce$1(false, "Picker not correct forward KeyDown operation. Please help to fire issue about this.");
          return false;
        }
      };
      var onInternalClick = function onInternalClick2() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        onClick === null || onClick === void 0 ? void 0 : onClick.apply(void 0, args);
        if (inputRef.current) {
          inputRef.current.focus();
          triggerOpen(true);
        }
      };
      var _usePickerInput = usePickerInput({
        blurToCancel: needConfirmButton,
        open: mergedOpen,
        value: text2,
        triggerOpen,
        forwardKeyDown,
        isClickOutside: function isClickOutside(target) {
          return !elementsContains([panelDivRef.current, inputDivRef.current, containerRef.current], target);
        },
        onSubmit: function onSubmit() {
          if (
            // When user typing disabledDate with keyboard and enter, this value will be empty
            !selectedValue || // Normal disabled check
            disabledDate && disabledDate(selectedValue)
          ) {
            return false;
          }
          triggerChange(selectedValue);
          triggerOpen(false);
          resetText();
          return true;
        },
        onCancel: function onCancel() {
          triggerOpen(false);
          setSelectedValue(mergedValue);
          resetText();
        },
        onKeyDown: function onKeyDown2(e2, preventDefault) {
          _onKeyDown === null || _onKeyDown === void 0 ? void 0 : _onKeyDown(e2, preventDefault);
        },
        onFocus,
        onBlur
      }), _usePickerInput2 = _slicedToArray(_usePickerInput, 2), inputProps = _usePickerInput2[0], _usePickerInput2$ = _usePickerInput2[1], focused = _usePickerInput2$.focused, typing = _usePickerInput2$.typing;
      reactExports.useEffect(function() {
        if (!mergedOpen) {
          setSelectedValue(mergedValue);
          if (!valueTexts.length || valueTexts[0] === "") {
            triggerTextChange("");
          } else if (firstValueText !== text2) {
            resetText();
          }
        }
      }, [mergedOpen, valueTexts]);
      reactExports.useEffect(function() {
        if (!mergedOpen) {
          resetText();
        }
      }, [picker]);
      reactExports.useEffect(function() {
        setSelectedValue(mergedValue);
      }, [mergedValue]);
      if (pickerRef) {
        pickerRef.current = {
          focus: function focus() {
            if (inputRef.current) {
              inputRef.current.focus();
            }
          },
          blur: function blur() {
            if (inputRef.current) {
              inputRef.current.blur();
            }
          }
        };
      }
      var _useHoverValue = useHoverValue(text2, {
        formatList,
        generateConfig: generateConfig2,
        locale: locale2
      }), _useHoverValue2 = _slicedToArray(_useHoverValue, 3), hoverValue = _useHoverValue2[0], onEnter = _useHoverValue2[1], onLeave = _useHoverValue2[2];
      var panelProps = _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        className: void 0,
        style: void 0,
        pickerValue: void 0,
        onPickerValueChange: void 0,
        onChange: null
      });
      var panelNode = /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-panel-layout")
      }, /* @__PURE__ */ reactExports.createElement(PresetPanel, {
        prefixCls,
        presets: presetList,
        onClick: function onClick2(nextValue) {
          triggerChange(nextValue);
          triggerOpen(false);
        }
      }), /* @__PURE__ */ reactExports.createElement(PickerPanel, _extends$2({}, panelProps, {
        generateConfig: generateConfig2,
        className: classNames(_defineProperty$7({}, "".concat(prefixCls, "-panel-focused"), !typing)),
        value: selectedValue,
        locale: locale2,
        tabIndex: -1,
        onSelect: function onSelect(date2) {
          _onSelect === null || _onSelect === void 0 ? void 0 : _onSelect(date2);
          setSelectedValue(date2);
        },
        direction,
        onPanelChange: function onPanelChange(viewDate, mode) {
          var onPanelChange2 = props.onPanelChange;
          onLeave(true);
          onPanelChange2 === null || onPanelChange2 === void 0 ? void 0 : onPanelChange2(viewDate, mode);
        }
      })));
      if (panelRender) {
        panelNode = panelRender(panelNode);
      }
      var panel = /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-panel-container"),
        ref: panelDivRef,
        onMouseDown: function onMouseDown2(e2) {
          e2.preventDefault();
        }
      }, panelNode);
      var suffixNode;
      if (suffixIcon) {
        suffixNode = /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(prefixCls, "-suffix")
        }, suffixIcon);
      }
      var clearNode;
      if (allowClear && mergedValue && !disabled) {
        clearNode = /* @__PURE__ */ reactExports.createElement("span", {
          onMouseDown: function onMouseDown2(e2) {
            e2.preventDefault();
            e2.stopPropagation();
          },
          onMouseUp: function onMouseUp2(e2) {
            e2.preventDefault();
            e2.stopPropagation();
            triggerChange(null);
            triggerOpen(false);
          },
          className: "".concat(prefixCls, "-clear"),
          role: "button"
        }, clearIcon || /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(prefixCls, "-clear-btn")
        }));
      }
      var mergedInputProps = _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({
        id: id2,
        tabIndex,
        disabled,
        readOnly: inputReadOnly || typeof formatList[0] === "function" || !typing,
        value: hoverValue || text2,
        onChange: function onChange2(e2) {
          triggerTextChange(e2.target.value);
        },
        autoFocus,
        placeholder,
        ref: inputRef,
        title: text2
      }, inputProps), {}, {
        size: getInputSize(picker, formatList[0], generateConfig2)
      }, getDataOrAriaProps(props)), {}, {
        autoComplete
      });
      var inputNode = inputRender ? inputRender(mergedInputProps) : /* @__PURE__ */ reactExports.createElement("input", mergedInputProps);
      var onContextSelect = function onContextSelect2(date2, type2) {
        if (type2 === "submit" || type2 !== "key" && !needConfirmButton) {
          triggerChange(date2);
          triggerOpen(false);
        }
      };
      var popupPlacement = direction === "rtl" ? "bottomRight" : "bottomLeft";
      return /* @__PURE__ */ reactExports.createElement(PanelContext.Provider, {
        value: {
          operationRef,
          hideHeader: picker === "time",
          onSelect: onContextSelect,
          open: mergedOpen,
          defaultOpenValue,
          onDateMouseEnter: onEnter,
          onDateMouseLeave: onLeave
        }
      }, /* @__PURE__ */ reactExports.createElement(PickerTrigger, {
        visible: mergedOpen,
        popupElement: panel,
        popupStyle,
        prefixCls,
        dropdownClassName,
        dropdownAlign,
        getPopupContainer,
        transitionName,
        popupPlacement,
        direction
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: containerRef,
        className: classNames(prefixCls, className, (_classNames2 = {}, _defineProperty$7(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$7(_classNames2, "".concat(prefixCls, "-focused"), focused), _defineProperty$7(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames2)),
        style: style2,
        onMouseDown,
        onMouseUp,
        onMouseEnter,
        onMouseLeave,
        onContextMenu,
        onClick: onInternalClick
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-input"), _defineProperty$7({}, "".concat(prefixCls, "-input-placeholder"), !!hoverValue)),
        ref: inputDivRef
      }, inputNode, suffixNode, clearNode))));
    }
    var Picker = /* @__PURE__ */ function(_React$Component) {
      _inherits(Picker2, _React$Component);
      var _super = _createSuper(Picker2);
      function Picker2() {
        var _this;
        _classCallCheck(this, Picker2);
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$7(_assertThisInitialized(_this), "pickerRef", /* @__PURE__ */ reactExports.createRef());
        _defineProperty$7(_assertThisInitialized(_this), "focus", function() {
          if (_this.pickerRef.current) {
            _this.pickerRef.current.focus();
          }
        });
        _defineProperty$7(_assertThisInitialized(_this), "blur", function() {
          if (_this.pickerRef.current) {
            _this.pickerRef.current.blur();
          }
        });
        return _this;
      }
      _createClass(Picker2, [{
        key: "render",
        value: function render2() {
          return /* @__PURE__ */ reactExports.createElement(InnerPicker, _extends$2({}, this.props, {
            pickerRef: this.pickerRef
          }));
        }
      }]);
      return Picker2;
    }(reactExports.Component);
    function useRangeDisabled(_ref, disabledStart, disabledEnd) {
      var picker = _ref.picker, locale2 = _ref.locale, selectedValue = _ref.selectedValue, disabledDate = _ref.disabledDate, disabled = _ref.disabled, generateConfig2 = _ref.generateConfig;
      var startDate = getValue$1(selectedValue, 0);
      var endDate = getValue$1(selectedValue, 1);
      function weekFirstDate(date2) {
        return generateConfig2.locale.getWeekFirstDate(locale2.locale, date2);
      }
      function monthNumber(date2) {
        var year = generateConfig2.getYear(date2);
        var month = generateConfig2.getMonth(date2);
        return year * 100 + month;
      }
      function quarterNumber(date2) {
        var year = generateConfig2.getYear(date2);
        var quarter = getQuarter(generateConfig2, date2);
        return year * 10 + quarter;
      }
      var disabledStartDate = reactExports.useCallback(function(date2) {
        if (disabledDate && disabledDate(date2)) {
          return true;
        }
        if (disabled[1] && endDate) {
          return !isSameDate(generateConfig2, date2, endDate) && generateConfig2.isAfter(date2, endDate);
        }
        if (disabledStart && endDate) {
          switch (picker) {
            case "quarter":
              return quarterNumber(date2) > quarterNumber(endDate);
            case "month":
              return monthNumber(date2) > monthNumber(endDate);
            case "week":
              return weekFirstDate(date2) > weekFirstDate(endDate);
            default:
              return !isSameDate(generateConfig2, date2, endDate) && generateConfig2.isAfter(date2, endDate);
          }
        }
        return false;
      }, [disabledDate, disabled[1], endDate, disabledStart]);
      var disabledEndDate = reactExports.useCallback(function(date2) {
        if (disabledDate && disabledDate(date2)) {
          return true;
        }
        if (disabled[0] && startDate) {
          return !isSameDate(generateConfig2, date2, endDate) && generateConfig2.isAfter(startDate, date2);
        }
        if (disabledEnd && startDate) {
          switch (picker) {
            case "quarter":
              return quarterNumber(date2) < quarterNumber(startDate);
            case "month":
              return monthNumber(date2) < monthNumber(startDate);
            case "week":
              return weekFirstDate(date2) < weekFirstDate(startDate);
            default:
              return !isSameDate(generateConfig2, date2, startDate) && generateConfig2.isAfter(startDate, date2);
          }
        }
        return false;
      }, [disabledDate, disabled[0], startDate, disabledEnd]);
      return [disabledStartDate, disabledEndDate];
    }
    function getStartEndDistance(startDate, endDate, picker, generateConfig2) {
      var startNext = getClosingViewDate(startDate, picker, generateConfig2, 1);
      function getDistance(compareFunc) {
        if (compareFunc(startDate, endDate)) {
          return "same";
        }
        if (compareFunc(startNext, endDate)) {
          return "closing";
        }
        return "far";
      }
      switch (picker) {
        case "year":
          return getDistance(function(start2, end2) {
            return isSameDecade(generateConfig2, start2, end2);
          });
        case "quarter":
        case "month":
          return getDistance(function(start2, end2) {
            return isSameYear(generateConfig2, start2, end2);
          });
        default:
          return getDistance(function(start2, end2) {
            return isSameMonth(generateConfig2, start2, end2);
          });
      }
    }
    function getRangeViewDate(values, index2, picker, generateConfig2) {
      var startDate = getValue$1(values, 0);
      var endDate = getValue$1(values, 1);
      if (index2 === 0) {
        return startDate;
      }
      if (startDate && endDate) {
        var distance = getStartEndDistance(startDate, endDate, picker, generateConfig2);
        switch (distance) {
          case "same":
            return startDate;
          case "closing":
            return startDate;
          default:
            return getClosingViewDate(endDate, picker, generateConfig2, -1);
        }
      }
      return startDate;
    }
    function useRangeViewDates(_ref) {
      var values = _ref.values, picker = _ref.picker, defaultDates = _ref.defaultDates, generateConfig2 = _ref.generateConfig;
      var _React$useState = reactExports.useState(function() {
        return [getValue$1(defaultDates, 0), getValue$1(defaultDates, 1)];
      }), _React$useState2 = _slicedToArray(_React$useState, 2), defaultViewDates = _React$useState2[0], setDefaultViewDates = _React$useState2[1];
      var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), viewDates = _React$useState4[0], setInternalViewDates = _React$useState4[1];
      var startDate = getValue$1(values, 0);
      var endDate = getValue$1(values, 1);
      function getViewDate(index2) {
        if (defaultViewDates[index2]) {
          return defaultViewDates[index2];
        }
        return getValue$1(viewDates, index2) || getRangeViewDate(values, index2, picker, generateConfig2) || startDate || endDate || generateConfig2.getNow();
      }
      function setViewDate(viewDate, index2) {
        if (viewDate) {
          var newViewDates = updateValues(viewDates, viewDate, index2);
          setDefaultViewDates(
            // Should always be an array
            updateValues(defaultViewDates, null, index2) || [null, null]
          );
          var anotherIndex = (index2 + 1) % 2;
          if (!getValue$1(values, anotherIndex)) {
            newViewDates = updateValues(newViewDates, viewDate, anotherIndex);
          }
          setInternalViewDates(newViewDates);
        } else if (startDate || endDate) {
          setInternalViewDates(null);
        }
      }
      return [getViewDate, setViewDate];
    }
    function reorderValues(values, generateConfig2) {
      if (values && values[0] && values[1] && generateConfig2.isAfter(values[0], values[1])) {
        return [values[1], values[0]];
      }
      return values;
    }
    function canValueTrigger(value, index2, disabled, allowEmpty) {
      if (value) {
        return true;
      }
      if (allowEmpty && allowEmpty[index2]) {
        return true;
      }
      if (disabled[(index2 + 1) % 2]) {
        return true;
      }
      return false;
    }
    function InnerRangePicker(props) {
      var _classNames2, _classNames3, _classNames4;
      var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-picker" : _ref$prefixCls, id2 = _ref.id, style2 = _ref.style, className = _ref.className, popupStyle = _ref.popupStyle, dropdownClassName = _ref.dropdownClassName, transitionName = _ref.transitionName, dropdownAlign = _ref.dropdownAlign, getPopupContainer = _ref.getPopupContainer, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, placeholder = _ref.placeholder, autoFocus = _ref.autoFocus, disabled = _ref.disabled, format2 = _ref.format, _ref$picker = _ref.picker, picker = _ref$picker === void 0 ? "date" : _ref$picker, showTime = _ref.showTime, use12Hours = _ref.use12Hours, _ref$separator = _ref.separator, separator = _ref$separator === void 0 ? "~" : _ref$separator, value = _ref.value, defaultValue = _ref.defaultValue, defaultPickerValue = _ref.defaultPickerValue, open2 = _ref.open, defaultOpen = _ref.defaultOpen, disabledDate = _ref.disabledDate, _disabledTime = _ref.disabledTime, dateRender = _ref.dateRender, panelRender = _ref.panelRender, presets = _ref.presets, ranges = _ref.ranges, allowEmpty = _ref.allowEmpty, allowClear = _ref.allowClear, suffixIcon = _ref.suffixIcon, clearIcon = _ref.clearIcon, pickerRef = _ref.pickerRef, inputReadOnly = _ref.inputReadOnly, mode = _ref.mode, renderExtraFooter = _ref.renderExtraFooter, onChange = _ref.onChange, onOpenChange = _ref.onOpenChange, onPanelChange = _ref.onPanelChange, onCalendarChange = _ref.onCalendarChange, _onFocus = _ref.onFocus, onBlur = _ref.onBlur, onMouseDown = _ref.onMouseDown, onMouseUp = _ref.onMouseUp, onMouseEnter = _ref.onMouseEnter, onMouseLeave = _ref.onMouseLeave, onClick = _ref.onClick, _onOk = _ref.onOk, _onKeyDown = _ref.onKeyDown, components = _ref.components, order2 = _ref.order, direction = _ref.direction, activePickerIndex = _ref.activePickerIndex, _ref$autoComplete = _ref.autoComplete, autoComplete = _ref$autoComplete === void 0 ? "off" : _ref$autoComplete;
      var needConfirmButton = picker === "date" && !!showTime || picker === "time";
      var openRecordsRef = reactExports.useRef({});
      var containerRef = reactExports.useRef(null);
      var panelDivRef = reactExports.useRef(null);
      var startInputDivRef = reactExports.useRef(null);
      var endInputDivRef = reactExports.useRef(null);
      var separatorRef = reactExports.useRef(null);
      var startInputRef = reactExports.useRef(null);
      var endInputRef = reactExports.useRef(null);
      var arrowRef = reactExports.useRef(null);
      var formatList = toArray$4(getDefaultFormat(format2, picker, showTime, use12Hours));
      var _useMergedState = useMergedState(0, {
        value: activePickerIndex
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedActivePickerIndex = _useMergedState2[0], setMergedActivePickerIndex = _useMergedState2[1];
      var operationRef = reactExports.useRef(null);
      var mergedDisabled = reactExports.useMemo(function() {
        if (Array.isArray(disabled)) {
          return disabled;
        }
        return [disabled || false, disabled || false];
      }, [disabled]);
      var _useMergedState3 = useMergedState(null, {
        value,
        defaultValue,
        postState: function postState(values) {
          return picker === "time" && !order2 ? values : reorderValues(values, generateConfig2);
        }
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedValue = _useMergedState4[0], setInnerValue = _useMergedState4[1];
      var _useRangeViewDates = useRangeViewDates({
        values: mergedValue,
        picker,
        defaultDates: defaultPickerValue,
        generateConfig: generateConfig2
      }), _useRangeViewDates2 = _slicedToArray(_useRangeViewDates, 2), getViewDate = _useRangeViewDates2[0], setViewDate = _useRangeViewDates2[1];
      var _useMergedState5 = useMergedState(mergedValue, {
        postState: function postState(values) {
          var postValues = values;
          if (mergedDisabled[0] && mergedDisabled[1]) {
            return postValues;
          }
          for (var i2 = 0; i2 < 2; i2 += 1) {
            if (mergedDisabled[i2] && !getValue$1(postValues, i2) && !getValue$1(allowEmpty, i2)) {
              postValues = updateValues(postValues, generateConfig2.getNow(), i2);
            }
          }
          return postValues;
        }
      }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), selectedValue = _useMergedState6[0], setSelectedValue = _useMergedState6[1];
      var _useMergedState7 = useMergedState([picker, picker], {
        value: mode
      }), _useMergedState8 = _slicedToArray(_useMergedState7, 2), mergedModes = _useMergedState8[0], setInnerModes = _useMergedState8[1];
      reactExports.useEffect(function() {
        setInnerModes([picker, picker]);
      }, [picker]);
      var triggerModesChange = function triggerModesChange2(modes, values) {
        setInnerModes(modes);
        if (onPanelChange) {
          onPanelChange(values, modes);
        }
      };
      var _useRangeDisabled = useRangeDisabled({
        picker,
        selectedValue,
        locale: locale2,
        disabled: mergedDisabled,
        disabledDate,
        generateConfig: generateConfig2
      }, openRecordsRef.current[1], openRecordsRef.current[0]), _useRangeDisabled2 = _slicedToArray(_useRangeDisabled, 2), disabledStartDate = _useRangeDisabled2[0], disabledEndDate = _useRangeDisabled2[1];
      var _useMergedState9 = useMergedState(false, {
        value: open2,
        defaultValue: defaultOpen,
        postState: function postState(postOpen) {
          return mergedDisabled[mergedActivePickerIndex] ? false : postOpen;
        },
        onChange: function onChange2(newOpen) {
          if (onOpenChange) {
            onOpenChange(newOpen);
          }
          if (!newOpen && operationRef.current && operationRef.current.onClose) {
            operationRef.current.onClose();
          }
        }
      }), _useMergedState10 = _slicedToArray(_useMergedState9, 2), mergedOpen = _useMergedState10[0], triggerInnerOpen = _useMergedState10[1];
      var startOpen = mergedOpen && mergedActivePickerIndex === 0;
      var endOpen = mergedOpen && mergedActivePickerIndex === 1;
      var _useState = reactExports.useState(0), _useState2 = _slicedToArray(_useState, 2), popupMinWidth = _useState2[0], setPopupMinWidth = _useState2[1];
      reactExports.useEffect(function() {
        if (!mergedOpen && containerRef.current) {
          setPopupMinWidth(containerRef.current.offsetWidth);
        }
      }, [mergedOpen]);
      var triggerRef = reactExports.useRef();
      function _triggerOpen(newOpen, index2) {
        if (newOpen) {
          clearTimeout(triggerRef.current);
          openRecordsRef.current[index2] = true;
          setMergedActivePickerIndex(index2);
          triggerInnerOpen(newOpen);
          if (!mergedOpen) {
            setViewDate(null, index2);
          }
        } else if (mergedActivePickerIndex === index2) {
          triggerInnerOpen(newOpen);
          var openRecords = openRecordsRef.current;
          triggerRef.current = setTimeout(function() {
            if (openRecords === openRecordsRef.current) {
              openRecordsRef.current = {};
            }
          });
        }
      }
      function triggerOpenAndFocus(index2) {
        _triggerOpen(true, index2);
        setTimeout(function() {
          var inputRef = [startInputRef, endInputRef][index2];
          if (inputRef.current) {
            inputRef.current.focus();
          }
        }, 0);
      }
      function triggerChange(newValue, sourceIndex) {
        var values = newValue;
        var startValue = getValue$1(values, 0);
        var endValue = getValue$1(values, 1);
        if (startValue && endValue && generateConfig2.isAfter(startValue, endValue)) {
          if (
            // WeekPicker only compare week
            picker === "week" && !isSameWeek(generateConfig2, locale2.locale, startValue, endValue) || // QuotaPicker only compare week
            picker === "quarter" && !isSameQuarter(generateConfig2, startValue, endValue) || // Other non-TimePicker compare date
            picker !== "week" && picker !== "quarter" && picker !== "time" && !isSameDate(generateConfig2, startValue, endValue)
          ) {
            if (sourceIndex === 0) {
              values = [startValue, null];
              endValue = null;
            } else {
              startValue = null;
              values = [null, endValue];
            }
            openRecordsRef.current = _defineProperty$7({}, sourceIndex, true);
          } else if (picker !== "time" || order2 !== false) {
            values = reorderValues(values, generateConfig2);
          }
        }
        setSelectedValue(values);
        var startStr2 = values && values[0] ? formatValue(values[0], {
          generateConfig: generateConfig2,
          locale: locale2,
          format: formatList[0]
        }) : "";
        var endStr2 = values && values[1] ? formatValue(values[1], {
          generateConfig: generateConfig2,
          locale: locale2,
          format: formatList[0]
        }) : "";
        if (onCalendarChange) {
          var _info = {
            range: sourceIndex === 0 ? "start" : "end"
          };
          onCalendarChange(values, [startStr2, endStr2], _info);
        }
        var canStartValueTrigger = canValueTrigger(startValue, 0, mergedDisabled, allowEmpty);
        var canEndValueTrigger = canValueTrigger(endValue, 1, mergedDisabled, allowEmpty);
        var canTrigger = values === null || canStartValueTrigger && canEndValueTrigger;
        if (canTrigger) {
          setInnerValue(values);
          if (onChange && (!isEqual(generateConfig2, getValue$1(mergedValue, 0), startValue) || !isEqual(generateConfig2, getValue$1(mergedValue, 1), endValue))) {
            onChange(values, [startStr2, endStr2]);
          }
        }
        var nextOpenIndex = null;
        if (sourceIndex === 0 && !mergedDisabled[1]) {
          nextOpenIndex = 1;
        } else if (sourceIndex === 1 && !mergedDisabled[0]) {
          nextOpenIndex = 0;
        }
        if (nextOpenIndex !== null && nextOpenIndex !== mergedActivePickerIndex && (!openRecordsRef.current[nextOpenIndex] || !getValue$1(values, nextOpenIndex)) && getValue$1(values, sourceIndex)) {
          triggerOpenAndFocus(nextOpenIndex);
        } else {
          _triggerOpen(false, sourceIndex);
        }
      }
      var forwardKeyDown = function forwardKeyDown2(e2) {
        if (mergedOpen && operationRef.current && operationRef.current.onKeyDown) {
          return operationRef.current.onKeyDown(e2);
        }
        {
          warningOnce$1(false, "Picker not correct forward KeyDown operation. Please help to fire issue about this.");
          return false;
        }
      };
      var sharedTextHooksProps = {
        formatList,
        generateConfig: generateConfig2,
        locale: locale2
      };
      var _useValueTexts = useValueTexts(getValue$1(selectedValue, 0), sharedTextHooksProps), _useValueTexts2 = _slicedToArray(_useValueTexts, 2), startValueTexts = _useValueTexts2[0], firstStartValueText = _useValueTexts2[1];
      var _useValueTexts3 = useValueTexts(getValue$1(selectedValue, 1), sharedTextHooksProps), _useValueTexts4 = _slicedToArray(_useValueTexts3, 2), endValueTexts = _useValueTexts4[0], firstEndValueText = _useValueTexts4[1];
      var _onTextChange = function onTextChange(newText, index2) {
        var inputDate = parseValue(newText, {
          locale: locale2,
          formatList,
          generateConfig: generateConfig2
        });
        var disabledFunc = index2 === 0 ? disabledStartDate : disabledEndDate;
        if (inputDate && !disabledFunc(inputDate)) {
          setSelectedValue(updateValues(selectedValue, inputDate, index2));
          setViewDate(inputDate, index2);
        }
      };
      var _useTextValueMapping = useTextValueMapping({
        valueTexts: startValueTexts,
        onTextChange: function onTextChange(newText) {
          return _onTextChange(newText, 0);
        }
      }), _useTextValueMapping2 = _slicedToArray(_useTextValueMapping, 3), startText = _useTextValueMapping2[0], triggerStartTextChange = _useTextValueMapping2[1], resetStartText = _useTextValueMapping2[2];
      var _useTextValueMapping3 = useTextValueMapping({
        valueTexts: endValueTexts,
        onTextChange: function onTextChange(newText) {
          return _onTextChange(newText, 1);
        }
      }), _useTextValueMapping4 = _slicedToArray(_useTextValueMapping3, 3), endText = _useTextValueMapping4[0], triggerEndTextChange = _useTextValueMapping4[1], resetEndText = _useTextValueMapping4[2];
      var _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), rangeHoverValue = _useState4[0], setRangeHoverValue = _useState4[1];
      var _useState5 = reactExports.useState(null), _useState6 = _slicedToArray(_useState5, 2), hoverRangedValue = _useState6[0], setHoverRangedValue = _useState6[1];
      var _useHoverValue = useHoverValue(startText, {
        formatList,
        generateConfig: generateConfig2,
        locale: locale2
      }), _useHoverValue2 = _slicedToArray(_useHoverValue, 3), startHoverValue = _useHoverValue2[0], onStartEnter = _useHoverValue2[1], onStartLeave = _useHoverValue2[2];
      var _useHoverValue3 = useHoverValue(endText, {
        formatList,
        generateConfig: generateConfig2,
        locale: locale2
      }), _useHoverValue4 = _slicedToArray(_useHoverValue3, 3), endHoverValue = _useHoverValue4[0], onEndEnter = _useHoverValue4[1], onEndLeave = _useHoverValue4[2];
      var onDateMouseEnter = function onDateMouseEnter2(date2) {
        setHoverRangedValue(updateValues(selectedValue, date2, mergedActivePickerIndex));
        if (mergedActivePickerIndex === 0) {
          onStartEnter(date2);
        } else {
          onEndEnter(date2);
        }
      };
      var onDateMouseLeave = function onDateMouseLeave2() {
        setHoverRangedValue(updateValues(selectedValue, null, mergedActivePickerIndex));
        if (mergedActivePickerIndex === 0) {
          onStartLeave();
        } else {
          onEndLeave();
        }
      };
      var getSharedInputHookProps = function getSharedInputHookProps2(index2, resetText) {
        return {
          blurToCancel: needConfirmButton,
          forwardKeyDown,
          onBlur,
          isClickOutside: function isClickOutside(target) {
            return !elementsContains([panelDivRef.current, startInputDivRef.current, endInputDivRef.current, containerRef.current], target);
          },
          onFocus: function onFocus(e2) {
            setMergedActivePickerIndex(index2);
            if (_onFocus) {
              _onFocus(e2);
            }
          },
          triggerOpen: function triggerOpen(newOpen) {
            _triggerOpen(newOpen, index2);
          },
          onSubmit: function onSubmit() {
            if (
              // When user typing disabledDate with keyboard and enter, this value will be empty
              !selectedValue || // Normal disabled check
              disabledDate && disabledDate(selectedValue[index2])
            ) {
              return false;
            }
            triggerChange(selectedValue, index2);
            resetText();
          },
          onCancel: function onCancel() {
            _triggerOpen(false, index2);
            setSelectedValue(mergedValue);
            resetText();
          }
        };
      };
      var _usePickerInput = usePickerInput(_objectSpread2$3(_objectSpread2$3({}, getSharedInputHookProps(0, resetStartText)), {}, {
        open: startOpen,
        value: startText,
        onKeyDown: function onKeyDown2(e2, preventDefault) {
          _onKeyDown === null || _onKeyDown === void 0 ? void 0 : _onKeyDown(e2, preventDefault);
        }
      })), _usePickerInput2 = _slicedToArray(_usePickerInput, 2), startInputProps = _usePickerInput2[0], _usePickerInput2$ = _usePickerInput2[1], startFocused = _usePickerInput2$.focused, startTyping = _usePickerInput2$.typing;
      var _usePickerInput3 = usePickerInput(_objectSpread2$3(_objectSpread2$3({}, getSharedInputHookProps(1, resetEndText)), {}, {
        open: endOpen,
        value: endText,
        onKeyDown: function onKeyDown2(e2, preventDefault) {
          _onKeyDown === null || _onKeyDown === void 0 ? void 0 : _onKeyDown(e2, preventDefault);
        }
      })), _usePickerInput4 = _slicedToArray(_usePickerInput3, 2), endInputProps = _usePickerInput4[0], _usePickerInput4$ = _usePickerInput4[1], endFocused = _usePickerInput4$.focused, endTyping = _usePickerInput4$.typing;
      var onPickerClick = function onPickerClick2(e2) {
        if (onClick) {
          onClick(e2);
        }
        if (!mergedOpen && !startInputRef.current.contains(e2.target) && !endInputRef.current.contains(e2.target)) {
          if (!mergedDisabled[0]) {
            triggerOpenAndFocus(0);
          } else if (!mergedDisabled[1]) {
            triggerOpenAndFocus(1);
          }
        }
      };
      var onPickerMouseDown = function onPickerMouseDown2(e2) {
        if (onMouseDown) {
          onMouseDown(e2);
        }
        if (mergedOpen && (startFocused || endFocused) && !startInputRef.current.contains(e2.target) && !endInputRef.current.contains(e2.target)) {
          e2.preventDefault();
        }
      };
      var startStr = mergedValue && mergedValue[0] ? formatValue(mergedValue[0], {
        locale: locale2,
        format: "YYYYMMDDHHmmss",
        generateConfig: generateConfig2
      }) : "";
      var endStr = mergedValue && mergedValue[1] ? formatValue(mergedValue[1], {
        locale: locale2,
        format: "YYYYMMDDHHmmss",
        generateConfig: generateConfig2
      }) : "";
      reactExports.useEffect(function() {
        if (!mergedOpen) {
          setSelectedValue(mergedValue);
          if (!startValueTexts.length || startValueTexts[0] === "") {
            triggerStartTextChange("");
          } else if (firstStartValueText !== startText) {
            resetStartText();
          }
          if (!endValueTexts.length || endValueTexts[0] === "") {
            triggerEndTextChange("");
          } else if (firstEndValueText !== endText) {
            resetEndText();
          }
        }
      }, [mergedOpen, startValueTexts, endValueTexts]);
      reactExports.useEffect(function() {
        setSelectedValue(mergedValue);
      }, [startStr, endStr]);
      if (pickerRef) {
        pickerRef.current = {
          focus: function focus() {
            if (startInputRef.current) {
              startInputRef.current.focus();
            }
          },
          blur: function blur() {
            if (startInputRef.current) {
              startInputRef.current.blur();
            }
            if (endInputRef.current) {
              endInputRef.current.blur();
            }
          }
        };
      }
      var presetList = usePresets(presets, ranges);
      function renderPanel() {
        var panelPosition = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var panelProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var panelHoverRangedValue = null;
        if (mergedOpen && hoverRangedValue && hoverRangedValue[0] && hoverRangedValue[1] && generateConfig2.isAfter(hoverRangedValue[1], hoverRangedValue[0])) {
          panelHoverRangedValue = hoverRangedValue;
        }
        var panelShowTime = showTime;
        if (showTime && _typeof$4(showTime) === "object" && showTime.defaultValue) {
          var timeDefaultValues = showTime.defaultValue;
          panelShowTime = _objectSpread2$3(_objectSpread2$3({}, showTime), {}, {
            defaultValue: getValue$1(timeDefaultValues, mergedActivePickerIndex) || void 0
          });
        }
        var panelDateRender = null;
        if (dateRender) {
          panelDateRender = function panelDateRender2(date2, today) {
            return dateRender(date2, today, {
              range: mergedActivePickerIndex ? "end" : "start"
            });
          };
        }
        return /* @__PURE__ */ reactExports.createElement(RangeContext.Provider, {
          value: {
            inRange: true,
            panelPosition,
            rangedValue: rangeHoverValue || selectedValue,
            hoverRangedValue: panelHoverRangedValue
          }
        }, /* @__PURE__ */ reactExports.createElement(PickerPanel, _extends$2({}, props, panelProps, {
          dateRender: panelDateRender,
          showTime: panelShowTime,
          mode: mergedModes[mergedActivePickerIndex],
          generateConfig: generateConfig2,
          style: void 0,
          direction,
          disabledDate: mergedActivePickerIndex === 0 ? disabledStartDate : disabledEndDate,
          disabledTime: function disabledTime(date2) {
            if (_disabledTime) {
              return _disabledTime(date2, mergedActivePickerIndex === 0 ? "start" : "end");
            }
            return false;
          },
          className: classNames(_defineProperty$7({}, "".concat(prefixCls, "-panel-focused"), mergedActivePickerIndex === 0 ? !startTyping : !endTyping)),
          value: getValue$1(selectedValue, mergedActivePickerIndex),
          locale: locale2,
          tabIndex: -1,
          onPanelChange: function onPanelChange2(date2, newMode) {
            if (mergedActivePickerIndex === 0) {
              onStartLeave(true);
            }
            if (mergedActivePickerIndex === 1) {
              onEndLeave(true);
            }
            triggerModesChange(updateValues(mergedModes, newMode, mergedActivePickerIndex), updateValues(selectedValue, date2, mergedActivePickerIndex));
            var viewDate = date2;
            if (panelPosition === "right" && mergedModes[mergedActivePickerIndex] === newMode) {
              viewDate = getClosingViewDate(viewDate, newMode, generateConfig2, -1);
            }
            setViewDate(viewDate, mergedActivePickerIndex);
          },
          onOk: null,
          onSelect: void 0,
          onChange: void 0,
          defaultValue: mergedActivePickerIndex === 0 ? getValue$1(selectedValue, 1) : getValue$1(selectedValue, 0)
          // defaultPickerValue={undefined}
        })));
      }
      var arrowLeft = 0;
      var panelLeft = 0;
      if (mergedActivePickerIndex && startInputDivRef.current && separatorRef.current && panelDivRef.current) {
        arrowLeft = startInputDivRef.current.offsetWidth + separatorRef.current.offsetWidth;
        var arrowMarginLeft = arrowRef.current.offsetLeft > arrowLeft ? arrowRef.current.offsetLeft - arrowLeft : arrowRef.current.offsetLeft;
        if (panelDivRef.current.offsetWidth !== void 0 && arrowRef.current.offsetWidth !== void 0 && arrowLeft > panelDivRef.current.offsetWidth - arrowRef.current.offsetWidth - (direction === "rtl" ? 0 : arrowMarginLeft)) {
          panelLeft = arrowLeft;
        }
      }
      var arrowPositionStyle = direction === "rtl" ? {
        right: arrowLeft
      } : {
        left: arrowLeft
      };
      function renderPanels() {
        var panels;
        var extraNode = getExtraFooter(prefixCls, mergedModes[mergedActivePickerIndex], renderExtraFooter);
        var rangesNode = getRanges({
          prefixCls,
          components,
          needConfirmButton,
          okDisabled: !getValue$1(selectedValue, mergedActivePickerIndex) || disabledDate && disabledDate(selectedValue[mergedActivePickerIndex]),
          locale: locale2,
          // rangeList,
          onOk: function onOk() {
            if (getValue$1(selectedValue, mergedActivePickerIndex)) {
              triggerChange(selectedValue, mergedActivePickerIndex);
              if (_onOk) {
                _onOk(selectedValue);
              }
            }
          }
        });
        if (picker !== "time" && !showTime) {
          var viewDate = getViewDate(mergedActivePickerIndex);
          var nextViewDate = getClosingViewDate(viewDate, picker, generateConfig2);
          var currentMode = mergedModes[mergedActivePickerIndex];
          var showDoublePanel = currentMode === picker;
          var leftPanel = renderPanel(showDoublePanel ? "left" : false, {
            pickerValue: viewDate,
            onPickerValueChange: function onPickerValueChange(newViewDate) {
              setViewDate(newViewDate, mergedActivePickerIndex);
            }
          });
          var rightPanel = renderPanel("right", {
            pickerValue: nextViewDate,
            onPickerValueChange: function onPickerValueChange(newViewDate) {
              setViewDate(getClosingViewDate(newViewDate, picker, generateConfig2, -1), mergedActivePickerIndex);
            }
          });
          if (direction === "rtl") {
            panels = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, rightPanel, showDoublePanel && leftPanel);
          } else {
            panels = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, leftPanel, showDoublePanel && rightPanel);
          }
        } else {
          panels = renderPanel();
        }
        var mergedNodes = /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(prefixCls, "-panel-layout")
        }, /* @__PURE__ */ reactExports.createElement(PresetPanel, {
          prefixCls,
          presets: presetList,
          onClick: function onClick2(nextValue) {
            triggerChange(nextValue, null);
            _triggerOpen(false, mergedActivePickerIndex);
          },
          onHover: function onHover(hoverValue) {
            setRangeHoverValue(hoverValue);
          }
        }), /* @__PURE__ */ reactExports.createElement("div", null, /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(prefixCls, "-panels")
        }, panels), (extraNode || rangesNode) && /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(prefixCls, "-footer")
        }, extraNode, rangesNode)));
        if (panelRender) {
          mergedNodes = panelRender(mergedNodes);
        }
        return /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(prefixCls, "-panel-container"),
          style: {
            marginLeft: panelLeft
          },
          ref: panelDivRef,
          onMouseDown: function onMouseDown2(e2) {
            e2.preventDefault();
          }
        }, mergedNodes);
      }
      var rangePanel = /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-range-wrapper"), "".concat(prefixCls, "-").concat(picker, "-range-wrapper")),
        style: {
          minWidth: popupMinWidth
        }
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: arrowRef,
        className: "".concat(prefixCls, "-range-arrow"),
        style: arrowPositionStyle
      }), renderPanels());
      var suffixNode;
      if (suffixIcon) {
        suffixNode = /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(prefixCls, "-suffix")
        }, suffixIcon);
      }
      var clearNode;
      if (allowClear && (getValue$1(mergedValue, 0) && !mergedDisabled[0] || getValue$1(mergedValue, 1) && !mergedDisabled[1])) {
        clearNode = /* @__PURE__ */ reactExports.createElement("span", {
          onMouseDown: function onMouseDown2(e2) {
            e2.preventDefault();
            e2.stopPropagation();
          },
          onMouseUp: function onMouseUp2(e2) {
            e2.preventDefault();
            e2.stopPropagation();
            var values = mergedValue;
            if (!mergedDisabled[0]) {
              values = updateValues(values, null, 0);
            }
            if (!mergedDisabled[1]) {
              values = updateValues(values, null, 1);
            }
            triggerChange(values, null);
            _triggerOpen(false, mergedActivePickerIndex);
          },
          className: "".concat(prefixCls, "-clear")
        }, clearIcon || /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(prefixCls, "-clear-btn")
        }));
      }
      var inputSharedProps = {
        size: getInputSize(picker, formatList[0], generateConfig2)
      };
      var activeBarLeft = 0;
      var activeBarWidth = 0;
      if (startInputDivRef.current && endInputDivRef.current && separatorRef.current) {
        if (mergedActivePickerIndex === 0) {
          activeBarWidth = startInputDivRef.current.offsetWidth;
        } else {
          activeBarLeft = arrowLeft;
          activeBarWidth = endInputDivRef.current.offsetWidth;
        }
      }
      var activeBarPositionStyle = direction === "rtl" ? {
        right: activeBarLeft
      } : {
        left: activeBarLeft
      };
      var onContextSelect = function onContextSelect2(date2, type2) {
        var values = updateValues(selectedValue, date2, mergedActivePickerIndex);
        if (type2 === "submit" || type2 !== "key" && !needConfirmButton) {
          triggerChange(values, mergedActivePickerIndex);
          if (mergedActivePickerIndex === 0) {
            onStartLeave();
          } else {
            onEndLeave();
          }
        } else {
          setSelectedValue(values);
        }
      };
      return /* @__PURE__ */ reactExports.createElement(PanelContext.Provider, {
        value: {
          operationRef,
          hideHeader: picker === "time",
          onDateMouseEnter,
          onDateMouseLeave,
          hideRanges: true,
          onSelect: onContextSelect,
          open: mergedOpen
        }
      }, /* @__PURE__ */ reactExports.createElement(PickerTrigger, {
        visible: mergedOpen,
        popupElement: rangePanel,
        popupStyle,
        prefixCls,
        dropdownClassName,
        dropdownAlign,
        getPopupContainer,
        transitionName,
        range: true,
        direction
      }, /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        ref: containerRef,
        className: classNames(prefixCls, "".concat(prefixCls, "-range"), className, (_classNames2 = {}, _defineProperty$7(_classNames2, "".concat(prefixCls, "-disabled"), mergedDisabled[0] && mergedDisabled[1]), _defineProperty$7(_classNames2, "".concat(prefixCls, "-focused"), mergedActivePickerIndex === 0 ? startFocused : endFocused), _defineProperty$7(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames2)),
        style: style2,
        onClick: onPickerClick,
        onMouseEnter,
        onMouseLeave,
        onMouseDown: onPickerMouseDown,
        onMouseUp
      }, getDataOrAriaProps(props)), /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-input"), (_classNames3 = {}, _defineProperty$7(_classNames3, "".concat(prefixCls, "-input-active"), mergedActivePickerIndex === 0), _defineProperty$7(_classNames3, "".concat(prefixCls, "-input-placeholder"), !!startHoverValue), _classNames3)),
        ref: startInputDivRef
      }, /* @__PURE__ */ reactExports.createElement("input", _extends$2({
        id: id2,
        disabled: mergedDisabled[0],
        readOnly: inputReadOnly || typeof formatList[0] === "function" || !startTyping,
        value: startHoverValue || startText,
        onChange: function onChange2(e2) {
          triggerStartTextChange(e2.target.value);
        },
        autoFocus,
        placeholder: getValue$1(placeholder, 0) || "",
        ref: startInputRef
      }, startInputProps, inputSharedProps, {
        autoComplete
      }))), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-range-separator"),
        ref: separatorRef
      }, separator), /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-input"), (_classNames4 = {}, _defineProperty$7(_classNames4, "".concat(prefixCls, "-input-active"), mergedActivePickerIndex === 1), _defineProperty$7(_classNames4, "".concat(prefixCls, "-input-placeholder"), !!endHoverValue), _classNames4)),
        ref: endInputDivRef
      }, /* @__PURE__ */ reactExports.createElement("input", _extends$2({
        disabled: mergedDisabled[1],
        readOnly: inputReadOnly || typeof formatList[0] === "function" || !endTyping,
        value: endHoverValue || endText,
        onChange: function onChange2(e2) {
          triggerEndTextChange(e2.target.value);
        },
        placeholder: getValue$1(placeholder, 1) || "",
        ref: endInputRef
      }, endInputProps, inputSharedProps, {
        autoComplete
      }))), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-active-bar"),
        style: _objectSpread2$3(_objectSpread2$3({}, activeBarPositionStyle), {}, {
          width: activeBarWidth,
          position: "absolute"
        })
      }), suffixNode, clearNode)));
    }
    var RangePicker$1 = /* @__PURE__ */ function(_React$Component) {
      _inherits(RangePicker2, _React$Component);
      var _super = _createSuper(RangePicker2);
      function RangePicker2() {
        var _this;
        _classCallCheck(this, RangePicker2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$7(_assertThisInitialized(_this), "pickerRef", /* @__PURE__ */ reactExports.createRef());
        _defineProperty$7(_assertThisInitialized(_this), "focus", function() {
          if (_this.pickerRef.current) {
            _this.pickerRef.current.focus();
          }
        });
        _defineProperty$7(_assertThisInitialized(_this), "blur", function() {
          if (_this.pickerRef.current) {
            _this.pickerRef.current.blur();
          }
        });
        return _this;
      }
      _createClass(RangePicker2, [{
        key: "render",
        value: function render2() {
          return /* @__PURE__ */ reactExports.createElement(InnerRangePicker, _extends$2({}, this.props, {
            pickerRef: this.pickerRef
          }));
        }
      }]);
      return RangePicker2;
    }(reactExports.Component);
    const RadioGroupContext = /* @__PURE__ */ reactExports.createContext(null);
    const RadioGroupContextProvider = RadioGroupContext.Provider;
    const RadioOptionTypeContext = /* @__PURE__ */ reactExports.createContext(null);
    const RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;
    var Checkbox$3 = /* @__PURE__ */ function(_Component) {
      _inherits(Checkbox2, _Component);
      var _super = _createSuper(Checkbox2);
      function Checkbox2(props) {
        var _this;
        _classCallCheck(this, Checkbox2);
        _this = _super.call(this, props);
        _this.handleChange = function(e2) {
          var _this$props = _this.props, disabled = _this$props.disabled, onChange = _this$props.onChange;
          if (disabled) {
            return;
          }
          if (!("checked" in _this.props)) {
            _this.setState({
              checked: e2.target.checked
            });
          }
          if (onChange) {
            onChange({
              target: _objectSpread2$3(_objectSpread2$3({}, _this.props), {}, {
                checked: e2.target.checked
              }),
              stopPropagation: function stopPropagation() {
                e2.stopPropagation();
              },
              preventDefault: function preventDefault() {
                e2.preventDefault();
              },
              nativeEvent: e2.nativeEvent
            });
          }
        };
        _this.saveInput = function(node2) {
          _this.input = node2;
        };
        var checked = "checked" in props ? props.checked : props.defaultChecked;
        _this.state = {
          checked
        };
        return _this;
      }
      _createClass(Checkbox2, [{
        key: "focus",
        value: function focus() {
          this.input.focus();
        }
      }, {
        key: "blur",
        value: function blur() {
          this.input.blur();
        }
      }, {
        key: "render",
        value: function render2() {
          var _classNames;
          var _this$props2 = this.props, prefixCls = _this$props2.prefixCls, className = _this$props2.className, style2 = _this$props2.style, name = _this$props2.name, id2 = _this$props2.id, type2 = _this$props2.type, disabled = _this$props2.disabled, readOnly2 = _this$props2.readOnly, tabIndex = _this$props2.tabIndex, onClick = _this$props2.onClick, onFocus = _this$props2.onFocus, onBlur = _this$props2.onBlur, onKeyDown2 = _this$props2.onKeyDown, onKeyPress = _this$props2.onKeyPress, onKeyUp = _this$props2.onKeyUp, autoFocus = _this$props2.autoFocus, value = _this$props2.value, required2 = _this$props2.required, others = _objectWithoutProperties$1(_this$props2, ["prefixCls", "className", "style", "name", "id", "type", "disabled", "readOnly", "tabIndex", "onClick", "onFocus", "onBlur", "onKeyDown", "onKeyPress", "onKeyUp", "autoFocus", "value", "required"]);
          var globalProps = Object.keys(others).reduce(function(prev2, key) {
            if (key.substr(0, 5) === "aria-" || key.substr(0, 5) === "data-" || key === "role") {
              prev2[key] = others[key];
            }
            return prev2;
          }, {});
          var checked = this.state.checked;
          var classString = classNames(prefixCls, className, (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-checked"), checked), _defineProperty$7(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
          return /* @__PURE__ */ React$3.createElement("span", {
            className: classString,
            style: style2
          }, /* @__PURE__ */ React$3.createElement("input", _extends$2({
            name,
            id: id2,
            type: type2,
            required: required2,
            readOnly: readOnly2,
            disabled,
            tabIndex,
            className: "".concat(prefixCls, "-input"),
            checked: !!checked,
            onClick,
            onFocus,
            onBlur,
            onKeyUp,
            onKeyDown: onKeyDown2,
            onKeyPress,
            onChange: this.handleChange,
            autoFocus,
            ref: this.saveInput,
            value
          }, globalProps)), /* @__PURE__ */ React$3.createElement("span", {
            className: "".concat(prefixCls, "-inner")
          }));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(props, state) {
          if ("checked" in props) {
            return _objectSpread2$3(_objectSpread2$3({}, state), {}, {
              checked: props.checked
            });
          }
          return null;
        }
      }]);
      return Checkbox2;
    }(reactExports.Component);
    Checkbox$3.defaultProps = {
      prefixCls: "rc-checkbox",
      className: "",
      style: {},
      type: "checkbox",
      defaultChecked: false,
      onFocus: function onFocus() {
      },
      onBlur: function onBlur() {
      },
      onChange: function onChange() {
      },
      onKeyDown: function onKeyDown2() {
      },
      onKeyPress: function onKeyPress() {
      },
      onKeyUp: function onKeyUp() {
      }
    };
    const antRadioEffect = new Keyframe("antRadioEffect", {
      "0%": {
        transform: "scale(1)",
        opacity: 0.5
      },
      "100%": {
        transform: "scale(1.6)",
        opacity: 0
      }
    });
    const getGroupRadioStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      const groupPrefixCls = `${componentCls}-group`;
      return {
        [groupPrefixCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
          display: "inline-block",
          fontSize: 0,
          // RTL
          [`&${groupPrefixCls}-rtl`]: {
            direction: "rtl"
          },
          [`${antCls}-badge ${antCls}-badge-count`]: {
            zIndex: 1
          },
          [`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: {
            borderInlineStart: "none"
          }
        })
      };
    };
    const getRadioBasicStyle = (token2) => {
      const {
        componentCls,
        radioWrapperMarginRight,
        radioCheckedColor,
        radioSize,
        motionDurationSlow,
        motionDurationMid,
        motionEaseInOut,
        motionEaseInOutCirc,
        radioButtonBg,
        colorBorder,
        lineWidth,
        radioDotSize,
        colorBgContainerDisabled,
        colorTextDisabled,
        paddingXS,
        radioDotDisabledColor,
        lineType,
        radioDotDisabledSize,
        wireframe,
        colorWhite
      } = token2;
      const radioInnerPrefixCls = `${componentCls}-inner`;
      return {
        [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
          position: "relative",
          display: "inline-flex",
          alignItems: "baseline",
          marginInlineStart: 0,
          marginInlineEnd: radioWrapperMarginRight,
          cursor: "pointer",
          // RTL
          [`&${componentCls}-wrapper-rtl`]: {
            direction: "rtl"
          },
          "&-disabled": {
            cursor: "not-allowed",
            color: token2.colorTextDisabled
          },
          "&::after": {
            display: "inline-block",
            width: 0,
            overflow: "hidden",
            content: '"\\a0"'
          },
          // hashId 在 wrapper 上，只能铺平
          [`${componentCls}-checked::after`]: {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineStart: 0,
            width: "100%",
            height: "100%",
            border: `${lineWidth}px ${lineType} ${radioCheckedColor}`,
            borderRadius: "50%",
            visibility: "hidden",
            animationName: antRadioEffect,
            animationDuration: motionDurationSlow,
            animationTimingFunction: motionEaseInOut,
            animationFillMode: "both",
            content: '""'
          },
          [componentCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
            position: "relative",
            display: "inline-block",
            outline: "none",
            cursor: "pointer",
            alignSelf: "center"
          }),
          [`${componentCls}-wrapper:hover &,
        &:hover ${radioInnerPrefixCls}`]: {
            borderColor: radioCheckedColor
          },
          [`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: Object.assign({}, genFocusOutline(token2)),
          [`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: {
            visibility: "visible"
          },
          [`${componentCls}-inner`]: {
            "&::after": {
              boxSizing: "border-box",
              position: "absolute",
              insetBlockStart: "50%",
              insetInlineStart: "50%",
              display: "block",
              width: radioSize,
              height: radioSize,
              marginBlockStart: radioSize / -2,
              marginInlineStart: radioSize / -2,
              backgroundColor: wireframe ? radioCheckedColor : colorWhite,
              borderBlockStart: 0,
              borderInlineStart: 0,
              borderRadius: radioSize,
              transform: "scale(0)",
              opacity: 0,
              transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
              content: '""'
            },
            boxSizing: "border-box",
            position: "relative",
            insetBlockStart: 0,
            insetInlineStart: 0,
            display: "block",
            width: radioSize,
            height: radioSize,
            backgroundColor: radioButtonBg,
            borderColor: colorBorder,
            borderStyle: "solid",
            borderWidth: lineWidth,
            borderRadius: "50%",
            transition: `all ${motionDurationMid}`
          },
          [`${componentCls}-input`]: {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineEnd: 0,
            insetBlockEnd: 0,
            insetInlineStart: 0,
            zIndex: 1,
            cursor: "pointer",
            opacity: 0
          },
          // 选中状态
          [`${componentCls}-checked`]: {
            [radioInnerPrefixCls]: {
              borderColor: radioCheckedColor,
              backgroundColor: wireframe ? radioButtonBg : radioCheckedColor,
              "&::after": {
                transform: `scale(${radioDotSize / radioSize})`,
                opacity: 1,
                transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
              }
            }
          },
          [`${componentCls}-disabled`]: {
            cursor: "not-allowed",
            [radioInnerPrefixCls]: {
              backgroundColor: colorBgContainerDisabled,
              borderColor: colorBorder,
              cursor: "not-allowed",
              "&::after": {
                backgroundColor: radioDotDisabledColor
              }
            },
            [`${componentCls}-input`]: {
              cursor: "not-allowed"
            },
            [`${componentCls}-disabled + span`]: {
              color: colorTextDisabled,
              cursor: "not-allowed"
            },
            [`&${componentCls}-checked`]: {
              [radioInnerPrefixCls]: {
                "&::after": {
                  transform: `scale(${radioDotDisabledSize / radioSize})`
                }
              }
            }
          },
          [`span${componentCls} + *`]: {
            paddingInlineStart: paddingXS,
            paddingInlineEnd: paddingXS
          }
        })
      };
    };
    const getRadioButtonStyle = (token2) => {
      const {
        radioButtonColor,
        controlHeight,
        componentCls,
        lineWidth,
        lineType,
        colorBorder,
        motionDurationSlow,
        motionDurationMid,
        radioButtonPaddingHorizontal,
        fontSize,
        radioButtonBg,
        fontSizeLG,
        controlHeightLG,
        controlHeightSM,
        paddingXS,
        borderRadius,
        borderRadiusSM,
        borderRadiusLG,
        radioCheckedColor,
        radioButtonCheckedBg,
        radioButtonHoverColor,
        radioButtonActiveColor,
        radioSolidCheckedColor,
        colorTextDisabled,
        colorBgContainerDisabled,
        radioDisabledButtonCheckedColor,
        radioDisabledButtonCheckedBg
      } = token2;
      return {
        [`${componentCls}-button-wrapper`]: {
          position: "relative",
          display: "inline-block",
          height: controlHeight,
          margin: 0,
          paddingInline: radioButtonPaddingHorizontal,
          paddingBlock: 0,
          color: radioButtonColor,
          fontSize,
          lineHeight: `${controlHeight - lineWidth * 2}px`,
          background: radioButtonBg,
          border: `${lineWidth}px ${lineType} ${colorBorder}`,
          // strange align fix for chrome but works
          // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
          borderBlockStartWidth: lineWidth + 0.02,
          borderInlineStartWidth: 0,
          borderInlineEndWidth: lineWidth,
          cursor: "pointer",
          transition: [`color ${motionDurationMid}`, `background ${motionDurationMid}`, `border-color ${motionDurationMid}`, `box-shadow ${motionDurationMid}`].join(","),
          a: {
            color: radioButtonColor
          },
          [`> ${componentCls}-button`]: {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineStart: 0,
            zIndex: -1,
            width: "100%",
            height: "100%"
          },
          "&:not(:first-child)": {
            "&::before": {
              position: "absolute",
              insetBlockStart: -lineWidth,
              insetInlineStart: -lineWidth,
              display: "block",
              boxSizing: "content-box",
              width: 1,
              height: "100%",
              paddingBlock: lineWidth,
              paddingInline: 0,
              backgroundColor: colorBorder,
              transition: `background-color ${motionDurationSlow}`,
              content: '""'
            }
          },
          "&:first-child": {
            borderInlineStart: `${lineWidth}px ${lineType} ${colorBorder}`,
            borderStartStartRadius: borderRadius,
            borderEndStartRadius: borderRadius
          },
          "&:last-child": {
            borderStartEndRadius: borderRadius,
            borderEndEndRadius: borderRadius
          },
          "&:first-child:last-child": {
            borderRadius
          },
          [`${componentCls}-group-large &`]: {
            height: controlHeightLG,
            fontSize: fontSizeLG,
            lineHeight: `${controlHeightLG - lineWidth * 2}px`,
            "&:first-child": {
              borderStartStartRadius: borderRadiusLG,
              borderEndStartRadius: borderRadiusLG
            },
            "&:last-child": {
              borderStartEndRadius: borderRadiusLG,
              borderEndEndRadius: borderRadiusLG
            }
          },
          [`${componentCls}-group-small &`]: {
            height: controlHeightSM,
            paddingInline: paddingXS - lineWidth,
            paddingBlock: 0,
            lineHeight: `${controlHeightSM - lineWidth * 2}px`,
            "&:first-child": {
              borderStartStartRadius: borderRadiusSM,
              borderEndStartRadius: borderRadiusSM
            },
            "&:last-child": {
              borderStartEndRadius: borderRadiusSM,
              borderEndEndRadius: borderRadiusSM
            }
          },
          "&:hover": {
            position: "relative",
            color: radioCheckedColor
          },
          "&:has(:focus-visible)": Object.assign({}, genFocusOutline(token2)),
          [`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
            width: 0,
            height: 0,
            opacity: 0,
            pointerEvents: "none"
          },
          [`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
            zIndex: 1,
            color: radioCheckedColor,
            background: radioButtonCheckedBg,
            borderColor: radioCheckedColor,
            "&::before": {
              backgroundColor: radioCheckedColor
            },
            "&:first-child": {
              borderColor: radioCheckedColor
            },
            "&:hover": {
              color: radioButtonHoverColor,
              borderColor: radioButtonHoverColor,
              "&::before": {
                backgroundColor: radioButtonHoverColor
              }
            },
            "&:active": {
              color: radioButtonActiveColor,
              borderColor: radioButtonActiveColor,
              "&::before": {
                backgroundColor: radioButtonActiveColor
              }
            }
          },
          [`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
            color: radioSolidCheckedColor,
            background: radioCheckedColor,
            borderColor: radioCheckedColor,
            "&:hover": {
              color: radioSolidCheckedColor,
              background: radioButtonHoverColor,
              borderColor: radioButtonHoverColor
            },
            "&:active": {
              color: radioSolidCheckedColor,
              background: radioButtonActiveColor,
              borderColor: radioButtonActiveColor
            }
          },
          "&-disabled": {
            color: colorTextDisabled,
            backgroundColor: colorBgContainerDisabled,
            borderColor: colorBorder,
            cursor: "not-allowed",
            "&:first-child, &:hover": {
              color: colorTextDisabled,
              backgroundColor: colorBgContainerDisabled,
              borderColor: colorBorder
            }
          },
          [`&-disabled${componentCls}-button-wrapper-checked`]: {
            color: radioDisabledButtonCheckedColor,
            backgroundColor: radioDisabledButtonCheckedBg,
            borderColor: colorBorder,
            boxShadow: "none"
          }
        }
      };
    };
    const useStyle$m = genComponentStyleHook("Radio", (token2) => {
      const {
        padding,
        lineWidth,
        controlItemBgActiveDisabled,
        colorTextDisabled,
        colorBgContainer,
        fontSizeLG,
        controlOutline,
        colorPrimaryHover,
        colorPrimaryActive,
        colorText,
        colorPrimary,
        marginXS,
        controlOutlineWidth,
        colorTextLightSolid,
        wireframe
      } = token2;
      const radioFocusShadow = `0 0 0 ${controlOutlineWidth}px ${controlOutline}`;
      const radioButtonFocusShadow = radioFocusShadow;
      const radioSize = fontSizeLG;
      const dotPadding = 4;
      const radioDotDisabledSize = radioSize - dotPadding * 2;
      const radioDotSize = wireframe ? radioDotDisabledSize : radioSize - (dotPadding + lineWidth) * 2;
      const radioCheckedColor = colorPrimary;
      const radioButtonColor = colorText;
      const radioButtonHoverColor = colorPrimaryHover;
      const radioButtonActiveColor = colorPrimaryActive;
      const radioButtonPaddingHorizontal = padding - lineWidth;
      const radioDisabledButtonCheckedColor = colorTextDisabled;
      const radioWrapperMarginRight = marginXS;
      const radioToken = merge$4(token2, {
        radioFocusShadow,
        radioButtonFocusShadow,
        radioSize,
        radioDotSize,
        radioDotDisabledSize,
        radioCheckedColor,
        radioDotDisabledColor: colorTextDisabled,
        radioSolidCheckedColor: colorTextLightSolid,
        radioButtonBg: colorBgContainer,
        radioButtonCheckedBg: colorBgContainer,
        radioButtonColor,
        radioButtonHoverColor,
        radioButtonActiveColor,
        radioButtonPaddingHorizontal,
        radioDisabledButtonCheckedBg: controlItemBgActiveDisabled,
        radioDisabledButtonCheckedColor,
        radioWrapperMarginRight
      });
      return [getGroupRadioStyle(radioToken), getRadioBasicStyle(radioToken), getRadioButtonStyle(radioToken)];
    });
    var __rest$G = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const InternalRadio = (props, ref) => {
      var _a, _b;
      const groupContext = reactExports.useContext(RadioGroupContext);
      const radioOptionTypeContext = reactExports.useContext(RadioOptionTypeContext);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const innerRef = reactExports.useRef();
      const mergedRef = composeRef(ref, innerRef);
      const {
        isFormItemInput
      } = reactExports.useContext(FormItemInputContext);
      const onChange = (e2) => {
        var _a2, _b2;
        (_a2 = props.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, e2);
        (_b2 = groupContext === null || groupContext === void 0 ? void 0 : groupContext.onChange) === null || _b2 === void 0 ? void 0 : _b2.call(groupContext, e2);
      };
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        children,
        style: style2
      } = props, restProps = __rest$G(props, ["prefixCls", "className", "rootClassName", "children", "style"]);
      const radioPrefixCls = getPrefixCls("radio", customizePrefixCls);
      const prefixCls = ((groupContext === null || groupContext === void 0 ? void 0 : groupContext.optionType) || radioOptionTypeContext) === "button" ? `${radioPrefixCls}-button` : radioPrefixCls;
      const [wrapSSR, hashId] = useStyle$m(radioPrefixCls);
      const radioProps = Object.assign({}, restProps);
      const disabled = reactExports.useContext(DisabledContext$1);
      if (groupContext) {
        radioProps.name = groupContext.name;
        radioProps.onChange = onChange;
        radioProps.checked = props.value === groupContext.value;
        radioProps.disabled = (_a = radioProps.disabled) !== null && _a !== void 0 ? _a : groupContext.disabled;
      }
      radioProps.disabled = (_b = radioProps.disabled) !== null && _b !== void 0 ? _b : disabled;
      const wrapperClassString = classNames(`${prefixCls}-wrapper`, {
        [`${prefixCls}-wrapper-checked`]: radioProps.checked,
        [`${prefixCls}-wrapper-disabled`]: radioProps.disabled,
        [`${prefixCls}-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
      }, className, rootClassName, hashId);
      return wrapSSR(
        // eslint-disable-next-line jsx-a11y/label-has-associated-control
        /* @__PURE__ */ reactExports.createElement("label", {
          className: wrapperClassString,
          style: style2,
          onMouseEnter: props.onMouseEnter,
          onMouseLeave: props.onMouseLeave
        }, /* @__PURE__ */ reactExports.createElement(Checkbox$3, Object.assign({}, radioProps, {
          type: "radio",
          prefixCls,
          ref: mergedRef
        })), children !== void 0 ? /* @__PURE__ */ reactExports.createElement("span", null, children) : null)
      );
    };
    const Radio$2 = /* @__PURE__ */ reactExports.forwardRef(InternalRadio);
    const InternalRadio$1 = Radio$2;
    const RadioGroup = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const size = reactExports.useContext(SizeContext$2);
      const [value, setValue2] = useMergedState(props.defaultValue, {
        value: props.value
      });
      const onRadioChange = (ev) => {
        const lastValue = value;
        const val = ev.target.value;
        if (!("value" in props)) {
          setValue2(val);
        }
        const {
          onChange
        } = props;
        if (onChange && val !== lastValue) {
          onChange(ev);
        }
      };
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        options,
        buttonStyle = "outline",
        disabled,
        children,
        size: customizeSize,
        style: style2,
        id: id2,
        onMouseEnter,
        onMouseLeave,
        onFocus,
        onBlur
      } = props;
      const prefixCls = getPrefixCls("radio", customizePrefixCls);
      const groupPrefixCls = `${prefixCls}-group`;
      const [wrapSSR, hashId] = useStyle$m(prefixCls);
      let childrenToRender = children;
      if (options && options.length > 0) {
        childrenToRender = options.map((option) => {
          if (typeof option === "string" || typeof option === "number") {
            return /* @__PURE__ */ reactExports.createElement(InternalRadio$1, {
              key: option.toString(),
              prefixCls,
              disabled,
              value: option,
              checked: value === option
            }, option);
          }
          return /* @__PURE__ */ reactExports.createElement(InternalRadio$1, {
            key: `radio-group-value-options-${option.value}`,
            prefixCls,
            disabled: option.disabled || disabled,
            value: option.value,
            checked: value === option.value,
            style: option.style
          }, option.label);
        });
      }
      const mergedSize = customizeSize || size;
      const classString = classNames(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
        [`${groupPrefixCls}-${mergedSize}`]: mergedSize,
        [`${groupPrefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", Object.assign({}, getDataOrAriaProps$1(props), {
        className: classString,
        style: style2,
        onMouseEnter,
        onMouseLeave,
        onFocus,
        onBlur,
        id: id2,
        ref
      }), /* @__PURE__ */ reactExports.createElement(RadioGroupContextProvider, {
        value: {
          onChange: onRadioChange,
          value,
          disabled: props.disabled,
          name: props.name,
          optionType: props.optionType
        }
      }, childrenToRender)));
    });
    const Group$3 = /* @__PURE__ */ reactExports.memo(RadioGroup);
    var __rest$F = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const RadioButton = (props, ref) => {
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls
      } = props, radioProps = __rest$F(props, ["prefixCls"]);
      const prefixCls = getPrefixCls("radio", customizePrefixCls);
      return /* @__PURE__ */ reactExports.createElement(RadioOptionTypeContextProvider, {
        value: "button"
      }, /* @__PURE__ */ reactExports.createElement(InternalRadio$1, Object.assign({
        prefixCls
      }, radioProps, {
        type: "radio",
        ref
      })));
    };
    const Button = /* @__PURE__ */ reactExports.forwardRef(RadioButton);
    const Radio = InternalRadio$1;
    Radio.Button = Button;
    Radio.Group = Group$3;
    Radio.__ANT_RADIO = true;
    const Radio$1 = Radio;
    const genPlaceholderStyle = (color2) => ({
      // Firefox
      "&::-moz-placeholder": {
        opacity: 1
      },
      "&::placeholder": {
        color: color2,
        userSelect: "none"
        // https://github.com/ant-design/ant-design/pull/32639
      },
      "&:placeholder-shown": {
        textOverflow: "ellipsis"
      }
    });
    const genHoverStyle = (token2) => ({
      borderColor: token2.inputBorderHoverColor,
      borderInlineEndWidth: token2.lineWidth
    });
    const genActiveStyle = (token2) => ({
      borderColor: token2.inputBorderHoverColor,
      boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`,
      borderInlineEndWidth: token2.lineWidth,
      outline: 0
    });
    const genDisabledStyle = (token2) => ({
      color: token2.colorTextDisabled,
      backgroundColor: token2.colorBgContainerDisabled,
      borderColor: token2.colorBorder,
      boxShadow: "none",
      cursor: "not-allowed",
      opacity: 1,
      "&:hover": Object.assign({}, genHoverStyle(merge$4(token2, {
        inputBorderHoverColor: token2.colorBorder
      })))
    });
    const genInputLargeStyle = (token2) => {
      const {
        inputPaddingVerticalLG,
        fontSizeLG,
        lineHeightLG,
        borderRadiusLG,
        inputPaddingHorizontalLG
      } = token2;
      return {
        padding: `${inputPaddingVerticalLG}px ${inputPaddingHorizontalLG}px`,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG,
        borderRadius: borderRadiusLG
      };
    };
    const genInputSmallStyle = (token2) => ({
      padding: `${token2.inputPaddingVerticalSM}px ${token2.controlPaddingHorizontalSM - 1}px`,
      borderRadius: token2.borderRadiusSM
    });
    const genStatusStyle = (token2, parentCls) => {
      const {
        componentCls,
        colorError,
        colorWarning,
        colorErrorOutline,
        colorWarningOutline,
        colorErrorBorderHover,
        colorWarningBorderHover
      } = token2;
      return {
        [`&-status-error:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
          borderColor: colorError,
          "&:hover": {
            borderColor: colorErrorBorderHover
          },
          "&:focus, &-focused": Object.assign({}, genActiveStyle(merge$4(token2, {
            inputBorderActiveColor: colorError,
            inputBorderHoverColor: colorError,
            controlOutline: colorErrorOutline
          }))),
          [`${componentCls}-prefix, ${componentCls}-suffix`]: {
            color: colorError
          }
        },
        [`&-status-warning:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
          borderColor: colorWarning,
          "&:hover": {
            borderColor: colorWarningBorderHover
          },
          "&:focus, &-focused": Object.assign({}, genActiveStyle(merge$4(token2, {
            inputBorderActiveColor: colorWarning,
            inputBorderHoverColor: colorWarning,
            controlOutline: colorWarningOutline
          }))),
          [`${componentCls}-prefix, ${componentCls}-suffix`]: {
            color: colorWarning
          }
        }
      };
    };
    const genBasicInputStyle = (token2) => Object.assign(Object.assign({
      position: "relative",
      display: "inline-block",
      width: "100%",
      minWidth: 0,
      padding: `${token2.inputPaddingVertical}px ${token2.inputPaddingHorizontal}px`,
      color: token2.colorText,
      fontSize: token2.fontSize,
      lineHeight: token2.lineHeight,
      backgroundColor: token2.colorBgContainer,
      backgroundImage: "none",
      borderWidth: token2.lineWidth,
      borderStyle: token2.lineType,
      borderColor: token2.colorBorder,
      borderRadius: token2.borderRadius,
      transition: `all ${token2.motionDurationMid}`
    }, genPlaceholderStyle(token2.colorTextPlaceholder)), {
      "&:hover": Object.assign({}, genHoverStyle(token2)),
      "&:focus, &-focused": Object.assign({}, genActiveStyle(token2)),
      "&-disabled, &[disabled]": Object.assign({}, genDisabledStyle(token2)),
      "&-borderless": {
        "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
          backgroundColor: "transparent",
          border: "none",
          boxShadow: "none"
        }
      },
      // Reset height for `textarea`s
      "textarea&": {
        maxWidth: "100%",
        height: "auto",
        minHeight: token2.controlHeight,
        lineHeight: token2.lineHeight,
        verticalAlign: "bottom",
        transition: `all ${token2.motionDurationSlow}, height 0s`,
        resize: "vertical"
      },
      // Size
      "&-lg": Object.assign({}, genInputLargeStyle(token2)),
      "&-sm": Object.assign({}, genInputSmallStyle(token2)),
      // RTL
      "&-rtl": {
        direction: "rtl"
      },
      "&-textarea-rtl": {
        direction: "rtl"
      }
    });
    const genInputGroupStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      return {
        position: "relative",
        display: "table",
        width: "100%",
        borderCollapse: "separate",
        borderSpacing: 0,
        // Undo padding and float of grid classes
        [`&[class*='col-']`]: {
          paddingInlineEnd: token2.paddingXS,
          "&:last-child": {
            paddingInlineEnd: 0
          }
        },
        // Sizing options
        [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token2)),
        [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token2)),
        // Fix https://github.com/ant-design/ant-design/issues/5754
        [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
          height: token2.controlHeightLG
        },
        [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
          height: token2.controlHeightSM
        },
        [`> ${componentCls}`]: {
          display: "table-cell",
          "&:not(:first-child):not(:last-child)": {
            borderRadius: 0
          }
        },
        [`${componentCls}-group`]: {
          [`&-addon, &-wrap`]: {
            display: "table-cell",
            width: 1,
            whiteSpace: "nowrap",
            verticalAlign: "middle",
            "&:not(:first-child):not(:last-child)": {
              borderRadius: 0
            }
          },
          "&-wrap > *": {
            display: "block !important"
          },
          "&-addon": {
            position: "relative",
            padding: `0 ${token2.inputPaddingHorizontal}px`,
            color: token2.colorText,
            fontWeight: "normal",
            fontSize: token2.fontSize,
            textAlign: "center",
            backgroundColor: token2.colorFillAlter,
            border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
            borderRadius: token2.borderRadius,
            transition: `all ${token2.motionDurationSlow}`,
            lineHeight: 1,
            // Reset Select's style in addon
            [`${antCls}-select`]: {
              margin: `-${token2.inputPaddingVertical + 1}px -${token2.inputPaddingHorizontal}px`,
              [`&${antCls}-select-single:not(${antCls}-select-customize-input)`]: {
                [`${antCls}-select-selector`]: {
                  backgroundColor: "inherit",
                  border: `${token2.lineWidth}px ${token2.lineType} transparent`,
                  boxShadow: "none"
                }
              },
              "&-open, &-focused": {
                [`${antCls}-select-selector`]: {
                  color: token2.colorPrimary
                }
              }
            },
            // https://github.com/ant-design/ant-design/issues/31333
            [`${antCls}-cascader-picker`]: {
              margin: `-9px -${token2.inputPaddingHorizontal}px`,
              backgroundColor: "transparent",
              [`${antCls}-cascader-input`]: {
                textAlign: "start",
                border: 0,
                boxShadow: "none"
              }
            }
          },
          "&-addon:first-child": {
            borderInlineEnd: 0
          },
          "&-addon:last-child": {
            borderInlineStart: 0
          }
        },
        [`${componentCls}`]: {
          width: "100%",
          marginBottom: 0,
          textAlign: "inherit",
          "&:focus": {
            zIndex: 1,
            borderInlineEndWidth: 1
          },
          "&:hover": {
            zIndex: 1,
            borderInlineEndWidth: 1,
            [`${componentCls}-search-with-button &`]: {
              zIndex: 0
            }
          }
        },
        // Reset rounded corners
        [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
          // Reset Select's style in addon
          [`${antCls}-select ${antCls}-select-selector`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`> ${componentCls}-affix-wrapper`]: {
          [`&:not(:first-child) ${componentCls}`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          },
          [`&:not(:last-child) ${componentCls}`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
          // Reset Select's style in addon
          [`${antCls}-select ${antCls}-select-selector`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`${componentCls}-affix-wrapper`]: {
          "&:not(:last-child)": {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            [`${componentCls}-search &`]: {
              borderStartStartRadius: token2.borderRadius,
              borderEndStartRadius: token2.borderRadius
            }
          },
          [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`&${componentCls}-group-compact`]: Object.assign(Object.assign({
          display: "block"
        }, clearFix()), {
          [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
            "&:not(:first-child):not(:last-child)": {
              borderInlineEndWidth: token2.lineWidth,
              "&:hover": {
                zIndex: 1
              },
              "&:focus": {
                zIndex: 1
              }
            }
          },
          "& > *": {
            display: "inline-block",
            float: "none",
            verticalAlign: "top",
            borderRadius: 0
          },
          [`& > ${componentCls}-affix-wrapper`]: {
            display: "inline-flex"
          },
          [`& > ${antCls}-picker-range`]: {
            display: "inline-flex"
          },
          "& > *:not(:last-child)": {
            marginInlineEnd: -token2.lineWidth,
            borderInlineEndWidth: token2.lineWidth
          },
          // Undo float for .ant-input-group .ant-input
          [`${componentCls}`]: {
            float: "none"
          },
          // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
          [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
            borderInlineEndWidth: token2.lineWidth,
            borderRadius: 0,
            "&:hover": {
              zIndex: 1
            },
            "&:focus": {
              zIndex: 1
            }
          },
          [`& > ${antCls}-select-focused`]: {
            zIndex: 1
          },
          // update z-index for arrow icon
          [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
            zIndex: 1
            // https://github.com/ant-design/ant-design/issues/20371
          },
          [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
            borderStartStartRadius: token2.borderRadius,
            borderEndStartRadius: token2.borderRadius
          },
          [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
            borderInlineEndWidth: token2.lineWidth,
            borderStartEndRadius: token2.borderRadius,
            borderEndEndRadius: token2.borderRadius
          },
          // https://github.com/ant-design/ant-design/issues/12493
          [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
            verticalAlign: "top"
          },
          [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
            marginInlineStart: -token2.lineWidth,
            [`${componentCls}-affix-wrapper`]: {
              borderRadius: 0
            }
          },
          [`${componentCls}-group-wrapper:not(:last-child)`]: {
            [`&${componentCls}-search > ${componentCls}-group`]: {
              [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
                borderRadius: 0
              },
              [`& > ${componentCls}`]: {
                borderStartStartRadius: token2.borderRadius,
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
                borderEndStartRadius: token2.borderRadius
              }
            }
          }
        })
      };
    };
    const genInputStyle = (token2) => {
      const {
        componentCls,
        controlHeightSM,
        lineWidth
      } = token2;
      const FIXED_CHROME_COLOR_HEIGHT = 16;
      const colorSmallPadding = (controlHeightSM - lineWidth * 2 - FIXED_CHROME_COLOR_HEIGHT) / 2;
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), genBasicInputStyle(token2)), genStatusStyle(token2, componentCls)), {
          '&[type="color"]': {
            height: token2.controlHeight,
            [`&${componentCls}-lg`]: {
              height: token2.controlHeightLG
            },
            [`&${componentCls}-sm`]: {
              height: controlHeightSM,
              paddingTop: colorSmallPadding,
              paddingBottom: colorSmallPadding
            }
          },
          '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
            "-webkit-appearance": "none"
          }
        })
      };
    };
    const genAllowClearStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        // ========================= Input =========================
        [`${componentCls}-clear-icon`]: {
          margin: 0,
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          verticalAlign: -1,
          // https://github.com/ant-design/ant-design/pull/18151
          // https://codesandbox.io/s/wizardly-sun-u10br
          cursor: "pointer",
          transition: `color ${token2.motionDurationSlow}`,
          "&:hover": {
            color: token2.colorTextTertiary
          },
          "&:active": {
            color: token2.colorText
          },
          "&-hidden": {
            visibility: "hidden"
          },
          "&-has-suffix": {
            margin: `0 ${token2.inputAffixPadding}px`
          }
        }
      };
    };
    const genAffixStyle = (token2) => {
      const {
        componentCls,
        inputAffixPadding,
        colorTextDescription,
        motionDurationSlow,
        colorIcon,
        colorIconHover,
        iconCls
      } = token2;
      return {
        [`${componentCls}-affix-wrapper`]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
          display: "inline-flex",
          [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: Object.assign(Object.assign({}, genHoverStyle(token2)), {
            zIndex: 1,
            [`${componentCls}-search-with-button &`]: {
              zIndex: 0
            }
          }),
          "&-focused, &:focus": {
            zIndex: 1
          },
          "&-disabled": {
            [`${componentCls}[disabled]`]: {
              background: "transparent"
            }
          },
          [`> input${componentCls}`]: {
            padding: 0,
            fontSize: "inherit",
            border: "none",
            borderRadius: 0,
            outline: "none",
            "&:focus": {
              boxShadow: "none !important"
            }
          },
          "&::before": {
            width: 0,
            visibility: "hidden",
            content: '"\\a0"'
          },
          [`${componentCls}`]: {
            "&-prefix, &-suffix": {
              display: "flex",
              flex: "none",
              alignItems: "center",
              "> *:not(:last-child)": {
                marginInlineEnd: token2.paddingXS
              }
            },
            "&-show-count-suffix": {
              color: colorTextDescription
            },
            "&-show-count-has-suffix": {
              marginInlineEnd: token2.paddingXXS
            },
            "&-prefix": {
              marginInlineEnd: inputAffixPadding
            },
            "&-suffix": {
              marginInlineStart: inputAffixPadding
            }
          }
        }), genAllowClearStyle(token2)), {
          // password
          [`${iconCls}${componentCls}-password-icon`]: {
            color: colorIcon,
            cursor: "pointer",
            transition: `all ${motionDurationSlow}`,
            "&:hover": {
              color: colorIconHover
            }
          }
        }), genStatusStyle(token2, `${componentCls}-affix-wrapper`))
      };
    };
    const genGroupStyle = (token2) => {
      const {
        componentCls,
        colorError,
        colorWarning,
        borderRadiusLG,
        borderRadiusSM
      } = token2;
      return {
        [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), genInputGroupStyle(token2)), {
          "&-rtl": {
            direction: "rtl"
          },
          "&-wrapper": {
            display: "inline-block",
            width: "100%",
            textAlign: "start",
            verticalAlign: "top",
            "&-rtl": {
              direction: "rtl"
            },
            // Size
            "&-lg": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusLG
              }
            },
            "&-sm": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusSM
              }
            },
            // Status
            "&-status-error": {
              [`${componentCls}-group-addon`]: {
                color: colorError,
                borderColor: colorError
              }
            },
            "&-status-warning": {
              [`${componentCls}-group-addon`]: {
                color: colorWarning,
                borderColor: colorWarning
              }
            },
            "&-disabled": {
              [`${componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token2))
            }
          }
        })
      };
    };
    const genSearchInputStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      const searchPrefixCls = `${componentCls}-search`;
      return {
        [searchPrefixCls]: {
          [`${componentCls}`]: {
            "&:hover, &:focus": {
              borderColor: token2.colorPrimaryHover,
              [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                borderInlineStartColor: token2.colorPrimaryHover
              }
            }
          },
          [`${componentCls}-affix-wrapper`]: {
            borderRadius: 0
          },
          // fix slight height diff in Firefox:
          // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
          [`${componentCls}-lg`]: {
            lineHeight: token2.lineHeightLG - 2e-4
          },
          [`> ${componentCls}-group`]: {
            [`> ${componentCls}-group-addon:last-child`]: {
              insetInlineStart: -1,
              padding: 0,
              border: 0,
              [`${searchPrefixCls}-button`]: {
                paddingTop: 0,
                paddingBottom: 0,
                borderStartStartRadius: 0,
                borderStartEndRadius: token2.borderRadius,
                borderEndEndRadius: token2.borderRadius,
                borderEndStartRadius: 0
              },
              [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                color: token2.colorTextDescription,
                "&:hover": {
                  color: token2.colorPrimaryHover
                },
                "&:active": {
                  color: token2.colorPrimaryActive
                },
                [`&${antCls}-btn-loading::before`]: {
                  insetInlineStart: 0,
                  insetInlineEnd: 0,
                  insetBlockStart: 0,
                  insetBlockEnd: 0
                }
              }
            }
          },
          [`${searchPrefixCls}-button`]: {
            height: token2.controlHeight,
            "&:hover, &:focus": {
              zIndex: 1
            }
          },
          [`&-large ${searchPrefixCls}-button`]: {
            height: token2.controlHeightLG
          },
          [`&-small ${searchPrefixCls}-button`]: {
            height: token2.controlHeightSM
          },
          "&-rtl": {
            direction: "rtl"
          },
          // ===================== Compact Item Customized Styles =====================
          [`&${componentCls}-compact-item`]: {
            [`&:not(${componentCls}-compact-last-item)`]: {
              [`${componentCls}-group-addon`]: {
                [`${componentCls}-search-button`]: {
                  marginInlineEnd: -token2.lineWidth,
                  borderRadius: 0
                }
              }
            },
            [`&:not(${componentCls}-compact-first-item)`]: {
              [`${componentCls},${componentCls}-affix-wrapper`]: {
                borderRadius: 0
              }
            },
            [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
              "&:hover,&:focus,&:active": {
                zIndex: 2
              }
            },
            [`> ${componentCls}-affix-wrapper-focused`]: {
              zIndex: 2
            }
          }
        }
      };
    };
    function initInputToken(token2) {
      return merge$4(token2, {
        inputAffixPadding: token2.paddingXXS,
        inputPaddingVertical: Math.max(Math.round((token2.controlHeight - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 3),
        inputPaddingVerticalLG: Math.ceil((token2.controlHeightLG - token2.fontSizeLG * token2.lineHeightLG) / 2 * 10) / 10 - token2.lineWidth,
        inputPaddingVerticalSM: Math.max(Math.round((token2.controlHeightSM - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 0),
        inputPaddingHorizontal: token2.paddingSM - token2.lineWidth,
        inputPaddingHorizontalSM: token2.paddingXS - token2.lineWidth,
        inputPaddingHorizontalLG: token2.controlPaddingHorizontal - token2.lineWidth,
        inputBorderHoverColor: token2.colorPrimaryHover,
        inputBorderActiveColor: token2.colorPrimaryHover
      });
    }
    const genTextAreaStyle = (token2) => {
      const {
        componentCls,
        paddingLG
      } = token2;
      const textareaPrefixCls = `${componentCls}-textarea`;
      return {
        [textareaPrefixCls]: {
          position: "relative",
          "&-show-count": {
            // https://github.com/ant-design/ant-design/issues/33049
            [`> ${componentCls}`]: {
              height: "100%"
            },
            [`${componentCls}-data-count`]: {
              color: token2.colorTextDescription,
              whiteSpace: "nowrap",
              pointerEvents: "none",
              float: "right",
              marginBottom: -token2.fontSize * token2.lineHeight
            },
            "&-rtl": {
              [`${componentCls}-data-count`]: {
                float: "left"
              }
            }
          },
          [`&-affix-wrapper${textareaPrefixCls}-has-feedback`]: {
            [`${componentCls}`]: {
              paddingInlineEnd: paddingLG
            }
          },
          [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
            padding: 0,
            [`> textarea${componentCls}`]: {
              fontSize: "inherit",
              border: "none",
              outline: "none",
              "&:focus": {
                boxShadow: "none !important"
              }
            },
            [`${componentCls}-suffix`]: {
              margin: 0,
              "> *:not(:last-child)": {
                marginInline: 0
              },
              // Clear Icon
              [`${componentCls}-clear-icon`]: {
                position: "absolute",
                insetInlineEnd: token2.paddingXS,
                insetBlockStart: token2.paddingXS
              },
              // Feedback Icon
              [`${textareaPrefixCls}-suffix`]: {
                position: "absolute",
                top: 0,
                insetInlineEnd: token2.inputPaddingHorizontal,
                bottom: 0,
                zIndex: 1,
                display: "inline-flex",
                alignItems: "center",
                margin: "auto",
                pointerEvents: "none"
              }
            }
          }
        }
      };
    };
    const useStyle$l = genComponentStyleHook("Input", (token2) => {
      const inputToken = initInputToken(token2);
      return [
        genInputStyle(inputToken),
        genTextAreaStyle(inputToken),
        genAffixStyle(inputToken),
        genGroupStyle(inputToken),
        genSearchInputStyle(inputToken),
        // =====================================================
        // ==             Space Compact                       ==
        // =====================================================
        genCompactItemStyle(inputToken)
      ];
    });
    const genPikerPadding = (token2, inputHeight, fontSize, paddingHorizontal) => {
      const {
        lineHeight
      } = token2;
      const fontHeight = Math.floor(fontSize * lineHeight) + 2;
      const paddingTop = Math.max((inputHeight - fontHeight) / 2, 0);
      const paddingBottom = Math.max(inputHeight - fontHeight - paddingTop, 0);
      return {
        padding: `${paddingTop}px ${paddingHorizontal}px ${paddingBottom}px`
      };
    };
    const genPickerCellInnerStyle = (token2) => {
      const {
        componentCls,
        pickerCellCls,
        pickerCellInnerCls,
        pickerPanelCellHeight,
        motionDurationSlow,
        borderRadiusSM,
        motionDurationMid,
        controlItemBgHover,
        lineWidth,
        lineType,
        colorPrimary,
        controlItemBgActive,
        colorTextLightSolid,
        controlHeightSM,
        pickerDateHoverRangeBorderColor,
        pickerCellBorderGap,
        pickerBasicCellHoverWithRangeColor,
        pickerPanelCellWidth,
        colorTextDisabled,
        colorBgContainerDisabled
      } = token2;
      return {
        "&::before": {
          position: "absolute",
          top: "50%",
          insetInlineStart: 0,
          insetInlineEnd: 0,
          zIndex: 1,
          height: pickerPanelCellHeight,
          transform: "translateY(-50%)",
          transition: `all ${motionDurationSlow}`,
          content: '""'
        },
        // >>> Default
        [pickerCellInnerCls]: {
          position: "relative",
          zIndex: 2,
          display: "inline-block",
          minWidth: pickerPanelCellHeight,
          height: pickerPanelCellHeight,
          lineHeight: `${pickerPanelCellHeight}px`,
          borderRadius: borderRadiusSM,
          transition: `background ${motionDurationMid}, border ${motionDurationMid}`
        },
        // >>> Hover
        [`&:hover:not(${pickerCellCls}-in-view),
    &:hover:not(${pickerCellCls}-selected):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end):not(${pickerCellCls}-range-hover-start):not(${pickerCellCls}-range-hover-end)`]: {
          [pickerCellInnerCls]: {
            background: controlItemBgHover
          }
        },
        // >>> Today
        [`&-in-view${pickerCellCls}-today ${pickerCellInnerCls}`]: {
          "&::before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            zIndex: 1,
            border: `${lineWidth}px ${lineType} ${colorPrimary}`,
            borderRadius: borderRadiusSM,
            content: '""'
          }
        },
        // >>> In Range
        [`&-in-view${pickerCellCls}-in-range`]: {
          position: "relative",
          "&::before": {
            background: controlItemBgActive
          }
        },
        // >>> Selected
        [`&-in-view${pickerCellCls}-selected ${pickerCellInnerCls},
      &-in-view${pickerCellCls}-range-start ${pickerCellInnerCls},
      &-in-view${pickerCellCls}-range-end ${pickerCellInnerCls}`]: {
          color: colorTextLightSolid,
          background: colorPrimary
        },
        [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single),
      &-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single)`]: {
          "&::before": {
            background: controlItemBgActive
          }
        },
        [`&-in-view${pickerCellCls}-range-start::before`]: {
          insetInlineStart: "50%"
        },
        [`&-in-view${pickerCellCls}-range-end::before`]: {
          insetInlineEnd: "50%"
        },
        // >>> Range Hover
        [`&-in-view${pickerCellCls}-range-hover-start:not(${pickerCellCls}-in-range):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end),
      &-in-view${pickerCellCls}-range-hover-end:not(${pickerCellCls}-in-range):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end),
      &-in-view${pickerCellCls}-range-hover-start${pickerCellCls}-range-start-single,
      &-in-view${pickerCellCls}-range-hover-start${pickerCellCls}-range-start${pickerCellCls}-range-end${pickerCellCls}-range-end-near-hover,
      &-in-view${pickerCellCls}-range-hover-end${pickerCellCls}-range-start${pickerCellCls}-range-end${pickerCellCls}-range-start-near-hover,
      &-in-view${pickerCellCls}-range-hover-end${pickerCellCls}-range-end-single,
      &-in-view${pickerCellCls}-range-hover:not(${pickerCellCls}-in-range)`]: {
          "&::after": {
            position: "absolute",
            top: "50%",
            zIndex: 0,
            height: controlHeightSM,
            borderTop: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
            borderBottom: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
            transform: "translateY(-50%)",
            transition: `all ${motionDurationSlow}`,
            content: '""'
          }
        },
        // Add space for stash
        [`&-range-hover-start::after,
      &-range-hover-end::after,
      &-range-hover::after`]: {
          insetInlineEnd: 0,
          insetInlineStart: pickerCellBorderGap
        },
        // Hover with in range
        [`&-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-start::before,
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-end::before,
      &-in-view${pickerCellCls}-range-start${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-range-end${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single)${pickerCellCls}-range-hover-start::before,
      &-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single)${pickerCellCls}-range-hover-end::before,
      ${componentCls}-panel
      > :not(${componentCls}-date-panel)
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-start::before,
      ${componentCls}-panel
      > :not(${componentCls}-date-panel)
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-end::before`]: {
          background: pickerBasicCellHoverWithRangeColor
        },
        // range start border-radius
        [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single):not(${pickerCellCls}-range-end) ${pickerCellInnerCls}`]: {
          borderStartStartRadius: borderRadiusSM,
          borderEndStartRadius: borderRadiusSM,
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        },
        // range end border-radius
        [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single):not(${pickerCellCls}-range-start) ${pickerCellInnerCls}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
          borderStartEndRadius: borderRadiusSM,
          borderEndEndRadius: borderRadiusSM
        },
        [`&-range-hover${pickerCellCls}-range-end::after`]: {
          insetInlineStart: "50%"
        },
        // Edge start
        [`tr > &-in-view${pickerCellCls}-range-hover:first-child::after,
      tr > &-in-view${pickerCellCls}-range-hover-end:first-child::after,
      &-in-view${pickerCellCls}-start${pickerCellCls}-range-hover-edge-start${pickerCellCls}-range-hover-edge-start-near-range::after,
      &-in-view${pickerCellCls}-range-hover-edge-start:not(${pickerCellCls}-range-hover-edge-start-near-range)::after,
      &-in-view${pickerCellCls}-range-hover-start::after`]: {
          insetInlineStart: (pickerPanelCellWidth - pickerPanelCellHeight) / 2,
          borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
          borderStartStartRadius: lineWidth,
          borderEndStartRadius: lineWidth
        },
        // Edge end
        [`tr > &-in-view${pickerCellCls}-range-hover:last-child::after,
      tr > &-in-view${pickerCellCls}-range-hover-start:last-child::after,
      &-in-view${pickerCellCls}-end${pickerCellCls}-range-hover-edge-end${pickerCellCls}-range-hover-edge-end-near-range::after,
      &-in-view${pickerCellCls}-range-hover-edge-end:not(${pickerCellCls}-range-hover-edge-end-near-range)::after,
      &-in-view${pickerCellCls}-range-hover-end::after`]: {
          insetInlineEnd: (pickerPanelCellWidth - pickerPanelCellHeight) / 2,
          borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
          borderStartEndRadius: lineWidth,
          borderEndEndRadius: lineWidth
        },
        // >>> Disabled
        "&-disabled": {
          color: colorTextDisabled,
          pointerEvents: "none",
          [pickerCellInnerCls]: {
            background: "transparent"
          },
          "&::before": {
            background: colorBgContainerDisabled
          }
        },
        [`&-disabled${pickerCellCls}-today ${pickerCellInnerCls}::before`]: {
          borderColor: colorTextDisabled
        }
      };
    };
    const genPanelStyle = (token2) => {
      const {
        componentCls,
        pickerCellCls,
        pickerCellInnerCls,
        pickerYearMonthCellWidth,
        pickerControlIconSize,
        pickerPanelCellWidth,
        paddingSM,
        paddingXS,
        paddingXXS,
        colorBgContainer,
        lineWidth,
        lineType,
        borderRadiusLG,
        colorPrimary,
        colorTextHeading,
        colorSplit,
        pickerControlIconBorderWidth,
        colorIcon,
        pickerTextHeight,
        motionDurationMid,
        colorIconHover,
        fontWeightStrong,
        pickerPanelCellHeight,
        pickerCellPaddingVertical,
        colorTextDisabled,
        colorText,
        fontSize,
        pickerBasicCellHoverWithRangeColor,
        motionDurationSlow,
        pickerPanelWithoutTimeCellHeight,
        pickerQuarterPanelContentHeight,
        colorLink,
        colorLinkActive,
        colorLinkHover,
        pickerDateHoverRangeBorderColor,
        borderRadiusSM,
        colorTextLightSolid,
        controlItemBgHover,
        pickerTimePanelColumnHeight,
        pickerTimePanelColumnWidth,
        pickerTimePanelCellHeight,
        controlItemBgActive,
        marginXXS,
        pickerDatePanelPaddingHorizontal
      } = token2;
      const pickerPanelWidth = pickerPanelCellWidth * 7 + pickerDatePanelPaddingHorizontal * 2;
      const commonHoverCellFixedDistance = (pickerPanelWidth - paddingXS * 2) / 3 - pickerYearMonthCellWidth - paddingSM;
      const quarterHoverCellFixedDistance = (pickerPanelWidth - paddingXS * 2) / 4 - pickerYearMonthCellWidth;
      return {
        [componentCls]: {
          "&-panel": {
            display: "inline-flex",
            flexDirection: "column",
            textAlign: "center",
            background: colorBgContainer,
            border: `${lineWidth}px ${lineType} ${colorSplit}`,
            borderRadius: borderRadiusLG,
            outline: "none",
            "&-focused": {
              borderColor: colorPrimary
            },
            "&-rtl": {
              direction: "rtl",
              [`${componentCls}-prev-icon,
              ${componentCls}-super-prev-icon`]: {
                transform: "rotate(45deg)"
              },
              [`${componentCls}-next-icon,
              ${componentCls}-super-next-icon`]: {
                transform: "rotate(-135deg)"
              }
            }
          },
          // ========================================================
          // =                     Shared Panel                     =
          // ========================================================
          [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel,
        &-week-panel,
        &-date-panel,
        &-time-panel`]: {
            display: "flex",
            flexDirection: "column",
            width: pickerPanelWidth
          },
          // ======================= Header =======================
          "&-header": {
            display: "flex",
            padding: `0 ${paddingXS}px`,
            color: colorTextHeading,
            borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
            "> *": {
              flex: "none"
            },
            button: {
              padding: 0,
              color: colorIcon,
              lineHeight: `${pickerTextHeight}px`,
              background: "transparent",
              border: 0,
              cursor: "pointer",
              transition: `color ${motionDurationMid}`,
              fontSize: "inherit"
            },
            "> button": {
              minWidth: "1.6em",
              fontSize,
              "&:hover": {
                color: colorIconHover
              }
            },
            "&-view": {
              flex: "auto",
              fontWeight: fontWeightStrong,
              lineHeight: `${pickerTextHeight}px`,
              button: {
                color: "inherit",
                fontWeight: "inherit",
                verticalAlign: "top",
                "&:not(:first-child)": {
                  marginInlineStart: paddingXS
                },
                "&:hover": {
                  color: colorPrimary
                }
              }
            }
          },
          // Arrow button
          [`&-prev-icon,
        &-next-icon,
        &-super-prev-icon,
        &-super-next-icon`]: {
            position: "relative",
            display: "inline-block",
            width: pickerControlIconSize,
            height: pickerControlIconSize,
            "&::before": {
              position: "absolute",
              top: 0,
              insetInlineStart: 0,
              display: "inline-block",
              width: pickerControlIconSize,
              height: pickerControlIconSize,
              border: `0 solid currentcolor`,
              borderBlockStartWidth: pickerControlIconBorderWidth,
              borderBlockEndWidth: 0,
              borderInlineStartWidth: pickerControlIconBorderWidth,
              borderInlineEndWidth: 0,
              content: '""'
            }
          },
          [`&-super-prev-icon,
        &-super-next-icon`]: {
            "&::after": {
              position: "absolute",
              top: Math.ceil(pickerControlIconSize / 2),
              insetInlineStart: Math.ceil(pickerControlIconSize / 2),
              display: "inline-block",
              width: pickerControlIconSize,
              height: pickerControlIconSize,
              border: "0 solid currentcolor",
              borderBlockStartWidth: pickerControlIconBorderWidth,
              borderBlockEndWidth: 0,
              borderInlineStartWidth: pickerControlIconBorderWidth,
              borderInlineEndWidth: 0,
              content: '""'
            }
          },
          [`&-prev-icon,
        &-super-prev-icon`]: {
            transform: "rotate(-45deg)"
          },
          [`&-next-icon,
        &-super-next-icon`]: {
            transform: "rotate(135deg)"
          },
          // ======================== Body ========================
          "&-content": {
            width: "100%",
            tableLayout: "fixed",
            borderCollapse: "collapse",
            "th, td": {
              position: "relative",
              minWidth: pickerPanelCellHeight,
              fontWeight: "normal"
            },
            th: {
              height: pickerPanelCellHeight + pickerCellPaddingVertical * 2,
              color: colorText,
              verticalAlign: "middle"
            }
          },
          "&-cell": Object.assign({
            padding: `${pickerCellPaddingVertical}px 0`,
            color: colorTextDisabled,
            cursor: "pointer",
            // In view
            "&-in-view": {
              color: colorText
            }
          }, genPickerCellInnerStyle(token2)),
          // DatePanel only
          [`&-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-start ${pickerCellInnerCls},
        &-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-end ${pickerCellInnerCls}`]: {
            "&::after": {
              position: "absolute",
              top: 0,
              bottom: 0,
              zIndex: -1,
              background: pickerBasicCellHoverWithRangeColor,
              transition: `all ${motionDurationSlow}`,
              content: '""'
            }
          },
          [`&-date-panel
        ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-start
        ${pickerCellInnerCls}::after`]: {
            insetInlineEnd: -(pickerPanelCellWidth - pickerPanelCellHeight) / 2,
            insetInlineStart: 0
          },
          [`&-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-end ${pickerCellInnerCls}::after`]: {
            insetInlineEnd: 0,
            insetInlineStart: -(pickerPanelCellWidth - pickerPanelCellHeight) / 2
          },
          // Hover with range start & end
          [`&-range-hover${componentCls}-range-start::after`]: {
            insetInlineEnd: "50%"
          },
          [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
            [`${componentCls}-content`]: {
              height: pickerPanelWithoutTimeCellHeight * 4
            },
            [pickerCellInnerCls]: {
              padding: `0 ${paddingXS}px`
            }
          },
          "&-quarter-panel": {
            [`${componentCls}-content`]: {
              height: pickerQuarterPanelContentHeight
            },
            // Quarter Panel Special Style
            [`${componentCls}-cell-range-hover-start::after`]: {
              insetInlineStart: quarterHoverCellFixedDistance,
              borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
              [`${componentCls}-panel-rtl &`]: {
                insetInlineEnd: quarterHoverCellFixedDistance,
                borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`
              }
            },
            [`${componentCls}-cell-range-hover-end::after`]: {
              insetInlineEnd: quarterHoverCellFixedDistance,
              borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
              [`${componentCls}-panel-rtl &`]: {
                insetInlineStart: quarterHoverCellFixedDistance,
                borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`
              }
            }
          },
          // ======================== Footer ========================
          [`&-panel ${componentCls}-footer`]: {
            borderTop: `${lineWidth}px ${lineType} ${colorSplit}`
          },
          "&-footer": {
            width: "min-content",
            minWidth: "100%",
            lineHeight: `${pickerTextHeight - 2 * lineWidth}px`,
            textAlign: "center",
            "&-extra": {
              padding: `0 ${paddingSM}`,
              lineHeight: `${pickerTextHeight - 2 * lineWidth}px`,
              textAlign: "start",
              "&:not(:last-child)": {
                borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`
              }
            }
          },
          "&-now": {
            textAlign: "start"
          },
          "&-today-btn": {
            color: colorLink,
            "&:hover": {
              color: colorLinkHover
            },
            "&:active": {
              color: colorLinkActive
            },
            [`&${componentCls}-today-btn-disabled`]: {
              color: colorTextDisabled,
              cursor: "not-allowed"
            }
          },
          // ========================================================
          // =                       Special                        =
          // ========================================================
          // ===================== Decade Panel =====================
          "&-decade-panel": {
            [pickerCellInnerCls]: {
              padding: `0 ${paddingXS / 2}px`
            },
            [`${componentCls}-cell::before`]: {
              display: "none"
            }
          },
          // ============= Year & Quarter & Month Panel =============
          [`&-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
            [`${componentCls}-body`]: {
              padding: `0 ${paddingXS}px`
            },
            [pickerCellInnerCls]: {
              width: pickerYearMonthCellWidth
            },
            [`${componentCls}-cell-range-hover-start::after`]: {
              borderStartStartRadius: borderRadiusSM,
              borderEndStartRadius: borderRadiusSM,
              borderStartEndRadius: 0,
              borderEndEndRadius: 0,
              [`${componentCls}-panel-rtl &`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0,
                borderStartEndRadius: borderRadiusSM,
                borderEndEndRadius: borderRadiusSM
              }
            },
            [`${componentCls}-cell-range-hover-end::after`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0,
              borderStartEndRadius: borderRadiusSM,
              borderEndEndRadius: borderRadiusSM,
              [`${componentCls}-panel-rtl &`]: {
                borderStartStartRadius: borderRadiusSM,
                borderEndStartRadius: borderRadiusSM,
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            }
          },
          [`&-year-panel,
        &-month-panel`]: {
            [`${componentCls}-cell-range-hover-start::after`]: {
              insetInlineStart: commonHoverCellFixedDistance,
              borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
              [`${componentCls}-panel-rtl &`]: {
                insetInlineEnd: commonHoverCellFixedDistance,
                borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`
              }
            },
            [`${componentCls}-cell-range-hover-end::after`]: {
              insetInlineEnd: commonHoverCellFixedDistance,
              borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
              [`${componentCls}-panel-rtl &`]: {
                insetInlineStart: commonHoverCellFixedDistance,
                borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`
              }
            }
          },
          // ====================== Week Panel ======================
          "&-week-panel": {
            [`${componentCls}-body`]: {
              padding: `${paddingXS}px ${paddingSM}px`
            },
            // Clear cell style
            [`${componentCls}-cell`]: {
              [`&:hover ${pickerCellInnerCls},
            &-selected ${pickerCellInnerCls},
            ${pickerCellInnerCls}`]: {
                background: "transparent !important"
              }
            },
            "&-row": {
              td: {
                "&:before": {
                  transition: `background ${motionDurationMid}`
                },
                "&:first-child:before": {
                  borderStartStartRadius: borderRadiusSM,
                  borderEndStartRadius: borderRadiusSM
                },
                "&:last-child:before": {
                  borderStartEndRadius: borderRadiusSM,
                  borderEndEndRadius: borderRadiusSM
                }
              },
              [`&:hover td`]: {
                "&:before": {
                  background: controlItemBgHover
                }
              },
              [`&-range-start td,
            &-range-end td,
            &-selected td`]: {
                // Rise priority to override hover style
                [`&${pickerCellCls}`]: {
                  "&:before": {
                    background: colorPrimary
                  },
                  [`&${componentCls}-cell-week`]: {
                    color: new TinyColor(colorTextLightSolid).setAlpha(0.5).toHexString()
                  },
                  [pickerCellInnerCls]: {
                    color: colorTextLightSolid
                  }
                }
              },
              [`&-range-hover td:before`]: {
                background: controlItemBgActive
              }
            }
          },
          // ====================== Date Panel ======================
          "&-date-panel": {
            [`${componentCls}-body`]: {
              padding: `${paddingXS}px ${pickerDatePanelPaddingHorizontal}px`
            },
            [`${componentCls}-content`]: {
              width: pickerPanelCellWidth * 7,
              th: {
                width: pickerPanelCellWidth
              }
            }
          },
          // ==================== Datetime Panel ====================
          "&-datetime-panel": {
            display: "flex",
            [`${componentCls}-time-panel`]: {
              borderInlineStart: `${lineWidth}px ${lineType} ${colorSplit}`
            },
            [`${componentCls}-date-panel,
          ${componentCls}-time-panel`]: {
              transition: `opacity ${motionDurationSlow}`
            },
            // Keyboard
            "&-active": {
              [`${componentCls}-date-panel,
            ${componentCls}-time-panel`]: {
                opacity: 0.3,
                "&-active": {
                  opacity: 1
                }
              }
            }
          },
          // ====================== Time Panel ======================
          "&-time-panel": {
            width: "auto",
            minWidth: "auto",
            direction: "ltr",
            [`${componentCls}-content`]: {
              display: "flex",
              flex: "auto",
              height: pickerTimePanelColumnHeight
            },
            "&-column": {
              flex: "1 0 auto",
              width: pickerTimePanelColumnWidth,
              margin: `${paddingXXS}px 0`,
              padding: 0,
              overflowY: "hidden",
              textAlign: "start",
              listStyle: "none",
              transition: `background ${motionDurationMid}`,
              overflowX: "hidden",
              "&::after": {
                display: "block",
                height: pickerTimePanelColumnHeight - pickerTimePanelCellHeight,
                content: '""'
              },
              "&:not(:first-child)": {
                borderInlineStart: `${lineWidth}px ${lineType} ${colorSplit}`
              },
              "&-active": {
                background: new TinyColor(controlItemBgActive).setAlpha(0.2).toHexString()
              },
              "&:hover": {
                overflowY: "auto"
              },
              "> li": {
                margin: 0,
                padding: 0,
                [`&${componentCls}-time-panel-cell`]: {
                  marginInline: marginXXS,
                  [`${componentCls}-time-panel-cell-inner`]: {
                    display: "block",
                    width: pickerTimePanelColumnWidth - 2 * marginXXS,
                    height: pickerTimePanelCellHeight,
                    margin: 0,
                    paddingBlock: 0,
                    paddingInlineEnd: 0,
                    paddingInlineStart: (pickerTimePanelColumnWidth - pickerTimePanelCellHeight) / 2,
                    color: colorText,
                    lineHeight: `${pickerTimePanelCellHeight}px`,
                    borderRadius: borderRadiusSM,
                    cursor: "pointer",
                    transition: `background ${motionDurationMid}`,
                    "&:hover": {
                      background: controlItemBgHover
                    }
                  },
                  "&-selected": {
                    [`${componentCls}-time-panel-cell-inner`]: {
                      background: controlItemBgActive
                    }
                  },
                  "&-disabled": {
                    [`${componentCls}-time-panel-cell-inner`]: {
                      color: colorTextDisabled,
                      background: "transparent",
                      cursor: "not-allowed"
                    }
                  }
                }
              }
            }
          },
          // https://github.com/ant-design/ant-design/issues/39227
          [`&-datetime-panel ${componentCls}-time-panel-column:after`]: {
            height: pickerTimePanelColumnHeight - pickerTimePanelCellHeight + paddingXXS * 2
          }
        }
      };
    };
    const genPickerStatusStyle = (token2) => {
      const {
        componentCls,
        colorBgContainer,
        colorError,
        colorErrorOutline,
        colorWarning,
        colorWarningOutline
      } = token2;
      return {
        [`${componentCls}:not(${componentCls}-disabled)`]: {
          [`&${componentCls}-status-error`]: {
            "&, &:not([disabled]):hover": {
              backgroundColor: colorBgContainer,
              borderColor: colorError
            },
            [`&${componentCls}-focused, &:focus`]: Object.assign({}, genActiveStyle(merge$4(token2, {
              inputBorderActiveColor: colorError,
              inputBorderHoverColor: colorError,
              controlOutline: colorErrorOutline
            }))),
            [`${componentCls}-active-bar`]: {
              background: colorError
            }
          },
          [`&${componentCls}-status-warning`]: {
            "&, &:not([disabled]):hover": {
              backgroundColor: colorBgContainer,
              borderColor: colorWarning
            },
            [`&${componentCls}-focused, &:focus`]: Object.assign({}, genActiveStyle(merge$4(token2, {
              inputBorderActiveColor: colorWarning,
              inputBorderHoverColor: colorWarning,
              controlOutline: colorWarningOutline
            }))),
            [`${componentCls}-active-bar`]: {
              background: colorWarning
            }
          }
        }
      };
    };
    const genPickerStyle = (token2) => {
      const {
        componentCls,
        antCls,
        controlHeight,
        fontSize,
        inputPaddingHorizontal,
        colorBgContainer,
        lineWidth,
        lineType,
        colorBorder,
        borderRadius,
        motionDurationMid,
        colorBgContainerDisabled,
        colorTextDisabled,
        colorTextPlaceholder,
        controlHeightLG,
        fontSizeLG,
        controlHeightSM,
        inputPaddingHorizontalSM,
        paddingXS,
        marginXS,
        colorTextDescription,
        lineWidthBold,
        lineHeight,
        colorPrimary,
        motionDurationSlow,
        zIndexPopup,
        paddingXXS,
        paddingSM,
        pickerTextHeight,
        controlItemBgActive,
        colorPrimaryBorder,
        sizePopupArrow,
        borderRadiusXS,
        borderRadiusOuter,
        colorBgElevated,
        borderRadiusLG,
        boxShadowSecondary,
        borderRadiusSM,
        colorSplit,
        controlItemBgHover,
        presetsWidth,
        presetsMaxWidth,
        boxShadowPopoverArrow
      } = token2;
      return [
        {
          [componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), genPikerPadding(token2, controlHeight, fontSize, inputPaddingHorizontal)), {
            position: "relative",
            display: "inline-flex",
            alignItems: "center",
            background: colorBgContainer,
            lineHeight: 1,
            border: `${lineWidth}px ${lineType} ${colorBorder}`,
            borderRadius,
            transition: `border ${motionDurationMid}, box-shadow ${motionDurationMid}`,
            "&:hover, &-focused": Object.assign({}, genHoverStyle(token2)),
            "&-focused": Object.assign({}, genActiveStyle(token2)),
            [`&${componentCls}-disabled`]: {
              background: colorBgContainerDisabled,
              borderColor: colorBorder,
              cursor: "not-allowed",
              [`${componentCls}-suffix`]: {
                color: colorTextDisabled
              }
            },
            [`&${componentCls}-borderless`]: {
              backgroundColor: "transparent !important",
              borderColor: "transparent !important",
              boxShadow: "none !important"
            },
            // ======================== Input =========================
            [`${componentCls}-input`]: {
              position: "relative",
              display: "inline-flex",
              alignItems: "center",
              width: "100%",
              "> input": Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
                flex: "auto",
                // Fix Firefox flex not correct:
                // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
                minWidth: 1,
                height: "auto",
                padding: 0,
                background: "transparent",
                border: 0,
                borderRadius: 0,
                "&:focus": {
                  boxShadow: "none"
                },
                "&[disabled]": {
                  background: "transparent"
                }
              }),
              "&:hover": {
                [`${componentCls}-clear`]: {
                  opacity: 1
                }
              },
              "&-placeholder": {
                "> input": {
                  color: colorTextPlaceholder
                }
              }
            },
            // Size
            "&-large": Object.assign(Object.assign({}, genPikerPadding(token2, controlHeightLG, fontSizeLG, inputPaddingHorizontal)), {
              [`${componentCls}-input > input`]: {
                fontSize: fontSizeLG
              }
            }),
            "&-small": Object.assign({}, genPikerPadding(token2, controlHeightSM, fontSize, inputPaddingHorizontalSM)),
            [`${componentCls}-suffix`]: {
              display: "flex",
              flex: "none",
              alignSelf: "center",
              marginInlineStart: paddingXS / 2,
              color: colorTextDisabled,
              lineHeight: 1,
              pointerEvents: "none",
              "> *": {
                verticalAlign: "top",
                "&:not(:last-child)": {
                  marginInlineEnd: marginXS
                }
              }
            },
            [`${componentCls}-clear`]: {
              position: "absolute",
              top: "50%",
              insetInlineEnd: 0,
              color: colorTextDisabled,
              lineHeight: 1,
              background: colorBgContainer,
              transform: "translateY(-50%)",
              cursor: "pointer",
              opacity: 0,
              transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
              "> *": {
                verticalAlign: "top"
              },
              "&:hover": {
                color: colorTextDescription
              }
            },
            [`${componentCls}-separator`]: {
              position: "relative",
              display: "inline-block",
              width: "1em",
              height: fontSizeLG,
              color: colorTextDisabled,
              fontSize: fontSizeLG,
              verticalAlign: "top",
              cursor: "default",
              [`${componentCls}-focused &`]: {
                color: colorTextDescription
              },
              [`${componentCls}-range-separator &`]: {
                [`${componentCls}-disabled &`]: {
                  cursor: "not-allowed"
                }
              }
            },
            // ======================== Range =========================
            "&-range": {
              position: "relative",
              display: "inline-flex",
              // Clear
              [`${componentCls}-clear`]: {
                insetInlineEnd: inputPaddingHorizontal
              },
              "&:hover": {
                [`${componentCls}-clear`]: {
                  opacity: 1
                }
              },
              // Active bar
              [`${componentCls}-active-bar`]: {
                bottom: -lineWidth,
                height: lineWidthBold,
                marginInlineStart: inputPaddingHorizontal,
                background: colorPrimary,
                opacity: 0,
                transition: `all ${motionDurationSlow} ease-out`,
                pointerEvents: "none"
              },
              [`&${componentCls}-focused`]: {
                [`${componentCls}-active-bar`]: {
                  opacity: 1
                }
              },
              [`${componentCls}-range-separator`]: {
                alignItems: "center",
                padding: `0 ${paddingXS}px`,
                lineHeight: 1
              },
              [`&${componentCls}-small`]: {
                [`${componentCls}-clear`]: {
                  insetInlineEnd: inputPaddingHorizontalSM
                },
                [`${componentCls}-active-bar`]: {
                  marginInlineStart: inputPaddingHorizontalSM
                }
              }
            },
            // ======================= Dropdown =======================
            "&-dropdown": Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), genPanelStyle(token2)), {
              position: "absolute",
              // Fix incorrect position of picker popup
              // https://github.com/ant-design/ant-design/issues/35590
              top: -9999,
              left: {
                _skip_check_: true,
                value: -9999
              },
              zIndex: zIndexPopup,
              [`&${componentCls}-dropdown-hidden`]: {
                display: "none"
              },
              [`&${componentCls}-dropdown-placement-bottomLeft`]: {
                [`${componentCls}-range-arrow`]: {
                  top: 0,
                  display: "block",
                  transform: "translateY(-100%)"
                }
              },
              [`&${componentCls}-dropdown-placement-topLeft`]: {
                [`${componentCls}-range-arrow`]: {
                  bottom: 0,
                  display: "block",
                  transform: "translateY(100%) rotate(180deg)"
                }
              },
              [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topRight`]: {
                animationName: slideDownIn
              },
              [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomRight`]: {
                animationName: slideUpIn
              },
              [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topRight`]: {
                animationName: slideDownOut
              },
              [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomRight`]: {
                animationName: slideUpOut
              },
              // Time picker with additional style
              [`${componentCls}-panel > ${componentCls}-time-panel`]: {
                paddingTop: paddingXXS
              },
              // ======================== Ranges ========================
              [`${componentCls}-ranges`]: {
                marginBottom: 0,
                padding: `${paddingXXS}px ${paddingSM}px`,
                overflow: "hidden",
                lineHeight: `${pickerTextHeight - 2 * lineWidth - paddingXS / 2}px`,
                textAlign: "start",
                listStyle: "none",
                display: "flex",
                justifyContent: "space-between",
                "> li": {
                  display: "inline-block"
                },
                // https://github.com/ant-design/ant-design/issues/23687
                [`${componentCls}-preset > ${antCls}-tag-blue`]: {
                  color: colorPrimary,
                  background: controlItemBgActive,
                  borderColor: colorPrimaryBorder,
                  cursor: "pointer"
                },
                [`${componentCls}-ok`]: {
                  marginInlineStart: "auto"
                }
              },
              [`${componentCls}-range-wrapper`]: {
                display: "flex",
                position: "relative"
              },
              [`${componentCls}-range-arrow`]: Object.assign({
                position: "absolute",
                zIndex: 1,
                display: "none",
                marginInlineStart: inputPaddingHorizontal * 1.5,
                transition: `left ${motionDurationSlow} ease-out`
              }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBgElevated, boxShadowPopoverArrow)),
              [`${componentCls}-panel-container`]: {
                overflow: "hidden",
                verticalAlign: "top",
                background: colorBgElevated,
                borderRadius: borderRadiusLG,
                boxShadow: boxShadowSecondary,
                transition: `margin ${motionDurationSlow}`,
                // ======================== Layout ========================
                [`${componentCls}-panel-layout`]: {
                  display: "flex",
                  flexWrap: "nowrap",
                  alignItems: "stretch"
                },
                // ======================== Preset ========================
                [`${componentCls}-presets`]: {
                  display: "flex",
                  flexDirection: "column",
                  minWidth: presetsWidth,
                  maxWidth: presetsMaxWidth,
                  ul: {
                    height: 0,
                    flex: "auto",
                    listStyle: "none",
                    overflow: "auto",
                    margin: 0,
                    padding: paddingXS,
                    borderInlineEnd: `${lineWidth}px ${lineType} ${colorSplit}`,
                    li: Object.assign(Object.assign({}, textEllipsis), {
                      borderRadius: borderRadiusSM,
                      paddingInline: paddingXS,
                      paddingBlock: (controlHeightSM - Math.round(fontSize * lineHeight)) / 2,
                      cursor: "pointer",
                      transition: `all ${motionDurationSlow}`,
                      "+ li": {
                        marginTop: marginXS
                      },
                      "&:hover": {
                        background: controlItemBgHover
                      }
                    })
                  }
                },
                // ======================== Panels ========================
                [`${componentCls}-panels`]: {
                  display: "inline-flex",
                  flexWrap: "nowrap",
                  direction: "ltr",
                  [`${componentCls}-panel`]: {
                    borderWidth: `0 0 ${lineWidth}px`
                  },
                  "&:last-child": {
                    [`${componentCls}-panel`]: {
                      borderWidth: 0
                    }
                  }
                },
                [`${componentCls}-panel`]: {
                  verticalAlign: "top",
                  background: "transparent",
                  borderRadius: 0,
                  borderWidth: 0,
                  [`${componentCls}-content,
            table`]: {
                    textAlign: "center"
                  },
                  "&-focused": {
                    borderColor: colorBorder
                  }
                }
              }
            }),
            "&-dropdown-range": {
              padding: `${sizePopupArrow * 2 / 3}px 0`,
              "&-hidden": {
                display: "none"
              }
            },
            "&-rtl": {
              direction: "rtl",
              [`${componentCls}-separator`]: {
                transform: "rotate(180deg)"
              },
              [`${componentCls}-footer`]: {
                "&-extra": {
                  direction: "rtl"
                }
              }
            }
          })
        },
        // Follow code may reuse in other components
        initSlideMotion(token2, "slide-up"),
        initSlideMotion(token2, "slide-down"),
        initMoveMotion(token2, "move-up"),
        initMoveMotion(token2, "move-down")
      ];
    };
    const initPickerPanelToken = (token2) => {
      const pickerTimePanelCellHeight = 28;
      const {
        componentCls,
        controlHeightLG,
        controlHeightSM,
        colorPrimary,
        paddingXXS,
        padding
      } = token2;
      return {
        pickerCellCls: `${componentCls}-cell`,
        pickerCellInnerCls: `${componentCls}-cell-inner`,
        pickerTextHeight: controlHeightLG,
        pickerPanelCellWidth: controlHeightSM * 1.5,
        pickerPanelCellHeight: controlHeightSM,
        pickerDateHoverRangeBorderColor: new TinyColor(colorPrimary).lighten(20).toHexString(),
        pickerBasicCellHoverWithRangeColor: new TinyColor(colorPrimary).lighten(35).toHexString(),
        pickerPanelWithoutTimeCellHeight: controlHeightLG * 1.65,
        pickerYearMonthCellWidth: controlHeightLG * 1.5,
        pickerTimePanelColumnHeight: pickerTimePanelCellHeight * 8,
        pickerTimePanelColumnWidth: controlHeightLG * 1.4,
        pickerTimePanelCellHeight,
        pickerQuarterPanelContentHeight: controlHeightLG * 1.4,
        pickerCellPaddingVertical: paddingXXS + paddingXXS / 2,
        pickerCellBorderGap: 2,
        pickerControlIconSize: 7,
        pickerControlIconBorderWidth: 1.5,
        pickerDatePanelPaddingHorizontal: padding + paddingXXS / 2
        // 18 in normal
      };
    };
    const useStyle$k = genComponentStyleHook("DatePicker", (token2) => {
      const pickerToken = merge$4(initInputToken(token2), initPickerPanelToken(token2));
      return [
        genPickerStyle(pickerToken),
        genPickerStatusStyle(pickerToken),
        // =====================================================
        // ==             Space Compact                       ==
        // =====================================================
        genCompactItemStyle(token2, {
          focusElCls: `${token2.componentCls}-focused`
        })
      ];
    }, (token2) => ({
      presetsWidth: 120,
      presetsMaxWidth: 200,
      zIndexPopup: token2.zIndexPopupBase + 50
    }));
    const Element$1 = (props) => {
      const {
        prefixCls,
        className,
        style: style2,
        size,
        shape
      } = props;
      const sizeCls = classNames({
        [`${prefixCls}-lg`]: size === "large",
        [`${prefixCls}-sm`]: size === "small"
      });
      const shapeCls = classNames({
        [`${prefixCls}-circle`]: shape === "circle",
        [`${prefixCls}-square`]: shape === "square",
        [`${prefixCls}-round`]: shape === "round"
      });
      const sizeStyle = reactExports.useMemo(() => typeof size === "number" ? {
        width: size,
        height: size,
        lineHeight: `${size}px`
      } : {}, [size]);
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames(prefixCls, sizeCls, shapeCls, className),
        style: Object.assign(Object.assign({}, sizeStyle), style2)
      });
    };
    const Element$2 = Element$1;
    const skeletonClsLoading = new Keyframe(`ant-skeleton-loading`, {
      "0%": {
        backgroundPosition: "100% 50%"
      },
      "100%": {
        backgroundPosition: "0 50%"
      }
    });
    const genSkeletonElementCommonSize = (size) => ({
      height: size,
      lineHeight: `${size}px`
    });
    const genSkeletonElementAvatarSize = (size) => Object.assign({
      width: size
    }, genSkeletonElementCommonSize(size));
    const genSkeletonColor = (token2) => ({
      background: token2.skeletonLoadingBackground,
      backgroundSize: "400% 100%",
      animationName: skeletonClsLoading,
      animationDuration: token2.skeletonLoadingMotionDuration,
      animationTimingFunction: "ease",
      animationIterationCount: "infinite"
    });
    const genSkeletonElementInputSize = (size) => Object.assign({
      width: size * 5,
      minWidth: size * 5
    }, genSkeletonElementCommonSize(size));
    const genSkeletonElementAvatar = (token2) => {
      const {
        skeletonAvatarCls,
        color: color2,
        controlHeight,
        controlHeightLG,
        controlHeightSM
      } = token2;
      return {
        [`${skeletonAvatarCls}`]: Object.assign({
          display: "inline-block",
          verticalAlign: "top",
          background: color2
        }, genSkeletonElementAvatarSize(controlHeight)),
        [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
          borderRadius: "50%"
        },
        [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
        [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
      };
    };
    const genSkeletonElementInput = (token2) => {
      const {
        controlHeight,
        borderRadiusSM,
        skeletonInputCls,
        controlHeightLG,
        controlHeightSM,
        color: color2
      } = token2;
      return {
        [`${skeletonInputCls}`]: Object.assign({
          display: "inline-block",
          verticalAlign: "top",
          background: color2,
          borderRadius: borderRadiusSM
        }, genSkeletonElementInputSize(controlHeight)),
        [`${skeletonInputCls}-lg`]: Object.assign({}, genSkeletonElementInputSize(controlHeightLG)),
        [`${skeletonInputCls}-sm`]: Object.assign({}, genSkeletonElementInputSize(controlHeightSM))
      };
    };
    const genSkeletonElementImageSize = (size) => Object.assign({
      width: size
    }, genSkeletonElementCommonSize(size));
    const genSkeletonElementImage = (token2) => {
      const {
        skeletonImageCls,
        imageSizeBase,
        color: color2,
        borderRadiusSM
      } = token2;
      return {
        [`${skeletonImageCls}`]: Object.assign(Object.assign({
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          verticalAlign: "top",
          background: color2,
          borderRadius: borderRadiusSM
        }, genSkeletonElementImageSize(imageSizeBase * 2)), {
          [`${skeletonImageCls}-path`]: {
            fill: "#bfbfbf"
          },
          [`${skeletonImageCls}-svg`]: Object.assign(Object.assign({}, genSkeletonElementImageSize(imageSizeBase)), {
            maxWidth: imageSizeBase * 4,
            maxHeight: imageSizeBase * 4
          }),
          [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
            borderRadius: "50%"
          }
        }),
        [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
          borderRadius: "50%"
        }
      };
    };
    const genSkeletonElementButtonShape = (token2, size, buttonCls) => {
      const {
        skeletonButtonCls
      } = token2;
      return {
        [`${buttonCls}${skeletonButtonCls}-circle`]: {
          width: size,
          minWidth: size,
          borderRadius: "50%"
        },
        [`${buttonCls}${skeletonButtonCls}-round`]: {
          borderRadius: size
        }
      };
    };
    const genSkeletonElementButtonSize = (size) => Object.assign({
      width: size * 2,
      minWidth: size * 2
    }, genSkeletonElementCommonSize(size));
    const genSkeletonElementButton = (token2) => {
      const {
        borderRadiusSM,
        skeletonButtonCls,
        controlHeight,
        controlHeightLG,
        controlHeightSM,
        color: color2
      } = token2;
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
        [`${skeletonButtonCls}`]: Object.assign({
          display: "inline-block",
          verticalAlign: "top",
          background: color2,
          borderRadius: borderRadiusSM,
          width: controlHeight * 2,
          minWidth: controlHeight * 2
        }, genSkeletonElementButtonSize(controlHeight))
      }, genSkeletonElementButtonShape(token2, controlHeight, skeletonButtonCls)), {
        [`${skeletonButtonCls}-lg`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightLG))
      }), genSkeletonElementButtonShape(token2, controlHeightLG, `${skeletonButtonCls}-lg`)), {
        [`${skeletonButtonCls}-sm`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightSM))
      }), genSkeletonElementButtonShape(token2, controlHeightSM, `${skeletonButtonCls}-sm`));
    };
    const genBaseStyle$6 = (token2) => {
      const {
        componentCls,
        skeletonAvatarCls,
        skeletonTitleCls,
        skeletonParagraphCls,
        skeletonButtonCls,
        skeletonInputCls,
        skeletonImageCls,
        controlHeight,
        controlHeightLG,
        controlHeightSM,
        color: color2,
        padding,
        marginSM,
        borderRadius,
        skeletonTitleHeight,
        skeletonBlockRadius,
        skeletonParagraphLineHeight,
        controlHeightXS,
        skeletonParagraphMarginTop
      } = token2;
      return {
        [`${componentCls}`]: {
          display: "table",
          width: "100%",
          [`${componentCls}-header`]: {
            display: "table-cell",
            paddingInlineEnd: padding,
            verticalAlign: "top",
            // Avatar
            [`${skeletonAvatarCls}`]: Object.assign({
              display: "inline-block",
              verticalAlign: "top",
              background: color2
            }, genSkeletonElementAvatarSize(controlHeight)),
            [`${skeletonAvatarCls}-circle`]: {
              borderRadius: "50%"
            },
            [`${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
            [`${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
          },
          [`${componentCls}-content`]: {
            display: "table-cell",
            width: "100%",
            verticalAlign: "top",
            // Title
            [`${skeletonTitleCls}`]: {
              width: "100%",
              height: skeletonTitleHeight,
              background: color2,
              borderRadius: skeletonBlockRadius,
              [`+ ${skeletonParagraphCls}`]: {
                marginBlockStart: controlHeightSM
              }
            },
            // paragraph
            [`${skeletonParagraphCls}`]: {
              padding: 0,
              "> li": {
                width: "100%",
                height: skeletonParagraphLineHeight,
                listStyle: "none",
                background: color2,
                borderRadius: skeletonBlockRadius,
                "+ li": {
                  marginBlockStart: controlHeightXS
                }
              }
            },
            [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
              width: "61%"
            }
          },
          [`&-round ${componentCls}-content`]: {
            [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
              borderRadius
            }
          }
        },
        [`${componentCls}-with-avatar ${componentCls}-content`]: {
          // Title
          [`${skeletonTitleCls}`]: {
            marginBlockStart: marginSM,
            [`+ ${skeletonParagraphCls}`]: {
              marginBlockStart: skeletonParagraphMarginTop
            }
          }
        },
        // Skeleton element
        [`${componentCls}${componentCls}-element`]: Object.assign(Object.assign(Object.assign(Object.assign({
          display: "inline-block",
          width: "auto"
        }, genSkeletonElementButton(token2)), genSkeletonElementAvatar(token2)), genSkeletonElementInput(token2)), genSkeletonElementImage(token2)),
        // Skeleton Block Button, Input
        [`${componentCls}${componentCls}-block`]: {
          width: "100%",
          [`${skeletonButtonCls}`]: {
            width: "100%"
          },
          [`${skeletonInputCls}`]: {
            width: "100%"
          }
        },
        // With active animation
        [`${componentCls}${componentCls}-active`]: {
          [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonImageCls}
      `]: Object.assign({}, genSkeletonColor(token2))
        }
      };
    };
    const useStyle$j = genComponentStyleHook("Skeleton", (token2) => {
      const {
        componentCls
      } = token2;
      const skeletonToken = merge$4(token2, {
        skeletonAvatarCls: `${componentCls}-avatar`,
        skeletonTitleCls: `${componentCls}-title`,
        skeletonParagraphCls: `${componentCls}-paragraph`,
        skeletonButtonCls: `${componentCls}-button`,
        skeletonInputCls: `${componentCls}-input`,
        skeletonImageCls: `${componentCls}-image`,
        imageSizeBase: token2.controlHeight * 1.5,
        skeletonTitleHeight: token2.controlHeight / 2,
        skeletonBlockRadius: token2.borderRadiusSM,
        skeletonParagraphLineHeight: token2.controlHeight / 2,
        skeletonParagraphMarginTop: token2.marginLG + token2.marginXXS,
        borderRadius: 100,
        skeletonLoadingBackground: `linear-gradient(90deg, ${token2.color} 25%, ${token2.colorGradientEnd} 37%, ${token2.color} 63%)`,
        skeletonLoadingMotionDuration: "1.4s"
      });
      return [genBaseStyle$6(skeletonToken)];
    }, (token2) => {
      const {
        colorFillContent,
        colorFill
      } = token2;
      return {
        color: colorFillContent,
        colorGradientEnd: colorFill
      };
    });
    const SkeletonAvatar = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        active,
        shape = "circle",
        size = "default"
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$j(prefixCls);
      const otherProps = omit(props, ["prefixCls", "className"]);
      const cls = classNames(prefixCls, `${prefixCls}-element`, {
        [`${prefixCls}-active`]: active
      }, className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", {
        className: cls
      }, /* @__PURE__ */ reactExports.createElement(Element$2, Object.assign({
        prefixCls: `${prefixCls}-avatar`,
        shape,
        size
      }, otherProps))));
    };
    const SkeletonAvatar$1 = SkeletonAvatar;
    const SkeletonButton = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        active,
        block = false,
        size = "default"
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$j(prefixCls);
      const otherProps = omit(props, ["prefixCls"]);
      const cls = classNames(prefixCls, `${prefixCls}-element`, {
        [`${prefixCls}-active`]: active,
        [`${prefixCls}-block`]: block
      }, className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", {
        className: cls
      }, /* @__PURE__ */ reactExports.createElement(Element$2, Object.assign({
        prefixCls: `${prefixCls}-button`,
        size
      }, otherProps))));
    };
    const SkeletonButton$1 = SkeletonButton;
    var DotChartOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M888 792H200V168c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h752c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM288 604a64 64 0 10128 0 64 64 0 10-128 0zm118-224a48 48 0 1096 0 48 48 0 10-96 0zm158 228a96 96 0 10192 0 96 96 0 10-192 0zm148-314a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "dot-chart", "theme": "outlined" };
    const DotChartOutlinedSvg = DotChartOutlined$2;
    var DotChartOutlined = function DotChartOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: DotChartOutlinedSvg
      }));
    };
    DotChartOutlined.displayName = "DotChartOutlined";
    const DotChartOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(DotChartOutlined);
    const SkeletonNode = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        style: style2,
        active,
        children
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$j(prefixCls);
      const cls = classNames(prefixCls, `${prefixCls}-element`, {
        [`${prefixCls}-active`]: active
      }, hashId, className, rootClassName);
      const content2 = children !== null && children !== void 0 ? children : /* @__PURE__ */ reactExports.createElement(DotChartOutlined$1, null);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", {
        className: cls
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(`${prefixCls}-image`, className),
        style: style2
      }, content2)));
    };
    const SkeletonNode$1 = SkeletonNode;
    const path$1 = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
    const SkeletonImage = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        style: style2,
        active
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$j(prefixCls);
      const cls = classNames(prefixCls, `${prefixCls}-element`, {
        [`${prefixCls}-active`]: active
      }, className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", {
        className: cls
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(`${prefixCls}-image`, className),
        style: style2
      }, /* @__PURE__ */ reactExports.createElement("svg", {
        viewBox: "0 0 1098 1024",
        xmlns: "http://www.w3.org/2000/svg",
        className: `${prefixCls}-image-svg`
      }, /* @__PURE__ */ reactExports.createElement("path", {
        d: path$1,
        className: `${prefixCls}-image-path`
      })))));
    };
    const SkeletonImage$1 = SkeletonImage;
    const SkeletonInput = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        active,
        block,
        size = "default"
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$j(prefixCls);
      const otherProps = omit(props, ["prefixCls"]);
      const cls = classNames(prefixCls, `${prefixCls}-element`, {
        [`${prefixCls}-active`]: active,
        [`${prefixCls}-block`]: block
      }, className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", {
        className: cls
      }, /* @__PURE__ */ reactExports.createElement(Element$2, Object.assign({
        prefixCls: `${prefixCls}-input`,
        size
      }, otherProps))));
    };
    const SkeletonInput$1 = SkeletonInput;
    const Paragraph$2 = (props) => {
      const getWidth = (index2) => {
        const {
          width,
          rows: rows2 = 2
        } = props;
        if (Array.isArray(width)) {
          return width[index2];
        }
        if (rows2 - 1 === index2) {
          return width;
        }
        return void 0;
      };
      const {
        prefixCls,
        className,
        style: style2,
        rows
      } = props;
      const rowList = _toConsumableArray(Array(rows)).map((_, index2) => (
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ reactExports.createElement("li", {
          key: index2,
          style: {
            width: getWidth(index2)
          }
        })
      ));
      return /* @__PURE__ */ reactExports.createElement("ul", {
        className: classNames(prefixCls, className),
        style: style2
      }, rowList);
    };
    const Paragraph$3 = Paragraph$2;
    const Title$d = (_ref) => {
      let {
        prefixCls,
        className,
        width,
        style: style2
      } = _ref;
      return /* @__PURE__ */ reactExports.createElement("h3", {
        className: classNames(prefixCls, className),
        style: Object.assign({
          width
        }, style2)
      });
    };
    const Title$e = Title$d;
    function getComponentProps(prop) {
      if (prop && typeof prop === "object") {
        return prop;
      }
      return {};
    }
    function getAvatarBasicProps(hasTitle, hasParagraph) {
      if (hasTitle && !hasParagraph) {
        return {
          size: "large",
          shape: "square"
        };
      }
      return {
        size: "large",
        shape: "circle"
      };
    }
    function getTitleBasicProps(hasAvatar, hasParagraph) {
      if (!hasAvatar && hasParagraph) {
        return {
          width: "38%"
        };
      }
      if (hasAvatar && hasParagraph) {
        return {
          width: "50%"
        };
      }
      return {};
    }
    function getParagraphBasicProps(hasAvatar, hasTitle) {
      const basicProps = {};
      if (!hasAvatar || !hasTitle) {
        basicProps.width = "61%";
      }
      if (!hasAvatar && hasTitle) {
        basicProps.rows = 3;
      } else {
        basicProps.rows = 2;
      }
      return basicProps;
    }
    const Skeleton = (props) => {
      const {
        prefixCls: customizePrefixCls,
        loading,
        className,
        rootClassName,
        style: style2,
        children,
        avatar = false,
        title = true,
        paragraph: paragraph2 = true,
        active,
        round
      } = props;
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$j(prefixCls);
      if (loading || !("loading" in props)) {
        const hasAvatar = !!avatar;
        const hasTitle = !!title;
        const hasParagraph = !!paragraph2;
        let avatarNode;
        if (hasAvatar) {
          const avatarProps = Object.assign(Object.assign({
            prefixCls: `${prefixCls}-avatar`
          }, getAvatarBasicProps(hasTitle, hasParagraph)), getComponentProps(avatar));
          avatarNode = /* @__PURE__ */ reactExports.createElement("div", {
            className: `${prefixCls}-header`
          }, /* @__PURE__ */ reactExports.createElement(Element$2, Object.assign({}, avatarProps)));
        }
        let contentNode;
        if (hasTitle || hasParagraph) {
          let $title;
          if (hasTitle) {
            const titleProps = Object.assign(Object.assign({
              prefixCls: `${prefixCls}-title`
            }, getTitleBasicProps(hasAvatar, hasParagraph)), getComponentProps(title));
            $title = /* @__PURE__ */ reactExports.createElement(Title$e, Object.assign({}, titleProps));
          }
          let paragraphNode;
          if (hasParagraph) {
            const paragraphProps = Object.assign(Object.assign({
              prefixCls: `${prefixCls}-paragraph`
            }, getParagraphBasicProps(hasAvatar, hasTitle)), getComponentProps(paragraph2));
            paragraphNode = /* @__PURE__ */ reactExports.createElement(Paragraph$3, Object.assign({}, paragraphProps));
          }
          contentNode = /* @__PURE__ */ reactExports.createElement("div", {
            className: `${prefixCls}-content`
          }, $title, paragraphNode);
        }
        const cls = classNames(prefixCls, {
          [`${prefixCls}-with-avatar`]: hasAvatar,
          [`${prefixCls}-active`]: active,
          [`${prefixCls}-rtl`]: direction === "rtl",
          [`${prefixCls}-round`]: round
        }, className, rootClassName, hashId);
        return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", {
          className: cls,
          style: style2
        }, avatarNode, contentNode));
      }
      return typeof children !== "undefined" ? children : null;
    };
    Skeleton.Button = SkeletonButton$1;
    Skeleton.Avatar = SkeletonAvatar$1;
    Skeleton.Input = SkeletonInput$1;
    Skeleton.Image = SkeletonImage$1;
    Skeleton.Node = SkeletonNode$1;
    const Skeleton$1 = Skeleton;
    var PlusOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { "tag": "path", "attrs": { "d": "M176 474h672q8 0 8 8v60q0 8-8 8H176q-8 0-8-8v-60q0-8 8-8z" } }] }, "name": "plus", "theme": "outlined" };
    const PlusOutlinedSvg = PlusOutlined$2;
    var PlusOutlined = function PlusOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: PlusOutlinedSvg
      }));
    };
    PlusOutlined.displayName = "PlusOutlined";
    const PlusOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(PlusOutlined);
    const TabContext = /* @__PURE__ */ reactExports.createContext(null);
    var TabPane$2 = /* @__PURE__ */ reactExports.forwardRef(function(_ref, ref) {
      var prefixCls = _ref.prefixCls, className = _ref.className, style2 = _ref.style, id2 = _ref.id, active = _ref.active, tabKey = _ref.tabKey, children = _ref.children;
      return /* @__PURE__ */ reactExports.createElement("div", {
        id: id2 && "".concat(id2, "-panel-").concat(tabKey),
        role: "tabpanel",
        tabIndex: active ? 0 : -1,
        "aria-labelledby": id2 && "".concat(id2, "-tab-").concat(tabKey),
        "aria-hidden": !active,
        style: style2,
        className: classNames(prefixCls, active && "".concat(prefixCls, "-active"), className),
        ref
      }, children);
    });
    var _excluded$m = ["key", "forceRender", "style", "className"];
    function TabPanelList(_ref) {
      var id2 = _ref.id, activeKey = _ref.activeKey, animated = _ref.animated, tabPosition = _ref.tabPosition, destroyInactiveTabPane = _ref.destroyInactiveTabPane;
      var _React$useContext = reactExports.useContext(TabContext), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
      var tabPaneAnimated = animated.tabPane;
      var tabPanePrefixCls = "".concat(prefixCls, "-tabpane");
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-content-holder"))
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-content"), "".concat(prefixCls, "-content-").concat(tabPosition), _defineProperty$7({}, "".concat(prefixCls, "-content-animated"), tabPaneAnimated))
      }, tabs.map(function(_ref2) {
        var key = _ref2.key, forceRender = _ref2.forceRender, paneStyle = _ref2.style, paneClassName = _ref2.className, restTabProps = _objectWithoutProperties$1(_ref2, _excluded$m);
        var active = key === activeKey;
        return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$2({
          key,
          visible: active,
          forceRender,
          removeOnLeave: !!destroyInactiveTabPane,
          leavedClassName: "".concat(tabPanePrefixCls, "-hidden")
        }, animated.tabPaneMotion), function(_ref3, ref) {
          var motionStyle = _ref3.style, motionClassName = _ref3.className;
          return /* @__PURE__ */ reactExports.createElement(TabPane$2, _extends$2({}, restTabProps, {
            prefixCls: tabPanePrefixCls,
            id: id2,
            tabKey: key,
            animated: tabPaneAnimated,
            active,
            style: _objectSpread2$3(_objectSpread2$3({}, paneStyle), motionStyle),
            className: classNames(paneClassName, motionClassName),
            ref
          }));
        });
      })));
    }
    var DEFAULT_SIZE$1 = {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    function useOffsets(tabs, tabSizes, holderScrollWidth) {
      return reactExports.useMemo(function() {
        var _tabs$;
        var map = /* @__PURE__ */ new Map();
        var lastOffset = tabSizes.get((_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key) || DEFAULT_SIZE$1;
        var rightOffset = lastOffset.left + lastOffset.width;
        for (var i2 = 0; i2 < tabs.length; i2 += 1) {
          var key = tabs[i2].key;
          var data2 = tabSizes.get(key);
          if (!data2) {
            var _tabs;
            data2 = tabSizes.get((_tabs = tabs[i2 - 1]) === null || _tabs === void 0 ? void 0 : _tabs.key) || DEFAULT_SIZE$1;
          }
          var entity = map.get(key) || _objectSpread2$3({}, data2);
          entity.right = rightOffset - entity.left - entity.width;
          map.set(key, entity);
        }
        return map;
      }, [tabs.map(function(tab) {
        return tab.key;
      }).join("_"), tabSizes, holderScrollWidth]);
    }
    function useSyncState$1(defaultState, onChange) {
      var stateRef = reactExports.useRef(defaultState);
      var _React$useState = reactExports.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
      function setState(updater) {
        var newValue = typeof updater === "function" ? updater(stateRef.current) : updater;
        if (newValue !== stateRef.current) {
          onChange(newValue, stateRef.current);
        }
        stateRef.current = newValue;
        forceUpdate({});
      }
      return [stateRef.current, setState];
    }
    var MIN_SWIPE_DISTANCE = 0.1;
    var STOP_SWIPE_DISTANCE = 0.01;
    var REFRESH_INTERVAL = 20;
    var SPEED_OFF_MULTIPLE = Math.pow(0.995, REFRESH_INTERVAL);
    function useTouchMove(ref, onOffset) {
      var _useState = reactExports.useState(), _useState2 = _slicedToArray(_useState, 2), touchPosition = _useState2[0], setTouchPosition = _useState2[1];
      var _useState3 = reactExports.useState(0), _useState4 = _slicedToArray(_useState3, 2), lastTimestamp = _useState4[0], setLastTimestamp = _useState4[1];
      var _useState5 = reactExports.useState(0), _useState6 = _slicedToArray(_useState5, 2), lastTimeDiff = _useState6[0], setLastTimeDiff = _useState6[1];
      var _useState7 = reactExports.useState(), _useState8 = _slicedToArray(_useState7, 2), lastOffset = _useState8[0], setLastOffset = _useState8[1];
      var motionRef = reactExports.useRef();
      function onTouchStart(e2) {
        var _e$touches$ = e2.touches[0], screenX = _e$touches$.screenX, screenY = _e$touches$.screenY;
        setTouchPosition({
          x: screenX,
          y: screenY
        });
        window.clearInterval(motionRef.current);
      }
      function onTouchMove(e2) {
        if (!touchPosition)
          return;
        e2.preventDefault();
        var _e$touches$2 = e2.touches[0], screenX = _e$touches$2.screenX, screenY = _e$touches$2.screenY;
        setTouchPosition({
          x: screenX,
          y: screenY
        });
        var offsetX = screenX - touchPosition.x;
        var offsetY = screenY - touchPosition.y;
        onOffset(offsetX, offsetY);
        var now2 = Date.now();
        setLastTimestamp(now2);
        setLastTimeDiff(now2 - lastTimestamp);
        setLastOffset({
          x: offsetX,
          y: offsetY
        });
      }
      function onTouchEnd() {
        if (!touchPosition)
          return;
        setTouchPosition(null);
        setLastOffset(null);
        if (lastOffset) {
          var distanceX = lastOffset.x / lastTimeDiff;
          var distanceY = lastOffset.y / lastTimeDiff;
          var absX = Math.abs(distanceX);
          var absY = Math.abs(distanceY);
          if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE)
            return;
          var currentX = distanceX;
          var currentY = distanceY;
          motionRef.current = window.setInterval(function() {
            if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
              window.clearInterval(motionRef.current);
              return;
            }
            currentX *= SPEED_OFF_MULTIPLE;
            currentY *= SPEED_OFF_MULTIPLE;
            onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
          }, REFRESH_INTERVAL);
        }
      }
      var lastWheelDirectionRef = reactExports.useRef();
      function onWheel(e2) {
        var deltaX = e2.deltaX, deltaY = e2.deltaY;
        var mixed = 0;
        var absX = Math.abs(deltaX);
        var absY = Math.abs(deltaY);
        if (absX === absY) {
          mixed = lastWheelDirectionRef.current === "x" ? deltaX : deltaY;
        } else if (absX > absY) {
          mixed = deltaX;
          lastWheelDirectionRef.current = "x";
        } else {
          mixed = deltaY;
          lastWheelDirectionRef.current = "y";
        }
        if (onOffset(-mixed, -mixed)) {
          e2.preventDefault();
        }
      }
      var touchEventsRef = reactExports.useRef(null);
      touchEventsRef.current = {
        onTouchStart,
        onTouchMove,
        onTouchEnd,
        onWheel
      };
      reactExports.useEffect(function() {
        function onProxyTouchStart(e2) {
          touchEventsRef.current.onTouchStart(e2);
        }
        function onProxyTouchMove(e2) {
          touchEventsRef.current.onTouchMove(e2);
        }
        function onProxyTouchEnd(e2) {
          touchEventsRef.current.onTouchEnd(e2);
        }
        function onProxyWheel(e2) {
          touchEventsRef.current.onWheel(e2);
        }
        document.addEventListener("touchmove", onProxyTouchMove, {
          passive: false
        });
        document.addEventListener("touchend", onProxyTouchEnd, {
          passive: false
        });
        ref.current.addEventListener("touchstart", onProxyTouchStart, {
          passive: false
        });
        ref.current.addEventListener("wheel", onProxyWheel);
        return function() {
          document.removeEventListener("touchmove", onProxyTouchMove);
          document.removeEventListener("touchend", onProxyTouchEnd);
        };
      }, []);
    }
    function useUpdate(callback) {
      var _useState = reactExports.useState(0), _useState2 = _slicedToArray(_useState, 2), count = _useState2[0], setCount = _useState2[1];
      var effectRef = reactExports.useRef(0);
      var callbackRef = reactExports.useRef();
      callbackRef.current = callback;
      useLayoutUpdateEffect(function() {
        var _callbackRef$current;
        (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef);
      }, [count]);
      return function() {
        if (effectRef.current !== count) {
          return;
        }
        effectRef.current += 1;
        setCount(effectRef.current);
      };
    }
    function useUpdateState(defaultState) {
      var batchRef = reactExports.useRef([]);
      var _useState3 = reactExports.useState({}), _useState4 = _slicedToArray(_useState3, 2), forceUpdate = _useState4[1];
      var state = reactExports.useRef(typeof defaultState === "function" ? defaultState() : defaultState);
      var flushUpdate = useUpdate(function() {
        var current = state.current;
        batchRef.current.forEach(function(callback) {
          current = callback(current);
        });
        batchRef.current = [];
        state.current = current;
        forceUpdate({});
      });
      function updater(callback) {
        batchRef.current.push(callback);
        flushUpdate();
      }
      return [state.current, updater];
    }
    var DEFAULT_SIZE = {
      width: 0,
      height: 0,
      left: 0,
      top: 0,
      right: 0
    };
    function useVisibleRange(tabOffsets, visibleTabContentValue, transform, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, _ref) {
      var tabs = _ref.tabs, tabPosition = _ref.tabPosition, rtl = _ref.rtl;
      var charUnit;
      var position2;
      var transformSize;
      if (["top", "bottom"].includes(tabPosition)) {
        charUnit = "width";
        position2 = rtl ? "right" : "left";
        transformSize = Math.abs(transform);
      } else {
        charUnit = "height";
        position2 = "top";
        transformSize = -transform;
      }
      return reactExports.useMemo(function() {
        if (!tabs.length) {
          return [0, 0];
        }
        var len = tabs.length;
        var endIndex = len;
        for (var i2 = 0; i2 < len; i2 += 1) {
          var offset2 = tabOffsets.get(tabs[i2].key) || DEFAULT_SIZE;
          if (offset2[position2] + offset2[charUnit] > transformSize + visibleTabContentValue) {
            endIndex = i2 - 1;
            break;
          }
        }
        var startIndex = 0;
        for (var _i = len - 1; _i >= 0; _i -= 1) {
          var _offset = tabOffsets.get(tabs[_i].key) || DEFAULT_SIZE;
          if (_offset[position2] < transformSize) {
            startIndex = _i + 1;
            break;
          }
        }
        return [startIndex, endIndex];
      }, [tabOffsets, visibleTabContentValue, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, transformSize, tabPosition, tabs.map(function(tab) {
        return tab.key;
      }).join("_"), rtl]);
    }
    function stringify$2(obj) {
      var tgt;
      if (obj instanceof Map) {
        tgt = {};
        obj.forEach(function(v2, k2) {
          tgt[k2] = v2;
        });
      } else {
        tgt = obj;
      }
      return JSON.stringify(tgt);
    }
    var RC_TABS_DOUBLE_QUOTE = "TABS_DQ";
    function genDataNodeKey(key) {
      return key.replace(/"/g, RC_TABS_DOUBLE_QUOTE);
    }
    function AddButton(_ref, ref) {
      var prefixCls = _ref.prefixCls, editable = _ref.editable, locale2 = _ref.locale, style2 = _ref.style;
      if (!editable || editable.showAdd === false) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("button", {
        ref,
        type: "button",
        className: "".concat(prefixCls, "-nav-add"),
        style: style2,
        "aria-label": (locale2 === null || locale2 === void 0 ? void 0 : locale2.addAriaLabel) || "Add tab",
        onClick: function onClick(event) {
          editable.onEdit("add", {
            event
          });
        }
      }, editable.addIcon || "+");
    }
    const AddButton$1 = /* @__PURE__ */ reactExports.forwardRef(AddButton);
    var ExtraContent = /* @__PURE__ */ reactExports.forwardRef(function(_ref, ref) {
      var position2 = _ref.position, prefixCls = _ref.prefixCls, extra = _ref.extra;
      if (!extra)
        return null;
      var content2;
      var assertExtra = {};
      if (_typeof$4(extra) === "object" && !/* @__PURE__ */ reactExports.isValidElement(extra)) {
        assertExtra = extra;
      } else {
        assertExtra.right = extra;
      }
      if (position2 === "right") {
        content2 = assertExtra.right;
      }
      if (position2 === "left") {
        content2 = assertExtra.left;
      }
      return content2 ? /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-extra-content"),
        ref
      }, content2) : null;
    });
    function OperationNode(_ref, ref) {
      var prefixCls = _ref.prefixCls, id2 = _ref.id, tabs = _ref.tabs, locale2 = _ref.locale, mobile = _ref.mobile, _ref$moreIcon = _ref.moreIcon, moreIcon = _ref$moreIcon === void 0 ? "More" : _ref$moreIcon, moreTransitionName = _ref.moreTransitionName, style2 = _ref.style, className = _ref.className, editable = _ref.editable, tabBarGutter = _ref.tabBarGutter, rtl = _ref.rtl, removeAriaLabel = _ref.removeAriaLabel, onTabClick = _ref.onTabClick, getPopupContainer = _ref.getPopupContainer, popupClassName = _ref.popupClassName;
      var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), open2 = _useState2[0], setOpen = _useState2[1];
      var _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), selectedKey = _useState4[0], setSelectedKey = _useState4[1];
      var popupId = "".concat(id2, "-more-popup");
      var dropdownPrefix = "".concat(prefixCls, "-dropdown");
      var selectedItemId = selectedKey !== null ? "".concat(popupId, "-").concat(selectedKey) : null;
      var dropdownAriaLabel = locale2 === null || locale2 === void 0 ? void 0 : locale2.dropdownAriaLabel;
      function onRemoveTab(event, key) {
        event.preventDefault();
        event.stopPropagation();
        editable.onEdit("remove", {
          key,
          event
        });
      }
      var menu = /* @__PURE__ */ reactExports.createElement(ExportMenu, {
        onClick: function onClick(_ref2) {
          var key = _ref2.key, domEvent = _ref2.domEvent;
          onTabClick(key, domEvent);
          setOpen(false);
        },
        prefixCls: "".concat(dropdownPrefix, "-menu"),
        id: popupId,
        tabIndex: -1,
        role: "listbox",
        "aria-activedescendant": selectedItemId,
        selectedKeys: [selectedKey],
        "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
      }, tabs.map(function(tab) {
        var removable = editable && tab.closable !== false && !tab.disabled;
        return /* @__PURE__ */ reactExports.createElement(MenuItem$1, {
          key: tab.key,
          id: "".concat(popupId, "-").concat(tab.key),
          role: "option",
          "aria-controls": id2 && "".concat(id2, "-panel-").concat(tab.key),
          disabled: tab.disabled
        }, /* @__PURE__ */ reactExports.createElement("span", null, tab.label), removable && /* @__PURE__ */ reactExports.createElement("button", {
          type: "button",
          "aria-label": removeAriaLabel || "remove",
          tabIndex: 0,
          className: "".concat(dropdownPrefix, "-menu-item-remove"),
          onClick: function onClick(e2) {
            e2.stopPropagation();
            onRemoveTab(e2, tab.key);
          }
        }, tab.closeIcon || editable.removeIcon || "×"));
      }));
      function selectOffset(offset2) {
        var enabledTabs = tabs.filter(function(tab2) {
          return !tab2.disabled;
        });
        var selectedIndex = enabledTabs.findIndex(function(tab2) {
          return tab2.key === selectedKey;
        }) || 0;
        var len = enabledTabs.length;
        for (var i2 = 0; i2 < len; i2 += 1) {
          selectedIndex = (selectedIndex + offset2 + len) % len;
          var tab = enabledTabs[selectedIndex];
          if (!tab.disabled) {
            setSelectedKey(tab.key);
            return;
          }
        }
      }
      function onKeyDown2(e2) {
        var which = e2.which;
        if (!open2) {
          if ([KeyCode.DOWN, KeyCode.SPACE, KeyCode.ENTER].includes(which)) {
            setOpen(true);
            e2.preventDefault();
          }
          return;
        }
        switch (which) {
          case KeyCode.UP:
            selectOffset(-1);
            e2.preventDefault();
            break;
          case KeyCode.DOWN:
            selectOffset(1);
            e2.preventDefault();
            break;
          case KeyCode.ESC:
            setOpen(false);
            break;
          case KeyCode.SPACE:
          case KeyCode.ENTER:
            if (selectedKey !== null)
              onTabClick(selectedKey, e2);
            break;
        }
      }
      reactExports.useEffect(function() {
        var ele = document.getElementById(selectedItemId);
        if (ele && ele.scrollIntoView) {
          ele.scrollIntoView(false);
        }
      }, [selectedKey]);
      reactExports.useEffect(function() {
        if (!open2) {
          setSelectedKey(null);
        }
      }, [open2]);
      var moreStyle = _defineProperty$7({}, rtl ? "marginRight" : "marginLeft", tabBarGutter);
      if (!tabs.length) {
        moreStyle.visibility = "hidden";
        moreStyle.order = 1;
      }
      var overlayClassName = classNames(_defineProperty$7({}, "".concat(dropdownPrefix, "-rtl"), rtl));
      var moreNode = mobile ? null : /* @__PURE__ */ reactExports.createElement(Dropdown$3, {
        prefixCls: dropdownPrefix,
        overlay: menu,
        trigger: ["hover"],
        visible: tabs.length ? open2 : false,
        transitionName: moreTransitionName,
        onVisibleChange: setOpen,
        overlayClassName: classNames(overlayClassName, popupClassName),
        mouseEnterDelay: 0.1,
        mouseLeaveDelay: 0.1,
        getPopupContainer
      }, /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        className: "".concat(prefixCls, "-nav-more"),
        style: moreStyle,
        tabIndex: -1,
        "aria-hidden": "true",
        "aria-haspopup": "listbox",
        "aria-controls": popupId,
        id: "".concat(id2, "-more"),
        "aria-expanded": open2,
        onKeyDown: onKeyDown2
      }, moreIcon));
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-nav-operations"), className),
        style: style2,
        ref
      }, moreNode, /* @__PURE__ */ reactExports.createElement(AddButton$1, {
        prefixCls,
        locale: locale2,
        editable
      }));
    }
    const OperationNode$1 = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(OperationNode), function(_, next2) {
      return (
        // https://github.com/ant-design/ant-design/issues/32544
        // We'd better remove syntactic sugar in `rc-menu` since this has perf issue
        next2.tabMoving
      );
    });
    function TabNode(_ref) {
      var _classNames;
      var prefixCls = _ref.prefixCls, id2 = _ref.id, active = _ref.active, _ref$tab = _ref.tab, key = _ref$tab.key, label = _ref$tab.label, disabled = _ref$tab.disabled, closeIcon = _ref$tab.closeIcon, closable = _ref.closable, renderWrapper = _ref.renderWrapper, removeAriaLabel = _ref.removeAriaLabel, editable = _ref.editable, onClick = _ref.onClick, onFocus = _ref.onFocus, style2 = _ref.style;
      var tabPrefix = "".concat(prefixCls, "-tab");
      var removable = editable && closable !== false && !disabled;
      function onInternalClick(e2) {
        if (disabled) {
          return;
        }
        onClick(e2);
      }
      function onRemoveTab(event) {
        event.preventDefault();
        event.stopPropagation();
        editable.onEdit("remove", {
          key,
          event
        });
      }
      var node2 = /* @__PURE__ */ reactExports.createElement("div", {
        key,
        "data-node-key": genDataNodeKey(key),
        className: classNames(tabPrefix, (_classNames = {}, _defineProperty$7(_classNames, "".concat(tabPrefix, "-with-remove"), removable), _defineProperty$7(_classNames, "".concat(tabPrefix, "-active"), active), _defineProperty$7(_classNames, "".concat(tabPrefix, "-disabled"), disabled), _classNames)),
        style: style2,
        onClick: onInternalClick
      }, /* @__PURE__ */ reactExports.createElement("div", {
        role: "tab",
        "aria-selected": active,
        id: id2 && "".concat(id2, "-tab-").concat(key),
        className: "".concat(tabPrefix, "-btn"),
        "aria-controls": id2 && "".concat(id2, "-panel-").concat(key),
        "aria-disabled": disabled,
        tabIndex: disabled ? null : 0,
        onClick: function onClick2(e2) {
          e2.stopPropagation();
          onInternalClick(e2);
        },
        onKeyDown: function onKeyDown2(e2) {
          if ([KeyCode.SPACE, KeyCode.ENTER].includes(e2.which)) {
            e2.preventDefault();
            onInternalClick(e2);
          }
        },
        onFocus
      }, label), removable && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        "aria-label": removeAriaLabel || "remove",
        tabIndex: 0,
        className: "".concat(tabPrefix, "-remove"),
        onClick: function onClick2(e2) {
          e2.stopPropagation();
          onRemoveTab(e2);
        }
      }, closeIcon || editable.removeIcon || "×"));
      return renderWrapper ? renderWrapper(node2) : node2;
    }
    var getSize$1 = function getSize2(refObj) {
      var _ref = refObj.current || {}, _ref$offsetWidth = _ref.offsetWidth, offsetWidth = _ref$offsetWidth === void 0 ? 0 : _ref$offsetWidth, _ref$offsetHeight = _ref.offsetHeight, offsetHeight = _ref$offsetHeight === void 0 ? 0 : _ref$offsetHeight;
      return [offsetWidth, offsetHeight];
    };
    var getUnitValue = function getUnitValue2(size, tabPositionTopOrBottom) {
      return size[tabPositionTopOrBottom ? 0 : 1];
    };
    function TabNavList(props, ref) {
      var _classNames;
      var _React$useContext = reactExports.useContext(TabContext), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
      var className = props.className, style2 = props.style, id2 = props.id, animated = props.animated, activeKey = props.activeKey, rtl = props.rtl, extra = props.extra, editable = props.editable, locale2 = props.locale, tabPosition = props.tabPosition, tabBarGutter = props.tabBarGutter, children = props.children, onTabClick = props.onTabClick, onTabScroll = props.onTabScroll;
      var containerRef = reactExports.useRef();
      var extraLeftRef = reactExports.useRef();
      var extraRightRef = reactExports.useRef();
      var tabsWrapperRef = reactExports.useRef();
      var tabListRef = reactExports.useRef();
      var operationsRef = reactExports.useRef();
      var innerAddButtonRef = reactExports.useRef();
      var tabPositionTopOrBottom = tabPosition === "top" || tabPosition === "bottom";
      var _useSyncState = useSyncState$1(0, function(next2, prev2) {
        if (tabPositionTopOrBottom && onTabScroll) {
          onTabScroll({
            direction: next2 > prev2 ? "left" : "right"
          });
        }
      }), _useSyncState2 = _slicedToArray(_useSyncState, 2), transformLeft = _useSyncState2[0], setTransformLeft = _useSyncState2[1];
      var _useSyncState3 = useSyncState$1(0, function(next2, prev2) {
        if (!tabPositionTopOrBottom && onTabScroll) {
          onTabScroll({
            direction: next2 > prev2 ? "top" : "bottom"
          });
        }
      }), _useSyncState4 = _slicedToArray(_useSyncState3, 2), transformTop = _useSyncState4[0], setTransformTop = _useSyncState4[1];
      var _useState = reactExports.useState([0, 0]), _useState2 = _slicedToArray(_useState, 2), containerExcludeExtraSize = _useState2[0], setContainerExcludeExtraSize = _useState2[1];
      var _useState3 = reactExports.useState([0, 0]), _useState4 = _slicedToArray(_useState3, 2), tabContentSize = _useState4[0], setTabContentSize = _useState4[1];
      var _useState5 = reactExports.useState([0, 0]), _useState6 = _slicedToArray(_useState5, 2), addSize = _useState6[0], setAddSize = _useState6[1];
      var _useState7 = reactExports.useState([0, 0]), _useState8 = _slicedToArray(_useState7, 2), operationSize = _useState8[0], setOperationSize = _useState8[1];
      var _useUpdateState = useUpdateState(/* @__PURE__ */ new Map()), _useUpdateState2 = _slicedToArray(_useUpdateState, 2), tabSizes = _useUpdateState2[0], setTabSizes = _useUpdateState2[1];
      var tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);
      var containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);
      var tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
      var addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
      var operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
      var needScroll = containerExcludeExtraSizeValue < tabContentSizeValue + addSizeValue;
      var visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;
      var operationsHiddenClassName = "".concat(prefixCls, "-nav-operations-hidden");
      var transformMin = 0;
      var transformMax = 0;
      if (!tabPositionTopOrBottom) {
        transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
        transformMax = 0;
      } else if (rtl) {
        transformMin = 0;
        transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
      } else {
        transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
        transformMax = 0;
      }
      function alignInRange(value) {
        if (value < transformMin) {
          return transformMin;
        }
        if (value > transformMax) {
          return transformMax;
        }
        return value;
      }
      var touchMovingRef = reactExports.useRef();
      var _useState9 = reactExports.useState(), _useState10 = _slicedToArray(_useState9, 2), lockAnimation = _useState10[0], setLockAnimation = _useState10[1];
      function doLockAnimation() {
        setLockAnimation(Date.now());
      }
      function clearTouchMoving() {
        window.clearTimeout(touchMovingRef.current);
      }
      useTouchMove(tabsWrapperRef, function(offsetX, offsetY) {
        function doMove(setState, offset2) {
          setState(function(value) {
            var newValue = alignInRange(value + offset2);
            return newValue;
          });
        }
        if (!needScroll) {
          return false;
        }
        if (tabPositionTopOrBottom) {
          doMove(setTransformLeft, offsetX);
        } else {
          doMove(setTransformTop, offsetY);
        }
        clearTouchMoving();
        doLockAnimation();
        return true;
      });
      reactExports.useEffect(function() {
        clearTouchMoving();
        if (lockAnimation) {
          touchMovingRef.current = window.setTimeout(function() {
            setLockAnimation(0);
          }, 100);
        }
        return clearTouchMoving;
      }, [lockAnimation]);
      var _useVisibleRange = useVisibleRange(
        tabOffsets,
        // Container
        visibleTabContentValue,
        // Transform
        tabPositionTopOrBottom ? transformLeft : transformTop,
        // Tabs
        tabContentSizeValue,
        // Add
        addSizeValue,
        // Operation
        operationSizeValue,
        _objectSpread2$3(_objectSpread2$3({}, props), {}, {
          tabs
        })
      ), _useVisibleRange2 = _slicedToArray(_useVisibleRange, 2), visibleStart = _useVisibleRange2[0], visibleEnd = _useVisibleRange2[1];
      var scrollToTab = useEvent(function() {
        var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : activeKey;
        var tabOffset = tabOffsets.get(key) || {
          width: 0,
          height: 0,
          left: 0,
          right: 0,
          top: 0
        };
        if (tabPositionTopOrBottom) {
          var newTransform = transformLeft;
          if (rtl) {
            if (tabOffset.right < transformLeft) {
              newTransform = tabOffset.right;
            } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {
              newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
            }
          } else if (tabOffset.left < -transformLeft) {
            newTransform = -tabOffset.left;
          } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {
            newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
          }
          setTransformTop(0);
          setTransformLeft(alignInRange(newTransform));
        } else {
          var _newTransform = transformTop;
          if (tabOffset.top < -transformTop) {
            _newTransform = -tabOffset.top;
          } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {
            _newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
          }
          setTransformLeft(0);
          setTransformTop(alignInRange(_newTransform));
        }
      });
      var tabNodeStyle = {};
      if (tabPosition === "top" || tabPosition === "bottom") {
        tabNodeStyle[rtl ? "marginRight" : "marginLeft"] = tabBarGutter;
      } else {
        tabNodeStyle.marginTop = tabBarGutter;
      }
      var tabNodes = tabs.map(function(tab, i2) {
        var key = tab.key;
        return /* @__PURE__ */ reactExports.createElement(TabNode, {
          id: id2,
          prefixCls,
          key,
          tab,
          style: i2 === 0 ? void 0 : tabNodeStyle,
          closable: tab.closable,
          editable,
          active: key === activeKey,
          renderWrapper: children,
          removeAriaLabel: locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
          onClick: function onClick(e2) {
            onTabClick(key, e2);
          },
          onFocus: function onFocus() {
            scrollToTab(key);
            doLockAnimation();
            if (!tabsWrapperRef.current) {
              return;
            }
            if (!rtl) {
              tabsWrapperRef.current.scrollLeft = 0;
            }
            tabsWrapperRef.current.scrollTop = 0;
          }
        });
      });
      var updateTabSizes = function updateTabSizes2() {
        return setTabSizes(function() {
          var newSizes = /* @__PURE__ */ new Map();
          tabs.forEach(function(_ref2) {
            var _tabListRef$current;
            var key = _ref2.key;
            var btnNode = (_tabListRef$current = tabListRef.current) === null || _tabListRef$current === void 0 ? void 0 : _tabListRef$current.querySelector('[data-node-key="'.concat(genDataNodeKey(key), '"]'));
            if (btnNode) {
              newSizes.set(key, {
                width: btnNode.offsetWidth,
                height: btnNode.offsetHeight,
                left: btnNode.offsetLeft,
                top: btnNode.offsetTop
              });
            }
          });
          return newSizes;
        });
      };
      reactExports.useEffect(function() {
        updateTabSizes();
      }, [tabs.map(function(tab) {
        return tab.key;
      }).join("_")]);
      var onListHolderResize = useUpdate(function() {
        var containerSize = getSize$1(containerRef);
        var extraLeftSize = getSize$1(extraLeftRef);
        var extraRightSize = getSize$1(extraRightRef);
        setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
        var newAddSize = getSize$1(innerAddButtonRef);
        setAddSize(newAddSize);
        var newOperationSize = getSize$1(operationsRef);
        setOperationSize(newOperationSize);
        var tabContentFullSize = getSize$1(tabListRef);
        setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);
        updateTabSizes();
      });
      var startHiddenTabs = tabs.slice(0, visibleStart);
      var endHiddenTabs = tabs.slice(visibleEnd + 1);
      var hiddenTabs = [].concat(_toConsumableArray(startHiddenTabs), _toConsumableArray(endHiddenTabs));
      var _useState11 = reactExports.useState(), _useState12 = _slicedToArray(_useState11, 2), inkStyle = _useState12[0], setInkStyle = _useState12[1];
      var activeTabOffset = tabOffsets.get(activeKey);
      var inkBarRafRef = reactExports.useRef();
      function cleanInkBarRaf() {
        wrapperRaf.cancel(inkBarRafRef.current);
      }
      reactExports.useEffect(function() {
        var newInkStyle = {};
        if (activeTabOffset) {
          if (tabPositionTopOrBottom) {
            if (rtl) {
              newInkStyle.right = activeTabOffset.right;
            } else {
              newInkStyle.left = activeTabOffset.left;
            }
            newInkStyle.width = activeTabOffset.width;
          } else {
            newInkStyle.top = activeTabOffset.top;
            newInkStyle.height = activeTabOffset.height;
          }
        }
        cleanInkBarRaf();
        inkBarRafRef.current = wrapperRaf(function() {
          setInkStyle(newInkStyle);
        });
        return cleanInkBarRaf;
      }, [activeTabOffset, tabPositionTopOrBottom, rtl]);
      reactExports.useEffect(function() {
        scrollToTab();
      }, [activeKey, transformMin, transformMax, stringify$2(activeTabOffset), stringify$2(tabOffsets), tabPositionTopOrBottom]);
      reactExports.useEffect(function() {
        onListHolderResize();
      }, [rtl]);
      var hasDropdown = !!hiddenTabs.length;
      var wrapPrefix = "".concat(prefixCls, "-nav-wrap");
      var pingLeft;
      var pingRight;
      var pingTop;
      var pingBottom;
      if (tabPositionTopOrBottom) {
        if (rtl) {
          pingRight = transformLeft > 0;
          pingLeft = transformLeft !== transformMax;
        } else {
          pingLeft = transformLeft < 0;
          pingRight = transformLeft !== transformMin;
        }
      } else {
        pingTop = transformTop < 0;
        pingBottom = transformTop !== transformMin;
      }
      return /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onListHolderResize
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: useComposeRef(ref, containerRef),
        role: "tablist",
        className: classNames("".concat(prefixCls, "-nav"), className),
        style: style2,
        onKeyDown: function onKeyDown2() {
          doLockAnimation();
        }
      }, /* @__PURE__ */ reactExports.createElement(ExtraContent, {
        ref: extraLeftRef,
        position: "left",
        extra,
        prefixCls
      }), /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(wrapPrefix, (_classNames = {}, _defineProperty$7(_classNames, "".concat(wrapPrefix, "-ping-left"), pingLeft), _defineProperty$7(_classNames, "".concat(wrapPrefix, "-ping-right"), pingRight), _defineProperty$7(_classNames, "".concat(wrapPrefix, "-ping-top"), pingTop), _defineProperty$7(_classNames, "".concat(wrapPrefix, "-ping-bottom"), pingBottom), _classNames)),
        ref: tabsWrapperRef
      }, /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onListHolderResize
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: tabListRef,
        className: "".concat(prefixCls, "-nav-list"),
        style: {
          transform: "translate(".concat(transformLeft, "px, ").concat(transformTop, "px)"),
          transition: lockAnimation ? "none" : void 0
        }
      }, tabNodes, /* @__PURE__ */ reactExports.createElement(AddButton$1, {
        ref: innerAddButtonRef,
        prefixCls,
        locale: locale2,
        editable,
        style: _objectSpread2$3(_objectSpread2$3({}, tabNodes.length === 0 ? void 0 : tabNodeStyle), {}, {
          visibility: hasDropdown ? "hidden" : null
        })
      }), /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-ink-bar"), _defineProperty$7({}, "".concat(prefixCls, "-ink-bar-animated"), animated.inkBar)),
        style: inkStyle
      })))), /* @__PURE__ */ reactExports.createElement(OperationNode$1, _extends$2({}, props, {
        removeAriaLabel: locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
        ref: operationsRef,
        prefixCls,
        tabs: hiddenTabs,
        className: !hasDropdown && operationsHiddenClassName,
        tabMoving: !!lockAnimation
      })), /* @__PURE__ */ reactExports.createElement(ExtraContent, {
        ref: extraRightRef,
        position: "right",
        extra,
        prefixCls
      })));
    }
    const TabNavList$1 = /* @__PURE__ */ reactExports.forwardRef(TabNavList);
    var _excluded$l = ["renderTabBar"], _excluded2$1 = ["label", "key"];
    function TabNavListWrapper(_ref) {
      var renderTabBar = _ref.renderTabBar, restProps = _objectWithoutProperties$1(_ref, _excluded$l);
      var _React$useContext = reactExports.useContext(TabContext), tabs = _React$useContext.tabs;
      if (renderTabBar) {
        var tabNavBarProps = _objectSpread2$3(_objectSpread2$3({}, restProps), {}, {
          // Legacy support. We do not use this actually
          panes: tabs.map(function(_ref2) {
            var label = _ref2.label, key = _ref2.key, restTabProps = _objectWithoutProperties$1(_ref2, _excluded2$1);
            return /* @__PURE__ */ reactExports.createElement(TabPane$2, _extends$2({
              tab: label,
              key,
              tabKey: key
            }, restTabProps));
          })
        });
        return renderTabBar(tabNavBarProps, TabNavList$1);
      }
      return /* @__PURE__ */ reactExports.createElement(TabNavList$1, restProps);
    }
    function useAnimateConfig$1() {
      var animated = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        inkBar: true,
        tabPane: false
      };
      var mergedAnimated;
      if (animated === false) {
        mergedAnimated = {
          inkBar: false,
          tabPane: false
        };
      } else if (animated === true) {
        mergedAnimated = {
          inkBar: true,
          tabPane: false
        };
      } else {
        mergedAnimated = _objectSpread2$3({
          inkBar: true
        }, _typeof$4(animated) === "object" ? animated : {});
      }
      if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === void 0) {
        mergedAnimated.tabPane = true;
      }
      if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {
        mergedAnimated.tabPane = false;
      }
      return mergedAnimated;
    }
    var _excluded$k = ["id", "prefixCls", "className", "items", "direction", "activeKey", "defaultActiveKey", "editable", "animated", "tabPosition", "tabBarGutter", "tabBarStyle", "tabBarExtraContent", "locale", "moreIcon", "moreTransitionName", "destroyInactiveTabPane", "renderTabBar", "onChange", "onTabClick", "onTabScroll", "getPopupContainer", "popupClassName"];
    var uuid$1 = 0;
    function Tabs$1(_ref, ref) {
      var _classNames;
      var id2 = _ref.id, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-tabs" : _ref$prefixCls, className = _ref.className, items = _ref.items, direction = _ref.direction, activeKey = _ref.activeKey, defaultActiveKey = _ref.defaultActiveKey, editable = _ref.editable, animated = _ref.animated, _ref$tabPosition = _ref.tabPosition, tabPosition = _ref$tabPosition === void 0 ? "top" : _ref$tabPosition, tabBarGutter = _ref.tabBarGutter, tabBarStyle = _ref.tabBarStyle, tabBarExtraContent = _ref.tabBarExtraContent, locale2 = _ref.locale, moreIcon = _ref.moreIcon, moreTransitionName = _ref.moreTransitionName, destroyInactiveTabPane = _ref.destroyInactiveTabPane, renderTabBar = _ref.renderTabBar, onChange = _ref.onChange, onTabClick = _ref.onTabClick, onTabScroll = _ref.onTabScroll, getPopupContainer = _ref.getPopupContainer, popupClassName = _ref.popupClassName, restProps = _objectWithoutProperties$1(_ref, _excluded$k);
      var tabs = reactExports.useMemo(function() {
        return (items || []).filter(function(item) {
          return item && _typeof$4(item) === "object" && "key" in item;
        });
      }, [items]);
      var rtl = direction === "rtl";
      var mergedAnimated = useAnimateConfig$1(animated);
      var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
      reactExports.useEffect(function() {
        setMobile(isMobile());
      }, []);
      var _useMergedState = useMergedState(function() {
        var _tabs$;
        return (_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key;
      }, {
        value: activeKey,
        defaultValue: defaultActiveKey
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedActiveKey = _useMergedState2[0], setMergedActiveKey = _useMergedState2[1];
      var _useState3 = reactExports.useState(function() {
        return tabs.findIndex(function(tab) {
          return tab.key === mergedActiveKey;
        });
      }), _useState4 = _slicedToArray(_useState3, 2), activeIndex = _useState4[0], setActiveIndex = _useState4[1];
      reactExports.useEffect(function() {
        var newActiveIndex = tabs.findIndex(function(tab) {
          return tab.key === mergedActiveKey;
        });
        if (newActiveIndex === -1) {
          var _tabs$newActiveIndex;
          newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
          setMergedActiveKey((_tabs$newActiveIndex = tabs[newActiveIndex]) === null || _tabs$newActiveIndex === void 0 ? void 0 : _tabs$newActiveIndex.key);
        }
        setActiveIndex(newActiveIndex);
      }, [tabs.map(function(tab) {
        return tab.key;
      }).join("_"), mergedActiveKey, activeIndex]);
      var _useMergedState3 = useMergedState(null, {
        value: id2
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedId = _useMergedState4[0], setMergedId = _useMergedState4[1];
      reactExports.useEffect(function() {
        if (!id2) {
          setMergedId("rc-tabs-".concat(uuid$1));
          uuid$1 += 1;
        }
      }, []);
      function onInternalTabClick(key, e2) {
        onTabClick === null || onTabClick === void 0 ? void 0 : onTabClick(key, e2);
        var isActiveChanged = key !== mergedActiveKey;
        setMergedActiveKey(key);
        if (isActiveChanged) {
          onChange === null || onChange === void 0 ? void 0 : onChange(key);
        }
      }
      var sharedProps = {
        id: mergedId,
        activeKey: mergedActiveKey,
        animated: mergedAnimated,
        tabPosition,
        rtl,
        mobile
      };
      var tabNavBar;
      var tabNavBarProps = _objectSpread2$3(_objectSpread2$3({}, sharedProps), {}, {
        editable,
        locale: locale2,
        moreIcon,
        moreTransitionName,
        tabBarGutter,
        onTabClick: onInternalTabClick,
        onTabScroll,
        extra: tabBarExtraContent,
        style: tabBarStyle,
        panes: null,
        getPopupContainer,
        popupClassName
      });
      return /* @__PURE__ */ reactExports.createElement(TabContext.Provider, {
        value: {
          tabs,
          prefixCls
        }
      }, /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        ref,
        id: id2,
        className: classNames(prefixCls, "".concat(prefixCls, "-").concat(tabPosition), (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-mobile"), mobile), _defineProperty$7(_classNames, "".concat(prefixCls, "-editable"), editable), _defineProperty$7(_classNames, "".concat(prefixCls, "-rtl"), rtl), _classNames), className)
      }, restProps), tabNavBar, /* @__PURE__ */ reactExports.createElement(TabNavListWrapper, _extends$2({}, tabNavBarProps, {
        renderTabBar
      })), /* @__PURE__ */ reactExports.createElement(TabPanelList, _extends$2({
        destroyInactiveTabPane
      }, sharedProps, {
        animated: mergedAnimated
      }))));
    }
    var ForwardTabs = /* @__PURE__ */ reactExports.forwardRef(Tabs$1);
    const motion = {
      motionAppear: false,
      motionEnter: true,
      motionLeave: true
    };
    function useAnimateConfig(prefixCls) {
      let animated = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        inkBar: true,
        tabPane: false
      };
      let mergedAnimated;
      if (animated === false) {
        mergedAnimated = {
          inkBar: false,
          tabPane: false
        };
      } else if (animated === true) {
        mergedAnimated = {
          inkBar: true,
          tabPane: true
        };
      } else {
        mergedAnimated = Object.assign({
          inkBar: true
        }, typeof animated === "object" ? animated : {});
      }
      if (mergedAnimated.tabPane) {
        mergedAnimated.tabPaneMotion = Object.assign(Object.assign({}, motion), {
          motionName: getTransitionName$1(prefixCls, "switch")
        });
      }
      return mergedAnimated;
    }
    var __rest$E = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function filter(items) {
      return items.filter((item) => item);
    }
    function useLegacyItems(items, children) {
      if (items) {
        return items;
      }
      const childrenItems = toArray$8(children).map((node2) => {
        if (/* @__PURE__ */ reactExports.isValidElement(node2)) {
          const {
            key,
            props
          } = node2;
          const _a = props || {}, {
            tab
          } = _a, restProps = __rest$E(_a, ["tab"]);
          const item = Object.assign(Object.assign({
            key: String(key)
          }, restProps), {
            label: tab
          });
          return item;
        }
        return null;
      });
      return filter(childrenItems);
    }
    const TabPane = () => null;
    const TabPane$1 = TabPane;
    const genMotionStyle$4 = (token2) => {
      const {
        componentCls,
        motionDurationSlow
      } = token2;
      return [
        {
          [componentCls]: {
            [`${componentCls}-switch`]: {
              "&-appear, &-enter": {
                transition: "none",
                "&-start": {
                  opacity: 0
                },
                "&-active": {
                  opacity: 1,
                  transition: `opacity ${motionDurationSlow}`
                }
              },
              "&-leave": {
                position: "absolute",
                transition: "none",
                inset: 0,
                "&-start": {
                  opacity: 1
                },
                "&-active": {
                  opacity: 0,
                  transition: `opacity ${motionDurationSlow}`
                }
              }
            }
          }
        },
        // Follow code may reuse in other components
        [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down")]
      ];
    };
    const genMotionStyle$5 = genMotionStyle$4;
    const genCardStyle$1 = (token2) => {
      const {
        componentCls,
        tabsCardHorizontalPadding,
        tabsCardHeadBackground,
        tabsCardGutter,
        colorSplit
      } = token2;
      return {
        [`${componentCls}-card`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              margin: 0,
              padding: tabsCardHorizontalPadding,
              background: tabsCardHeadBackground,
              border: `${token2.lineWidth}px ${token2.lineType} ${colorSplit}`,
              transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
            },
            [`${componentCls}-tab-active`]: {
              color: token2.colorPrimary,
              background: token2.colorBgContainer
            },
            [`${componentCls}-ink-bar`]: {
              visibility: "hidden"
            }
          },
          // ========================== Top & Bottom ==========================
          [`&${componentCls}-top, &${componentCls}-bottom`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab + ${componentCls}-tab`]: {
                marginLeft: {
                  _skip_check_: true,
                  value: `${tabsCardGutter}px`
                }
              }
            }
          },
          [`&${componentCls}-top`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`
              },
              [`${componentCls}-tab-active`]: {
                borderBottomColor: token2.colorBgContainer
              }
            }
          },
          [`&${componentCls}-bottom`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`
              },
              [`${componentCls}-tab-active`]: {
                borderTopColor: token2.colorBgContainer
              }
            }
          },
          // ========================== Left & Right ==========================
          [`&${componentCls}-left, &${componentCls}-right`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab + ${componentCls}-tab`]: {
                marginTop: `${tabsCardGutter}px`
              }
            }
          },
          [`&${componentCls}-left`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                borderRadius: {
                  _skip_check_: true,
                  value: `${token2.borderRadiusLG}px 0 0 ${token2.borderRadiusLG}px`
                }
              },
              [`${componentCls}-tab-active`]: {
                borderRightColor: {
                  _skip_check_: true,
                  value: token2.colorBgContainer
                }
              }
            }
          },
          [`&${componentCls}-right`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                borderRadius: {
                  _skip_check_: true,
                  value: `0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0`
                }
              },
              [`${componentCls}-tab-active`]: {
                borderLeftColor: {
                  _skip_check_: true,
                  value: token2.colorBgContainer
                }
              }
            }
          }
        }
      };
    };
    const genDropdownStyle = (token2) => {
      const {
        componentCls,
        tabsHoverColor,
        dropdownEdgeChildVerticalPadding
      } = token2;
      return {
        [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
          position: "absolute",
          top: -9999,
          left: {
            _skip_check_: true,
            value: -9999
          },
          zIndex: token2.zIndexPopup,
          display: "block",
          "&-hidden": {
            display: "none"
          },
          [`${componentCls}-dropdown-menu`]: {
            maxHeight: token2.tabsDropdownHeight,
            margin: 0,
            padding: `${dropdownEdgeChildVerticalPadding}px 0`,
            overflowX: "hidden",
            overflowY: "auto",
            textAlign: {
              _skip_check_: true,
              value: "left"
            },
            listStyleType: "none",
            backgroundColor: token2.colorBgContainer,
            backgroundClip: "padding-box",
            borderRadius: token2.borderRadiusLG,
            outline: "none",
            boxShadow: token2.boxShadowSecondary,
            "&-item": Object.assign(Object.assign({}, textEllipsis), {
              display: "flex",
              alignItems: "center",
              minWidth: token2.tabsDropdownWidth,
              margin: 0,
              padding: `${token2.paddingXXS}px ${token2.paddingSM}px`,
              color: token2.colorText,
              fontWeight: "normal",
              fontSize: token2.fontSize,
              lineHeight: token2.lineHeight,
              cursor: "pointer",
              transition: `all ${token2.motionDurationSlow}`,
              "> span": {
                flex: 1,
                whiteSpace: "nowrap"
              },
              "&-remove": {
                flex: "none",
                marginLeft: {
                  _skip_check_: true,
                  value: token2.marginSM
                },
                color: token2.colorTextDescription,
                fontSize: token2.fontSizeSM,
                background: "transparent",
                border: 0,
                cursor: "pointer",
                "&:hover": {
                  color: tabsHoverColor
                }
              },
              "&:hover": {
                background: token2.controlItemBgHover
              },
              "&-disabled": {
                "&, &:hover": {
                  color: token2.colorTextDisabled,
                  background: "transparent",
                  cursor: "not-allowed"
                }
              }
            })
          }
        })
      };
    };
    const genPositionStyle = (token2) => {
      const {
        componentCls,
        margin,
        colorSplit
      } = token2;
      return {
        // ========================== Top & Bottom ==========================
        [`${componentCls}-top, ${componentCls}-bottom`]: {
          flexDirection: "column",
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            margin: `0 0 ${margin}px 0`,
            "&::before": {
              position: "absolute",
              right: {
                _skip_check_: true,
                value: 0
              },
              left: {
                _skip_check_: true,
                value: 0
              },
              borderBottom: `${token2.lineWidth}px ${token2.lineType} ${colorSplit}`,
              content: "''"
            },
            [`${componentCls}-ink-bar`]: {
              height: token2.lineWidthBold,
              "&-animated": {
                transition: `width ${token2.motionDurationSlow}, left ${token2.motionDurationSlow},
            right ${token2.motionDurationSlow}`
              }
            },
            [`${componentCls}-nav-wrap`]: {
              "&::before, &::after": {
                top: 0,
                bottom: 0,
                width: token2.controlHeight
              },
              "&::before": {
                left: {
                  _skip_check_: true,
                  value: 0
                },
                boxShadow: token2.boxShadowTabsOverflowLeft
              },
              "&::after": {
                right: {
                  _skip_check_: true,
                  value: 0
                },
                boxShadow: token2.boxShadowTabsOverflowRight
              },
              [`&${componentCls}-nav-wrap-ping-left::before`]: {
                opacity: 1
              },
              [`&${componentCls}-nav-wrap-ping-right::after`]: {
                opacity: 1
              }
            }
          }
        },
        [`${componentCls}-top`]: {
          [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
            "&::before": {
              bottom: 0
            },
            [`${componentCls}-ink-bar`]: {
              bottom: 0
            }
          }
        },
        [`${componentCls}-bottom`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            order: 1,
            marginTop: `${margin}px`,
            marginBottom: 0,
            "&::before": {
              top: 0
            },
            [`${componentCls}-ink-bar`]: {
              top: 0
            }
          },
          [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
            order: 0
          }
        },
        // ========================== Left & Right ==========================
        [`${componentCls}-left, ${componentCls}-right`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            flexDirection: "column",
            minWidth: token2.controlHeight * 1.25,
            // >>>>>>>>>>> Tab
            [`${componentCls}-tab`]: {
              padding: `${token2.paddingXS}px ${token2.paddingLG}px`,
              textAlign: "center"
            },
            [`${componentCls}-tab + ${componentCls}-tab`]: {
              margin: `${token2.margin}px 0 0 0`
            },
            // >>>>>>>>>>> Nav
            [`${componentCls}-nav-wrap`]: {
              flexDirection: "column",
              "&::before, &::after": {
                right: {
                  _skip_check_: true,
                  value: 0
                },
                left: {
                  _skip_check_: true,
                  value: 0
                },
                height: token2.controlHeight
              },
              "&::before": {
                top: 0,
                boxShadow: token2.boxShadowTabsOverflowTop
              },
              "&::after": {
                bottom: 0,
                boxShadow: token2.boxShadowTabsOverflowBottom
              },
              [`&${componentCls}-nav-wrap-ping-top::before`]: {
                opacity: 1
              },
              [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
                opacity: 1
              }
            },
            // >>>>>>>>>>> Ink Bar
            [`${componentCls}-ink-bar`]: {
              width: token2.lineWidthBold,
              "&-animated": {
                transition: `height ${token2.motionDurationSlow}, top ${token2.motionDurationSlow}`
              }
            },
            [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
              flex: "1 0 auto",
              flexDirection: "column"
            }
          }
        },
        [`${componentCls}-left`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-ink-bar`]: {
              right: {
                _skip_check_: true,
                value: 0
              }
            }
          },
          [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
            marginLeft: {
              _skip_check_: true,
              value: `-${token2.lineWidth}px`
            },
            borderLeft: {
              _skip_check_: true,
              value: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
            },
            [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
              paddingLeft: {
                _skip_check_: true,
                value: token2.paddingLG
              }
            }
          }
        },
        [`${componentCls}-right`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            order: 1,
            [`${componentCls}-ink-bar`]: {
              left: {
                _skip_check_: true,
                value: 0
              }
            }
          },
          [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
            order: 0,
            marginRight: {
              _skip_check_: true,
              value: -token2.lineWidth
            },
            borderRight: {
              _skip_check_: true,
              value: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
            },
            [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
              paddingRight: {
                _skip_check_: true,
                value: token2.paddingLG
              }
            }
          }
        }
      };
    };
    const genSizeStyle$2 = (token2) => {
      const {
        componentCls,
        padding
      } = token2;
      return {
        [componentCls]: {
          "&-small": {
            [`> ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                padding: `${token2.paddingXS}px 0`,
                fontSize: token2.fontSize
              }
            }
          },
          "&-large": {
            [`> ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                padding: `${padding}px 0`,
                fontSize: token2.fontSizeLG
              }
            }
          }
        },
        [`${componentCls}-card`]: {
          [`&${componentCls}-small`]: {
            [`> ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                padding: `${token2.paddingXXS * 1.5}px ${padding}px`
              }
            },
            [`&${componentCls}-bottom`]: {
              [`> ${componentCls}-nav ${componentCls}-tab`]: {
                borderRadius: `0 0 ${token2.borderRadius}px ${token2.borderRadius}px`
              }
            },
            [`&${componentCls}-top`]: {
              [`> ${componentCls}-nav ${componentCls}-tab`]: {
                borderRadius: `${token2.borderRadius}px ${token2.borderRadius}px 0 0`
              }
            },
            [`&${componentCls}-right`]: {
              [`> ${componentCls}-nav ${componentCls}-tab`]: {
                borderRadius: {
                  _skip_check_: true,
                  value: `0 ${token2.borderRadius}px ${token2.borderRadius}px 0`
                }
              }
            },
            [`&${componentCls}-left`]: {
              [`> ${componentCls}-nav ${componentCls}-tab`]: {
                borderRadius: {
                  _skip_check_: true,
                  value: `${token2.borderRadius}px 0 0 ${token2.borderRadius}px`
                }
              }
            }
          },
          [`&${componentCls}-large`]: {
            [`> ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                padding: `${token2.paddingXS}px ${padding}px ${token2.paddingXXS * 1.5}px`
              }
            }
          }
        }
      };
    };
    const genTabStyle = (token2) => {
      const {
        componentCls,
        tabsActiveColor,
        tabsHoverColor,
        iconCls,
        tabsHorizontalGutter
      } = token2;
      const tabCls = `${componentCls}-tab`;
      return {
        [tabCls]: {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          padding: `${token2.paddingSM}px 0`,
          fontSize: `${token2.fontSize}px`,
          background: "transparent",
          border: 0,
          outline: "none",
          cursor: "pointer",
          "&-btn, &-remove": Object.assign({
            "&:focus:not(:focus-visible), &:active": {
              color: tabsActiveColor
            }
          }, genFocusStyle(token2)),
          "&-btn": {
            outline: "none",
            transition: "all 0.3s"
          },
          "&-remove": {
            flex: "none",
            marginRight: {
              _skip_check_: true,
              value: -token2.marginXXS
            },
            marginLeft: {
              _skip_check_: true,
              value: token2.marginXS
            },
            color: token2.colorTextDescription,
            fontSize: token2.fontSizeSM,
            background: "transparent",
            border: "none",
            outline: "none",
            cursor: "pointer",
            transition: `all ${token2.motionDurationSlow}`,
            "&:hover": {
              color: token2.colorTextHeading
            }
          },
          "&:hover": {
            color: tabsHoverColor
          },
          [`&${tabCls}-active ${tabCls}-btn`]: {
            color: token2.colorPrimary,
            textShadow: token2.tabsActiveTextShadow
          },
          [`&${tabCls}-disabled`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed"
          },
          [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
            "&:focus, &:active": {
              color: token2.colorTextDisabled
            }
          },
          [`& ${tabCls}-remove ${iconCls}`]: {
            margin: 0
          },
          [iconCls]: {
            marginRight: {
              _skip_check_: true,
              value: token2.marginSM
            }
          }
        },
        [`${tabCls} + ${tabCls}`]: {
          margin: {
            _skip_check_: true,
            value: `0 0 0 ${tabsHorizontalGutter}px`
          }
        }
      };
    };
    const genRtlStyle$3 = (token2) => {
      const {
        componentCls,
        tabsHorizontalGutter,
        iconCls,
        tabsCardGutter
      } = token2;
      const rtlCls = `${componentCls}-rtl`;
      return {
        [rtlCls]: {
          direction: "rtl",
          [`${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              margin: {
                _skip_check_: true,
                value: `0 0 0 ${tabsHorizontalGutter}px`
              },
              [`${componentCls}-tab:last-of-type`]: {
                marginLeft: {
                  _skip_check_: true,
                  value: 0
                }
              },
              [iconCls]: {
                marginRight: {
                  _skip_check_: true,
                  value: 0
                },
                marginLeft: {
                  _skip_check_: true,
                  value: `${token2.marginSM}px`
                }
              },
              [`${componentCls}-tab-remove`]: {
                marginRight: {
                  _skip_check_: true,
                  value: `${token2.marginXS}px`
                },
                marginLeft: {
                  _skip_check_: true,
                  value: `-${token2.marginXXS}px`
                },
                [iconCls]: {
                  margin: 0
                }
              }
            }
          },
          [`&${componentCls}-left`]: {
            [`> ${componentCls}-nav`]: {
              order: 1
            },
            [`> ${componentCls}-content-holder`]: {
              order: 0
            }
          },
          [`&${componentCls}-right`]: {
            [`> ${componentCls}-nav`]: {
              order: 0
            },
            [`> ${componentCls}-content-holder`]: {
              order: 1
            }
          },
          // ====================== Card ======================
          [`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab + ${componentCls}-tab`]: {
                marginRight: {
                  _skip_check_: true,
                  value: `${tabsCardGutter}px`
                },
                marginLeft: {
                  _skip_check_: true,
                  value: 0
                }
              }
            }
          }
        },
        [`${componentCls}-dropdown-rtl`]: {
          direction: "rtl"
        },
        [`${componentCls}-menu-item`]: {
          [`${componentCls}-dropdown-rtl`]: {
            textAlign: {
              _skip_check_: true,
              value: "right"
            }
          }
        }
      };
    };
    const genTabsStyle = (token2) => {
      const {
        componentCls,
        tabsCardHorizontalPadding,
        tabsCardHeight,
        tabsCardGutter,
        tabsHoverColor,
        tabsActiveColor,
        colorSplit
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), {
          display: "flex",
          // ========================== Navigation ==========================
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            position: "relative",
            display: "flex",
            flex: "none",
            alignItems: "center",
            [`${componentCls}-nav-wrap`]: {
              position: "relative",
              display: "flex",
              flex: "auto",
              alignSelf: "stretch",
              overflow: "hidden",
              whiteSpace: "nowrap",
              transform: "translate(0)",
              // >>>>> Ping shadow
              "&::before, &::after": {
                position: "absolute",
                zIndex: 1,
                opacity: 0,
                transition: `opacity ${token2.motionDurationSlow}`,
                content: "''",
                pointerEvents: "none"
              }
            },
            [`${componentCls}-nav-list`]: {
              position: "relative",
              display: "flex",
              transition: `opacity ${token2.motionDurationSlow}`
            },
            // >>>>>>>> Operations
            [`${componentCls}-nav-operations`]: {
              display: "flex",
              alignSelf: "stretch"
            },
            [`${componentCls}-nav-operations-hidden`]: {
              position: "absolute",
              visibility: "hidden",
              pointerEvents: "none"
            },
            [`${componentCls}-nav-more`]: {
              position: "relative",
              padding: tabsCardHorizontalPadding,
              background: "transparent",
              border: 0,
              "&::after": {
                position: "absolute",
                right: {
                  _skip_check_: true,
                  value: 0
                },
                bottom: 0,
                left: {
                  _skip_check_: true,
                  value: 0
                },
                height: token2.controlHeightLG / 8,
                transform: "translateY(100%)",
                content: "''"
              }
            },
            [`${componentCls}-nav-add`]: Object.assign({
              minWidth: `${tabsCardHeight}px`,
              marginLeft: {
                _skip_check_: true,
                value: `${tabsCardGutter}px`
              },
              padding: `0 ${token2.paddingXS}px`,
              background: "transparent",
              border: `${token2.lineWidth}px ${token2.lineType} ${colorSplit}`,
              borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`,
              outline: "none",
              cursor: "pointer",
              color: token2.colorText,
              transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
              "&:hover": {
                color: tabsHoverColor
              },
              "&:active, &:focus:not(:focus-visible)": {
                color: tabsActiveColor
              }
            }, genFocusStyle(token2))
          },
          [`${componentCls}-extra-content`]: {
            flex: "none"
          },
          // ============================ InkBar ============================
          [`${componentCls}-ink-bar`]: {
            position: "absolute",
            background: token2.colorPrimary,
            pointerEvents: "none"
          }
        }), genTabStyle(token2)), {
          // =========================== TabPanes ===========================
          [`${componentCls}-content`]: {
            position: "relative",
            width: "100%"
          },
          [`${componentCls}-content-holder`]: {
            flex: "auto",
            minWidth: 0,
            minHeight: 0
          },
          [`${componentCls}-tabpane`]: {
            outline: "none",
            "&-hidden": {
              display: "none"
            }
          }
        }),
        [`${componentCls}-centered`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-nav-wrap`]: {
              [`&:not([class*='${componentCls}-nav-wrap-ping'])`]: {
                justifyContent: "center"
              }
            }
          }
        }
      };
    };
    const useStyle$i = genComponentStyleHook("Tabs", (token2) => {
      const tabsCardHeight = token2.controlHeightLG;
      const tabsToken = merge$4(token2, {
        tabsHoverColor: token2.colorPrimaryHover,
        tabsActiveColor: token2.colorPrimaryActive,
        tabsCardHorizontalPadding: `${(tabsCardHeight - Math.round(token2.fontSize * token2.lineHeight)) / 2 - token2.lineWidth}px ${token2.padding}px`,
        tabsCardHeight,
        tabsCardGutter: token2.marginXXS / 2,
        tabsHorizontalGutter: 32,
        tabsCardHeadBackground: token2.colorFillAlter,
        dropdownEdgeChildVerticalPadding: token2.paddingXXS,
        tabsActiveTextShadow: "0 0 0.25px currentcolor",
        tabsDropdownHeight: 200,
        tabsDropdownWidth: 120
      });
      return [genSizeStyle$2(tabsToken), genRtlStyle$3(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle$1(tabsToken), genTabsStyle(tabsToken), genMotionStyle$5(tabsToken)];
    }, (token2) => ({
      zIndexPopup: token2.zIndexPopupBase + 50
    }));
    var __rest$D = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function Tabs(_a) {
      var {
        type: type2,
        className,
        rootClassName,
        size: propSize,
        onEdit,
        hideAdd,
        centered,
        addIcon,
        popupClassName,
        children,
        items,
        animated
      } = _a, props = __rest$D(_a, ["type", "className", "rootClassName", "size", "onEdit", "hideAdd", "centered", "addIcon", "popupClassName", "children", "items", "animated"]);
      const {
        prefixCls: customizePrefixCls,
        moreIcon = /* @__PURE__ */ reactExports.createElement(EllipsisOutlined$1, null)
      } = props;
      const {
        direction,
        getPrefixCls,
        getPopupContainer
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("tabs", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$i(prefixCls);
      let editable;
      if (type2 === "editable-card") {
        editable = {
          onEdit: (editType, _ref) => {
            let {
              key,
              event
            } = _ref;
            onEdit === null || onEdit === void 0 ? void 0 : onEdit(editType === "add" ? event : key, editType);
          },
          removeIcon: /* @__PURE__ */ reactExports.createElement(CloseOutlined$1, null),
          addIcon: addIcon || /* @__PURE__ */ reactExports.createElement(PlusOutlined$1, null),
          showAdd: hideAdd !== true
        };
      }
      const rootPrefixCls = getPrefixCls();
      const mergedItems = useLegacyItems(items, children);
      const mergedAnimated = useAnimateConfig(prefixCls, animated);
      const contextSize = reactExports.useContext(SizeContext$2);
      const size = propSize !== void 0 ? propSize : contextSize;
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(ForwardTabs, Object.assign({
        direction,
        getPopupContainer,
        moreTransitionName: `${rootPrefixCls}-slide-up`
      }, props, {
        items: mergedItems,
        className: classNames({
          [`${prefixCls}-${size}`]: size,
          [`${prefixCls}-card`]: ["card", "editable-card"].includes(type2),
          [`${prefixCls}-editable-card`]: type2 === "editable-card",
          [`${prefixCls}-centered`]: centered
        }, className, rootClassName, hashId),
        popupClassName: classNames(popupClassName, hashId),
        editable,
        moreIcon,
        prefixCls,
        animated: mergedAnimated
      })));
    }
    Tabs.TabPane = TabPane$1;
    var __rest$C = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Grid$1 = (_a) => {
      var {
        prefixCls,
        className,
        hoverable = true
      } = _a, props = __rest$C(_a, ["prefixCls", "className", "hoverable"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefix = getPrefixCls("card", prefixCls);
      const classString = classNames(`${prefix}-grid`, className, {
        [`${prefix}-grid-hoverable`]: hoverable
      });
      return /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, props, {
        className: classString
      }));
    };
    const Grid$2 = Grid$1;
    const genCardHeadStyle = (token2) => {
      const {
        antCls,
        componentCls,
        cardHeadHeight,
        cardPaddingBase,
        cardHeadTabsMarginBottom
      } = token2;
      return Object.assign(Object.assign({
        display: "flex",
        justifyContent: "center",
        flexDirection: "column",
        minHeight: cardHeadHeight,
        marginBottom: -1,
        padding: `0 ${cardPaddingBase}px`,
        color: token2.colorTextHeading,
        fontWeight: token2.fontWeightStrong,
        fontSize: token2.fontSizeLG,
        background: "transparent",
        borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorderSecondary}`,
        borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`
      }, clearFix()), {
        "&-wrapper": {
          width: "100%",
          display: "flex",
          alignItems: "center"
        },
        "&-title": Object.assign(Object.assign({
          display: "inline-block",
          flex: 1
        }, textEllipsis), {
          [`
          > ${componentCls}-typography,
          > ${componentCls}-typography-edit-content
        `]: {
            insetInlineStart: 0,
            marginTop: 0,
            marginBottom: 0
          }
        }),
        [`${antCls}-tabs-top`]: {
          clear: "both",
          marginBottom: cardHeadTabsMarginBottom,
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.fontSize,
          "&-bar": {
            borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorderSecondary}`
          }
        }
      });
    };
    const genCardGridStyle = (token2) => {
      const {
        cardPaddingBase,
        colorBorderSecondary,
        cardShadow,
        lineWidth
      } = token2;
      return {
        width: "33.33%",
        padding: cardPaddingBase,
        border: 0,
        borderRadius: 0,
        boxShadow: `
      ${lineWidth}px 0 0 0 ${colorBorderSecondary},
      0 ${lineWidth}px 0 0 ${colorBorderSecondary},
      ${lineWidth}px ${lineWidth}px 0 0 ${colorBorderSecondary},
      ${lineWidth}px 0 0 0 ${colorBorderSecondary} inset,
      0 ${lineWidth}px 0 0 ${colorBorderSecondary} inset;
    `,
        transition: `all ${token2.motionDurationMid}`,
        "&-hoverable:hover": {
          position: "relative",
          zIndex: 1,
          boxShadow: cardShadow
        }
      };
    };
    const genCardActionsStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        cardActionsLiMargin,
        cardActionsIconSize,
        colorBorderSecondary
      } = token2;
      return Object.assign(Object.assign({
        margin: 0,
        padding: 0,
        listStyle: "none",
        background: token2.colorBgContainer,
        borderTop: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
        display: "flex",
        borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px `
      }, clearFix()), {
        "& > li": {
          margin: cardActionsLiMargin,
          color: token2.colorTextDescription,
          textAlign: "center",
          "> span": {
            position: "relative",
            display: "block",
            minWidth: token2.cardActionsIconSize * 2,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            cursor: "pointer",
            "&:hover": {
              color: token2.colorPrimary,
              transition: `color ${token2.motionDurationMid}`
            },
            [`a:not(${componentCls}-btn), > ${iconCls}`]: {
              display: "inline-block",
              width: "100%",
              color: token2.colorTextDescription,
              lineHeight: `${token2.fontSize * token2.lineHeight}px`,
              transition: `color ${token2.motionDurationMid}`,
              "&:hover": {
                color: token2.colorPrimary
              }
            },
            [`> ${iconCls}`]: {
              fontSize: cardActionsIconSize,
              lineHeight: `${cardActionsIconSize * token2.lineHeight}px`
            }
          },
          "&:not(:last-child)": {
            borderInlineEnd: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`
          }
        }
      });
    };
    const genCardMetaStyle = (token2) => Object.assign(Object.assign({
      margin: `-${token2.marginXXS}px 0`,
      display: "flex"
    }, clearFix()), {
      "&-avatar": {
        paddingInlineEnd: token2.padding
      },
      "&-detail": {
        overflow: "hidden",
        flex: 1,
        "> div:not(:last-child)": {
          marginBottom: token2.marginXS
        }
      },
      "&-title": Object.assign({
        color: token2.colorTextHeading,
        fontWeight: token2.fontWeightStrong,
        fontSize: token2.fontSizeLG
      }, textEllipsis),
      "&-description": {
        color: token2.colorTextDescription
      }
    });
    const genCardTypeInnerStyle = (token2) => {
      const {
        componentCls,
        cardPaddingBase,
        colorFillAlter
      } = token2;
      return {
        [`${componentCls}-head`]: {
          padding: `0 ${cardPaddingBase}px`,
          background: colorFillAlter,
          "&-title": {
            fontSize: token2.fontSize
          }
        },
        [`${componentCls}-body`]: {
          padding: `${token2.padding}px ${cardPaddingBase}px`
        }
      };
    };
    const genCardLoadingStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        overflow: "hidden",
        [`${componentCls}-body`]: {
          userSelect: "none"
        }
      };
    };
    const genCardStyle = (token2) => {
      const {
        componentCls,
        cardShadow,
        cardHeadPadding,
        colorBorderSecondary,
        boxShadowTertiary,
        cardPaddingBase
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
          position: "relative",
          background: token2.colorBgContainer,
          borderRadius: token2.borderRadiusLG,
          [`&:not(${componentCls}-bordered)`]: {
            boxShadow: boxShadowTertiary
          },
          [`${componentCls}-head`]: genCardHeadStyle(token2),
          [`${componentCls}-extra`]: {
            // https://stackoverflow.com/a/22429853/3040605
            marginInlineStart: "auto",
            color: "",
            fontWeight: "normal",
            fontSize: token2.fontSize
          },
          [`${componentCls}-body`]: Object.assign({
            padding: cardPaddingBase,
            borderRadius: ` 0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`
          }, clearFix()),
          [`${componentCls}-grid`]: genCardGridStyle(token2),
          [`${componentCls}-cover`]: {
            "> *": {
              display: "block",
              width: "100%"
            },
            img: {
              borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`
            }
          },
          [`${componentCls}-actions`]: genCardActionsStyle(token2),
          [`${componentCls}-meta`]: genCardMetaStyle(token2)
        }),
        [`${componentCls}-bordered`]: {
          border: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
          [`${componentCls}-cover`]: {
            marginTop: -1,
            marginInlineStart: -1,
            marginInlineEnd: -1
          }
        },
        [`${componentCls}-hoverable`]: {
          cursor: "pointer",
          transition: `box-shadow ${token2.motionDurationMid}, border-color ${token2.motionDurationMid}`,
          "&:hover": {
            borderColor: "transparent",
            boxShadow: cardShadow
          }
        },
        [`${componentCls}-contain-grid`]: {
          [`${componentCls}-body`]: {
            display: "flex",
            flexWrap: "wrap"
          },
          [`&:not(${componentCls}-loading) ${componentCls}-body`]: {
            marginBlockStart: -token2.lineWidth,
            marginInlineStart: -token2.lineWidth,
            padding: 0
          }
        },
        [`${componentCls}-contain-tabs`]: {
          [`> ${componentCls}-head`]: {
            [`${componentCls}-head-title, ${componentCls}-extra`]: {
              paddingTop: cardHeadPadding
            }
          }
        },
        [`${componentCls}-type-inner`]: genCardTypeInnerStyle(token2),
        [`${componentCls}-loading`]: genCardLoadingStyle(token2),
        [`${componentCls}-rtl`]: {
          direction: "rtl"
        }
      };
    };
    const genCardSizeStyle = (token2) => {
      const {
        componentCls,
        cardPaddingSM,
        cardHeadHeightSM
      } = token2;
      return {
        [`${componentCls}-small`]: {
          [`> ${componentCls}-head`]: {
            minHeight: cardHeadHeightSM,
            padding: `0 ${cardPaddingSM}px`,
            fontSize: token2.fontSize,
            [`> ${componentCls}-head-wrapper`]: {
              [`> ${componentCls}-extra`]: {
                fontSize: token2.fontSize
              }
            }
          },
          [`> ${componentCls}-body`]: {
            padding: cardPaddingSM
          }
        },
        [`${componentCls}-small${componentCls}-contain-tabs`]: {
          [`> ${componentCls}-head`]: {
            [`${componentCls}-head-title, ${componentCls}-extra`]: {
              minHeight: cardHeadHeightSM,
              paddingTop: 0,
              display: "flex",
              alignItems: "center"
            }
          }
        }
      };
    };
    const useStyle$h = genComponentStyleHook("Card", (token2) => {
      const cardToken = merge$4(token2, {
        cardShadow: token2.boxShadowCard,
        cardHeadHeight: token2.fontSizeLG * token2.lineHeightLG + token2.padding * 2,
        cardHeadHeightSM: token2.fontSize * token2.lineHeight + token2.paddingXS * 2,
        cardHeadPadding: token2.padding,
        cardPaddingBase: token2.paddingLG,
        cardHeadTabsMarginBottom: -token2.padding - token2.lineWidth,
        cardActionsLiMargin: `${token2.paddingSM}px 0`,
        cardActionsIconSize: token2.fontSize,
        cardPaddingSM: 12
        // Fixed padding.
      });
      return [
        // Style
        genCardStyle(cardToken),
        // Size
        genCardSizeStyle(cardToken)
      ];
    });
    var __rest$B = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function getAction(actions) {
      const actionList = actions.map((action, index2) => (
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ reactExports.createElement("li", {
          style: {
            width: `${100 / actions.length}%`
          },
          key: `action-${index2}`
        }, /* @__PURE__ */ reactExports.createElement("span", null, action))
      ));
      return actionList;
    }
    const Card$2 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const size = reactExports.useContext(SizeContext$2);
      const onTabChange = (key) => {
        var _a;
        (_a = props.onTabChange) === null || _a === void 0 ? void 0 : _a.call(props, key);
      };
      const isContainGrid = () => {
        let containGrid;
        reactExports.Children.forEach(props.children, (element) => {
          if (element && element.type && element.type === Grid$2) {
            containGrid = true;
          }
        });
        return containGrid;
      };
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        extra,
        headStyle = {},
        bodyStyle = {},
        title,
        loading,
        bordered = true,
        size: customizeSize,
        type: type2,
        cover,
        actions,
        tabList,
        children,
        activeTabKey,
        defaultActiveTabKey,
        tabBarExtraContent,
        hoverable,
        tabProps = {}
      } = props, others = __rest$B(props, ["prefixCls", "className", "rootClassName", "extra", "headStyle", "bodyStyle", "title", "loading", "bordered", "size", "type", "cover", "actions", "tabList", "children", "activeTabKey", "defaultActiveTabKey", "tabBarExtraContent", "hoverable", "tabProps"]);
      const prefixCls = getPrefixCls("card", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$h(prefixCls);
      const loadingBlock = /* @__PURE__ */ reactExports.createElement(Skeleton$1, {
        loading: true,
        active: true,
        paragraph: {
          rows: 4
        },
        title: false
      }, children);
      const hasActiveTabKey = activeTabKey !== void 0;
      const extraProps = Object.assign(Object.assign({}, tabProps), {
        [hasActiveTabKey ? "activeKey" : "defaultActiveKey"]: hasActiveTabKey ? activeTabKey : defaultActiveTabKey,
        tabBarExtraContent
      });
      let head;
      const tabs = tabList && tabList.length ? /* @__PURE__ */ reactExports.createElement(Tabs, Object.assign({
        size: "large"
      }, extraProps, {
        className: `${prefixCls}-head-tabs`,
        onChange: onTabChange,
        items: tabList.map((item) => {
          var _a;
          return {
            label: item.tab,
            key: item.key,
            disabled: (_a = item.disabled) !== null && _a !== void 0 ? _a : false
          };
        })
      })) : null;
      if (title || extra || tabs) {
        head = /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-head`,
          style: headStyle
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-head-wrapper`
        }, title && /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-head-title`
        }, title), extra && /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-extra`
        }, extra)), tabs);
      }
      const coverDom = cover ? /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-cover`
      }, cover) : null;
      const body = /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-body`,
        style: bodyStyle
      }, loading ? loadingBlock : children);
      const actionDom = actions && actions.length ? /* @__PURE__ */ reactExports.createElement("ul", {
        className: `${prefixCls}-actions`
      }, getAction(actions)) : null;
      const divProps = omit(others, ["onTabChange"]);
      const mergedSize = customizeSize || size;
      const classString = classNames(prefixCls, {
        [`${prefixCls}-loading`]: loading,
        [`${prefixCls}-bordered`]: bordered,
        [`${prefixCls}-hoverable`]: hoverable,
        [`${prefixCls}-contain-grid`]: isContainGrid(),
        [`${prefixCls}-contain-tabs`]: tabList && tabList.length,
        [`${prefixCls}-${mergedSize}`]: mergedSize,
        [`${prefixCls}-type-${type2}`]: !!type2,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        ref
      }, divProps, {
        className: classString
      }), head, coverDom, body, actionDom));
    });
    const InternalCard = Card$2;
    var __rest$A = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Meta = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        avatar,
        title,
        description
      } = props, others = __rest$A(props, ["prefixCls", "className", "avatar", "title", "description"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("card", customizePrefixCls);
      const classString = classNames(`${prefixCls}-meta`, className);
      const avatarDom = avatar ? /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-meta-avatar`
      }, avatar) : null;
      const titleDom = title ? /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-meta-title`
      }, title) : null;
      const descriptionDom = description ? /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-meta-description`
      }, description) : null;
      const MetaDetail = titleDom || descriptionDom ? /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-meta-detail`
      }, titleDom, descriptionDom) : null;
      return /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, others, {
        className: classString
      }), avatarDom, MetaDetail);
    };
    const Meta$1 = Meta;
    const Card = InternalCard;
    Card.Grid = Grid$2;
    Card.Meta = Meta$1;
    const Card$1 = Card;
    function throttle(delay, callback, options) {
      var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
      var timeoutID;
      var cancelled = false;
      var lastExec = 0;
      function clearExistingTimeout() {
        if (timeoutID) {
          clearTimeout(timeoutID);
        }
      }
      function cancel(options2) {
        var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
        clearExistingTimeout();
        cancelled = !upcomingOnly;
      }
      function wrapper() {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
          arguments_[_key] = arguments[_key];
        }
        var self2 = this;
        var elapsed = Date.now() - lastExec;
        if (cancelled) {
          return;
        }
        function exec() {
          lastExec = Date.now();
          callback.apply(self2, arguments_);
        }
        function clear() {
          timeoutID = void 0;
        }
        if (!noLeading && debounceMode && !timeoutID) {
          exec();
        }
        clearExistingTimeout();
        if (debounceMode === void 0 && elapsed > delay) {
          if (noLeading) {
            lastExec = Date.now();
            if (!noTrailing) {
              timeoutID = setTimeout(debounceMode ? clear : exec, delay);
            }
          } else {
            exec();
          }
        } else if (noTrailing !== true) {
          timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
        }
      }
      wrapper.cancel = cancel;
      return wrapper;
    }
    function debounce(delay, callback, options) {
      var _ref = options || {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
      return throttle(delay, callback, {
        debounceMode: atBegin !== false
      });
    }
    function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
      var filteredKeys = /* @__PURE__ */ new Set();
      halfCheckedKeys.forEach(function(key) {
        if (!checkedKeys.has(key)) {
          filteredKeys.add(key);
        }
      });
      return filteredKeys;
    }
    function isCheckDisabled(node2) {
      var _ref = node2 || {}, disabled = _ref.disabled, disableCheckbox = _ref.disableCheckbox, checkable = _ref.checkable;
      return !!(disabled || disableCheckbox) || checkable === false;
    }
    function fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) {
      var checkedKeys = new Set(keys2);
      var halfCheckedKeys = /* @__PURE__ */ new Set();
      for (var level = 0; level <= maxLevel; level += 1) {
        var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
        entities.forEach(function(entity) {
          var key = entity.key, node2 = entity.node, _entity$children = entity.children, children = _entity$children === void 0 ? [] : _entity$children;
          if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node2)) {
            children.filter(function(childEntity) {
              return !syntheticGetCheckDisabled(childEntity.node);
            }).forEach(function(childEntity) {
              checkedKeys.add(childEntity.key);
            });
          }
        });
      }
      var visitedKeys = /* @__PURE__ */ new Set();
      for (var _level = maxLevel; _level >= 0; _level -= 1) {
        var _entities = levelEntities.get(_level) || /* @__PURE__ */ new Set();
        _entities.forEach(function(entity) {
          var parent = entity.parent, node2 = entity.node;
          if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
            return;
          }
          if (syntheticGetCheckDisabled(entity.parent.node)) {
            visitedKeys.add(parent.key);
            return;
          }
          var allChecked = true;
          var partialChecked = false;
          (parent.children || []).filter(function(childEntity) {
            return !syntheticGetCheckDisabled(childEntity.node);
          }).forEach(function(_ref2) {
            var key = _ref2.key;
            var checked = checkedKeys.has(key);
            if (allChecked && !checked) {
              allChecked = false;
            }
            if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
              partialChecked = true;
            }
          });
          if (allChecked) {
            checkedKeys.add(parent.key);
          }
          if (partialChecked) {
            halfCheckedKeys.add(parent.key);
          }
          visitedKeys.add(parent.key);
        });
      }
      return {
        checkedKeys: Array.from(checkedKeys),
        halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
      };
    }
    function cleanConductCheck(keys2, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
      var checkedKeys = new Set(keys2);
      var halfCheckedKeys = new Set(halfKeys);
      for (var level = 0; level <= maxLevel; level += 1) {
        var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
        entities.forEach(function(entity) {
          var key = entity.key, node2 = entity.node, _entity$children2 = entity.children, children = _entity$children2 === void 0 ? [] : _entity$children2;
          if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node2)) {
            children.filter(function(childEntity) {
              return !syntheticGetCheckDisabled(childEntity.node);
            }).forEach(function(childEntity) {
              checkedKeys.delete(childEntity.key);
            });
          }
        });
      }
      halfCheckedKeys = /* @__PURE__ */ new Set();
      var visitedKeys = /* @__PURE__ */ new Set();
      for (var _level2 = maxLevel; _level2 >= 0; _level2 -= 1) {
        var _entities2 = levelEntities.get(_level2) || /* @__PURE__ */ new Set();
        _entities2.forEach(function(entity) {
          var parent = entity.parent, node2 = entity.node;
          if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
            return;
          }
          if (syntheticGetCheckDisabled(entity.parent.node)) {
            visitedKeys.add(parent.key);
            return;
          }
          var allChecked = true;
          var partialChecked = false;
          (parent.children || []).filter(function(childEntity) {
            return !syntheticGetCheckDisabled(childEntity.node);
          }).forEach(function(_ref3) {
            var key = _ref3.key;
            var checked = checkedKeys.has(key);
            if (allChecked && !checked) {
              allChecked = false;
            }
            if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
              partialChecked = true;
            }
          });
          if (!allChecked) {
            checkedKeys.delete(parent.key);
          }
          if (partialChecked) {
            halfCheckedKeys.add(parent.key);
          }
          visitedKeys.add(parent.key);
        });
      }
      return {
        checkedKeys: Array.from(checkedKeys),
        halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
      };
    }
    function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
      var warningMissKeys = [];
      var syntheticGetCheckDisabled;
      if (getCheckDisabled) {
        syntheticGetCheckDisabled = getCheckDisabled;
      } else {
        syntheticGetCheckDisabled = isCheckDisabled;
      }
      var keys2 = new Set(keyList.filter(function(key) {
        var hasEntity = !!keyEntities[key];
        if (!hasEntity) {
          warningMissKeys.push(key);
        }
        return hasEntity;
      }));
      var levelEntities = /* @__PURE__ */ new Map();
      var maxLevel = 0;
      Object.keys(keyEntities).forEach(function(key) {
        var entity = keyEntities[key];
        var level = entity.level;
        var levelSet = levelEntities.get(level);
        if (!levelSet) {
          levelSet = /* @__PURE__ */ new Set();
          levelEntities.set(level, levelSet);
        }
        levelSet.add(entity);
        maxLevel = Math.max(maxLevel, level);
      });
      warningOnce$1(!warningMissKeys.length, "Tree missing follow keys: ".concat(warningMissKeys.slice(0, 100).map(function(key) {
        return "'".concat(key, "'");
      }).join(", ")));
      var result;
      if (checked === true) {
        result = fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled);
      } else {
        result = cleanConductCheck(keys2, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
      }
      return result;
    }
    var TreeContext = /* @__PURE__ */ reactExports.createContext(null);
    var Indent = function Indent2(_ref) {
      var prefixCls = _ref.prefixCls, level = _ref.level, isStart = _ref.isStart, isEnd = _ref.isEnd;
      var baseClassName = "".concat(prefixCls, "-indent-unit");
      var list2 = [];
      for (var i2 = 0; i2 < level; i2 += 1) {
        var _classNames;
        list2.push(/* @__PURE__ */ reactExports.createElement("span", {
          key: i2,
          className: classNames(baseClassName, (_classNames = {}, _defineProperty$7(_classNames, "".concat(baseClassName, "-start"), isStart[i2]), _defineProperty$7(_classNames, "".concat(baseClassName, "-end"), isEnd[i2]), _classNames))
        }));
      }
      return /* @__PURE__ */ reactExports.createElement("span", {
        "aria-hidden": "true",
        className: "".concat(prefixCls, "-indent")
      }, list2);
    };
    const Indent$1 = /* @__PURE__ */ reactExports.memo(Indent);
    var _excluded$j = ["eventKey", "className", "style", "dragOver", "dragOverGapTop", "dragOverGapBottom", "isLeaf", "isStart", "isEnd", "expanded", "selected", "checked", "halfChecked", "loading", "domRef", "active", "data", "onMouseMove", "selectable"];
    var ICON_OPEN = "open";
    var ICON_CLOSE = "close";
    var defaultTitle = "---";
    var InternalTreeNode = /* @__PURE__ */ function(_React$Component) {
      _inherits(InternalTreeNode2, _React$Component);
      var _super = _createSuper(InternalTreeNode2);
      function InternalTreeNode2() {
        var _this;
        _classCallCheck(this, InternalTreeNode2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.state = {
          dragNodeHighlight: false
        };
        _this.selectHandle = void 0;
        _this.onSelectorClick = function(e2) {
          var onNodeClick = _this.props.context.onNodeClick;
          onNodeClick(e2, convertNodePropsToEventData(_this.props));
          if (_this.isSelectable()) {
            _this.onSelect(e2);
          } else {
            _this.onCheck(e2);
          }
        };
        _this.onSelectorDoubleClick = function(e2) {
          var onNodeDoubleClick = _this.props.context.onNodeDoubleClick;
          onNodeDoubleClick(e2, convertNodePropsToEventData(_this.props));
        };
        _this.onSelect = function(e2) {
          if (_this.isDisabled())
            return;
          var onNodeSelect = _this.props.context.onNodeSelect;
          e2.preventDefault();
          onNodeSelect(e2, convertNodePropsToEventData(_this.props));
        };
        _this.onCheck = function(e2) {
          if (_this.isDisabled())
            return;
          var _this$props = _this.props, disableCheckbox = _this$props.disableCheckbox, checked = _this$props.checked;
          var onNodeCheck = _this.props.context.onNodeCheck;
          if (!_this.isCheckable() || disableCheckbox)
            return;
          e2.preventDefault();
          var targetChecked = !checked;
          onNodeCheck(e2, convertNodePropsToEventData(_this.props), targetChecked);
        };
        _this.onMouseEnter = function(e2) {
          var onNodeMouseEnter = _this.props.context.onNodeMouseEnter;
          onNodeMouseEnter(e2, convertNodePropsToEventData(_this.props));
        };
        _this.onMouseLeave = function(e2) {
          var onNodeMouseLeave = _this.props.context.onNodeMouseLeave;
          onNodeMouseLeave(e2, convertNodePropsToEventData(_this.props));
        };
        _this.onContextMenu = function(e2) {
          var onNodeContextMenu = _this.props.context.onNodeContextMenu;
          onNodeContextMenu(e2, convertNodePropsToEventData(_this.props));
        };
        _this.onDragStart = function(e2) {
          var onNodeDragStart = _this.props.context.onNodeDragStart;
          e2.stopPropagation();
          _this.setState({
            dragNodeHighlight: true
          });
          onNodeDragStart(e2, _assertThisInitialized(_this));
          try {
            e2.dataTransfer.setData("text/plain", "");
          } catch (error) {
          }
        };
        _this.onDragEnter = function(e2) {
          var onNodeDragEnter = _this.props.context.onNodeDragEnter;
          e2.preventDefault();
          e2.stopPropagation();
          onNodeDragEnter(e2, _assertThisInitialized(_this));
        };
        _this.onDragOver = function(e2) {
          var onNodeDragOver = _this.props.context.onNodeDragOver;
          e2.preventDefault();
          e2.stopPropagation();
          onNodeDragOver(e2, _assertThisInitialized(_this));
        };
        _this.onDragLeave = function(e2) {
          var onNodeDragLeave = _this.props.context.onNodeDragLeave;
          e2.stopPropagation();
          onNodeDragLeave(e2, _assertThisInitialized(_this));
        };
        _this.onDragEnd = function(e2) {
          var onNodeDragEnd = _this.props.context.onNodeDragEnd;
          e2.stopPropagation();
          _this.setState({
            dragNodeHighlight: false
          });
          onNodeDragEnd(e2, _assertThisInitialized(_this));
        };
        _this.onDrop = function(e2) {
          var onNodeDrop = _this.props.context.onNodeDrop;
          e2.preventDefault();
          e2.stopPropagation();
          _this.setState({
            dragNodeHighlight: false
          });
          onNodeDrop(e2, _assertThisInitialized(_this));
        };
        _this.onExpand = function(e2) {
          var _this$props2 = _this.props, loading = _this$props2.loading, onNodeExpand = _this$props2.context.onNodeExpand;
          if (loading)
            return;
          onNodeExpand(e2, convertNodePropsToEventData(_this.props));
        };
        _this.setSelectHandle = function(node2) {
          _this.selectHandle = node2;
        };
        _this.getNodeState = function() {
          var expanded = _this.props.expanded;
          if (_this.isLeaf()) {
            return null;
          }
          return expanded ? ICON_OPEN : ICON_CLOSE;
        };
        _this.hasChildren = function() {
          var eventKey = _this.props.eventKey;
          var keyEntities = _this.props.context.keyEntities;
          var _ref = keyEntities[eventKey] || {}, children = _ref.children;
          return !!(children || []).length;
        };
        _this.isLeaf = function() {
          var _this$props3 = _this.props, isLeaf = _this$props3.isLeaf, loaded = _this$props3.loaded;
          var loadData = _this.props.context.loadData;
          var hasChildren = _this.hasChildren();
          if (isLeaf === false) {
            return false;
          }
          return isLeaf || !loadData && !hasChildren || loadData && loaded && !hasChildren;
        };
        _this.isDisabled = function() {
          var disabled = _this.props.disabled;
          var treeDisabled = _this.props.context.disabled;
          return !!(treeDisabled || disabled);
        };
        _this.isCheckable = function() {
          var checkable = _this.props.checkable;
          var treeCheckable = _this.props.context.checkable;
          if (!treeCheckable || checkable === false)
            return false;
          return treeCheckable;
        };
        _this.syncLoadData = function(props) {
          var expanded = props.expanded, loading = props.loading, loaded = props.loaded;
          var _this$props$context = _this.props.context, loadData = _this$props$context.loadData, onNodeLoad = _this$props$context.onNodeLoad;
          if (loading) {
            return;
          }
          if (loadData && expanded && !_this.isLeaf()) {
            if (!_this.hasChildren() && !loaded) {
              onNodeLoad(convertNodePropsToEventData(_this.props));
            }
          }
        };
        _this.isDraggable = function() {
          var _this$props4 = _this.props, data2 = _this$props4.data, draggable = _this$props4.context.draggable;
          return !!(draggable && (!draggable.nodeDraggable || draggable.nodeDraggable(data2)));
        };
        _this.renderDragHandler = function() {
          var _this$props$context2 = _this.props.context, draggable = _this$props$context2.draggable, prefixCls = _this$props$context2.prefixCls;
          return (draggable === null || draggable === void 0 ? void 0 : draggable.icon) ? /* @__PURE__ */ reactExports.createElement("span", {
            className: "".concat(prefixCls, "-draggable-icon")
          }, draggable.icon) : null;
        };
        _this.renderSwitcherIconDom = function(isLeaf) {
          var switcherIconFromProps = _this.props.switcherIcon;
          var switcherIconFromCtx = _this.props.context.switcherIcon;
          var switcherIcon = switcherIconFromProps || switcherIconFromCtx;
          if (typeof switcherIcon === "function") {
            return switcherIcon(_objectSpread2$3(_objectSpread2$3({}, _this.props), {}, {
              isLeaf
            }));
          }
          return switcherIcon;
        };
        _this.renderSwitcher = function() {
          var expanded = _this.props.expanded;
          var prefixCls = _this.props.context.prefixCls;
          if (_this.isLeaf()) {
            var _switcherIconDom = _this.renderSwitcherIconDom(true);
            return _switcherIconDom !== false ? /* @__PURE__ */ reactExports.createElement("span", {
              className: classNames("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher-noop"))
            }, _switcherIconDom) : null;
          }
          var switcherCls = classNames("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher_").concat(expanded ? ICON_OPEN : ICON_CLOSE));
          var switcherIconDom = _this.renderSwitcherIconDom(false);
          return switcherIconDom !== false ? /* @__PURE__ */ reactExports.createElement("span", {
            onClick: _this.onExpand,
            className: switcherCls
          }, switcherIconDom) : null;
        };
        _this.renderCheckbox = function() {
          var _this$props5 = _this.props, checked = _this$props5.checked, halfChecked = _this$props5.halfChecked, disableCheckbox = _this$props5.disableCheckbox;
          var prefixCls = _this.props.context.prefixCls;
          var disabled = _this.isDisabled();
          var checkable = _this.isCheckable();
          if (!checkable)
            return null;
          var $custom = typeof checkable !== "boolean" ? checkable : null;
          return /* @__PURE__ */ reactExports.createElement("span", {
            className: classNames("".concat(prefixCls, "-checkbox"), checked && "".concat(prefixCls, "-checkbox-checked"), !checked && halfChecked && "".concat(prefixCls, "-checkbox-indeterminate"), (disabled || disableCheckbox) && "".concat(prefixCls, "-checkbox-disabled")),
            onClick: _this.onCheck
          }, $custom);
        };
        _this.renderIcon = function() {
          var loading = _this.props.loading;
          var prefixCls = _this.props.context.prefixCls;
          return /* @__PURE__ */ reactExports.createElement("span", {
            className: classNames("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__").concat(_this.getNodeState() || "docu"), loading && "".concat(prefixCls, "-icon_loading"))
          });
        };
        _this.renderSelector = function() {
          var dragNodeHighlight = _this.state.dragNodeHighlight;
          var _this$props6 = _this.props, title = _this$props6.title, selected = _this$props6.selected, icon = _this$props6.icon, loading = _this$props6.loading, data2 = _this$props6.data;
          var _this$props$context3 = _this.props.context, prefixCls = _this$props$context3.prefixCls, showIcon = _this$props$context3.showIcon, treeIcon = _this$props$context3.icon, loadData = _this$props$context3.loadData, titleRender = _this$props$context3.titleRender;
          var disabled = _this.isDisabled();
          var wrapClass = "".concat(prefixCls, "-node-content-wrapper");
          var $icon;
          if (showIcon) {
            var currentIcon = icon || treeIcon;
            $icon = currentIcon ? /* @__PURE__ */ reactExports.createElement("span", {
              className: classNames("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__customize"))
            }, typeof currentIcon === "function" ? currentIcon(_this.props) : currentIcon) : _this.renderIcon();
          } else if (loadData && loading) {
            $icon = _this.renderIcon();
          }
          var titleNode;
          if (typeof title === "function") {
            titleNode = title(data2);
          } else if (titleRender) {
            titleNode = titleRender(data2);
          } else {
            titleNode = title;
          }
          var $title = /* @__PURE__ */ reactExports.createElement("span", {
            className: "".concat(prefixCls, "-title")
          }, titleNode);
          return /* @__PURE__ */ reactExports.createElement("span", {
            ref: _this.setSelectHandle,
            title: typeof title === "string" ? title : "",
            className: classNames("".concat(wrapClass), "".concat(wrapClass, "-").concat(_this.getNodeState() || "normal"), !disabled && (selected || dragNodeHighlight) && "".concat(prefixCls, "-node-selected")),
            onMouseEnter: _this.onMouseEnter,
            onMouseLeave: _this.onMouseLeave,
            onContextMenu: _this.onContextMenu,
            onClick: _this.onSelectorClick,
            onDoubleClick: _this.onSelectorDoubleClick
          }, $icon, $title, _this.renderDropIndicator());
        };
        _this.renderDropIndicator = function() {
          var _this$props7 = _this.props, disabled = _this$props7.disabled, eventKey = _this$props7.eventKey;
          var _this$props$context4 = _this.props.context, draggable = _this$props$context4.draggable, dropLevelOffset = _this$props$context4.dropLevelOffset, dropPosition = _this$props$context4.dropPosition, prefixCls = _this$props$context4.prefixCls, indent = _this$props$context4.indent, dropIndicatorRender2 = _this$props$context4.dropIndicatorRender, dragOverNodeKey = _this$props$context4.dragOverNodeKey, direction = _this$props$context4.direction;
          var rootDraggable = !!draggable;
          var showIndicator = !disabled && rootDraggable && dragOverNodeKey === eventKey;
          return showIndicator ? dropIndicatorRender2({
            dropPosition,
            dropLevelOffset,
            indent,
            prefixCls,
            direction
          }) : null;
        };
        return _this;
      }
      _createClass(InternalTreeNode2, [{
        key: "componentDidMount",
        value: (
          // Isomorphic needn't load data in server side
          function componentDidMount() {
            this.syncLoadData(this.props);
          }
        )
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          this.syncLoadData(this.props);
        }
      }, {
        key: "isSelectable",
        value: function isSelectable() {
          var selectable = this.props.selectable;
          var treeSelectable = this.props.context.selectable;
          if (typeof selectable === "boolean") {
            return selectable;
          }
          return treeSelectable;
        }
      }, {
        key: "render",
        value: (
          // =========================== Render ===========================
          function render2() {
            var _classNames;
            var _this$props8 = this.props, eventKey = _this$props8.eventKey, className = _this$props8.className, style2 = _this$props8.style, dragOver = _this$props8.dragOver, dragOverGapTop = _this$props8.dragOverGapTop, dragOverGapBottom = _this$props8.dragOverGapBottom, isLeaf = _this$props8.isLeaf, isStart = _this$props8.isStart, isEnd = _this$props8.isEnd, expanded = _this$props8.expanded, selected = _this$props8.selected, checked = _this$props8.checked, halfChecked = _this$props8.halfChecked, loading = _this$props8.loading, domRef = _this$props8.domRef, active = _this$props8.active;
            _this$props8.data;
            var onMouseMove = _this$props8.onMouseMove, selectable = _this$props8.selectable, otherProps = _objectWithoutProperties$1(_this$props8, _excluded$j);
            var _this$props$context5 = this.props.context, prefixCls = _this$props$context5.prefixCls, filterTreeNode = _this$props$context5.filterTreeNode, keyEntities = _this$props$context5.keyEntities, dropContainerKey = _this$props$context5.dropContainerKey, dropTargetKey = _this$props$context5.dropTargetKey, draggingNodeKey = _this$props$context5.draggingNodeKey;
            var disabled = this.isDisabled();
            var dataOrAriaAttributeProps = pickAttrs(otherProps, {
              aria: true,
              data: true
            });
            var _ref2 = keyEntities[eventKey] || {}, level = _ref2.level;
            var isEndNode = isEnd[isEnd.length - 1];
            var mergedDraggable = this.isDraggable();
            var draggableWithoutDisabled = !disabled && mergedDraggable;
            var dragging = draggingNodeKey === eventKey;
            var ariaSelected = selectable !== void 0 ? {
              "aria-selected": !!selectable
            } : void 0;
            return /* @__PURE__ */ reactExports.createElement("div", _extends$2({
              ref: domRef,
              className: classNames(className, "".concat(prefixCls, "-treenode"), (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-treenode-disabled"), disabled), _defineProperty$7(_classNames, "".concat(prefixCls, "-treenode-switcher-").concat(expanded ? "open" : "close"), !isLeaf), _defineProperty$7(_classNames, "".concat(prefixCls, "-treenode-checkbox-checked"), checked), _defineProperty$7(_classNames, "".concat(prefixCls, "-treenode-checkbox-indeterminate"), halfChecked), _defineProperty$7(_classNames, "".concat(prefixCls, "-treenode-selected"), selected), _defineProperty$7(_classNames, "".concat(prefixCls, "-treenode-loading"), loading), _defineProperty$7(_classNames, "".concat(prefixCls, "-treenode-active"), active), _defineProperty$7(_classNames, "".concat(prefixCls, "-treenode-leaf-last"), isEndNode), _defineProperty$7(_classNames, "".concat(prefixCls, "-treenode-draggable"), mergedDraggable), _defineProperty$7(_classNames, "dragging", dragging), _defineProperty$7(_classNames, "drop-target", dropTargetKey === eventKey), _defineProperty$7(_classNames, "drop-container", dropContainerKey === eventKey), _defineProperty$7(_classNames, "drag-over", !disabled && dragOver), _defineProperty$7(_classNames, "drag-over-gap-top", !disabled && dragOverGapTop), _defineProperty$7(_classNames, "drag-over-gap-bottom", !disabled && dragOverGapBottom), _defineProperty$7(_classNames, "filter-node", filterTreeNode && filterTreeNode(convertNodePropsToEventData(this.props))), _classNames)),
              style: style2,
              draggable: draggableWithoutDisabled,
              "aria-grabbed": dragging,
              onDragStart: draggableWithoutDisabled ? this.onDragStart : void 0,
              onDragEnter: mergedDraggable ? this.onDragEnter : void 0,
              onDragOver: mergedDraggable ? this.onDragOver : void 0,
              onDragLeave: mergedDraggable ? this.onDragLeave : void 0,
              onDrop: mergedDraggable ? this.onDrop : void 0,
              onDragEnd: mergedDraggable ? this.onDragEnd : void 0,
              onMouseMove
            }, ariaSelected, dataOrAriaAttributeProps), /* @__PURE__ */ reactExports.createElement(Indent$1, {
              prefixCls,
              level,
              isStart,
              isEnd
            }), this.renderDragHandler(), this.renderSwitcher(), this.renderCheckbox(), this.renderSelector());
          }
        )
      }]);
      return InternalTreeNode2;
    }(reactExports.Component);
    var ContextTreeNode = function ContextTreeNode2(props) {
      return /* @__PURE__ */ reactExports.createElement(TreeContext.Consumer, null, function(context) {
        return /* @__PURE__ */ reactExports.createElement(InternalTreeNode, _extends$2({}, props, {
          context
        }));
      });
    };
    ContextTreeNode.displayName = "TreeNode";
    ContextTreeNode.defaultProps = {
      title: defaultTitle
    };
    ContextTreeNode.isTreeNode = 1;
    function arrDel(list2, value) {
      if (!list2)
        return [];
      var clone = list2.slice();
      var index2 = clone.indexOf(value);
      if (index2 >= 0) {
        clone.splice(index2, 1);
      }
      return clone;
    }
    function arrAdd(list2, value) {
      var clone = (list2 || []).slice();
      if (clone.indexOf(value) === -1) {
        clone.push(value);
      }
      return clone;
    }
    function posToArr(pos) {
      return pos.split("-");
    }
    function getPosition(level, index2) {
      return "".concat(level, "-").concat(index2);
    }
    function isTreeNode(node2) {
      return node2 && node2.type && node2.type.isTreeNode;
    }
    function getDragChildrenKeys(dragNodeKey, keyEntities) {
      var dragChildrenKeys = [];
      var entity = keyEntities[dragNodeKey];
      function dig() {
        var list2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        list2.forEach(function(_ref) {
          var key = _ref.key, children = _ref.children;
          dragChildrenKeys.push(key);
          dig(children);
        });
      }
      dig(entity.children);
      return dragChildrenKeys;
    }
    function isLastChild(treeNodeEntity) {
      if (treeNodeEntity.parent) {
        var posArr = posToArr(treeNodeEntity.pos);
        return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
      }
      return false;
    }
    function isFirstChild(treeNodeEntity) {
      var posArr = posToArr(treeNodeEntity.pos);
      return Number(posArr[posArr.length - 1]) === 0;
    }
    function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {
      var _abstractDropNodeEnti;
      var clientX = event.clientX, clientY = event.clientY;
      var _event$target$getBoun = event.target.getBoundingClientRect(), top = _event$target$getBoun.top, height = _event$target$getBoun.height;
      var horizontalMouseOffset = (direction === "rtl" ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);
      var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
      var abstractDropNodeEntity = keyEntities[targetNode.props.eventKey];
      if (clientY < top + height / 2) {
        var nodeIndex = flattenedNodes.findIndex(function(flattenedNode) {
          return flattenedNode.key === abstractDropNodeEntity.key;
        });
        var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
        var prevNodeKey = flattenedNodes[prevNodeIndex].key;
        abstractDropNodeEntity = keyEntities[prevNodeKey];
      }
      var initialAbstractDropNodeKey = abstractDropNodeEntity.key;
      var abstractDragOverEntity = abstractDropNodeEntity;
      var dragOverNodeKey = abstractDropNodeEntity.key;
      var dropPosition = 0;
      var dropLevelOffset = 0;
      if (!expandKeys.includes(initialAbstractDropNodeKey)) {
        for (var i2 = 0; i2 < rawDropLevelOffset; i2 += 1) {
          if (isLastChild(abstractDropNodeEntity)) {
            abstractDropNodeEntity = abstractDropNodeEntity.parent;
            dropLevelOffset += 1;
          } else {
            break;
          }
        }
      }
      var abstractDragDataNode = dragNode.props.data;
      var abstractDropDataNode = abstractDropNodeEntity.node;
      var dropAllowed = true;
      if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: -1
      }) && abstractDropNodeEntity.key === targetNode.props.eventKey) {
        dropPosition = -1;
      } else if ((abstractDragOverEntity.children || []).length && expandKeys.includes(dragOverNodeKey)) {
        if (allowDrop({
          dragNode: abstractDragDataNode,
          dropNode: abstractDropDataNode,
          dropPosition: 0
        })) {
          dropPosition = 0;
        } else {
          dropAllowed = false;
        }
      } else if (dropLevelOffset === 0) {
        if (rawDropLevelOffset > -1.5) {
          if (allowDrop({
            dragNode: abstractDragDataNode,
            dropNode: abstractDropDataNode,
            dropPosition: 1
          })) {
            dropPosition = 1;
          } else {
            dropAllowed = false;
          }
        } else {
          if (allowDrop({
            dragNode: abstractDragDataNode,
            dropNode: abstractDropDataNode,
            dropPosition: 0
          })) {
            dropPosition = 0;
          } else if (allowDrop({
            dragNode: abstractDragDataNode,
            dropNode: abstractDropDataNode,
            dropPosition: 1
          })) {
            dropPosition = 1;
          } else {
            dropAllowed = false;
          }
        }
      } else {
        if (allowDrop({
          dragNode: abstractDragDataNode,
          dropNode: abstractDropDataNode,
          dropPosition: 1
        })) {
          dropPosition = 1;
        } else {
          dropAllowed = false;
        }
      }
      return {
        dropPosition,
        dropLevelOffset,
        dropTargetKey: abstractDropNodeEntity.key,
        dropTargetPos: abstractDropNodeEntity.pos,
        dragOverNodeKey,
        dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,
        dropAllowed
      };
    }
    function calcSelectedKeys(selectedKeys, props) {
      if (!selectedKeys)
        return void 0;
      var multiple = props.multiple;
      if (multiple) {
        return selectedKeys.slice();
      }
      if (selectedKeys.length) {
        return [selectedKeys[0]];
      }
      return selectedKeys;
    }
    function parseCheckedKeys(keys2) {
      if (!keys2) {
        return null;
      }
      var keyProps;
      if (Array.isArray(keys2)) {
        keyProps = {
          checkedKeys: keys2,
          halfCheckedKeys: void 0
        };
      } else if (_typeof$4(keys2) === "object") {
        keyProps = {
          checkedKeys: keys2.checked || void 0,
          halfCheckedKeys: keys2.halfChecked || void 0
        };
      } else {
        warningOnce$1(false, "`checkedKeys` is not an array or an object");
        return null;
      }
      return keyProps;
    }
    function conductExpandParent(keyList, keyEntities) {
      var expandedKeys = /* @__PURE__ */ new Set();
      function conductUp(key) {
        if (expandedKeys.has(key))
          return;
        var entity = keyEntities[key];
        if (!entity)
          return;
        expandedKeys.add(key);
        var parent = entity.parent, node2 = entity.node;
        if (node2.disabled)
          return;
        if (parent) {
          conductUp(parent.key);
        }
      }
      (keyList || []).forEach(function(key) {
        conductUp(key);
      });
      return _toConsumableArray(expandedKeys);
    }
    var _excluded$i = ["children"];
    function getKey(key, pos) {
      if (key !== null && key !== void 0) {
        return key;
      }
      return pos;
    }
    function fillFieldNames(fieldNames) {
      var _ref = fieldNames || {}, title = _ref.title, _title = _ref._title, key = _ref.key, children = _ref.children;
      var mergedTitle = title || "title";
      return {
        title: mergedTitle,
        _title: _title || [mergedTitle],
        key: key || "key",
        children: children || "children"
      };
    }
    function convertTreeToData(rootNodes) {
      function dig(node2) {
        var treeNodes = toArray$8(node2);
        return treeNodes.map(function(treeNode) {
          if (!isTreeNode(treeNode)) {
            warningOnce$1(!treeNode, "Tree/TreeNode can only accept TreeNode as children.");
            return null;
          }
          var key = treeNode.key;
          var _treeNode$props = treeNode.props, children = _treeNode$props.children, rest = _objectWithoutProperties$1(_treeNode$props, _excluded$i);
          var dataNode = _objectSpread2$3({
            key
          }, rest);
          var parsedChildren = dig(children);
          if (parsedChildren.length) {
            dataNode.children = parsedChildren;
          }
          return dataNode;
        }).filter(function(dataNode) {
          return dataNode;
        });
      }
      return dig(rootNodes);
    }
    function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
      var _fillFieldNames = fillFieldNames(fieldNames), fieldTitles = _fillFieldNames._title, fieldKey = _fillFieldNames.key, fieldChildren = _fillFieldNames.children;
      var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
      var flattenList = [];
      function dig(list2) {
        var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        return list2.map(function(treeNode, index2) {
          var pos = getPosition(parent ? parent.pos : "0", index2);
          var mergedKey = getKey(treeNode[fieldKey], pos);
          var mergedTitle;
          for (var i2 = 0; i2 < fieldTitles.length; i2 += 1) {
            var fieldTitle = fieldTitles[i2];
            if (treeNode[fieldTitle] !== void 0) {
              mergedTitle = treeNode[fieldTitle];
              break;
            }
          }
          var flattenNode = _objectSpread2$3(_objectSpread2$3({}, omit(treeNode, [].concat(_toConsumableArray(fieldTitles), [fieldKey, fieldChildren]))), {}, {
            title: mergedTitle,
            key: mergedKey,
            parent,
            pos,
            children: null,
            data: treeNode,
            isStart: [].concat(_toConsumableArray(parent ? parent.isStart : []), [index2 === 0]),
            isEnd: [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index2 === list2.length - 1])
          });
          flattenList.push(flattenNode);
          if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
            flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
          } else {
            flattenNode.children = [];
          }
          return flattenNode;
        });
      }
      dig(treeNodeList);
      return flattenList;
    }
    function traverseDataNodes(dataNodes, callback, config) {
      var mergedConfig = {};
      if (_typeof$4(config) === "object") {
        mergedConfig = config;
      } else {
        mergedConfig = {
          externalGetKey: config
        };
      }
      mergedConfig = mergedConfig || {};
      var _mergedConfig = mergedConfig, childrenPropName = _mergedConfig.childrenPropName, externalGetKey = _mergedConfig.externalGetKey, fieldNames = _mergedConfig.fieldNames;
      var _fillFieldNames2 = fillFieldNames(fieldNames), fieldKey = _fillFieldNames2.key, fieldChildren = _fillFieldNames2.children;
      var mergeChildrenPropName = childrenPropName || fieldChildren;
      var syntheticGetKey;
      if (externalGetKey) {
        if (typeof externalGetKey === "string") {
          syntheticGetKey = function syntheticGetKey2(node2) {
            return node2[externalGetKey];
          };
        } else if (typeof externalGetKey === "function") {
          syntheticGetKey = function syntheticGetKey2(node2) {
            return externalGetKey(node2);
          };
        }
      } else {
        syntheticGetKey = function syntheticGetKey2(node2, pos) {
          return getKey(node2[fieldKey], pos);
        };
      }
      function processNode(node2, index2, parent, pathNodes) {
        var children = node2 ? node2[mergeChildrenPropName] : dataNodes;
        var pos = node2 ? getPosition(parent.pos, index2) : "0";
        var connectNodes = node2 ? [].concat(_toConsumableArray(pathNodes), [node2]) : [];
        if (node2) {
          var key = syntheticGetKey(node2, pos);
          var data2 = {
            node: node2,
            index: index2,
            pos,
            key,
            parentPos: parent.node ? parent.pos : null,
            level: parent.level + 1,
            nodes: connectNodes
          };
          callback(data2);
        }
        if (children) {
          children.forEach(function(subNode, subIndex) {
            processNode(subNode, subIndex, {
              node: node2,
              pos,
              level: parent ? parent.level + 1 : -1
            }, connectNodes);
          });
        }
      }
      processNode(null);
    }
    function convertDataToEntities(dataNodes) {
      var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, initWrapper = _ref2.initWrapper, processEntity = _ref2.processEntity, onProcessFinished = _ref2.onProcessFinished, externalGetKey = _ref2.externalGetKey, childrenPropName = _ref2.childrenPropName, fieldNames = _ref2.fieldNames;
      var legacyExternalGetKey = arguments.length > 2 ? arguments[2] : void 0;
      var mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
      var posEntities = {};
      var keyEntities = {};
      var wrapper = {
        posEntities,
        keyEntities
      };
      if (initWrapper) {
        wrapper = initWrapper(wrapper) || wrapper;
      }
      traverseDataNodes(dataNodes, function(item) {
        var node2 = item.node, index2 = item.index, pos = item.pos, key = item.key, parentPos = item.parentPos, level = item.level, nodes = item.nodes;
        var entity = {
          node: node2,
          nodes,
          index: index2,
          key,
          pos,
          level
        };
        var mergedKey = getKey(key, pos);
        posEntities[pos] = entity;
        keyEntities[mergedKey] = entity;
        entity.parent = posEntities[parentPos];
        if (entity.parent) {
          entity.parent.children = entity.parent.children || [];
          entity.parent.children.push(entity);
        }
        if (processEntity) {
          processEntity(entity, wrapper);
        }
      }, {
        externalGetKey: mergedExternalGetKey,
        childrenPropName,
        fieldNames
      });
      if (onProcessFinished) {
        onProcessFinished(wrapper);
      }
      return wrapper;
    }
    function getTreeNodeProps(key, _ref3) {
      var expandedKeys = _ref3.expandedKeys, selectedKeys = _ref3.selectedKeys, loadedKeys = _ref3.loadedKeys, loadingKeys = _ref3.loadingKeys, checkedKeys = _ref3.checkedKeys, halfCheckedKeys = _ref3.halfCheckedKeys, dragOverNodeKey = _ref3.dragOverNodeKey, dropPosition = _ref3.dropPosition, keyEntities = _ref3.keyEntities;
      var entity = keyEntities[key];
      var treeNodeProps = {
        eventKey: key,
        expanded: expandedKeys.indexOf(key) !== -1,
        selected: selectedKeys.indexOf(key) !== -1,
        loaded: loadedKeys.indexOf(key) !== -1,
        loading: loadingKeys.indexOf(key) !== -1,
        checked: checkedKeys.indexOf(key) !== -1,
        halfChecked: halfCheckedKeys.indexOf(key) !== -1,
        pos: String(entity ? entity.pos : ""),
        // [Legacy] Drag props
        // Since the interaction of drag is changed, the semantic of the props are
        // not accuracy, I think it should be finally removed
        dragOver: dragOverNodeKey === key && dropPosition === 0,
        dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
        dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
      };
      return treeNodeProps;
    }
    function convertNodePropsToEventData(props) {
      var data2 = props.data, expanded = props.expanded, selected = props.selected, checked = props.checked, loaded = props.loaded, loading = props.loading, halfChecked = props.halfChecked, dragOver = props.dragOver, dragOverGapTop = props.dragOverGapTop, dragOverGapBottom = props.dragOverGapBottom, pos = props.pos, active = props.active, eventKey = props.eventKey;
      var eventData = _objectSpread2$3(_objectSpread2$3({}, data2), {}, {
        expanded,
        selected,
        checked,
        loaded,
        loading,
        halfChecked,
        dragOver,
        dragOverGapTop,
        dragOverGapBottom,
        pos,
        active,
        key: eventKey
      });
      if (!("props" in eventData)) {
        Object.defineProperty(eventData, "props", {
          get: function get2() {
            warningOnce$1(false, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.");
            return props;
          }
        });
      }
      return eventData;
    }
    const antCheckboxEffect = new Keyframe("antCheckboxEffect", {
      "0%": {
        transform: "scale(1)",
        opacity: 0.5
      },
      "100%": {
        transform: "scale(1.6)",
        opacity: 0
      }
    });
    const genCheckboxStyle = (token2) => {
      const {
        checkboxCls
      } = token2;
      const wrapperCls = `${checkboxCls}-wrapper`;
      return [
        // ===================== Basic =====================
        {
          // Group
          [`${checkboxCls}-group`]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
            display: "inline-flex"
          }),
          // Wrapper
          [wrapperCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
            display: "inline-flex",
            alignItems: "baseline",
            cursor: "pointer",
            // Fix checkbox & radio in flex align #30260
            "&:after": {
              display: "inline-block",
              width: 0,
              overflow: "hidden",
              content: "'\\a0'"
            },
            // Checkbox near checkbox
            [`& + ${wrapperCls}`]: {
              marginInlineStart: token2.marginXS
            },
            [`&${wrapperCls}-in-form-item`]: {
              'input[type="checkbox"]': {
                width: 14,
                height: 14
                // FIXME: magic
              }
            }
          }),
          // Wrapper > Checkbox
          [checkboxCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
            top: "0.2em",
            position: "relative",
            whiteSpace: "nowrap",
            lineHeight: 1,
            cursor: "pointer",
            // Wrapper > Checkbox > input
            [`${checkboxCls}-input`]: {
              position: "absolute",
              inset: 0,
              zIndex: 1,
              width: "100%",
              height: "100%",
              cursor: "pointer",
              opacity: 0,
              [`&:focus-visible + ${checkboxCls}-inner`]: Object.assign({}, genFocusOutline(token2))
            },
            // Wrapper > Checkbox > inner
            [`${checkboxCls}-inner`]: {
              boxSizing: "border-box",
              position: "relative",
              top: 0,
              insetInlineStart: 0,
              display: "block",
              width: token2.checkboxSize,
              height: token2.checkboxSize,
              direction: "ltr",
              backgroundColor: token2.colorBgContainer,
              border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
              borderRadius: token2.borderRadiusSM,
              borderCollapse: "separate",
              transition: `all ${token2.motionDurationSlow}`,
              "&:after": {
                boxSizing: "border-box",
                position: "absolute",
                top: "50%",
                insetInlineStart: "21.5%",
                display: "table",
                width: token2.checkboxSize / 14 * 5,
                height: token2.checkboxSize / 14 * 8,
                border: `${token2.lineWidthBold}px solid ${token2.colorWhite}`,
                borderTop: 0,
                borderInlineStart: 0,
                transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
                opacity: 0,
                content: '""',
                transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
              }
            },
            // Wrapper > Checkbox + Text
            "& + span": {
              paddingInlineStart: token2.paddingXS,
              paddingInlineEnd: token2.paddingXS
            }
          })
        },
        // ================= Indeterminate =================
        {
          [checkboxCls]: {
            "&-indeterminate": {
              // Wrapper > Checkbox > inner
              [`${checkboxCls}-inner`]: {
                "&:after": {
                  top: "50%",
                  insetInlineStart: "50%",
                  width: token2.fontSizeLG / 2,
                  height: token2.fontSizeLG / 2,
                  backgroundColor: token2.colorPrimary,
                  border: 0,
                  transform: "translate(-50%, -50%) scale(1)",
                  opacity: 1,
                  content: '""'
                }
              }
            }
          }
        },
        // ===================== Hover =====================
        {
          // Wrapper
          [`${wrapperCls}:hover ${checkboxCls}:after`]: {
            visibility: "visible"
          },
          // Wrapper & Wrapper > Checkbox
          [`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: {
            [`&:hover ${checkboxCls}-inner`]: {
              borderColor: token2.colorPrimary
            }
          },
          [`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
            [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
              backgroundColor: token2.colorPrimaryHover,
              borderColor: "transparent"
            },
            [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: {
              borderColor: token2.colorPrimaryHover
            }
          }
        },
        // ==================== Checked ====================
        {
          // Wrapper > Checkbox
          [`${checkboxCls}-checked`]: {
            [`${checkboxCls}-inner`]: {
              backgroundColor: token2.colorPrimary,
              borderColor: token2.colorPrimary,
              "&:after": {
                opacity: 1,
                transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
                transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
              }
            },
            // Checked Effect
            "&:after": {
              position: "absolute",
              top: 0,
              insetInlineStart: 0,
              width: "100%",
              height: "100%",
              borderRadius: token2.borderRadiusSM,
              visibility: "hidden",
              border: `${token2.lineWidthBold}px solid ${token2.colorPrimary}`,
              animationName: antCheckboxEffect,
              animationDuration: token2.motionDurationSlow,
              animationTimingFunction: "ease-in-out",
              animationFillMode: "backwards",
              content: '""',
              transition: `all ${token2.motionDurationSlow}`
            }
          },
          [`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: {
            [`&:hover ${checkboxCls}-inner`]: {
              backgroundColor: token2.colorPrimaryHover,
              borderColor: "transparent"
            },
            [`&:hover ${checkboxCls}:after`]: {
              borderColor: token2.colorPrimaryHover
            }
          }
        },
        // ==================== Disable ====================
        {
          // Wrapper
          [`${wrapperCls}-disabled`]: {
            cursor: "not-allowed"
          },
          // Wrapper > Checkbox
          [`${checkboxCls}-disabled`]: {
            // Wrapper > Checkbox > input
            [`&, ${checkboxCls}-input`]: {
              cursor: "not-allowed",
              // Disabled for native input to enable Tooltip event handler
              // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
              pointerEvents: "none"
            },
            // Wrapper > Checkbox > inner
            [`${checkboxCls}-inner`]: {
              background: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder,
              "&:after": {
                borderColor: token2.colorTextDisabled
              }
            },
            "&:after": {
              display: "none"
            },
            "& + span": {
              color: token2.colorTextDisabled
            },
            [`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: {
              background: token2.colorTextDisabled
            }
          }
        }
      ];
    };
    function getStyle$1(prefixCls, token2) {
      const checkboxToken = merge$4(token2, {
        checkboxCls: `.${prefixCls}`,
        checkboxSize: token2.controlInteractiveSize
      });
      return [genCheckboxStyle(checkboxToken)];
    }
    const useStyle$g = genComponentStyleHook("Checkbox", (token2, _ref) => {
      let {
        prefixCls
      } = _ref;
      return [getStyle$1(prefixCls, token2)];
    });
    var __rest$z = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const GroupContext = /* @__PURE__ */ reactExports.createContext(null);
    const InternalCheckboxGroup = (_a, ref) => {
      var {
        defaultValue,
        children,
        options = [],
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        style: style2,
        onChange
      } = _a, restProps = __rest$z(_a, ["defaultValue", "children", "options", "prefixCls", "className", "rootClassName", "style", "onChange"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const [value, setValue2] = reactExports.useState(restProps.value || defaultValue || []);
      const [registeredValues, setRegisteredValues] = reactExports.useState([]);
      reactExports.useEffect(() => {
        if ("value" in restProps) {
          setValue2(restProps.value || []);
        }
      }, [restProps.value]);
      const getOptions = () => options.map((option) => {
        if (typeof option === "string" || typeof option === "number") {
          return {
            label: option,
            value: option
          };
        }
        return option;
      });
      const cancelValue = (val) => {
        setRegisteredValues((prevValues) => prevValues.filter((v2) => v2 !== val));
      };
      const registerValue = (val) => {
        setRegisteredValues((prevValues) => [].concat(_toConsumableArray(prevValues), [val]));
      };
      const toggleOption = (option) => {
        const optionIndex = value.indexOf(option.value);
        const newValue = _toConsumableArray(value);
        if (optionIndex === -1) {
          newValue.push(option.value);
        } else {
          newValue.splice(optionIndex, 1);
        }
        if (!("value" in restProps)) {
          setValue2(newValue);
        }
        const opts = getOptions();
        onChange === null || onChange === void 0 ? void 0 : onChange(newValue.filter((val) => registeredValues.includes(val)).sort((a, b2) => {
          const indexA = opts.findIndex((opt) => opt.value === a);
          const indexB = opts.findIndex((opt) => opt.value === b2);
          return indexA - indexB;
        }));
      };
      const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
      const groupPrefixCls = `${prefixCls}-group`;
      const [wrapSSR, hashId] = useStyle$g(prefixCls);
      const domProps = omit(restProps, ["value", "disabled"]);
      if (options && options.length > 0) {
        children = getOptions().map((option) => /* @__PURE__ */ reactExports.createElement(InternalCheckbox$1, {
          prefixCls,
          key: option.value.toString(),
          disabled: "disabled" in option ? option.disabled : restProps.disabled,
          value: option.value,
          checked: value.includes(option.value),
          onChange: option.onChange,
          className: `${groupPrefixCls}-item`,
          style: option.style
        }, option.label));
      }
      const context = {
        toggleOption,
        value,
        disabled: restProps.disabled,
        name: restProps.name,
        // https://github.com/ant-design/ant-design/issues/16376
        registerValue,
        cancelValue
      };
      const classString = classNames(groupPrefixCls, {
        [`${groupPrefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        className: classString,
        style: style2
      }, domProps, {
        ref
      }), /* @__PURE__ */ reactExports.createElement(GroupContext.Provider, {
        value: context
      }, children)));
    };
    const CheckboxGroup = /* @__PURE__ */ reactExports.forwardRef(InternalCheckboxGroup);
    const Group$2 = /* @__PURE__ */ reactExports.memo(CheckboxGroup);
    var __rest$y = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const InternalCheckbox = (_a, ref) => {
      var _b;
      var {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        children,
        indeterminate = false,
        style: style2,
        onMouseEnter,
        onMouseLeave,
        skipGroup = false,
        disabled
      } = _a, restProps = __rest$y(_a, ["prefixCls", "className", "rootClassName", "children", "indeterminate", "style", "onMouseEnter", "onMouseLeave", "skipGroup", "disabled"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const checkboxGroup = reactExports.useContext(GroupContext);
      const {
        isFormItemInput
      } = reactExports.useContext(FormItemInputContext);
      const contextDisabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = (_b = (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.disabled) || disabled) !== null && _b !== void 0 ? _b : contextDisabled;
      const prevValue = reactExports.useRef(restProps.value);
      reactExports.useEffect(() => {
        checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
      }, []);
      reactExports.useEffect(() => {
        if (skipGroup) {
          return;
        }
        if (restProps.value !== prevValue.current) {
          checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(prevValue.current);
          checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
          prevValue.current = restProps.value;
        }
        return () => checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(restProps.value);
      }, [restProps.value]);
      const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$g(prefixCls);
      const checkboxProps = Object.assign({}, restProps);
      if (checkboxGroup && !skipGroup) {
        checkboxProps.onChange = function() {
          if (restProps.onChange) {
            restProps.onChange.apply(restProps, arguments);
          }
          if (checkboxGroup.toggleOption) {
            checkboxGroup.toggleOption({
              label: children,
              value: restProps.value
            });
          }
        };
        checkboxProps.name = checkboxGroup.name;
        checkboxProps.checked = checkboxGroup.value.includes(restProps.value);
      }
      const classString = classNames({
        [`${prefixCls}-wrapper`]: true,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-wrapper-checked`]: checkboxProps.checked,
        [`${prefixCls}-wrapper-disabled`]: mergedDisabled,
        [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
      }, className, rootClassName, hashId);
      const checkboxClass = classNames({
        [`${prefixCls}-indeterminate`]: indeterminate
      }, hashId);
      const ariaChecked = indeterminate ? "mixed" : void 0;
      return wrapSSR(
        // eslint-disable-next-line jsx-a11y/label-has-associated-control
        /* @__PURE__ */ reactExports.createElement("label", {
          className: classString,
          style: style2,
          onMouseEnter,
          onMouseLeave
        }, /* @__PURE__ */ reactExports.createElement(Checkbox$3, Object.assign({
          "aria-checked": ariaChecked
        }, checkboxProps, {
          prefixCls,
          className: checkboxClass,
          disabled: mergedDisabled,
          ref
        })), children !== void 0 && /* @__PURE__ */ reactExports.createElement("span", null, children))
      );
    };
    const Checkbox$2 = /* @__PURE__ */ reactExports.forwardRef(InternalCheckbox);
    const InternalCheckbox$1 = Checkbox$2;
    const Checkbox = InternalCheckbox$1;
    Checkbox.Group = Group$2;
    Checkbox.__ANT_CHECKBOX = true;
    const Checkbox$1 = Checkbox;
    const RowContext = /* @__PURE__ */ reactExports.createContext({});
    const RowContext$1 = RowContext;
    const genGridRowStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        // Grid system
        [componentCls]: {
          display: "flex",
          flexFlow: "row wrap",
          minWidth: 0,
          "&::before, &::after": {
            display: "flex"
          },
          "&-no-wrap": {
            flexWrap: "nowrap"
          },
          // The origin of the X-axis
          "&-start": {
            justifyContent: "flex-start"
          },
          // The center of the X-axis
          "&-center": {
            justifyContent: "center"
          },
          // The opposite of the X-axis
          "&-end": {
            justifyContent: "flex-end"
          },
          "&-space-between": {
            justifyContent: "space-between"
          },
          "&-space-around ": {
            justifyContent: "space-around"
          },
          // Align at the top
          "&-top": {
            alignItems: "flex-start"
          },
          // Align at the center
          "&-middle": {
            alignItems: "center"
          },
          "&-bottom": {
            alignItems: "flex-end"
          }
        }
      };
    };
    const genGridColStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        // Grid system
        [componentCls]: {
          position: "relative",
          maxWidth: "100%",
          // Prevent columns from collapsing when empty
          minHeight: 1
        }
      };
    };
    const genLoopGridColumnsStyle = (token2, sizeCls) => {
      const {
        componentCls,
        gridColumns
      } = token2;
      const gridColumnsStyle = {};
      for (let i2 = gridColumns; i2 >= 0; i2--) {
        if (i2 === 0) {
          gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
            display: "none"
          };
          gridColumnsStyle[`${componentCls}-push-${i2}`] = {
            insetInlineStart: "auto"
          };
          gridColumnsStyle[`${componentCls}-pull-${i2}`] = {
            insetInlineEnd: "auto"
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
            insetInlineStart: "auto"
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
            insetInlineEnd: "auto"
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
            marginInlineEnd: 0
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
            order: 0
          };
        } else {
          gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
            display: "block",
            flex: `0 0 ${i2 / gridColumns * 100}%`,
            maxWidth: `${i2 / gridColumns * 100}%`
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
            insetInlineStart: `${i2 / gridColumns * 100}%`
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
            insetInlineEnd: `${i2 / gridColumns * 100}%`
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
            marginInlineStart: `${i2 / gridColumns * 100}%`
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
            order: i2
          };
        }
      }
      return gridColumnsStyle;
    };
    const genGridStyle = (token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls);
    const genGridMediaStyle = (token2, screenSize, sizeCls) => ({
      [`@media (min-width: ${screenSize}px)`]: Object.assign({}, genGridStyle(token2, sizeCls))
    });
    const useRowStyle = genComponentStyleHook("Grid", (token2) => [genGridRowStyle(token2)]);
    const useColStyle = genComponentStyleHook("Grid", (token2) => {
      const gridToken = merge$4(token2, {
        gridColumns: 24
        // Row is divided into 24 parts in Grid
      });
      const gridMediaSizesMap = {
        "-sm": gridToken.screenSMMin,
        "-md": gridToken.screenMDMin,
        "-lg": gridToken.screenLGMin,
        "-xl": gridToken.screenXLMin,
        "-xxl": gridToken.screenXXLMin
      };
      return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key) => genGridMediaStyle(gridToken, gridMediaSizesMap[key], key)).reduce((pre, cur) => Object.assign(Object.assign({}, pre), cur), {})];
    });
    var __rest$x = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function parseFlex(flex) {
      if (typeof flex === "number") {
        return `${flex} ${flex} auto`;
      }
      if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
        return `0 0 ${flex}`;
      }
      return flex;
    }
    const sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
    const Col = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        gutter,
        wrap: wrap2,
        supportFlexGap
      } = reactExports.useContext(RowContext$1);
      const {
        prefixCls: customizePrefixCls,
        span,
        order: order2,
        offset: offset2,
        push: push2,
        pull,
        className,
        children,
        flex,
        style: style2
      } = props, others = __rest$x(props, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]);
      const prefixCls = getPrefixCls("col", customizePrefixCls);
      const [wrapSSR, hashId] = useColStyle(prefixCls);
      let sizeClassObj = {};
      sizes.forEach((size) => {
        let sizeProps = {};
        const propSize = props[size];
        if (typeof propSize === "number") {
          sizeProps.span = propSize;
        } else if (typeof propSize === "object") {
          sizeProps = propSize || {};
        }
        delete others[size];
        sizeClassObj = Object.assign(Object.assign({}, sizeClassObj), {
          [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
          [`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
          [`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
          [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
          [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
          [`${prefixCls}-rtl`]: direction === "rtl"
        });
      });
      const classes = classNames(prefixCls, {
        [`${prefixCls}-${span}`]: span !== void 0,
        [`${prefixCls}-order-${order2}`]: order2,
        [`${prefixCls}-offset-${offset2}`]: offset2,
        [`${prefixCls}-push-${push2}`]: push2,
        [`${prefixCls}-pull-${pull}`]: pull
      }, className, sizeClassObj, hashId);
      const mergedStyle = {};
      if (gutter && gutter[0] > 0) {
        const horizontalGutter = gutter[0] / 2;
        mergedStyle.paddingLeft = horizontalGutter;
        mergedStyle.paddingRight = horizontalGutter;
      }
      if (gutter && gutter[1] > 0 && !supportFlexGap) {
        const verticalGutter = gutter[1] / 2;
        mergedStyle.paddingTop = verticalGutter;
        mergedStyle.paddingBottom = verticalGutter;
      }
      if (flex) {
        mergedStyle.flex = parseFlex(flex);
        if (wrap2 === false && !mergedStyle.minWidth) {
          mergedStyle.minWidth = 0;
        }
      }
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", Object.assign({}, others, {
        style: Object.assign(Object.assign({}, mergedStyle), style2),
        className: classes,
        ref
      }), children));
    });
    const Col$1 = Col;
    var __rest$w = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function useMergePropByScreen(oriProp, screen) {
      const [prop, setProp] = reactExports.useState(typeof oriProp === "string" ? oriProp : "");
      const calcMergeAlignOrJustify = () => {
        if (typeof oriProp === "string") {
          setProp(oriProp);
        }
        if (typeof oriProp !== "object") {
          return;
        }
        for (let i2 = 0; i2 < responsiveArray.length; i2++) {
          const breakpoint = responsiveArray[i2];
          if (!screen[breakpoint])
            continue;
          const curVal = oriProp[breakpoint];
          if (curVal !== void 0) {
            setProp(curVal);
            return;
          }
        }
      };
      reactExports.useEffect(() => {
        calcMergeAlignOrJustify();
      }, [JSON.stringify(oriProp), screen]);
      return prop;
    }
    const Row = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        justify,
        align,
        className,
        style: style2,
        children,
        gutter = 0,
        wrap: wrap2
      } = props, others = __rest$w(props, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const [screens, setScreens] = reactExports.useState({
        xs: true,
        sm: true,
        md: true,
        lg: true,
        xl: true,
        xxl: true
      });
      const [curScreens, setCurScreens] = reactExports.useState({
        xs: false,
        sm: false,
        md: false,
        lg: false,
        xl: false,
        xxl: false
      });
      const mergeAlign = useMergePropByScreen(align, curScreens);
      const mergeJustify = useMergePropByScreen(justify, curScreens);
      const supportFlexGap = useFlexGapSupport();
      const gutterRef = reactExports.useRef(gutter);
      const responsiveObserver = useResponsiveObserver();
      reactExports.useEffect(() => {
        const token2 = responsiveObserver.subscribe((screen) => {
          setCurScreens(screen);
          const currentGutter = gutterRef.current || 0;
          if (!Array.isArray(currentGutter) && typeof currentGutter === "object" || Array.isArray(currentGutter) && (typeof currentGutter[0] === "object" || typeof currentGutter[1] === "object")) {
            setScreens(screen);
          }
        });
        return () => responsiveObserver.unsubscribe(token2);
      }, []);
      const getGutter = () => {
        const results = [void 0, void 0];
        const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
        normalizedGutter.forEach((g2, index2) => {
          if (typeof g2 === "object") {
            for (let i2 = 0; i2 < responsiveArray.length; i2++) {
              const breakpoint = responsiveArray[i2];
              if (screens[breakpoint] && g2[breakpoint] !== void 0) {
                results[index2] = g2[breakpoint];
                break;
              }
            }
          } else {
            results[index2] = g2;
          }
        });
        return results;
      };
      const prefixCls = getPrefixCls("row", customizePrefixCls);
      const [wrapSSR, hashId] = useRowStyle(prefixCls);
      const gutters = getGutter();
      const classes = classNames(prefixCls, {
        [`${prefixCls}-no-wrap`]: wrap2 === false,
        [`${prefixCls}-${mergeJustify}`]: mergeJustify,
        [`${prefixCls}-${mergeAlign}`]: mergeAlign,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, hashId);
      const rowStyle = {};
      const horizontalGutter = gutters[0] != null && gutters[0] > 0 ? gutters[0] / -2 : void 0;
      const verticalGutter = gutters[1] != null && gutters[1] > 0 ? gutters[1] / -2 : void 0;
      if (horizontalGutter) {
        rowStyle.marginLeft = horizontalGutter;
        rowStyle.marginRight = horizontalGutter;
      }
      if (supportFlexGap) {
        [, rowStyle.rowGap] = gutters;
      } else if (verticalGutter) {
        rowStyle.marginTop = verticalGutter;
        rowStyle.marginBottom = verticalGutter;
      }
      const [gutterH, gutterV] = gutters;
      const rowContext = reactExports.useMemo(() => ({
        gutter: [gutterH, gutterV],
        wrap: wrap2,
        supportFlexGap
      }), [gutterH, gutterV, wrap2, supportFlexGap]);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(RowContext$1.Provider, {
        value: rowContext
      }, /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, others, {
        className: classes,
        style: Object.assign(Object.assign({}, rowStyle), style2),
        ref
      }), children)));
    });
    const Row$1 = Row;
    function useBreakpoint$2() {
      return useBreakpoint$3();
    }
    const Grid = {
      useBreakpoint: useBreakpoint$2
    };
    function PickerButton(props) {
      return /* @__PURE__ */ reactExports.createElement(Button$2, Object.assign({
        size: "small",
        type: "primary"
      }, props));
    }
    var CalendarOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z" } }] }, "name": "calendar", "theme": "outlined" };
    const CalendarOutlinedSvg = CalendarOutlined$2;
    var CalendarOutlined = function CalendarOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: CalendarOutlinedSvg
      }));
    };
    CalendarOutlined.displayName = "CalendarOutlined";
    const CalendarOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CalendarOutlined);
    var ClockCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" } }] }, "name": "clock-circle", "theme": "outlined" };
    const ClockCircleOutlinedSvg = ClockCircleOutlined$2;
    var ClockCircleOutlined = function ClockCircleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: ClockCircleOutlinedSvg
      }));
    };
    ClockCircleOutlined.displayName = "ClockCircleOutlined";
    const ClockCircleOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(ClockCircleOutlined);
    var SwapRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" } }] }, "name": "swap-right", "theme": "outlined" };
    const SwapRightOutlinedSvg = SwapRightOutlined$2;
    var SwapRightOutlined = function SwapRightOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: SwapRightOutlinedSvg
      }));
    };
    SwapRightOutlined.displayName = "SwapRightOutlined";
    const SwapRightOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(SwapRightOutlined);
    function getPlaceholder(locale2, picker, customizePlaceholder) {
      if (customizePlaceholder !== void 0) {
        return customizePlaceholder;
      }
      if (picker === "year" && locale2.lang.yearPlaceholder) {
        return locale2.lang.yearPlaceholder;
      }
      if (picker === "quarter" && locale2.lang.quarterPlaceholder) {
        return locale2.lang.quarterPlaceholder;
      }
      if (picker === "month" && locale2.lang.monthPlaceholder) {
        return locale2.lang.monthPlaceholder;
      }
      if (picker === "week" && locale2.lang.weekPlaceholder) {
        return locale2.lang.weekPlaceholder;
      }
      if (picker === "time" && locale2.timePickerLocale.placeholder) {
        return locale2.timePickerLocale.placeholder;
      }
      return locale2.lang.placeholder;
    }
    function getRangePlaceholder(locale2, picker, customizePlaceholder) {
      if (customizePlaceholder !== void 0) {
        return customizePlaceholder;
      }
      if (picker === "year" && locale2.lang.yearPlaceholder) {
        return locale2.lang.rangeYearPlaceholder;
      }
      if (picker === "quarter" && locale2.lang.quarterPlaceholder) {
        return locale2.lang.rangeQuarterPlaceholder;
      }
      if (picker === "month" && locale2.lang.monthPlaceholder) {
        return locale2.lang.rangeMonthPlaceholder;
      }
      if (picker === "week" && locale2.lang.weekPlaceholder) {
        return locale2.lang.rangeWeekPlaceholder;
      }
      if (picker === "time" && locale2.timePickerLocale.placeholder) {
        return locale2.timePickerLocale.rangePlaceholder;
      }
      return locale2.lang.rangePlaceholder;
    }
    function transPlacement2DropdownAlign(direction, placement) {
      const overflow = {
        adjustX: 1,
        adjustY: 1
      };
      switch (placement) {
        case "bottomLeft": {
          return {
            points: ["tl", "bl"],
            offset: [0, 4],
            overflow
          };
        }
        case "bottomRight": {
          return {
            points: ["tr", "br"],
            offset: [0, 4],
            overflow
          };
        }
        case "topLeft": {
          return {
            points: ["bl", "tl"],
            offset: [0, -4],
            overflow
          };
        }
        case "topRight": {
          return {
            points: ["br", "tr"],
            offset: [0, -4],
            overflow
          };
        }
        default: {
          return {
            points: direction === "rtl" ? ["tr", "br"] : ["tl", "bl"],
            offset: [0, 4],
            overflow
          };
        }
      }
    }
    var __rest$v = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function generateRangePicker(generateConfig2) {
      const RangePicker2 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
        const {
          prefixCls: customizePrefixCls,
          getPopupContainer: customGetPopupContainer,
          className,
          placement,
          size: customizeSize,
          disabled: customDisabled,
          bordered = true,
          placeholder,
          popupClassName,
          dropdownClassName,
          status: customStatus
        } = props, restProps = __rest$v(props, ["prefixCls", "getPopupContainer", "className", "placement", "size", "disabled", "bordered", "placeholder", "popupClassName", "dropdownClassName", "status"]);
        const innerRef = reactExports.useRef(null);
        const {
          getPrefixCls,
          direction,
          getPopupContainer
        } = reactExports.useContext(ConfigContext);
        const prefixCls = getPrefixCls("picker", customizePrefixCls);
        const {
          compactSize,
          compactItemClassnames
        } = useCompactItemContext(prefixCls, direction);
        const {
          format: format2,
          showTime,
          picker
        } = props;
        const rootPrefixCls = getPrefixCls();
        const [wrapSSR, hashId] = useStyle$k(prefixCls);
        let additionalOverrideProps = {};
        additionalOverrideProps = Object.assign(Object.assign(Object.assign({}, additionalOverrideProps), showTime ? getTimeProps(Object.assign({
          format: format2,
          picker
        }, showTime)) : {}), picker === "time" ? getTimeProps(Object.assign(Object.assign({
          format: format2
        }, props), {
          picker
        })) : {});
        const size = reactExports.useContext(SizeContext$2);
        const mergedSize = compactSize || customizeSize || size;
        const disabled = reactExports.useContext(DisabledContext$1);
        const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
        const formItemContext = reactExports.useContext(FormItemInputContext);
        const {
          hasFeedback,
          status: contextStatus,
          feedbackIcon
        } = formItemContext;
        const suffixNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, picker === "time" ? /* @__PURE__ */ reactExports.createElement(ClockCircleOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(CalendarOutlined$1, null), hasFeedback && feedbackIcon);
        reactExports.useImperativeHandle(ref, () => ({
          focus: () => {
            var _a;
            return (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
          },
          blur: () => {
            var _a;
            return (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.blur();
          }
        }));
        const [contextLocale] = useLocale$1("Calendar", enUS);
        const locale2 = Object.assign(Object.assign({}, contextLocale), props.locale);
        return wrapSSR(/* @__PURE__ */ reactExports.createElement(RangePicker$1, Object.assign({
          separator: /* @__PURE__ */ reactExports.createElement("span", {
            "aria-label": "to",
            className: `${prefixCls}-separator`
          }, /* @__PURE__ */ reactExports.createElement(SwapRightOutlined$1, null)),
          disabled: mergedDisabled,
          ref: innerRef,
          dropdownAlign: transPlacement2DropdownAlign(direction, placement),
          placeholder: getRangePlaceholder(locale2, picker, placeholder),
          suffixIcon: suffixNode,
          clearIcon: /* @__PURE__ */ reactExports.createElement(CloseCircleFilled$1, null),
          prevIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-prev-icon`
          }),
          nextIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-next-icon`
          }),
          superPrevIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-super-prev-icon`
          }),
          superNextIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-super-next-icon`
          }),
          allowClear: true,
          transitionName: `${rootPrefixCls}-slide-up`
        }, restProps, additionalOverrideProps, {
          className: classNames({
            [`${prefixCls}-${mergedSize}`]: mergedSize,
            [`${prefixCls}-borderless`]: !bordered
          }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), hashId, compactItemClassnames, className),
          locale: locale2.lang,
          prefixCls,
          getPopupContainer: customGetPopupContainer || getPopupContainer,
          generateConfig: generateConfig2,
          components: Components,
          direction,
          dropdownClassName: classNames(hashId, popupClassName || dropdownClassName)
        })));
      });
      return RangePicker2;
    }
    var __rest$u = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function generatePicker$1(generateConfig2) {
      function getPicker(picker, displayName) {
        const Picker$1 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
          const {
            prefixCls: customizePrefixCls,
            getPopupContainer: customizeGetPopupContainer,
            className,
            rootClassName,
            size: customizeSize,
            bordered = true,
            placement,
            placeholder,
            popupClassName,
            dropdownClassName,
            disabled: customDisabled,
            status: customStatus
          } = props, restProps = __rest$u(props, ["prefixCls", "getPopupContainer", "className", "rootClassName", "size", "bordered", "placement", "placeholder", "popupClassName", "dropdownClassName", "disabled", "status"]);
          const {
            getPrefixCls,
            direction,
            getPopupContainer
          } = reactExports.useContext(ConfigContext);
          const prefixCls = getPrefixCls("picker", customizePrefixCls);
          const {
            compactSize,
            compactItemClassnames
          } = useCompactItemContext(prefixCls, direction);
          const innerRef = reactExports.useRef(null);
          const {
            format: format2,
            showTime
          } = props;
          const [wrapSSR, hashId] = useStyle$k(prefixCls);
          reactExports.useImperativeHandle(ref, () => ({
            focus: () => {
              var _a;
              return (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            },
            blur: () => {
              var _a;
              return (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.blur();
            }
          }));
          const additionalProps = {
            showToday: true
          };
          let additionalOverrideProps = {};
          if (picker) {
            additionalOverrideProps.picker = picker;
          }
          const mergedPicker = picker || props.picker;
          additionalOverrideProps = Object.assign(Object.assign(Object.assign({}, additionalOverrideProps), showTime ? getTimeProps(Object.assign({
            format: format2,
            picker: mergedPicker
          }, showTime)) : {}), mergedPicker === "time" ? getTimeProps(Object.assign(Object.assign({
            format: format2
          }, props), {
            picker: mergedPicker
          })) : {});
          const rootPrefixCls = getPrefixCls();
          const size = reactExports.useContext(SizeContext$2);
          const mergedSize = compactSize || customizeSize || size;
          const disabled = reactExports.useContext(DisabledContext$1);
          const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
          const formItemContext = reactExports.useContext(FormItemInputContext);
          const {
            hasFeedback,
            status: contextStatus,
            feedbackIcon
          } = formItemContext;
          const suffixNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, mergedPicker === "time" ? /* @__PURE__ */ reactExports.createElement(ClockCircleOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(CalendarOutlined$1, null), hasFeedback && feedbackIcon);
          const [contextLocale] = useLocale$1("DatePicker", enUS);
          const locale2 = Object.assign(Object.assign({}, contextLocale), props.locale);
          return wrapSSR(/* @__PURE__ */ reactExports.createElement(Picker, Object.assign({
            ref: innerRef,
            placeholder: getPlaceholder(locale2, mergedPicker, placeholder),
            suffixIcon: suffixNode,
            dropdownAlign: transPlacement2DropdownAlign(direction, placement),
            clearIcon: /* @__PURE__ */ reactExports.createElement(CloseCircleFilled$1, null),
            prevIcon: /* @__PURE__ */ reactExports.createElement("span", {
              className: `${prefixCls}-prev-icon`
            }),
            nextIcon: /* @__PURE__ */ reactExports.createElement("span", {
              className: `${prefixCls}-next-icon`
            }),
            superPrevIcon: /* @__PURE__ */ reactExports.createElement("span", {
              className: `${prefixCls}-super-prev-icon`
            }),
            superNextIcon: /* @__PURE__ */ reactExports.createElement("span", {
              className: `${prefixCls}-super-next-icon`
            }),
            allowClear: true,
            transitionName: `${rootPrefixCls}-slide-up`
          }, additionalProps, restProps, additionalOverrideProps, {
            locale: locale2.lang,
            className: classNames({
              [`${prefixCls}-${mergedSize}`]: mergedSize,
              [`${prefixCls}-borderless`]: !bordered
            }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), hashId, compactItemClassnames, className, rootClassName),
            prefixCls,
            getPopupContainer: customizeGetPopupContainer || getPopupContainer,
            generateConfig: generateConfig2,
            components: Components,
            direction,
            disabled: mergedDisabled,
            dropdownClassName: classNames(hashId, rootClassName, popupClassName || dropdownClassName)
          })));
        });
        if (displayName) {
          Picker$1.displayName = displayName;
        }
        return Picker$1;
      }
      const DatePicker2 = getPicker();
      const WeekPicker = getPicker("week", "WeekPicker");
      const MonthPicker = getPicker("month", "MonthPicker");
      const YearPicker = getPicker("year", "YearPicker");
      const TimePicker2 = getPicker("time", "TimePicker");
      const QuarterPicker = getPicker("quarter", "QuarterPicker");
      return {
        DatePicker: DatePicker2,
        WeekPicker,
        MonthPicker,
        YearPicker,
        TimePicker: TimePicker2,
        QuarterPicker
      };
    }
    const Components = {
      button: PickerButton
    };
    function toArray$3(list2) {
      if (!list2) {
        return [];
      }
      return Array.isArray(list2) ? list2 : [list2];
    }
    function getTimeProps(props) {
      const {
        format: format2,
        picker,
        showHour,
        showMinute,
        showSecond,
        use12Hours
      } = props;
      const firstFormat = toArray$3(format2)[0];
      const showTimeObj = Object.assign({}, props);
      if (firstFormat && typeof firstFormat === "string") {
        if (!firstFormat.includes("s") && showSecond === void 0) {
          showTimeObj.showSecond = false;
        }
        if (!firstFormat.includes("m") && showMinute === void 0) {
          showTimeObj.showMinute = false;
        }
        if (!firstFormat.includes("H") && !firstFormat.includes("h") && showHour === void 0) {
          showTimeObj.showHour = false;
        }
        if ((firstFormat.includes("a") || firstFormat.includes("A")) && use12Hours === void 0) {
          showTimeObj.use12Hours = true;
        }
      }
      if (picker === "time") {
        return showTimeObj;
      }
      if (typeof firstFormat === "function") {
        delete showTimeObj.format;
      }
      return {
        showTime: showTimeObj
      };
    }
    function generatePicker(generateConfig2) {
      const {
        DatePicker: DatePicker2,
        WeekPicker,
        MonthPicker,
        YearPicker,
        TimePicker: TimePicker2,
        QuarterPicker
      } = generatePicker$1(generateConfig2);
      const RangePicker2 = generateRangePicker(generateConfig2);
      const MergedDatePicker = DatePicker2;
      MergedDatePicker.WeekPicker = WeekPicker;
      MergedDatePicker.MonthPicker = MonthPicker;
      MergedDatePicker.YearPicker = YearPicker;
      MergedDatePicker.RangePicker = RangePicker2;
      MergedDatePicker.TimePicker = TimePicker2;
      MergedDatePicker.QuarterPicker = QuarterPicker;
      return MergedDatePicker;
    }
    const DatePicker = generatePicker(generateConfig);
    const PurePanel$3 = genPurePanel(DatePicker, "picker");
    DatePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$3;
    const PureRangePanel = genPurePanel(DatePicker.RangePicker, "picker");
    DatePicker._InternalRangePanelDoNotUseOrYouWillBeFired = PureRangePanel;
    const DatePicker$1 = DatePicker;
    const genSharedDividerStyle = (token2) => {
      const {
        componentCls,
        sizePaddingEdgeHorizontal,
        colorSplit,
        lineWidth
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
          borderBlockStart: `${lineWidth}px solid ${colorSplit}`,
          // vertical
          "&-vertical": {
            position: "relative",
            top: "-0.06em",
            display: "inline-block",
            height: "0.9em",
            margin: `0 ${token2.dividerVerticalGutterMargin}px`,
            verticalAlign: "middle",
            borderTop: 0,
            borderInlineStart: `${lineWidth}px solid ${colorSplit}`
          },
          "&-horizontal": {
            display: "flex",
            clear: "both",
            width: "100%",
            minWidth: "100%",
            margin: `${token2.dividerHorizontalGutterMargin}px 0`
          },
          [`&-horizontal${componentCls}-with-text`]: {
            display: "flex",
            alignItems: "center",
            margin: `${token2.dividerHorizontalWithTextGutterMargin}px 0`,
            color: token2.colorTextHeading,
            fontWeight: 500,
            fontSize: token2.fontSizeLG,
            whiteSpace: "nowrap",
            textAlign: "center",
            borderBlockStart: `0 ${colorSplit}`,
            "&::before, &::after": {
              position: "relative",
              width: "50%",
              borderBlockStart: `${lineWidth}px solid transparent`,
              // Chrome not accept `inherit` in `border-top`
              borderBlockStartColor: "inherit",
              borderBlockEnd: 0,
              transform: "translateY(50%)",
              content: "''"
            }
          },
          [`&-horizontal${componentCls}-with-text-left`]: {
            "&::before": {
              width: "5%"
            },
            "&::after": {
              width: "95%"
            }
          },
          [`&-horizontal${componentCls}-with-text-right`]: {
            "&::before": {
              width: "95%"
            },
            "&::after": {
              width: "5%"
            }
          },
          [`${componentCls}-inner-text`]: {
            display: "inline-block",
            padding: "0 1em"
          },
          "&-dashed": {
            background: "none",
            borderColor: colorSplit,
            borderStyle: "dashed",
            borderWidth: `${lineWidth}px 0 0`
          },
          [`&-horizontal${componentCls}-with-text${componentCls}-dashed`]: {
            "&::before, &::after": {
              borderStyle: "dashed none none"
            }
          },
          [`&-vertical${componentCls}-dashed`]: {
            borderInlineStart: lineWidth,
            borderInlineEnd: 0,
            borderBlockStart: 0,
            borderBlockEnd: 0
          },
          [`&-plain${componentCls}-with-text`]: {
            color: token2.colorText,
            fontWeight: "normal",
            fontSize: token2.fontSize
          },
          [`&-horizontal${componentCls}-with-text-left${componentCls}-no-default-orientation-margin-left`]: {
            "&::before": {
              width: 0
            },
            "&::after": {
              width: "100%"
            },
            [`${componentCls}-inner-text`]: {
              paddingInlineStart: sizePaddingEdgeHorizontal
            }
          },
          [`&-horizontal${componentCls}-with-text-right${componentCls}-no-default-orientation-margin-right`]: {
            "&::before": {
              width: "100%"
            },
            "&::after": {
              width: 0
            },
            [`${componentCls}-inner-text`]: {
              paddingInlineEnd: sizePaddingEdgeHorizontal
            }
          }
        })
      };
    };
    const useStyle$f = genComponentStyleHook("Divider", (token2) => {
      const dividerToken = merge$4(token2, {
        dividerVerticalGutterMargin: token2.marginXS,
        dividerHorizontalWithTextGutterMargin: token2.margin,
        dividerHorizontalGutterMargin: token2.marginLG
      });
      return [genSharedDividerStyle(dividerToken)];
    }, {
      sizePaddingEdgeHorizontal: 0
    });
    var __rest$t = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Divider = (props) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        type: type2 = "horizontal",
        orientation = "center",
        orientationMargin,
        className,
        rootClassName,
        children,
        dashed,
        plain: plain2
      } = props, restProps = __rest$t(props, ["prefixCls", "type", "orientation", "orientationMargin", "className", "rootClassName", "children", "dashed", "plain"]);
      const prefixCls = getPrefixCls("divider", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$f(prefixCls);
      const orientationPrefix = orientation.length > 0 ? `-${orientation}` : orientation;
      const hasChildren = !!children;
      const hasCustomMarginLeft = orientation === "left" && orientationMargin != null;
      const hasCustomMarginRight = orientation === "right" && orientationMargin != null;
      const classString = classNames(prefixCls, hashId, `${prefixCls}-${type2}`, {
        [`${prefixCls}-with-text`]: hasChildren,
        [`${prefixCls}-with-text${orientationPrefix}`]: hasChildren,
        [`${prefixCls}-dashed`]: !!dashed,
        [`${prefixCls}-plain`]: !!plain2,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-no-default-orientation-margin-left`]: hasCustomMarginLeft,
        [`${prefixCls}-no-default-orientation-margin-right`]: hasCustomMarginRight
      }, className, rootClassName);
      const innerStyle = Object.assign(Object.assign({}, hasCustomMarginLeft && {
        marginLeft: orientationMargin
      }), hasCustomMarginRight && {
        marginRight: orientationMargin
      });
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        className: classString
      }, restProps, {
        role: "separator"
      }), children && type2 !== "vertical" && /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-inner-text`,
        style: innerStyle
      }, children)));
    };
    const Divider$1 = Divider;
    var DrawerPanel$1 = function DrawerPanel2(props) {
      var prefixCls = props.prefixCls, className = props.className, style2 = props.style, children = props.children, containerRef = props.containerRef;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-content"), className),
        style: _objectSpread2$3({}, style2),
        "aria-modal": "true",
        role: "dialog",
        ref: containerRef
      }, children));
    };
    var DrawerContext = /* @__PURE__ */ reactExports.createContext(null);
    function parseWidthHeight(value) {
      if (typeof value === "string" && String(Number(value)) === value) {
        warningOnce$1(false, "Invalid value type of `width` or `height` which should be number type instead.");
        return Number(value);
      }
      return value;
    }
    var sentinelStyle = {
      width: 0,
      height: 0,
      overflow: "hidden",
      outline: "none",
      position: "absolute"
    };
    function DrawerPopup(props, ref) {
      var _ref, _pushConfig$distance, _pushConfig, _classNames;
      var prefixCls = props.prefixCls, open2 = props.open, placement = props.placement, inline2 = props.inline, push2 = props.push, forceRender = props.forceRender, autoFocus = props.autoFocus, keyboard = props.keyboard, rootClassName = props.rootClassName, rootStyle = props.rootStyle, zIndex = props.zIndex, className = props.className, style2 = props.style, motion2 = props.motion, width = props.width, height = props.height, children = props.children, contentWrapperStyle = props.contentWrapperStyle, mask = props.mask, maskClosable = props.maskClosable, maskMotion = props.maskMotion, maskClassName = props.maskClassName, maskStyle = props.maskStyle, afterOpenChange = props.afterOpenChange, onClose = props.onClose;
      var panelRef = reactExports.useRef();
      var sentinelStartRef = reactExports.useRef();
      var sentinelEndRef = reactExports.useRef();
      reactExports.useImperativeHandle(ref, function() {
        return panelRef.current;
      });
      var onPanelKeyDown = function onPanelKeyDown2(event) {
        var keyCode = event.keyCode, shiftKey = event.shiftKey;
        switch (keyCode) {
          case KeyCode.TAB: {
            if (keyCode === KeyCode.TAB) {
              if (!shiftKey && document.activeElement === sentinelEndRef.current) {
                var _sentinelStartRef$cur;
                (_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 ? void 0 : _sentinelStartRef$cur.focus({
                  preventScroll: true
                });
              } else if (shiftKey && document.activeElement === sentinelStartRef.current) {
                var _sentinelEndRef$curre;
                (_sentinelEndRef$curre = sentinelEndRef.current) === null || _sentinelEndRef$curre === void 0 ? void 0 : _sentinelEndRef$curre.focus({
                  preventScroll: true
                });
              }
            }
            break;
          }
          case KeyCode.ESC: {
            if (onClose && keyboard) {
              event.stopPropagation();
              onClose(event);
            }
            break;
          }
        }
      };
      reactExports.useEffect(function() {
        if (open2 && autoFocus) {
          var _panelRef$current;
          (_panelRef$current = panelRef.current) === null || _panelRef$current === void 0 ? void 0 : _panelRef$current.focus({
            preventScroll: true
          });
        }
      }, [open2]);
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), pushed = _React$useState2[0], setPushed = _React$useState2[1];
      var parentContext = reactExports.useContext(DrawerContext);
      var pushConfig;
      if (push2 === false) {
        pushConfig = {
          distance: 0
        };
      } else if (push2 === true) {
        pushConfig = {};
      } else {
        pushConfig = push2 || {};
      }
      var pushDistance = (_ref = (_pushConfig$distance = (_pushConfig = pushConfig) === null || _pushConfig === void 0 ? void 0 : _pushConfig.distance) !== null && _pushConfig$distance !== void 0 ? _pushConfig$distance : parentContext === null || parentContext === void 0 ? void 0 : parentContext.pushDistance) !== null && _ref !== void 0 ? _ref : 180;
      var mergedContext = reactExports.useMemo(function() {
        return {
          pushDistance,
          push: function push3() {
            setPushed(true);
          },
          pull: function pull() {
            setPushed(false);
          }
        };
      }, [pushDistance]);
      reactExports.useEffect(function() {
        if (open2) {
          var _parentContext$push;
          parentContext === null || parentContext === void 0 ? void 0 : (_parentContext$push = parentContext.push) === null || _parentContext$push === void 0 ? void 0 : _parentContext$push.call(parentContext);
        } else {
          var _parentContext$pull;
          parentContext === null || parentContext === void 0 ? void 0 : (_parentContext$pull = parentContext.pull) === null || _parentContext$pull === void 0 ? void 0 : _parentContext$pull.call(parentContext);
        }
      }, [open2]);
      reactExports.useEffect(function() {
        return function() {
          var _parentContext$pull2;
          parentContext === null || parentContext === void 0 ? void 0 : (_parentContext$pull2 = parentContext.pull) === null || _parentContext$pull2 === void 0 ? void 0 : _parentContext$pull2.call(parentContext);
        };
      }, []);
      var maskNode = mask && /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$2({
        key: "mask"
      }, maskMotion, {
        visible: open2
      }), function(_ref2, maskRef) {
        var motionMaskClassName = _ref2.className, motionMaskStyle = _ref2.style;
        return /* @__PURE__ */ reactExports.createElement("div", {
          className: classNames("".concat(prefixCls, "-mask"), motionMaskClassName, maskClassName),
          style: _objectSpread2$3(_objectSpread2$3({}, motionMaskStyle), maskStyle),
          onClick: maskClosable && open2 ? onClose : void 0,
          ref: maskRef
        });
      });
      var motionProps = typeof motion2 === "function" ? motion2(placement) : motion2;
      var wrapperStyle = {};
      if (pushed && pushDistance) {
        switch (placement) {
          case "top":
            wrapperStyle.transform = "translateY(".concat(pushDistance, "px)");
            break;
          case "bottom":
            wrapperStyle.transform = "translateY(".concat(-pushDistance, "px)");
            break;
          case "left":
            wrapperStyle.transform = "translateX(".concat(pushDistance, "px)");
            break;
          default:
            wrapperStyle.transform = "translateX(".concat(-pushDistance, "px)");
            break;
        }
      }
      if (placement === "left" || placement === "right") {
        wrapperStyle.width = parseWidthHeight(width);
      } else {
        wrapperStyle.height = parseWidthHeight(height);
      }
      var panelNode = /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$2({
        key: "panel"
      }, motionProps, {
        visible: open2,
        forceRender,
        onVisibleChanged: function onVisibleChanged(nextVisible) {
          afterOpenChange === null || afterOpenChange === void 0 ? void 0 : afterOpenChange(nextVisible);
        },
        removeOnLeave: false,
        leavedClassName: "".concat(prefixCls, "-content-wrapper-hidden")
      }), function(_ref3, motionRef) {
        var motionClassName = _ref3.className, motionStyle = _ref3.style;
        return /* @__PURE__ */ reactExports.createElement("div", {
          className: classNames("".concat(prefixCls, "-content-wrapper"), motionClassName),
          style: _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, wrapperStyle), motionStyle), contentWrapperStyle)
        }, /* @__PURE__ */ reactExports.createElement(DrawerPanel$1, {
          containerRef: motionRef,
          prefixCls,
          className,
          style: style2
        }, children));
      });
      var containerStyle2 = _objectSpread2$3({}, rootStyle);
      if (zIndex) {
        containerStyle2.zIndex = zIndex;
      }
      return /* @__PURE__ */ reactExports.createElement(DrawerContext.Provider, {
        value: mergedContext
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(prefixCls, "".concat(prefixCls, "-").concat(placement), rootClassName, (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-open"), open2), _defineProperty$7(_classNames, "".concat(prefixCls, "-inline"), inline2), _classNames)),
        style: containerStyle2,
        tabIndex: -1,
        ref: panelRef,
        onKeyDown: onPanelKeyDown
      }, maskNode, /* @__PURE__ */ reactExports.createElement("div", {
        tabIndex: 0,
        ref: sentinelStartRef,
        style: sentinelStyle,
        "aria-hidden": "true",
        "data-sentinel": "start"
      }), panelNode, /* @__PURE__ */ reactExports.createElement("div", {
        tabIndex: 0,
        ref: sentinelEndRef,
        style: sentinelStyle,
        "aria-hidden": "true",
        "data-sentinel": "end"
      })));
    }
    var RefDrawerPopup = /* @__PURE__ */ reactExports.forwardRef(DrawerPopup);
    var Drawer$1 = function Drawer2(props) {
      var _props$open = props.open, open2 = _props$open === void 0 ? false : _props$open, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-drawer" : _props$prefixCls, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$width = props.width, width = _props$width === void 0 ? 378 : _props$width, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getContainer2 = props.getContainer, forceRender = props.forceRender, afterOpenChange = props.afterOpenChange, destroyOnClose = props.destroyOnClose;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
      var panelRef = reactExports.useRef();
      var lastActiveRef = reactExports.useRef();
      useLayoutEffect$1(function() {
        if (open2) {
          lastActiveRef.current = document.activeElement;
        }
      }, [open2]);
      var internalAfterOpenChange = function internalAfterOpenChange2(nextVisible) {
        var _panelRef$current;
        setAnimatedVisible(nextVisible);
        afterOpenChange === null || afterOpenChange === void 0 ? void 0 : afterOpenChange(nextVisible);
        if (!nextVisible && lastActiveRef.current && !((_panelRef$current = panelRef.current) === null || _panelRef$current === void 0 ? void 0 : _panelRef$current.contains(lastActiveRef.current))) {
          var _lastActiveRef$curren;
          (_lastActiveRef$curren = lastActiveRef.current) === null || _lastActiveRef$curren === void 0 ? void 0 : _lastActiveRef$curren.focus();
        }
      };
      if (!forceRender && !animatedVisible && !open2 && destroyOnClose) {
        return null;
      }
      var drawerPopupProps = _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        open: open2,
        prefixCls,
        placement,
        autoFocus,
        keyboard,
        width,
        mask,
        maskClosable,
        inline: getContainer2 === false,
        afterOpenChange: internalAfterOpenChange,
        ref: panelRef
      });
      return /* @__PURE__ */ reactExports.createElement(Portal$1, {
        open: open2 || forceRender || animatedVisible,
        autoDestroy: false,
        getContainer: getContainer2,
        autoLock: mask && (open2 || animatedVisible)
      }, /* @__PURE__ */ reactExports.createElement(RefDrawerPopup, drawerPopupProps));
    };
    function DrawerPanel(props) {
      const {
        prefixCls,
        title,
        footer: footer2,
        extra,
        closable = true,
        closeIcon = /* @__PURE__ */ reactExports.createElement(CloseOutlined$1, null),
        onClose,
        headerStyle,
        drawerStyle,
        bodyStyle,
        footerStyle,
        children
      } = props;
      const closeIconNode = closable && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onClose,
        "aria-label": "Close",
        className: `${prefixCls}-close`
      }, closeIcon);
      function renderHeader() {
        if (!title && !closable) {
          return null;
        }
        return /* @__PURE__ */ reactExports.createElement("div", {
          className: classNames(`${prefixCls}-header`, {
            [`${prefixCls}-header-close-only`]: closable && !title && !extra
          }),
          style: headerStyle
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-header-title`
        }, closeIconNode, title && /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-title`
        }, title)), extra && /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-extra`
        }, extra));
      }
      function renderFooter2() {
        if (!footer2) {
          return null;
        }
        const footerClassName = `${prefixCls}-footer`;
        return /* @__PURE__ */ reactExports.createElement("div", {
          className: footerClassName,
          style: footerStyle
        }, footer2);
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-wrapper-body`,
        style: Object.assign({}, drawerStyle)
      }, renderHeader(), /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-body`,
        style: bodyStyle
      }, children), renderFooter2());
    }
    const genMotionStyle$2 = (token2) => {
      const {
        componentCls,
        motionDurationSlow
      } = token2;
      const sharedPanelMotion = {
        "&-enter, &-appear, &-leave": {
          "&-start": {
            transition: "none"
          },
          "&-active": {
            transition: `all ${motionDurationSlow}`
          }
        }
      };
      return {
        [componentCls]: {
          // ======================== Mask ========================
          [`${componentCls}-mask-motion`]: {
            "&-enter, &-appear, &-leave": {
              "&-active": {
                transition: `all ${motionDurationSlow}`
              }
            },
            "&-enter, &-appear": {
              opacity: 0,
              "&-active": {
                opacity: 1
              }
            },
            "&-leave": {
              opacity: 1,
              "&-active": {
                opacity: 0
              }
            }
          },
          // ======================= Panel ========================
          [`${componentCls}-panel-motion`]: {
            // Left
            "&-left": [sharedPanelMotion, {
              "&-enter, &-appear": {
                "&-start": {
                  transform: "translateX(-100%) !important"
                },
                "&-active": {
                  transform: "translateX(0)"
                }
              },
              "&-leave": {
                transform: "translateX(0)",
                "&-active": {
                  transform: "translateX(-100%)"
                }
              }
            }],
            // Right
            "&-right": [sharedPanelMotion, {
              "&-enter, &-appear": {
                "&-start": {
                  transform: "translateX(100%) !important"
                },
                "&-active": {
                  transform: "translateX(0)"
                }
              },
              "&-leave": {
                transform: "translateX(0)",
                "&-active": {
                  transform: "translateX(100%)"
                }
              }
            }],
            // Top
            "&-top": [sharedPanelMotion, {
              "&-enter, &-appear": {
                "&-start": {
                  transform: "translateY(-100%) !important"
                },
                "&-active": {
                  transform: "translateY(0)"
                }
              },
              "&-leave": {
                transform: "translateY(0)",
                "&-active": {
                  transform: "translateY(-100%)"
                }
              }
            }],
            // Bottom
            "&-bottom": [sharedPanelMotion, {
              "&-enter, &-appear": {
                "&-start": {
                  transform: "translateY(100%) !important"
                },
                "&-active": {
                  transform: "translateY(0)"
                }
              },
              "&-leave": {
                transform: "translateY(0)",
                "&-active": {
                  transform: "translateY(100%)"
                }
              }
            }]
          }
        }
      };
    };
    const genMotionStyle$3 = genMotionStyle$2;
    const genDrawerStyle = (token2) => {
      const {
        componentCls,
        zIndexPopup,
        colorBgMask,
        colorBgElevated,
        motionDurationSlow,
        motionDurationMid,
        padding,
        paddingLG,
        fontSizeLG,
        lineHeightLG,
        lineWidth,
        lineType,
        colorSplit,
        marginSM,
        colorIcon,
        colorIconHover,
        colorText,
        fontWeightStrong,
        drawerFooterPaddingVertical,
        drawerFooterPaddingHorizontal
      } = token2;
      const wrapperCls = `${componentCls}-content-wrapper`;
      return {
        [componentCls]: {
          position: "fixed",
          inset: 0,
          zIndex: zIndexPopup,
          pointerEvents: "none",
          "&-pure": {
            position: "relative",
            background: colorBgElevated,
            [`&${componentCls}-left`]: {
              boxShadow: token2.boxShadowDrawerLeft
            },
            [`&${componentCls}-right`]: {
              boxShadow: token2.boxShadowDrawerRight
            },
            [`&${componentCls}-top`]: {
              boxShadow: token2.boxShadowDrawerUp
            },
            [`&${componentCls}-bottom`]: {
              boxShadow: token2.boxShadowDrawerDown
            }
          },
          "&-inline": {
            position: "absolute"
          },
          // ====================== Mask ======================
          [`${componentCls}-mask`]: {
            position: "absolute",
            inset: 0,
            zIndex: zIndexPopup,
            background: colorBgMask,
            pointerEvents: "auto"
          },
          // ==================== Content =====================
          [wrapperCls]: {
            position: "absolute",
            zIndex: zIndexPopup,
            transition: `all ${motionDurationSlow}`,
            "&-hidden": {
              display: "none"
            }
          },
          // Placement
          [`&-left > ${wrapperCls}`]: {
            top: 0,
            bottom: 0,
            left: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token2.boxShadowDrawerLeft
          },
          [`&-right > ${wrapperCls}`]: {
            top: 0,
            right: {
              _skip_check_: true,
              value: 0
            },
            bottom: 0,
            boxShadow: token2.boxShadowDrawerRight
          },
          [`&-top > ${wrapperCls}`]: {
            top: 0,
            insetInline: 0,
            boxShadow: token2.boxShadowDrawerUp
          },
          [`&-bottom > ${wrapperCls}`]: {
            bottom: 0,
            insetInline: 0,
            boxShadow: token2.boxShadowDrawerDown
          },
          [`${componentCls}-content`]: {
            width: "100%",
            height: "100%",
            overflow: "auto",
            background: colorBgElevated,
            pointerEvents: "auto"
          },
          // ===================== Panel ======================
          [`${componentCls}-wrapper-body`]: {
            display: "flex",
            flexDirection: "column",
            width: "100%",
            height: "100%"
          },
          // Header
          [`${componentCls}-header`]: {
            display: "flex",
            flex: 0,
            alignItems: "center",
            padding: `${padding}px ${paddingLG}px`,
            fontSize: fontSizeLG,
            lineHeight: lineHeightLG,
            borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
            "&-title": {
              display: "flex",
              flex: 1,
              alignItems: "center",
              minWidth: 0,
              minHeight: 0
            }
          },
          [`${componentCls}-extra`]: {
            flex: "none"
          },
          [`${componentCls}-close`]: {
            display: "inline-block",
            marginInlineEnd: marginSM,
            color: colorIcon,
            fontWeight: fontWeightStrong,
            fontSize: fontSizeLG,
            fontStyle: "normal",
            lineHeight: 1,
            textAlign: "center",
            textTransform: "none",
            textDecoration: "none",
            background: "transparent",
            border: 0,
            outline: 0,
            cursor: "pointer",
            transition: `color ${motionDurationMid}`,
            textRendering: "auto",
            "&:focus, &:hover": {
              color: colorIconHover,
              textDecoration: "none"
            }
          },
          [`${componentCls}-title`]: {
            flex: 1,
            margin: 0,
            color: colorText,
            fontWeight: token2.fontWeightStrong,
            fontSize: fontSizeLG,
            lineHeight: lineHeightLG
          },
          // Body
          [`${componentCls}-body`]: {
            flex: 1,
            minWidth: 0,
            minHeight: 0,
            padding: paddingLG,
            overflow: "auto"
          },
          // Footer
          [`${componentCls}-footer`]: {
            flexShrink: 0,
            padding: `${drawerFooterPaddingVertical}px ${drawerFooterPaddingHorizontal}px`,
            borderTop: `${lineWidth}px ${lineType} ${colorSplit}`
          },
          // ====================== RTL =======================
          "&-rtl": {
            direction: "rtl"
          }
        }
      };
    };
    const useStyle$e = genComponentStyleHook("Drawer", (token2) => {
      const drawerToken = merge$4(token2, {
        drawerFooterPaddingVertical: token2.paddingXS,
        drawerFooterPaddingHorizontal: token2.padding
      });
      return [genDrawerStyle(drawerToken), genMotionStyle$3(drawerToken)];
    }, (token2) => ({
      zIndexPopup: token2.zIndexPopupBase
    }));
    var __rest$s = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const defaultPushState = {
      distance: 180
    };
    function Drawer(props) {
      const {
        rootClassName,
        width,
        height,
        size = "default",
        mask = true,
        push: push2 = defaultPushState,
        open: open2,
        afterOpenChange,
        onClose,
        prefixCls: customizePrefixCls,
        getContainer: customizeGetContainer,
        // Deprecated
        visible,
        afterVisibleChange
      } = props, rest = __rest$s(props, ["rootClassName", "width", "height", "size", "mask", "push", "open", "afterOpenChange", "onClose", "prefixCls", "getContainer", "visible", "afterVisibleChange"]);
      const {
        getPopupContainer,
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("drawer", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$e(prefixCls);
      const getContainer2 = (
        // 有可能为 false，所以不能直接判断
        customizeGetContainer === void 0 && getPopupContainer ? () => getPopupContainer(document.body) : customizeGetContainer
      );
      const drawerClassName = classNames({
        "no-mask": !mask,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, rootClassName, hashId);
      const mergedWidth = reactExports.useMemo(() => width !== null && width !== void 0 ? width : size === "large" ? 736 : 378, [width, size]);
      const mergedHeight = reactExports.useMemo(() => height !== null && height !== void 0 ? height : size === "large" ? 736 : 378, [height, size]);
      const maskMotion = {
        motionName: getTransitionName$1(prefixCls, "mask-motion"),
        motionAppear: true,
        motionEnter: true,
        motionLeave: true,
        motionDeadline: 500
      };
      const panelMotion = (motionPlacement) => ({
        motionName: getTransitionName$1(prefixCls, `panel-motion-${motionPlacement}`),
        motionAppear: true,
        motionEnter: true,
        motionLeave: true,
        motionDeadline: 500
      });
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(NoCompactStyle, null, /* @__PURE__ */ reactExports.createElement(NoFormStyle, {
        status: true,
        override: true
      }, /* @__PURE__ */ reactExports.createElement(Drawer$1, Object.assign({
        prefixCls,
        onClose,
        maskMotion,
        motion: panelMotion
      }, rest, {
        open: open2 !== null && open2 !== void 0 ? open2 : visible,
        mask,
        push: push2,
        width: mergedWidth,
        height: mergedHeight,
        rootClassName: drawerClassName,
        getContainer: getContainer2,
        afterOpenChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange
      }), /* @__PURE__ */ reactExports.createElement(DrawerPanel, Object.assign({
        prefixCls
      }, rest, {
        onClose
      }))))));
    }
    function PurePanel$2(_a) {
      var {
        prefixCls: customizePrefixCls,
        style: style2,
        className,
        placement = "right"
      } = _a, restProps = __rest$s(_a, ["prefixCls", "style", "className", "placement"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("drawer", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$e(prefixCls);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(prefixCls, `${prefixCls}-pure`, `${prefixCls}-${placement}`, hashId, className),
        style: style2
      }, /* @__PURE__ */ reactExports.createElement(DrawerPanel, Object.assign({
        prefixCls
      }, restProps))));
    }
    Drawer._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$2;
    function useDebounce(value) {
      const [cacheValue, setCacheValue] = reactExports.useState(value);
      reactExports.useEffect(() => {
        const timeout = setTimeout(() => {
          setCacheValue(value);
        }, value.length ? 0 : 10);
        return () => {
          clearTimeout(timeout);
        };
      }, [value]);
      return cacheValue;
    }
    const genFormValidateMotionStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const helpCls = `${componentCls}-show-help`;
      const helpItemCls = `${componentCls}-show-help-item`;
      return {
        [helpCls]: {
          // Explain holder
          transition: `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
          "&-appear, &-enter": {
            opacity: 0,
            "&-active": {
              opacity: 1
            }
          },
          "&-leave": {
            opacity: 1,
            "&-active": {
              opacity: 0
            }
          },
          // Explain
          [helpItemCls]: {
            overflow: "hidden",
            transition: `height ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     transform ${token2.motionDurationSlow} ${token2.motionEaseInOut} !important`,
            [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
              transform: `translateY(-5px)`,
              opacity: 0,
              [`&-active`]: {
                transform: "translateY(0)",
                opacity: 1
              }
            },
            [`&${helpItemCls}-leave-active`]: {
              transform: `translateY(-5px)`
            }
          }
        }
      };
    };
    const genFormValidateMotionStyle$1 = genFormValidateMotionStyle;
    const resetForm = (token2) => ({
      legend: {
        display: "block",
        width: "100%",
        marginBottom: token2.marginLG,
        padding: 0,
        color: token2.colorTextDescription,
        fontSize: token2.fontSizeLG,
        lineHeight: "inherit",
        border: 0,
        borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
      },
      label: {
        fontSize: token2.fontSize
      },
      'input[type="search"]': {
        boxSizing: "border-box"
      },
      // Position radios and checkboxes better
      'input[type="radio"], input[type="checkbox"]': {
        lineHeight: "normal"
      },
      'input[type="file"]': {
        display: "block"
      },
      // Make range inputs behave like textual form controls
      'input[type="range"]': {
        display: "block",
        width: "100%"
      },
      // Make multiple select elements height not fixed
      "select[multiple], select[size]": {
        height: "auto"
      },
      // Focus for file, radio, and checkbox
      [`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
        outline: 0,
        boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`
      },
      // Adjust output element
      output: {
        display: "block",
        paddingTop: 15,
        color: token2.colorText,
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight
      }
    });
    const genFormSize = (token2, height) => {
      const {
        formItemCls
      } = token2;
      return {
        [formItemCls]: {
          [`${formItemCls}-label > label`]: {
            height
          },
          [`${formItemCls}-control-input`]: {
            minHeight: height
          }
        }
      };
    };
    const genFormStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [token2.componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), resetForm(token2)), {
          [`${componentCls}-text`]: {
            display: "inline-block",
            paddingInlineEnd: token2.paddingSM
          },
          // ================================================================
          // =                             Size                             =
          // ================================================================
          "&-small": Object.assign({}, genFormSize(token2, token2.controlHeightSM)),
          "&-large": Object.assign({}, genFormSize(token2, token2.controlHeightLG))
        })
      };
    };
    const genFormItemStyle = (token2) => {
      const {
        formItemCls,
        iconCls,
        componentCls,
        rootPrefixCls
      } = token2;
      return {
        [formItemCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
          marginBottom: token2.marginLG,
          verticalAlign: "top",
          "&-with-help": {
            transition: "none"
          },
          [`&-hidden,
        &-hidden.${rootPrefixCls}-row`]: {
            // https://github.com/ant-design/ant-design/issues/26141
            display: "none"
          },
          "&-has-warning": {
            [`${formItemCls}-split`]: {
              color: token2.colorError
            }
          },
          "&-has-error": {
            [`${formItemCls}-split`]: {
              color: token2.colorWarning
            }
          },
          // ==============================================================
          // =                            Label                           =
          // ==============================================================
          [`${formItemCls}-label`]: {
            display: "inline-block",
            flexGrow: 0,
            overflow: "hidden",
            whiteSpace: "nowrap",
            textAlign: "end",
            verticalAlign: "middle",
            "&-left": {
              textAlign: "start"
            },
            "&-wrap": {
              overflow: "unset",
              lineHeight: `${token2.lineHeight} - 0.25em`,
              whiteSpace: "unset"
            },
            "> label": {
              position: "relative",
              display: "inline-flex",
              alignItems: "center",
              maxWidth: "100%",
              height: token2.controlHeight,
              color: token2.colorTextHeading,
              fontSize: token2.fontSize,
              [`> ${iconCls}`]: {
                fontSize: token2.fontSize,
                verticalAlign: "top"
              },
              // Required mark
              [`&${formItemCls}-required:not(${formItemCls}-required-mark-optional)::before`]: {
                display: "inline-block",
                marginInlineEnd: token2.marginXXS,
                color: token2.colorError,
                fontSize: token2.fontSize,
                fontFamily: "SimSun, sans-serif",
                lineHeight: 1,
                content: '"*"',
                [`${componentCls}-hide-required-mark &`]: {
                  display: "none"
                }
              },
              // Optional mark
              [`${formItemCls}-optional`]: {
                display: "inline-block",
                marginInlineStart: token2.marginXXS,
                color: token2.colorTextDescription,
                [`${componentCls}-hide-required-mark &`]: {
                  display: "none"
                }
              },
              // Optional mark
              [`${formItemCls}-tooltip`]: {
                color: token2.colorTextDescription,
                cursor: "help",
                writingMode: "horizontal-tb",
                marginInlineStart: token2.marginXXS
              },
              "&::after": {
                content: '":"',
                position: "relative",
                marginBlock: 0,
                marginInlineStart: token2.marginXXS / 2,
                marginInlineEnd: token2.marginXS
              },
              [`&${formItemCls}-no-colon::after`]: {
                content: '" "'
              }
            }
          },
          // ==============================================================
          // =                            Input                           =
          // ==============================================================
          [`${formItemCls}-control`]: {
            display: "flex",
            flexDirection: "column",
            flexGrow: 1,
            [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
              width: "100%"
            },
            "&-input": {
              position: "relative",
              display: "flex",
              alignItems: "center",
              minHeight: token2.controlHeight,
              "&-content": {
                flex: "auto",
                maxWidth: "100%"
              }
            }
          },
          // ==============================================================
          // =                           Explain                          =
          // ==============================================================
          [formItemCls]: {
            "&-explain, &-extra": {
              clear: "both",
              color: token2.colorTextDescription,
              fontSize: token2.fontSize,
              lineHeight: token2.lineHeight
            },
            "&-explain-connected": {
              width: "100%"
            },
            "&-extra": {
              minHeight: token2.controlHeightSM,
              transition: `color ${token2.motionDurationMid} ${token2.motionEaseOut}`
              // sync input color transition
            },
            "&-explain": {
              "&-error": {
                color: token2.colorError
              },
              "&-warning": {
                color: token2.colorWarning
              }
            }
          },
          [`&-with-help ${formItemCls}-explain`]: {
            height: "auto",
            opacity: 1
          },
          // ==============================================================
          // =                        Feedback Icon                       =
          // ==============================================================
          [`${formItemCls}-feedback-icon`]: {
            fontSize: token2.fontSize,
            textAlign: "center",
            visibility: "visible",
            animationName: zoomIn,
            animationDuration: token2.motionDurationMid,
            animationTimingFunction: token2.motionEaseOutBack,
            pointerEvents: "none",
            "&-success": {
              color: token2.colorSuccess
            },
            "&-error": {
              color: token2.colorError
            },
            "&-warning": {
              color: token2.colorWarning
            },
            "&-validating": {
              color: token2.colorPrimary
            }
          }
        })
      };
    };
    const genHorizontalStyle = (token2) => {
      const {
        componentCls,
        formItemCls,
        rootPrefixCls
      } = token2;
      return {
        [`${componentCls}-horizontal`]: {
          [`${formItemCls}-label`]: {
            flexGrow: 0
          },
          [`${formItemCls}-control`]: {
            flex: "1 1 0",
            // https://github.com/ant-design/ant-design/issues/32777
            // https://github.com/ant-design/ant-design/issues/33773
            minWidth: 0
          },
          // https://github.com/ant-design/ant-design/issues/32980
          [`${formItemCls}-label.${rootPrefixCls}-col-24 + ${formItemCls}-control`]: {
            minWidth: "unset"
          }
        }
      };
    };
    const genInlineStyle = (token2) => {
      const {
        componentCls,
        formItemCls
      } = token2;
      return {
        [`${componentCls}-inline`]: {
          display: "flex",
          flexWrap: "wrap",
          [formItemCls]: {
            flex: "none",
            flexWrap: "nowrap",
            marginInlineEnd: token2.margin,
            marginBottom: 0,
            "&-with-help": {
              marginBottom: token2.marginLG
            },
            [`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
              display: "inline-block",
              verticalAlign: "top"
            },
            [`> ${formItemCls}-label`]: {
              flex: "none"
            },
            [`${componentCls}-text`]: {
              display: "inline-block"
            },
            [`${formItemCls}-has-feedback`]: {
              display: "inline-block"
            }
          }
        }
      };
    };
    const makeVerticalLayoutLabel = (token2) => ({
      margin: 0,
      padding: `0 0 ${token2.paddingXS}px`,
      whiteSpace: "initial",
      textAlign: "start",
      "> label": {
        margin: 0,
        "&::after": {
          display: "none"
        }
      }
    });
    const makeVerticalLayout = (token2) => {
      const {
        componentCls,
        formItemCls
      } = token2;
      return {
        [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
        [componentCls]: {
          [formItemCls]: {
            flexWrap: "wrap",
            [`${formItemCls}-label,
          ${formItemCls}-control`]: {
              flex: "0 0 100%",
              maxWidth: "100%"
            }
          }
        }
      };
    };
    const genVerticalStyle = (token2) => {
      const {
        componentCls,
        formItemCls,
        rootPrefixCls
      } = token2;
      return {
        [`${componentCls}-vertical`]: {
          [formItemCls]: {
            "&-row": {
              flexDirection: "column"
            },
            "&-label > label": {
              height: "auto"
            },
            [`${componentCls}-item-control`]: {
              width: "100%"
            }
          }
        },
        [`${componentCls}-vertical ${formItemCls}-label,
      .${rootPrefixCls}-col-24${formItemCls}-label,
      .${rootPrefixCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
        [`@media (max-width: ${token2.screenXSMax}px)`]: [makeVerticalLayout(token2), {
          [componentCls]: {
            [`.${rootPrefixCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        }],
        [`@media (max-width: ${token2.screenSMMax}px)`]: {
          [componentCls]: {
            [`.${rootPrefixCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        },
        [`@media (max-width: ${token2.screenMDMax}px)`]: {
          [componentCls]: {
            [`.${rootPrefixCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        },
        [`@media (max-width: ${token2.screenLGMax}px)`]: {
          [componentCls]: {
            [`.${rootPrefixCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        }
      };
    };
    const useStyle$d = genComponentStyleHook("Form", (token2, _ref) => {
      let {
        rootPrefixCls
      } = _ref;
      const formToken = merge$4(token2, {
        formItemCls: `${token2.componentCls}-item`,
        rootPrefixCls
      });
      return [genFormStyle(formToken), genFormItemStyle(formToken), genFormValidateMotionStyle$1(formToken), genHorizontalStyle(formToken), genInlineStyle(formToken), genVerticalStyle(formToken), genCollapseMotion$1(formToken), zoomIn];
    });
    const EMPTY_LIST$2 = [];
    function toErrorEntity(error, prefix, errorStatus) {
      let index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      return {
        key: typeof error === "string" ? error : `${prefix}-${index2}`,
        error,
        errorStatus
      };
    }
    function ErrorList(_ref) {
      let {
        help,
        helpStatus,
        errors = EMPTY_LIST$2,
        warnings = EMPTY_LIST$2,
        className: rootClassName,
        fieldId,
        onVisibleChanged
      } = _ref;
      const {
        prefixCls
      } = reactExports.useContext(FormItemPrefixContext);
      const baseClassName = `${prefixCls}-item-explain`;
      const [, hashId] = useStyle$d(prefixCls);
      const collapseMotion = reactExports.useMemo(() => initCollapseMotion$1(prefixCls), [prefixCls]);
      const debounceErrors = useDebounce(errors);
      const debounceWarnings = useDebounce(warnings);
      const fullKeyList = reactExports.useMemo(() => {
        if (help !== void 0 && help !== null) {
          return [toErrorEntity(help, "help", helpStatus)];
        }
        return [].concat(_toConsumableArray(debounceErrors.map((error, index2) => toErrorEntity(error, "error", "error", index2))), _toConsumableArray(debounceWarnings.map((warning2, index2) => toErrorEntity(warning2, "warning", "warning", index2))));
      }, [help, helpStatus, debounceErrors, debounceWarnings]);
      const helpProps = {};
      if (fieldId) {
        helpProps.id = `${fieldId}_help`;
      }
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, {
        motionDeadline: collapseMotion.motionDeadline,
        motionName: `${prefixCls}-show-help`,
        visible: !!fullKeyList.length,
        onVisibleChanged
      }, (holderProps) => {
        const {
          className: holderClassName,
          style: holderStyle
        } = holderProps;
        return /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, helpProps, {
          className: classNames(baseClassName, holderClassName, rootClassName, hashId),
          style: holderStyle,
          role: "alert"
        }), /* @__PURE__ */ reactExports.createElement(CSSMotionList, Object.assign({
          keys: fullKeyList
        }, initCollapseMotion$1(prefixCls), {
          motionName: `${prefixCls}-show-help-item`,
          component: false
        }), (itemProps) => {
          const {
            key,
            error,
            errorStatus,
            className: itemClassName,
            style: itemStyle2
          } = itemProps;
          return /* @__PURE__ */ reactExports.createElement("div", {
            key,
            className: classNames(itemClassName, {
              [`${baseClassName}-${errorStatus}`]: errorStatus
            }),
            style: itemStyle2
          }, error);
        }));
      });
    }
    const formItemNameBlackList = ["parentNode"];
    const defaultItemNamePrefixCls = "form_item";
    function toArray$2(candidate) {
      if (candidate === void 0 || candidate === false)
        return [];
      return Array.isArray(candidate) ? candidate : [candidate];
    }
    function getFieldId(namePath, formName) {
      if (!namePath.length) {
        return void 0;
      }
      const mergedId = namePath.join("_");
      if (formName) {
        return `${formName}_${mergedId}`;
      }
      const isIllegalName = formItemNameBlackList.includes(mergedId);
      return isIllegalName ? `${defaultItemNamePrefixCls}_${mergedId}` : mergedId;
    }
    function toNamePathStr(name) {
      const namePath = toArray$2(name);
      return namePath.join("_");
    }
    function useForm$1(form) {
      const [rcForm] = useForm$2();
      const itemsRef = reactExports.useRef({});
      const wrapForm = reactExports.useMemo(() => form !== null && form !== void 0 ? form : Object.assign(Object.assign({}, rcForm), {
        __INTERNAL__: {
          itemRef: (name) => (node2) => {
            const namePathStr = toNamePathStr(name);
            if (node2) {
              itemsRef.current[namePathStr] = node2;
            } else {
              delete itemsRef.current[namePathStr];
            }
          }
        },
        scrollToField: function(name) {
          let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const namePath = toArray$2(name);
          const fieldId = getFieldId(namePath, wrapForm.__INTERNAL__.name);
          const node2 = fieldId ? document.getElementById(fieldId) : null;
          if (node2) {
            n$1(node2, Object.assign({
              scrollMode: "if-needed",
              block: "nearest"
            }, options));
          }
        },
        getFieldInstance: (name) => {
          const namePathStr = toNamePathStr(name);
          return itemsRef.current[namePathStr];
        }
      }), [form, rcForm]);
      return [wrapForm];
    }
    var __rest$r = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const InternalForm = (props, ref) => {
      const contextSize = reactExports.useContext(SizeContext$2);
      const contextDisabled = reactExports.useContext(DisabledContext$1);
      const {
        getPrefixCls,
        direction,
        form: contextForm
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        size = contextSize,
        disabled = contextDisabled,
        form,
        colon,
        labelAlign,
        labelWrap,
        labelCol,
        wrapperCol,
        hideRequiredMark,
        layout = "horizontal",
        scrollToFirstError,
        requiredMark,
        onFinishFailed,
        name
      } = props, restFormProps = __rest$r(props, ["prefixCls", "className", "rootClassName", "size", "disabled", "form", "colon", "labelAlign", "labelWrap", "labelCol", "wrapperCol", "hideRequiredMark", "layout", "scrollToFirstError", "requiredMark", "onFinishFailed", "name"]);
      const mergedRequiredMark = reactExports.useMemo(() => {
        if (requiredMark !== void 0) {
          return requiredMark;
        }
        if (contextForm && contextForm.requiredMark !== void 0) {
          return contextForm.requiredMark;
        }
        if (hideRequiredMark) {
          return false;
        }
        return true;
      }, [hideRequiredMark, requiredMark, contextForm]);
      const mergedColon = colon !== null && colon !== void 0 ? colon : contextForm === null || contextForm === void 0 ? void 0 : contextForm.colon;
      const prefixCls = getPrefixCls("form", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$d(prefixCls);
      const formClassName = classNames(prefixCls, {
        [`${prefixCls}-${layout}`]: true,
        [`${prefixCls}-hide-required-mark`]: mergedRequiredMark === false,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-${size}`]: size
      }, hashId, className, rootClassName);
      const [wrapForm] = useForm$1(form);
      const {
        __INTERNAL__
      } = wrapForm;
      __INTERNAL__.name = name;
      const formContextValue = reactExports.useMemo(() => ({
        name,
        labelAlign,
        labelCol,
        labelWrap,
        wrapperCol,
        vertical: layout === "vertical",
        colon: mergedColon,
        requiredMark: mergedRequiredMark,
        itemRef: __INTERNAL__.itemRef,
        form: wrapForm
      }), [name, labelAlign, labelCol, wrapperCol, layout, mergedColon, mergedRequiredMark, wrapForm]);
      reactExports.useImperativeHandle(ref, () => wrapForm);
      const scrollToField = (options, fieldName) => {
        if (options) {
          let defaultScrollToFirstError = {
            block: "nearest"
          };
          if (typeof options === "object") {
            defaultScrollToFirstError = options;
          }
          wrapForm.scrollToField(fieldName, defaultScrollToFirstError);
        }
      };
      const onInternalFinishFailed = (errorInfo) => {
        onFinishFailed === null || onFinishFailed === void 0 ? void 0 : onFinishFailed(errorInfo);
        if (errorInfo.errorFields.length) {
          const fieldName = errorInfo.errorFields[0].name;
          if (scrollToFirstError !== void 0) {
            scrollToField(scrollToFirstError, fieldName);
            return;
          }
          if (contextForm && contextForm.scrollToFirstError !== void 0) {
            scrollToField(contextForm.scrollToFirstError, fieldName);
          }
        }
      };
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(DisabledContextProvider, {
        disabled
      }, /* @__PURE__ */ reactExports.createElement(SizeContextProvider$1, {
        size
      }, /* @__PURE__ */ reactExports.createElement(FormContext.Provider, {
        value: formContextValue
      }, /* @__PURE__ */ reactExports.createElement(RefForm, Object.assign({
        id: name
      }, restFormProps, {
        name,
        onFinishFailed: onInternalFinishFailed,
        form: wrapForm,
        className: formClassName
      }))))));
    };
    const Form$2 = /* @__PURE__ */ reactExports.forwardRef(InternalForm);
    const InternalForm$1 = Form$2;
    const useFormItemStatus = () => {
      const {
        status
      } = reactExports.useContext(FormItemInputContext);
      return {
        status
      };
    };
    useFormItemStatus.Context = FormItemInputContext;
    const useFormItemStatus$1 = useFormItemStatus;
    function useFrameState(defaultValue) {
      const [value, setValue2] = reactExports.useState(defaultValue);
      const frameRef = reactExports.useRef(null);
      const batchRef = reactExports.useRef([]);
      const destroyRef = reactExports.useRef(false);
      reactExports.useEffect(() => {
        destroyRef.current = false;
        return () => {
          destroyRef.current = true;
          wrapperRaf.cancel(frameRef.current);
          frameRef.current = null;
        };
      }, []);
      function setFrameValue(updater) {
        if (destroyRef.current) {
          return;
        }
        if (frameRef.current === null) {
          batchRef.current = [];
          frameRef.current = wrapperRaf(() => {
            frameRef.current = null;
            setValue2((prevValue) => {
              let current = prevValue;
              batchRef.current.forEach((func) => {
                current = func(current);
              });
              return current;
            });
          });
        }
        batchRef.current.push(updater);
      }
      return [value, setFrameValue];
    }
    function useItemRef() {
      const {
        itemRef
      } = reactExports.useContext(FormContext);
      const cacheRef = reactExports.useRef({});
      function getRef(name, children) {
        const childrenRef = children && typeof children === "object" && children.ref;
        const nameStr = name.join("_");
        if (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) {
          cacheRef.current.name = nameStr;
          cacheRef.current.originRef = childrenRef;
          cacheRef.current.ref = composeRef(itemRef(name), childrenRef);
        }
        return cacheRef.current.ref;
      }
      return getRef;
    }
    const FormItemInput = (props) => {
      const {
        prefixCls,
        status,
        wrapperCol,
        children,
        errors,
        warnings,
        _internalItemRender: formItemRender,
        extra,
        help,
        fieldId,
        marginBottom,
        onErrorVisibleChanged
      } = props;
      const baseClassName = `${prefixCls}-item`;
      const formContext = reactExports.useContext(FormContext);
      const mergedWrapperCol = wrapperCol || formContext.wrapperCol || {};
      const className = classNames(`${baseClassName}-control`, mergedWrapperCol.className);
      const subFormContext = reactExports.useMemo(() => Object.assign({}, formContext), [formContext]);
      delete subFormContext.labelCol;
      delete subFormContext.wrapperCol;
      const inputDom = /* @__PURE__ */ reactExports.createElement("div", {
        className: `${baseClassName}-control-input`
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${baseClassName}-control-input-content`
      }, children));
      const formItemContext = reactExports.useMemo(() => ({
        prefixCls,
        status
      }), [prefixCls, status]);
      const errorListDom = marginBottom !== null || errors.length || warnings.length ? /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          display: "flex",
          flexWrap: "nowrap"
        }
      }, /* @__PURE__ */ reactExports.createElement(FormItemPrefixContext.Provider, {
        value: formItemContext
      }, /* @__PURE__ */ reactExports.createElement(ErrorList, {
        fieldId,
        errors,
        warnings,
        help,
        helpStatus: status,
        className: `${baseClassName}-explain-connected`,
        onVisibleChanged: onErrorVisibleChanged
      })), !!marginBottom && /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          width: 0,
          height: marginBottom
        }
      })) : null;
      const extraProps = {};
      if (fieldId) {
        extraProps.id = `${fieldId}_extra`;
      }
      const extraDom = extra ? /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, extraProps, {
        className: `${baseClassName}-extra`
      }), extra) : null;
      const dom = formItemRender && formItemRender.mark === "pro_table_render" && formItemRender.render ? formItemRender.render(props, {
        input: inputDom,
        errorList: errorListDom,
        extra: extraDom
      }) : /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, inputDom, errorListDom, extraDom);
      return /* @__PURE__ */ reactExports.createElement(FormContext.Provider, {
        value: subFormContext
      }, /* @__PURE__ */ reactExports.createElement(Col$1, Object.assign({}, mergedWrapperCol, {
        className
      }), dom));
    };
    const FormItemInput$1 = FormItemInput;
    var QuestionCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "question-circle", "theme": "outlined" };
    const QuestionCircleOutlinedSvg = QuestionCircleOutlined$2;
    var QuestionCircleOutlined = function QuestionCircleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: QuestionCircleOutlinedSvg
      }));
    };
    QuestionCircleOutlined.displayName = "QuestionCircleOutlined";
    const QuestionCircleOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(QuestionCircleOutlined);
    var __rest$q = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function toTooltipProps(tooltip) {
      if (!tooltip) {
        return null;
      }
      if (typeof tooltip === "object" && !/* @__PURE__ */ reactExports.isValidElement(tooltip)) {
        return tooltip;
      }
      return {
        title: tooltip
      };
    }
    const FormItemLabel = (_ref) => {
      let {
        prefixCls,
        label,
        htmlFor,
        labelCol,
        labelAlign,
        colon,
        required: required2,
        requiredMark,
        tooltip
      } = _ref;
      var _a;
      const [formLocale] = useLocale$1("Form");
      const {
        vertical,
        labelAlign: contextLabelAlign,
        labelCol: contextLabelCol,
        labelWrap,
        colon: contextColon
      } = reactExports.useContext(FormContext);
      if (!label) {
        return null;
      }
      const mergedLabelCol = labelCol || contextLabelCol || {};
      const mergedLabelAlign = labelAlign || contextLabelAlign;
      const labelClsBasic = `${prefixCls}-item-label`;
      const labelColClassName = classNames(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.className, {
        [`${labelClsBasic}-wrap`]: !!labelWrap
      });
      let labelChildren = label;
      const computedColon = colon === true || contextColon !== false && colon !== false;
      const haveColon = computedColon && !vertical;
      if (haveColon && typeof label === "string" && label.trim() !== "") {
        labelChildren = label.replace(/[:|：]\s*$/, "");
      }
      const tooltipProps = toTooltipProps(tooltip);
      if (tooltipProps) {
        const {
          icon = /* @__PURE__ */ reactExports.createElement(QuestionCircleOutlined$1, null)
        } = tooltipProps, restTooltipProps = __rest$q(tooltipProps, ["icon"]);
        const tooltipNode = /* @__PURE__ */ reactExports.createElement(pn, Object.assign({}, restTooltipProps), /* @__PURE__ */ reactExports.cloneElement(icon, {
          className: `${prefixCls}-item-tooltip`,
          title: ""
        }));
        labelChildren = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, labelChildren, tooltipNode);
      }
      if (requiredMark === "optional" && !required2) {
        labelChildren = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, labelChildren, /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-item-optional`,
          title: ""
        }, (formLocale === null || formLocale === void 0 ? void 0 : formLocale.optional) || ((_a = defaultLocale.Form) === null || _a === void 0 ? void 0 : _a.optional)));
      }
      const labelClassName = classNames({
        [`${prefixCls}-item-required`]: required2,
        [`${prefixCls}-item-required-mark-optional`]: requiredMark === "optional",
        [`${prefixCls}-item-no-colon`]: !computedColon
      });
      return /* @__PURE__ */ reactExports.createElement(Col$1, Object.assign({}, mergedLabelCol, {
        className: labelColClassName
      }), /* @__PURE__ */ reactExports.createElement("label", {
        htmlFor,
        className: labelClassName,
        title: typeof label === "string" ? label : ""
      }, labelChildren));
    };
    const FormItemLabel$1 = FormItemLabel;
    var __rest$p = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const iconMap = {
      success: CheckCircleFilled$1,
      warning: ExclamationCircleFilled$1,
      error: CloseCircleFilled$1,
      validating: LoadingOutlined$1
    };
    function ItemHolder(props) {
      const {
        prefixCls,
        className,
        rootClassName,
        style: style2,
        help,
        errors,
        warnings,
        validateStatus,
        meta,
        hasFeedback,
        hidden,
        children,
        fieldId,
        isRequired,
        onSubItemMetaChange
      } = props, restProps = __rest$p(props, ["prefixCls", "className", "rootClassName", "style", "help", "errors", "warnings", "validateStatus", "meta", "hasFeedback", "hidden", "children", "fieldId", "isRequired", "onSubItemMetaChange"]);
      const itemPrefixCls = `${prefixCls}-item`;
      const {
        requiredMark
      } = reactExports.useContext(FormContext);
      const itemRef = reactExports.useRef(null);
      const debounceErrors = useDebounce(errors);
      const debounceWarnings = useDebounce(warnings);
      const hasHelp = help !== void 0 && help !== null;
      const hasError = !!(hasHelp || errors.length || warnings.length);
      const [marginBottom, setMarginBottom] = reactExports.useState(null);
      useLayoutEffect$1(() => {
        if (hasError && itemRef.current) {
          const itemStyle2 = getComputedStyle(itemRef.current);
          setMarginBottom(parseInt(itemStyle2.marginBottom, 10));
        }
      }, [hasError]);
      const onErrorVisibleChanged = (nextVisible) => {
        if (!nextVisible) {
          setMarginBottom(null);
        }
      };
      let mergedValidateStatus = "";
      if (validateStatus !== void 0) {
        mergedValidateStatus = validateStatus;
      } else if (meta.validating) {
        mergedValidateStatus = "validating";
      } else if (debounceErrors.length) {
        mergedValidateStatus = "error";
      } else if (debounceWarnings.length) {
        mergedValidateStatus = "warning";
      } else if (meta.touched) {
        mergedValidateStatus = "success";
      }
      const formItemStatusContext = reactExports.useMemo(() => {
        let feedbackIcon;
        if (hasFeedback) {
          const IconNode = mergedValidateStatus && iconMap[mergedValidateStatus];
          feedbackIcon = IconNode ? /* @__PURE__ */ reactExports.createElement("span", {
            className: classNames(`${itemPrefixCls}-feedback-icon`, `${itemPrefixCls}-feedback-icon-${mergedValidateStatus}`)
          }, /* @__PURE__ */ reactExports.createElement(IconNode, null)) : null;
        }
        return {
          status: mergedValidateStatus,
          hasFeedback,
          feedbackIcon,
          isFormItemInput: true
        };
      }, [mergedValidateStatus, hasFeedback]);
      const itemClassName = classNames(itemPrefixCls, className, rootClassName, {
        [`${itemPrefixCls}-with-help`]: hasHelp || debounceErrors.length || debounceWarnings.length,
        // Status
        [`${itemPrefixCls}-has-feedback`]: mergedValidateStatus && hasFeedback,
        [`${itemPrefixCls}-has-success`]: mergedValidateStatus === "success",
        [`${itemPrefixCls}-has-warning`]: mergedValidateStatus === "warning",
        [`${itemPrefixCls}-has-error`]: mergedValidateStatus === "error",
        [`${itemPrefixCls}-is-validating`]: mergedValidateStatus === "validating",
        [`${itemPrefixCls}-hidden`]: hidden
      });
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: itemClassName,
        style: style2,
        ref: itemRef
      }, /* @__PURE__ */ reactExports.createElement(Row$1, Object.assign({
        className: `${itemPrefixCls}-row`
      }, omit(restProps, ["_internalItemRender", "colon", "dependencies", "extra", "fieldKey", "getValueFromEvent", "getValueProps", "htmlFor", "id", "initialValue", "isListField", "label", "labelAlign", "labelCol", "labelWrap", "messageVariables", "name", "normalize", "noStyle", "preserve", "required", "requiredMark", "rules", "shouldUpdate", "trigger", "tooltip", "validateFirst", "validateTrigger", "valuePropName", "wrapperCol"])), /* @__PURE__ */ reactExports.createElement(FormItemLabel$1, Object.assign({
        htmlFor: fieldId,
        required: isRequired,
        requiredMark
      }, props, {
        prefixCls
      })), /* @__PURE__ */ reactExports.createElement(FormItemInput$1, Object.assign({}, props, meta, {
        errors: debounceErrors,
        warnings: debounceWarnings,
        prefixCls,
        status: mergedValidateStatus,
        help,
        marginBottom,
        onErrorVisibleChanged
      }), /* @__PURE__ */ reactExports.createElement(NoStyleItemContext.Provider, {
        value: onSubItemMetaChange
      }, /* @__PURE__ */ reactExports.createElement(FormItemInputContext.Provider, {
        value: formItemStatusContext
      }, children)))), !!marginBottom && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${itemPrefixCls}-margin-offset`,
        style: {
          marginBottom: -marginBottom
        }
      }));
    }
    const NAME_SPLIT = "__SPLIT__";
    const MemoInput = /* @__PURE__ */ reactExports.memo((_ref) => {
      let {
        children
      } = _ref;
      return children;
    }, (prev2, next2) => prev2.value === next2.value && prev2.update === next2.update && prev2.childProps.length === next2.childProps.length && prev2.childProps.every((value, index2) => value === next2.childProps[index2]));
    function hasValidName(name) {
      return !(name === void 0 || name === null);
    }
    function genEmptyMeta() {
      return {
        errors: [],
        warnings: [],
        touched: false,
        validating: false,
        name: []
      };
    }
    function InternalFormItem(props) {
      const {
        name,
        noStyle,
        className,
        dependencies,
        prefixCls: customizePrefixCls,
        shouldUpdate,
        rules: rules2,
        children,
        required: required2,
        label,
        messageVariables,
        trigger = "onChange",
        validateTrigger,
        hidden
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const {
        name: formName
      } = reactExports.useContext(FormContext);
      const isRenderProps = typeof children === "function";
      const notifyParentMetaChange = reactExports.useContext(NoStyleItemContext);
      const {
        validateTrigger: contextValidateTrigger
      } = reactExports.useContext(Context$2);
      const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : contextValidateTrigger;
      const hasName = hasValidName(name);
      const prefixCls = getPrefixCls("form", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$d(prefixCls);
      const listContext = reactExports.useContext(ListContext);
      const fieldKeyPathRef = reactExports.useRef();
      const [subFieldErrors, setSubFieldErrors] = useFrameState({});
      const [meta, setMeta] = useSafeState(() => genEmptyMeta());
      const onMetaChange = (nextMeta) => {
        const keyInfo = listContext === null || listContext === void 0 ? void 0 : listContext.getKey(nextMeta.name);
        setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, true);
        if (noStyle && notifyParentMetaChange) {
          let namePath = nextMeta.name;
          if (!nextMeta.destroy) {
            if (keyInfo !== void 0) {
              const [fieldKey, restPath] = keyInfo;
              namePath = [fieldKey].concat(_toConsumableArray(restPath));
              fieldKeyPathRef.current = namePath;
            }
          } else {
            namePath = fieldKeyPathRef.current || namePath;
          }
          notifyParentMetaChange(nextMeta, namePath);
        }
      };
      const onSubItemMetaChange = (subMeta, uniqueKeys) => {
        setSubFieldErrors((prevSubFieldErrors) => {
          const clone = Object.assign({}, prevSubFieldErrors);
          const mergedNamePath = [].concat(_toConsumableArray(subMeta.name.slice(0, -1)), _toConsumableArray(uniqueKeys));
          const mergedNameKey = mergedNamePath.join(NAME_SPLIT);
          if (subMeta.destroy) {
            delete clone[mergedNameKey];
          } else {
            clone[mergedNameKey] = subMeta;
          }
          return clone;
        });
      };
      const [mergedErrors, mergedWarnings] = reactExports.useMemo(() => {
        const errorList = _toConsumableArray(meta.errors);
        const warningList = _toConsumableArray(meta.warnings);
        Object.values(subFieldErrors).forEach((subFieldError) => {
          errorList.push.apply(errorList, _toConsumableArray(subFieldError.errors || []));
          warningList.push.apply(warningList, _toConsumableArray(subFieldError.warnings || []));
        });
        return [errorList, warningList];
      }, [subFieldErrors, meta.errors, meta.warnings]);
      const getItemRef = useItemRef();
      function renderLayout(baseChildren, fieldId, isRequired) {
        if (noStyle && !hidden) {
          return baseChildren;
        }
        return /* @__PURE__ */ reactExports.createElement(ItemHolder, Object.assign({
          key: "row"
        }, props, {
          className: classNames(className, hashId),
          prefixCls,
          fieldId,
          isRequired,
          errors: mergedErrors,
          warnings: mergedWarnings,
          meta,
          onSubItemMetaChange
        }), baseChildren);
      }
      if (!hasName && !isRenderProps && !dependencies) {
        return wrapSSR(renderLayout(children));
      }
      let variables = {};
      if (typeof label === "string") {
        variables.label = label;
      } else if (name) {
        variables.label = String(name);
      }
      if (messageVariables) {
        variables = Object.assign(Object.assign({}, variables), messageVariables);
      }
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(WrapperField, Object.assign({}, props, {
        messageVariables: variables,
        trigger,
        validateTrigger: mergedValidateTrigger,
        onMetaChange
      }), (control, renderMeta, context) => {
        const mergedName = toArray$2(name).length && renderMeta ? renderMeta.name : [];
        const fieldId = getFieldId(mergedName, formName);
        const isRequired = required2 !== void 0 ? required2 : !!(rules2 && rules2.some((rule) => {
          if (rule && typeof rule === "object" && rule.required && !rule.warningOnly) {
            return true;
          }
          if (typeof rule === "function") {
            const ruleEntity = rule(context);
            return ruleEntity && ruleEntity.required && !ruleEntity.warningOnly;
          }
          return false;
        }));
        const mergedControl = Object.assign({}, control);
        let childNode = null;
        if (Array.isArray(children) && hasName) {
          childNode = children;
        } else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName))
          ;
        else if (dependencies && !isRenderProps && !hasName)
          ;
        else if (isValidElement(children)) {
          const childProps = Object.assign(Object.assign({}, children.props), mergedControl);
          if (!childProps.id) {
            childProps.id = fieldId;
          }
          if (props.help || mergedErrors.length > 0 || mergedWarnings.length > 0 || props.extra) {
            const describedbyArr = [];
            if (props.help || mergedErrors.length > 0) {
              describedbyArr.push(`${fieldId}_help`);
            }
            if (props.extra) {
              describedbyArr.push(`${fieldId}_extra`);
            }
            childProps["aria-describedby"] = describedbyArr.join(" ");
          }
          if (mergedErrors.length > 0) {
            childProps["aria-invalid"] = "true";
          }
          if (isRequired) {
            childProps["aria-required"] = "true";
          }
          if (supportRef(children)) {
            childProps.ref = getItemRef(mergedName, children);
          }
          const triggers = new Set([].concat(_toConsumableArray(toArray$2(trigger)), _toConsumableArray(toArray$2(mergedValidateTrigger))));
          triggers.forEach((eventName) => {
            childProps[eventName] = function() {
              var _a2, _c2;
              var _a, _b, _c;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              (_a = mergedControl[eventName]) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [mergedControl].concat(args));
              (_c = (_b = children.props)[eventName]) === null || _c === void 0 ? void 0 : (_c2 = _c).call.apply(_c2, [_b].concat(args));
            };
          });
          const watchingChildProps = [childProps["aria-required"], childProps["aria-invalid"], childProps["aria-describedby"]];
          childNode = /* @__PURE__ */ reactExports.createElement(MemoInput, {
            value: mergedControl[props.valuePropName || "value"],
            update: children,
            childProps: watchingChildProps
          }, cloneElement(children, childProps));
        } else if (isRenderProps && (shouldUpdate || dependencies) && !hasName) {
          childNode = children(context);
        } else {
          childNode = children;
        }
        return renderLayout(childNode, fieldId, isRequired);
      }));
    }
    const FormItem = InternalFormItem;
    FormItem.useStatus = useFormItemStatus$1;
    const Item = FormItem;
    var __rest$o = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const FormList = (_a) => {
      var {
        prefixCls: customizePrefixCls,
        children
      } = _a, props = __rest$o(_a, ["prefixCls", "children"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("form", customizePrefixCls);
      const contextValue = reactExports.useMemo(() => ({
        prefixCls,
        status: "error"
      }), [prefixCls]);
      return /* @__PURE__ */ reactExports.createElement(List$2, Object.assign({}, props), (fields, operation, meta) => /* @__PURE__ */ reactExports.createElement(FormItemPrefixContext.Provider, {
        value: contextValue
      }, children(fields.map((field) => Object.assign(Object.assign({}, field), {
        fieldKey: field.key
      })), operation, {
        errors: meta.errors,
        warnings: meta.warnings
      })));
    };
    const List = FormList;
    function useFormInstance() {
      const {
        form
      } = reactExports.useContext(FormContext);
      return form;
    }
    const Form = InternalForm$1;
    Form.Item = Item;
    Form.List = List;
    Form.ErrorList = ErrorList;
    Form.useForm = useForm$1;
    Form.useFormInstance = useFormInstance;
    Form.useWatch = useWatch$1;
    Form.Provider = FormProvider;
    Form.create = () => {
    };
    const Form$1 = Form;
    var EyeOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
    const EyeOutlinedSvg = EyeOutlined$2;
    var EyeOutlined = function EyeOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: EyeOutlinedSvg
      }));
    };
    EyeOutlined.displayName = "EyeOutlined";
    const EyeOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(EyeOutlined);
    function getOffset(node2) {
      var box2 = node2.getBoundingClientRect();
      var docElem = document.documentElement;
      return {
        left: box2.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
        top: box2.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
      };
    }
    const Group = (props) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        className = ""
      } = props;
      const prefixCls = getPrefixCls("input-group", customizePrefixCls);
      const inputPrefixCls = getPrefixCls("input");
      const [wrapSSR, hashId] = useStyle$l(inputPrefixCls);
      const cls = classNames(prefixCls, {
        [`${prefixCls}-lg`]: props.size === "large",
        [`${prefixCls}-sm`]: props.size === "small",
        [`${prefixCls}-compact`]: props.compact,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, hashId, className);
      const formItemContext = reactExports.useContext(FormItemInputContext);
      const groupFormItemContext = reactExports.useMemo(() => Object.assign(Object.assign({}, formItemContext), {
        isFormItemInput: false
      }), [formItemContext]);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("span", {
        className: cls,
        style: props.style,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        onFocus: props.onFocus,
        onBlur: props.onBlur
      }, /* @__PURE__ */ reactExports.createElement(FormItemInputContext.Provider, {
        value: groupFormItemContext
      }, props.children)));
    };
    const Group$1 = Group;
    function hasAddon(props) {
      return !!(props.addonBefore || props.addonAfter);
    }
    function hasPrefixSuffix$1(props) {
      return !!(props.prefix || props.suffix || props.allowClear);
    }
    function resolveOnChange(target, e2, onChange, targetValue) {
      if (!onChange) {
        return;
      }
      var event = e2;
      if (e2.type === "click") {
        var currentTarget = target.cloneNode(true);
        event = Object.create(e2, {
          target: {
            value: currentTarget
          },
          currentTarget: {
            value: currentTarget
          }
        });
        currentTarget.value = "";
        onChange(event);
        return;
      }
      if (targetValue !== void 0) {
        event = Object.create(e2, {
          target: {
            value: target
          },
          currentTarget: {
            value: target
          }
        });
        target.value = targetValue;
        onChange(event);
        return;
      }
      onChange(event);
    }
    function triggerFocus$1(element, option) {
      if (!element)
        return;
      element.focus(option);
      var _ref = option || {}, cursor = _ref.cursor;
      if (cursor) {
        var len = element.value.length;
        switch (cursor) {
          case "start":
            element.setSelectionRange(0, 0);
            break;
          case "end":
            element.setSelectionRange(len, len);
            break;
          default:
            element.setSelectionRange(0, len);
        }
      }
    }
    function fixControlledValue(value) {
      if (typeof value === "undefined" || value === null) {
        return "";
      }
      return String(value);
    }
    var BaseInput = function BaseInput2(props) {
      var _inputElement$props;
      var inputElement = props.inputElement, prefixCls = props.prefixCls, prefix = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style2 = props.style, affixWrapperClassName = props.affixWrapperClassName, groupClassName = props.groupClassName, wrapperClassName = props.wrapperClassName, disabled = props.disabled, readOnly2 = props.readOnly, focused = props.focused, triggerFocus2 = props.triggerFocus, allowClear = props.allowClear, value = props.value, handleReset = props.handleReset, hidden = props.hidden, inputStyle = props.inputStyle, classes = props.classes;
      var containerRef = reactExports.useRef(null);
      var onInputClick = function onInputClick2(e2) {
        var _containerRef$current;
        if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e2.target)) {
          triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();
        }
      };
      var getClearIcon = function getClearIcon2() {
        var _classNames;
        if (!allowClear) {
          return null;
        }
        var needClear = !disabled && !readOnly2 && value;
        var clearIconCls = "".concat(prefixCls, "-clear-icon");
        var iconNode = _typeof$4(allowClear) === "object" && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : "✖";
        return /* @__PURE__ */ React$3.createElement("span", {
          onClick: handleReset,
          onMouseDown: function onMouseDown(e2) {
            return e2.preventDefault();
          },
          className: classNames(clearIconCls, (_classNames = {}, _defineProperty$7(_classNames, "".concat(clearIconCls, "-hidden"), !needClear), _defineProperty$7(_classNames, "".concat(clearIconCls, "-has-suffix"), !!suffix), _classNames)),
          role: "button",
          tabIndex: -1
        }, iconNode);
      };
      var element = /* @__PURE__ */ reactExports.cloneElement(inputElement, {
        value,
        hidden,
        style: _objectSpread2$3(_objectSpread2$3({}, (_inputElement$props = inputElement.props) === null || _inputElement$props === void 0 ? void 0 : _inputElement$props.style), inputStyle)
      });
      if (hasPrefixSuffix$1(props)) {
        var _classNames2;
        var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
        var affixWrapperCls = classNames(affixWrapperPrefixCls, (_classNames2 = {}, _defineProperty$7(_classNames2, "".concat(affixWrapperPrefixCls, "-disabled"), disabled), _defineProperty$7(_classNames2, "".concat(affixWrapperPrefixCls, "-focused"), focused), _defineProperty$7(_classNames2, "".concat(affixWrapperPrefixCls, "-readonly"), readOnly2), _defineProperty$7(_classNames2, "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value), _classNames2), !hasAddon(props) && className, affixWrapperClassName, classes === null || classes === void 0 ? void 0 : classes.affixWrapper);
        var suffixNode = (suffix || allowClear) && /* @__PURE__ */ React$3.createElement("span", {
          className: "".concat(prefixCls, "-suffix")
        }, getClearIcon(), suffix);
        element = /* @__PURE__ */ React$3.createElement("span", {
          className: affixWrapperCls,
          style: style2,
          hidden: !hasAddon(props) && hidden,
          onClick: onInputClick,
          ref: containerRef
        }, prefix && /* @__PURE__ */ React$3.createElement("span", {
          className: "".concat(prefixCls, "-prefix")
        }, prefix), /* @__PURE__ */ reactExports.cloneElement(inputElement, {
          style: inputStyle !== null && inputStyle !== void 0 ? inputStyle : null,
          value,
          hidden: null
        }), suffixNode);
      }
      if (hasAddon(props)) {
        var wrapperCls = "".concat(prefixCls, "-group");
        var addonCls = "".concat(wrapperCls, "-addon");
        var mergedWrapperClassName = classNames("".concat(prefixCls, "-wrapper"), wrapperCls, wrapperClassName, classes === null || classes === void 0 ? void 0 : classes.wrapper);
        var mergedGroupClassName = classNames("".concat(prefixCls, "-group-wrapper"), className, groupClassName, classes === null || classes === void 0 ? void 0 : classes.group);
        return /* @__PURE__ */ React$3.createElement("span", {
          className: mergedGroupClassName,
          style: style2,
          hidden
        }, /* @__PURE__ */ React$3.createElement("span", {
          className: mergedWrapperClassName
        }, addonBefore && /* @__PURE__ */ React$3.createElement("span", {
          className: addonCls
        }, addonBefore), /* @__PURE__ */ reactExports.cloneElement(element, {
          style: inputStyle !== null && inputStyle !== void 0 ? inputStyle : null,
          hidden: null
        }), addonAfter && /* @__PURE__ */ React$3.createElement("span", {
          className: addonCls
        }, addonAfter)));
      }
      return element;
    };
    var _excluded$h = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "type", "inputClassName", "classes"];
    var Input$3 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var autoComplete = props.autoComplete, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown2 = props.onKeyDown, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input" : _props$prefixCls, disabled = props.disabled, htmlSize = props.htmlSize, className = props.className, maxLength = props.maxLength, suffix = props.suffix, showCount = props.showCount, _props$type = props.type, type2 = _props$type === void 0 ? "text" : _props$type, inputClassName = props.inputClassName, classes = props.classes, rest = _objectWithoutProperties$1(props, _excluded$h);
      var _useMergedState = useMergedState(props.defaultValue, {
        value: props.value
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue2 = _useMergedState2[1];
      var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), focused = _useState2[0], setFocused = _useState2[1];
      var inputRef = reactExports.useRef(null);
      var focus = function focus2(option) {
        if (inputRef.current) {
          triggerFocus$1(inputRef.current, option);
        }
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          focus,
          blur: function blur() {
            var _inputRef$current;
            (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.blur();
          },
          setSelectionRange: function setSelectionRange(start2, end2, direction) {
            var _inputRef$current2;
            (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.setSelectionRange(start2, end2, direction);
          },
          select: function select() {
            var _inputRef$current3;
            (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.select();
          },
          input: inputRef.current
        };
      });
      reactExports.useEffect(function() {
        setFocused(function(prev2) {
          return prev2 && disabled ? false : prev2;
        });
      }, [disabled]);
      var handleChange = function handleChange2(e2) {
        if (props.value === void 0) {
          setValue2(e2.target.value);
        }
        if (inputRef.current) {
          resolveOnChange(inputRef.current, e2, onChange);
        }
      };
      var handleKeyDown = function handleKeyDown2(e2) {
        if (onPressEnter && e2.key === "Enter") {
          onPressEnter(e2);
        }
        onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(e2);
      };
      var handleFocus = function handleFocus2(e2) {
        setFocused(true);
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
      };
      var handleBlur = function handleBlur2(e2) {
        setFocused(false);
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
      };
      var handleReset = function handleReset2(e2) {
        setValue2("");
        focus();
        if (inputRef.current) {
          resolveOnChange(inputRef.current, e2, onChange);
        }
      };
      var getInputElement = function getInputElement2() {
        var otherProps = omit(props, [
          "prefixCls",
          "onPressEnter",
          "addonBefore",
          "addonAfter",
          "prefix",
          "suffix",
          "allowClear",
          // Input elements must be either controlled or uncontrolled,
          // specify either the value prop, or the defaultValue prop, but not both.
          "defaultValue",
          "showCount",
          "affixWrapperClassName",
          "groupClassName",
          "inputClassName",
          "classes",
          "wrapperClassName",
          "htmlSize"
        ]);
        return /* @__PURE__ */ React$3.createElement("input", _extends$2({
          autoComplete
        }, otherProps, {
          onChange: handleChange,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onKeyDown: handleKeyDown,
          className: classNames(prefixCls, _defineProperty$7({}, "".concat(prefixCls, "-disabled"), disabled), inputClassName, classes === null || classes === void 0 ? void 0 : classes.input, !hasAddon(props) && !hasPrefixSuffix$1(props) && className),
          ref: inputRef,
          size: htmlSize,
          type: type2
        }));
      };
      var getSuffix = function getSuffix2() {
        var hasMaxLength = Number(maxLength) > 0;
        if (suffix || showCount) {
          var val = fixControlledValue(value);
          var valueLength = _toConsumableArray(val).length;
          var dataCount = _typeof$4(showCount) === "object" ? showCount.formatter({
            value: val,
            count: valueLength,
            maxLength
          }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
          return /* @__PURE__ */ React$3.createElement(React$3.Fragment, null, !!showCount && /* @__PURE__ */ React$3.createElement("span", {
            className: classNames("".concat(prefixCls, "-show-count-suffix"), _defineProperty$7({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix))
          }, dataCount), suffix);
        }
        return null;
      };
      return /* @__PURE__ */ React$3.createElement(BaseInput, _extends$2({}, rest, {
        prefixCls,
        className,
        inputElement: getInputElement(),
        handleReset,
        value: fixControlledValue(value),
        focused,
        triggerFocus: focus,
        suffix: getSuffix(),
        disabled,
        classes
      }));
    });
    function useRemovePasswordTimeout(inputRef, triggerOnMount) {
      const removePasswordTimeoutRef = reactExports.useRef([]);
      const removePasswordTimeout = () => {
        removePasswordTimeoutRef.current.push(setTimeout(() => {
          var _a, _b, _c, _d;
          if (((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute("value"))) {
            (_d = inputRef.current) === null || _d === void 0 ? void 0 : _d.input.removeAttribute("value");
          }
        }));
      };
      reactExports.useEffect(() => {
        if (triggerOnMount) {
          removePasswordTimeout();
        }
        return () => removePasswordTimeoutRef.current.forEach((timer) => {
          if (timer) {
            clearTimeout(timer);
          }
        });
      }, []);
      return removePasswordTimeout;
    }
    function hasPrefixSuffix(props) {
      return !!(props.prefix || props.suffix || props.allowClear);
    }
    var __rest$n = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function triggerFocus(element, option) {
      if (!element) {
        return;
      }
      element.focus(option);
      const {
        cursor
      } = option || {};
      if (cursor) {
        const len = element.value.length;
        switch (cursor) {
          case "start":
            element.setSelectionRange(0, 0);
            break;
          case "end":
            element.setSelectionRange(len, len);
            break;
          default:
            element.setSelectionRange(0, len);
            break;
        }
      }
    }
    const Input$2 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        bordered = true,
        status: customStatus,
        size: customSize,
        disabled: customDisabled,
        onBlur,
        onFocus,
        suffix,
        allowClear,
        addonAfter,
        addonBefore,
        className,
        rootClassName,
        onChange
      } = props, rest = __rest$n(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "rootClassName", "onChange"]);
      const {
        getPrefixCls,
        direction,
        input
      } = React$3.useContext(ConfigContext);
      const prefixCls = getPrefixCls("input", customizePrefixCls);
      const inputRef = reactExports.useRef(null);
      const [wrapSSR, hashId] = useStyle$l(prefixCls);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const size = React$3.useContext(SizeContext$2);
      const mergedSize = compactSize || customSize || size;
      const disabled = React$3.useContext(DisabledContext$1);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const {
        status: contextStatus,
        hasFeedback,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      const inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
      const prevHasPrefixSuffix = reactExports.useRef(inputHasPrefixSuffix);
      reactExports.useEffect(() => {
        if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current)
          ;
        prevHasPrefixSuffix.current = inputHasPrefixSuffix;
      }, [inputHasPrefixSuffix]);
      const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
      const handleBlur = (e2) => {
        removePasswordTimeout();
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
      };
      const handleFocus = (e2) => {
        removePasswordTimeout();
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
      };
      const handleChange = (e2) => {
        removePasswordTimeout();
        onChange === null || onChange === void 0 ? void 0 : onChange(e2);
      };
      const suffixNode = (hasFeedback || suffix) && /* @__PURE__ */ React$3.createElement(React$3.Fragment, null, suffix, hasFeedback && feedbackIcon);
      let mergedAllowClear;
      if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
        mergedAllowClear = allowClear;
      } else if (allowClear) {
        mergedAllowClear = {
          clearIcon: /* @__PURE__ */ React$3.createElement(CloseCircleFilled$1, null)
        };
      }
      return wrapSSR(/* @__PURE__ */ React$3.createElement(Input$3, Object.assign({
        ref: composeRef(ref, inputRef),
        prefixCls,
        autoComplete: input === null || input === void 0 ? void 0 : input.autoComplete
      }, rest, {
        disabled: mergedDisabled,
        onBlur: handleBlur,
        onFocus: handleFocus,
        suffix: suffixNode,
        allowClear: mergedAllowClear,
        className: classNames(className, rootClassName, compactItemClassnames),
        onChange: handleChange,
        addonAfter: addonAfter && /* @__PURE__ */ React$3.createElement(NoCompactStyle, null, /* @__PURE__ */ React$3.createElement(NoFormStyle, {
          override: true,
          status: true
        }, addonAfter)),
        addonBefore: addonBefore && /* @__PURE__ */ React$3.createElement(NoCompactStyle, null, /* @__PURE__ */ React$3.createElement(NoFormStyle, {
          override: true,
          status: true
        }, addonBefore)),
        classes: {
          input: classNames({
            [`${prefixCls}-sm`]: mergedSize === "small",
            [`${prefixCls}-lg`]: mergedSize === "large",
            [`${prefixCls}-rtl`]: direction === "rtl",
            [`${prefixCls}-borderless`]: !bordered
          }, !inputHasPrefixSuffix && getStatusClassNames(prefixCls, mergedStatus), hashId),
          affixWrapper: classNames({
            [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-affix-wrapper-borderless`]: !bordered
          }, getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus, hasFeedback), hashId),
          wrapper: classNames({
            [`${prefixCls}-group-rtl`]: direction === "rtl"
          }, hashId),
          group: classNames({
            [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-group-wrapper-disabled`]: mergedDisabled
          }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
        }
      })));
    });
    const InternalInput = Input$2;
    var EyeInvisibleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
    const EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;
    var EyeInvisibleOutlined = function EyeInvisibleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: EyeInvisibleOutlinedSvg
      }));
    };
    EyeInvisibleOutlined.displayName = "EyeInvisibleOutlined";
    const EyeInvisibleOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(EyeInvisibleOutlined);
    var __rest$m = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const defaultIconRender = (visible) => visible ? /* @__PURE__ */ reactExports.createElement(EyeOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(EyeInvisibleOutlined$1, null);
    const ActionMap = {
      click: "onClick",
      hover: "onMouseOver"
    };
    const Password = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        visibilityToggle = true
      } = props;
      const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
      const [visible, setVisible] = reactExports.useState(() => visibilityControlled ? visibilityToggle.visible : false);
      const inputRef = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (visibilityControlled) {
          setVisible(visibilityToggle.visible);
        }
      }, [visibilityControlled, visibilityToggle]);
      const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
      const onVisibleChange = () => {
        const {
          disabled
        } = props;
        if (disabled) {
          return;
        }
        if (visible) {
          removePasswordTimeout();
        }
        setVisible((prevState) => {
          var _a;
          const newState = !prevState;
          if (typeof visibilityToggle === "object") {
            (_a = visibilityToggle.onVisibleChange) === null || _a === void 0 ? void 0 : _a.call(visibilityToggle, newState);
          }
          return newState;
        });
      };
      const getIcon2 = (prefixCls2) => {
        const {
          action = "click",
          iconRender = defaultIconRender
        } = props;
        const iconTrigger = ActionMap[action] || "";
        const icon = iconRender(visible);
        const iconProps = {
          [iconTrigger]: onVisibleChange,
          className: `${prefixCls2}-icon`,
          key: "passwordIcon",
          onMouseDown: (e2) => {
            e2.preventDefault();
          },
          onMouseUp: (e2) => {
            e2.preventDefault();
          }
        };
        return /* @__PURE__ */ reactExports.cloneElement(/* @__PURE__ */ reactExports.isValidElement(icon) ? icon : /* @__PURE__ */ reactExports.createElement("span", null, icon), iconProps);
      };
      const {
        className,
        prefixCls: customizePrefixCls,
        inputPrefixCls: customizeInputPrefixCls,
        size
      } = props, restProps = __rest$m(props, ["className", "prefixCls", "inputPrefixCls", "size"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
      const prefixCls = getPrefixCls("input-password", customizePrefixCls);
      const suffixIcon = visibilityToggle && getIcon2(prefixCls);
      const inputClassName = classNames(prefixCls, className, {
        [`${prefixCls}-${size}`]: !!size
      });
      const omittedProps = Object.assign(Object.assign({}, omit(restProps, ["suffix", "iconRender", "visibilityToggle"])), {
        type: visible ? "text" : "password",
        className: inputClassName,
        prefixCls: inputPrefixCls,
        suffix: suffixIcon
      });
      if (size) {
        omittedProps.size = size;
      }
      return /* @__PURE__ */ reactExports.createElement(InternalInput, Object.assign({
        ref: composeRef(ref, inputRef)
      }, omittedProps));
    });
    const Password$1 = Password;
    var __rest$l = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Search = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        inputPrefixCls: customizeInputPrefixCls,
        className,
        size: customizeSize,
        suffix,
        enterButton = false,
        addonAfter,
        loading,
        disabled,
        onSearch: customOnSearch,
        onChange: customOnChange,
        onCompositionStart,
        onCompositionEnd
      } = props, restProps = __rest$l(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const contextSize = reactExports.useContext(SizeContext$2);
      const composedRef = reactExports.useRef(false);
      const prefixCls = getPrefixCls("input-search", customizePrefixCls);
      const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
      const {
        compactSize
      } = useCompactItemContext(prefixCls, direction);
      const size = compactSize || customizeSize || contextSize;
      const inputRef = reactExports.useRef(null);
      const onChange = (e2) => {
        if (e2 && e2.target && e2.type === "click" && customOnSearch) {
          customOnSearch(e2.target.value, e2);
        }
        if (customOnChange) {
          customOnChange(e2);
        }
      };
      const onMouseDown = (e2) => {
        var _a;
        if (document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input)) {
          e2.preventDefault();
        }
      };
      const onSearch = (e2) => {
        var _a, _b;
        if (customOnSearch) {
          customOnSearch((_b = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.value, e2);
        }
      };
      const onPressEnter = (e2) => {
        if (composedRef.current || loading) {
          return;
        }
        onSearch(e2);
      };
      const searchIcon = typeof enterButton === "boolean" ? /* @__PURE__ */ reactExports.createElement(SearchOutlined$1, null) : null;
      const btnClassName = `${prefixCls}-button`;
      let button;
      const enterButtonAsElement = enterButton || {};
      const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
      if (isAntdButton || enterButtonAsElement.type === "button") {
        button = cloneElement(enterButtonAsElement, Object.assign({
          onMouseDown,
          onClick: (e2) => {
            var _a, _b;
            (_b = (_a = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e2);
            onSearch(e2);
          },
          key: "enterButton"
        }, isAntdButton ? {
          className: btnClassName,
          size
        } : {}));
      } else {
        button = /* @__PURE__ */ reactExports.createElement(Button$2, {
          className: btnClassName,
          type: enterButton ? "primary" : void 0,
          size,
          disabled,
          key: "enterButton",
          onMouseDown,
          onClick: onSearch,
          loading,
          icon: searchIcon
        }, enterButton);
      }
      if (addonAfter) {
        button = [button, cloneElement(addonAfter, {
          key: "addonAfter"
        })];
      }
      const cls = classNames(prefixCls, {
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-${size}`]: !!size,
        [`${prefixCls}-with-button`]: !!enterButton
      }, className);
      const handleOnCompositionStart = (e2) => {
        composedRef.current = true;
        onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
      };
      const handleOnCompositionEnd = (e2) => {
        composedRef.current = false;
        onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
      };
      return /* @__PURE__ */ reactExports.createElement(InternalInput, Object.assign({
        ref: composeRef(inputRef, ref),
        onPressEnter
      }, restProps, {
        size,
        onCompositionStart: handleOnCompositionStart,
        onCompositionEnd: handleOnCompositionEnd,
        prefixCls: inputPrefixCls,
        addonAfter: button,
        suffix,
        onChange,
        className: cls,
        disabled
      }));
    });
    const Search$1 = Search;
    var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n  pointer-events: none !important;\n";
    var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
    var computedStyleCache = {};
    var hiddenTextarea;
    function calculateNodeStyling(node2) {
      var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
      if (useCache2 && computedStyleCache[nodeRef]) {
        return computedStyleCache[nodeRef];
      }
      var style2 = window.getComputedStyle(node2);
      var boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
      var paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
      var borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
      var sizingStyle = SIZING_STYLE.map(function(name) {
        return "".concat(name, ":").concat(style2.getPropertyValue(name));
      }).join(";");
      var nodeInfo = {
        sizingStyle,
        paddingSize,
        borderSize,
        boxSizing
      };
      if (useCache2 && nodeRef) {
        computedStyleCache[nodeRef] = nodeInfo;
      }
      return nodeInfo;
    }
    function calculateAutoSizeStyle(uiTextNode) {
      var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      if (!hiddenTextarea) {
        hiddenTextarea = document.createElement("textarea");
        hiddenTextarea.setAttribute("tab-index", "-1");
        hiddenTextarea.setAttribute("aria-hidden", "true");
        document.body.appendChild(hiddenTextarea);
      }
      if (uiTextNode.getAttribute("wrap")) {
        hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
      } else {
        hiddenTextarea.removeAttribute("wrap");
      }
      var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache2), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
      hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
      hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
      var minHeight = void 0;
      var maxHeight = void 0;
      var overflowY;
      var height = hiddenTextarea.scrollHeight;
      if (boxSizing === "border-box") {
        height += borderSize;
      } else if (boxSizing === "content-box") {
        height -= paddingSize;
      }
      if (minRows !== null || maxRows !== null) {
        hiddenTextarea.value = " ";
        var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (minRows !== null) {
          minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
        }
        if (maxRows !== null) {
          maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          overflowY = height > maxHeight ? "" : "hidden";
          height = Math.min(maxHeight, height);
        }
      }
      var style2 = {
        height,
        overflowY,
        resize: "none"
      };
      if (minHeight) {
        style2.minHeight = minHeight;
      }
      if (maxHeight) {
        style2.maxHeight = maxHeight;
      }
      return style2;
    }
    var _excluded$g = ["prefixCls", "onPressEnter", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"];
    var RESIZE_START = 0;
    var RESIZE_MEASURING = 1;
    var RESIZE_STABLE = 2;
    var ResizableTextArea = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _ref = props, prefixCls = _ref.prefixCls;
      _ref.onPressEnter;
      var defaultValue = _ref.defaultValue, value = _ref.value, autoSize = _ref.autoSize, onResize2 = _ref.onResize, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, onChange = _ref.onChange;
      _ref.onInternalAutoSize;
      var restProps = _objectWithoutProperties$1(_ref, _excluded$g);
      var _useMergedState = useMergedState(defaultValue, {
        value,
        postState: function postState(val) {
          return val !== null && val !== void 0 ? val : "";
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setMergedValue = _useMergedState2[1];
      var onInternalChange = function onInternalChange2(event) {
        setMergedValue(event.target.value);
        onChange === null || onChange === void 0 ? void 0 : onChange(event);
      };
      var textareaRef = reactExports.useRef();
      reactExports.useImperativeHandle(ref, function() {
        return {
          textArea: textareaRef.current
        };
      });
      var _React$useMemo = reactExports.useMemo(function() {
        if (autoSize && _typeof$4(autoSize) === "object") {
          return [autoSize.minRows, autoSize.maxRows];
        }
        return [];
      }, [autoSize]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), minRows = _React$useMemo2[0], maxRows = _React$useMemo2[1];
      var needAutoSize = !!autoSize;
      var fixFirefoxAutoScroll = function fixFirefoxAutoScroll2() {
        try {
          if (document.activeElement === textareaRef.current) {
            var _textareaRef$current = textareaRef.current, selectionStart = _textareaRef$current.selectionStart, selectionEnd = _textareaRef$current.selectionEnd, scrollTop = _textareaRef$current.scrollTop;
            textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
            textareaRef.current.scrollTop = scrollTop;
          }
        } catch (e2) {
        }
      };
      var _React$useState = reactExports.useState(RESIZE_STABLE), _React$useState2 = _slicedToArray(_React$useState, 2), resizeState = _React$useState2[0], setResizeState = _React$useState2[1];
      var _React$useState3 = reactExports.useState(), _React$useState4 = _slicedToArray(_React$useState3, 2), autoSizeStyle = _React$useState4[0], setAutoSizeStyle = _React$useState4[1];
      var startResize = function startResize2() {
        setResizeState(RESIZE_START);
      };
      useLayoutEffect$1(function() {
        if (needAutoSize) {
          startResize();
        }
      }, [value, minRows, maxRows, needAutoSize]);
      useLayoutEffect$1(function() {
        if (resizeState === RESIZE_START) {
          setResizeState(RESIZE_MEASURING);
        } else if (resizeState === RESIZE_MEASURING) {
          var textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
          setResizeState(RESIZE_STABLE);
          setAutoSizeStyle(textareaStyles);
        } else {
          fixFirefoxAutoScroll();
        }
      }, [resizeState]);
      var resizeRafRef = reactExports.useRef();
      var cleanRaf = function cleanRaf2() {
        wrapperRaf.cancel(resizeRafRef.current);
      };
      var onInternalResize = function onInternalResize2(size) {
        if (resizeState === RESIZE_STABLE) {
          onResize2 === null || onResize2 === void 0 ? void 0 : onResize2(size);
          if (autoSize) {
            cleanRaf();
            resizeRafRef.current = wrapperRaf(function() {
              startResize();
            });
          }
        }
      };
      reactExports.useEffect(function() {
        return cleanRaf;
      }, []);
      var mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
      var mergedStyle = _objectSpread2$3(_objectSpread2$3({}, style2), mergedAutoSizeStyle);
      if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
        mergedStyle.overflowY = "hidden";
        mergedStyle.overflowX = "hidden";
      }
      return /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onInternalResize,
        disabled: !(autoSize || onResize2)
      }, /* @__PURE__ */ reactExports.createElement("textarea", _extends$2({}, restProps, {
        ref: textareaRef,
        style: mergedStyle,
        className: classNames(prefixCls, className, _defineProperty$7({}, "".concat(prefixCls, "-disabled"), disabled)),
        disabled,
        value: mergedValue,
        onChange: onInternalChange
      })));
    });
    var _excluded$f = ["defaultValue", "value", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "classes", "showCount", "className", "style", "disabled"];
    function fixEmojiLength(value, maxLength) {
      return _toConsumableArray(value || "").slice(0, maxLength).join("");
    }
    function setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {
      var newTriggerValue = triggerValue;
      if (isCursorInEnd) {
        newTriggerValue = fixEmojiLength(triggerValue, maxLength);
      } else if (_toConsumableArray(preValue || "").length < triggerValue.length && _toConsumableArray(triggerValue || "").length > maxLength) {
        newTriggerValue = preValue;
      }
      return newTriggerValue;
    }
    var TextArea$2 = /* @__PURE__ */ React$3.forwardRef(function(_ref, ref) {
      var defaultValue = _ref.defaultValue, customValue = _ref.value, onChange = _ref.onChange, allowClear = _ref.allowClear, maxLength = _ref.maxLength, onCompositionStart = _ref.onCompositionStart, onCompositionEnd = _ref.onCompositionEnd, suffix = _ref.suffix, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-textarea" : _ref$prefixCls, classes = _ref.classes, showCount = _ref.showCount, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, rest = _objectWithoutProperties$1(_ref, _excluded$f);
      var _useMergedState = useMergedState(defaultValue, {
        value: customValue,
        defaultValue
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue2 = _useMergedState2[1];
      var resizableTextAreaRef = reactExports.useRef(null);
      var _React$useState = React$3.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), compositing = _React$useState2[0], setCompositing = _React$useState2[1];
      var oldCompositionValueRef = React$3.useRef();
      var oldSelectionStartRef = React$3.useRef(0);
      var focus = function focus2() {
        resizableTextAreaRef.current.textArea.focus();
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          resizableTextArea: resizableTextAreaRef.current,
          focus,
          blur: function blur() {
            resizableTextAreaRef.current.textArea.blur();
          }
        };
      });
      var hasMaxLength = Number(maxLength) > 0;
      var onInternalCompositionStart = function onInternalCompositionStart2(e2) {
        setCompositing(true);
        oldCompositionValueRef.current = value;
        oldSelectionStartRef.current = e2.currentTarget.selectionStart;
        onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
      };
      var onInternalCompositionEnd = function onInternalCompositionEnd2(e2) {
        setCompositing(false);
        var triggerValue = e2.currentTarget.value;
        if (hasMaxLength) {
          var _oldCompositionValueR;
          var isCursorInEnd = oldSelectionStartRef.current >= maxLength + 1 || oldSelectionStartRef.current === ((_oldCompositionValueR = oldCompositionValueRef.current) === null || _oldCompositionValueR === void 0 ? void 0 : _oldCompositionValueR.length);
          triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.current, triggerValue, maxLength);
        }
        if (triggerValue !== value) {
          setValue2(triggerValue);
          resolveOnChange(e2.currentTarget, e2, onChange, triggerValue);
        }
        onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
      };
      var handleChange = function handleChange2(e2) {
        var triggerValue = e2.target.value;
        if (!compositing && hasMaxLength) {
          var isCursorInEnd = e2.target.selectionStart >= maxLength + 1 || e2.target.selectionStart === triggerValue.length || !e2.target.selectionStart;
          triggerValue = setTriggerValue(isCursorInEnd, value, triggerValue, maxLength);
        }
        setValue2(triggerValue);
        resolveOnChange(e2.currentTarget, e2, onChange, triggerValue);
      };
      var handleKeyDown = function handleKeyDown2(e2) {
        var onPressEnter = rest.onPressEnter, onKeyDown2 = rest.onKeyDown;
        if (e2.key === "Enter" && onPressEnter) {
          onPressEnter(e2);
        }
        onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(e2);
      };
      var handleReset = function handleReset2(e2) {
        setValue2("");
        focus();
        resolveOnChange(resizableTextAreaRef.current.textArea, e2, onChange);
      };
      var val = fixControlledValue(value);
      if (!compositing && hasMaxLength && (customValue === null || customValue === void 0)) {
        val = fixEmojiLength(val, maxLength);
      }
      var textarea = /* @__PURE__ */ React$3.createElement(BaseInput, {
        value: val,
        allowClear,
        handleReset,
        suffix,
        prefixCls,
        classes: {
          affixWrapper: classes === null || classes === void 0 ? void 0 : classes.affixWrapper
        },
        disabled,
        style: style2,
        inputStyle: {
          resize: style2 === null || style2 === void 0 ? void 0 : style2.resize
        },
        inputElement: /* @__PURE__ */ React$3.createElement(ResizableTextArea, _extends$2({}, rest, {
          onKeyDown: handleKeyDown,
          onChange: handleChange,
          onCompositionStart: onInternalCompositionStart,
          onCompositionEnd: onInternalCompositionEnd,
          className: classNames(showCount ? "" : className, classes === null || classes === void 0 ? void 0 : classes.textarea),
          style: !showCount && style2,
          disabled,
          prefixCls,
          ref: resizableTextAreaRef
        }))
      });
      if (showCount) {
        var valueLength = _toConsumableArray(val).length;
        var dataCount;
        if (_typeof$4(showCount) === "object") {
          dataCount = showCount.formatter({
            value: val,
            count: valueLength,
            maxLength
          });
        } else {
          dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
        }
        return /* @__PURE__ */ React$3.createElement("div", {
          hidden: rest.hidden,
          className: classNames("".concat(prefixCls, "-show-count"), className, classes === null || classes === void 0 ? void 0 : classes.countWrapper),
          style: style2,
          "data-count": dataCount
        }, textarea, /* @__PURE__ */ React$3.createElement("span", {
          className: "".concat(prefixCls, "-data-count")
        }, dataCount));
      }
      return textarea;
    });
    var __rest$k = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const TextArea = /* @__PURE__ */ reactExports.forwardRef((_a, ref) => {
      var {
        prefixCls: customizePrefixCls,
        bordered = true,
        size: customizeSize,
        disabled: customDisabled,
        status: customStatus,
        allowClear
      } = _a, rest = __rest$k(_a, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const size = reactExports.useContext(SizeContext$2);
      const mergedSize = customizeSize || size;
      const disabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const {
        status: contextStatus,
        hasFeedback,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      const innerRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, () => {
        var _a2;
        return {
          resizableTextArea: (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea,
          focus: (option) => {
            var _a3, _b;
            triggerFocus((_b = (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
          },
          blur: () => {
            var _a3;
            return (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.blur();
          }
        };
      });
      const prefixCls = getPrefixCls("input", customizePrefixCls);
      let mergedAllowClear;
      if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
        mergedAllowClear = allowClear;
      } else if (allowClear) {
        mergedAllowClear = {
          clearIcon: /* @__PURE__ */ reactExports.createElement(CloseCircleFilled$1, null)
        };
      }
      const [wrapSSR, hashId] = useStyle$l(prefixCls);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(TextArea$2, Object.assign({}, rest, {
        disabled: mergedDisabled,
        allowClear: mergedAllowClear,
        classes: {
          affixWrapper: classNames(`${prefixCls}-textarea-affix-wrapper`, {
            [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-affix-wrapper-borderless`]: !bordered,
            [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large"
          }, getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus), hashId),
          countWrapper: classNames(`${prefixCls}-textarea`, `${prefixCls}-textarea-show-count`, hashId),
          textarea: classNames({
            [`${prefixCls}-borderless`]: !bordered,
            [`${prefixCls}-sm`]: mergedSize === "small",
            [`${prefixCls}-lg`]: mergedSize === "large"
          }, getStatusClassNames(prefixCls, mergedStatus), hashId)
        },
        prefixCls,
        suffix: hasFeedback && /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-textarea-suffix`
        }, feedbackIcon),
        ref: innerRef
      })));
    });
    const TextArea$1 = TextArea;
    const Input = InternalInput;
    Input.Group = Group$1;
    Input.Search = Search$1;
    Input.TextArea = TextArea$1;
    Input.Password = Password$1;
    const Input$1 = Input;
    var UpOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, "name": "up", "theme": "outlined" };
    const UpOutlinedSvg = UpOutlined$2;
    var UpOutlined = function UpOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: UpOutlinedSvg
      }));
    };
    UpOutlined.displayName = "UpOutlined";
    const UpOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(UpOutlined);
    function supportBigInt() {
      return typeof BigInt === "function";
    }
    function trimNumber(numStr) {
      var str = numStr.trim();
      var negative = str.startsWith("-");
      if (negative) {
        str = str.slice(1);
      }
      str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
      if (str.startsWith(".")) {
        str = "0".concat(str);
      }
      var trimStr = str || "0";
      var splitNumber = trimStr.split(".");
      var integerStr = splitNumber[0] || "0";
      var decimalStr = splitNumber[1] || "0";
      if (integerStr === "0" && decimalStr === "0") {
        negative = false;
      }
      var negativeStr = negative ? "-" : "";
      return {
        negative,
        negativeStr,
        trimStr,
        integerStr,
        decimalStr,
        fullStr: "".concat(negativeStr).concat(trimStr)
      };
    }
    function isE(number2) {
      var str = String(number2);
      return !Number.isNaN(Number(str)) && str.includes("e");
    }
    function getNumberPrecision(number2) {
      var numStr = String(number2);
      if (isE(number2)) {
        var precision = Number(numStr.slice(numStr.indexOf("e-") + 2));
        var decimalMatch = numStr.match(/\.(\d+)/);
        if (decimalMatch !== null && decimalMatch !== void 0 && decimalMatch[1]) {
          precision += decimalMatch[1].length;
        }
        return precision;
      }
      return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
    }
    function num2str(number2) {
      var numStr = String(number2);
      if (isE(number2)) {
        if (number2 > Number.MAX_SAFE_INTEGER) {
          return String(supportBigInt() ? BigInt(number2).toString() : Number.MAX_SAFE_INTEGER);
        }
        if (number2 < Number.MIN_SAFE_INTEGER) {
          return String(supportBigInt() ? BigInt(number2).toString() : Number.MIN_SAFE_INTEGER);
        }
        numStr = number2.toFixed(getNumberPrecision(numStr));
      }
      return trimNumber(numStr).fullStr;
    }
    function validateNumber(num) {
      if (typeof num === "number") {
        return !Number.isNaN(num);
      }
      if (!num) {
        return false;
      }
      return (
        // Normal type: 11.28
        /^\s*-?\d+(\.\d+)?\s*$/.test(num) || // Pre-number: 1.
        /^\s*-?\d+\.\s*$/.test(num) || // Post-number: .1
        /^\s*-?\.\d+\s*$/.test(num)
      );
    }
    function isEmpty(value) {
      return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();
    }
    var NumberDecimal = /* @__PURE__ */ function() {
      function NumberDecimal2(value) {
        _classCallCheck(this, NumberDecimal2);
        _defineProperty$7(this, "origin", "");
        _defineProperty$7(this, "number", void 0);
        _defineProperty$7(this, "empty", void 0);
        if (isEmpty(value)) {
          this.empty = true;
          return;
        }
        this.origin = String(value);
        this.number = Number(value);
      }
      _createClass(NumberDecimal2, [{
        key: "negate",
        value: function negate() {
          return new NumberDecimal2(-this.toNumber());
        }
      }, {
        key: "add",
        value: function add2(value) {
          if (this.isInvalidate()) {
            return new NumberDecimal2(value);
          }
          var target = Number(value);
          if (Number.isNaN(target)) {
            return this;
          }
          var number2 = this.number + target;
          if (number2 > Number.MAX_SAFE_INTEGER) {
            return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
          }
          if (number2 < Number.MIN_SAFE_INTEGER) {
            return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
          }
          var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
          return new NumberDecimal2(number2.toFixed(maxPrecision));
        }
      }, {
        key: "isEmpty",
        value: function isEmpty2() {
          return this.empty;
        }
      }, {
        key: "isNaN",
        value: function isNaN2() {
          return Number.isNaN(this.number);
        }
      }, {
        key: "isInvalidate",
        value: function isInvalidate() {
          return this.isEmpty() || this.isNaN();
        }
      }, {
        key: "equals",
        value: function equals(target) {
          return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
        }
      }, {
        key: "lessEquals",
        value: function lessEquals(target) {
          return this.add(target.negate().toString()).toNumber() <= 0;
        }
      }, {
        key: "toNumber",
        value: function toNumber2() {
          return this.number;
        }
      }, {
        key: "toString",
        value: function toString2() {
          var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          if (!safe) {
            return this.origin;
          }
          if (this.isInvalidate()) {
            return "";
          }
          return num2str(this.number);
        }
      }]);
      return NumberDecimal2;
    }();
    var BigIntDecimal = /* @__PURE__ */ function() {
      function BigIntDecimal2(value) {
        _classCallCheck(this, BigIntDecimal2);
        _defineProperty$7(this, "origin", "");
        _defineProperty$7(this, "negative", void 0);
        _defineProperty$7(this, "integer", void 0);
        _defineProperty$7(this, "decimal", void 0);
        _defineProperty$7(this, "decimalLen", void 0);
        _defineProperty$7(this, "empty", void 0);
        _defineProperty$7(this, "nan", void 0);
        if (isEmpty(value)) {
          this.empty = true;
          return;
        }
        this.origin = String(value);
        if (value === "-" || Number.isNaN(value)) {
          this.nan = true;
          return;
        }
        var mergedValue = value;
        if (isE(mergedValue)) {
          mergedValue = Number(mergedValue);
        }
        mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
        if (validateNumber(mergedValue)) {
          var trimRet = trimNumber(mergedValue);
          this.negative = trimRet.negative;
          var numbers = trimRet.trimStr.split(".");
          this.integer = BigInt(numbers[0]);
          var decimalStr = numbers[1] || "0";
          this.decimal = BigInt(decimalStr);
          this.decimalLen = decimalStr.length;
        } else {
          this.nan = true;
        }
      }
      _createClass(BigIntDecimal2, [{
        key: "getMark",
        value: function getMark2() {
          return this.negative ? "-" : "";
        }
      }, {
        key: "getIntegerStr",
        value: function getIntegerStr() {
          return this.integer.toString();
        }
      }, {
        key: "getDecimalStr",
        value: function getDecimalStr() {
          return this.decimal.toString().padStart(this.decimalLen, "0");
        }
        /**
         * Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
         * This is used for add function only.
         */
      }, {
        key: "alignDecimal",
        value: function alignDecimal(decimalLength) {
          var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, "0"));
          return BigInt(str);
        }
      }, {
        key: "negate",
        value: function negate() {
          var clone = new BigIntDecimal2(this.toString());
          clone.negative = !clone.negative;
          return clone;
        }
      }, {
        key: "add",
        value: function add2(value) {
          if (this.isInvalidate()) {
            return new BigIntDecimal2(value);
          }
          var offset2 = new BigIntDecimal2(value);
          if (offset2.isInvalidate()) {
            return this;
          }
          var maxDecimalLength = Math.max(this.getDecimalStr().length, offset2.getDecimalStr().length);
          var myAlignedDecimal = this.alignDecimal(maxDecimalLength);
          var offsetAlignedDecimal = offset2.alignDecimal(maxDecimalLength);
          var valueStr = (myAlignedDecimal + offsetAlignedDecimal).toString();
          var _trimNumber = trimNumber(valueStr), negativeStr = _trimNumber.negativeStr, trimStr = _trimNumber.trimStr;
          var hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(maxDecimalLength + 1, "0"));
          return new BigIntDecimal2("".concat(hydrateValueStr.slice(0, -maxDecimalLength), ".").concat(hydrateValueStr.slice(-maxDecimalLength)));
        }
      }, {
        key: "isEmpty",
        value: function isEmpty2() {
          return this.empty;
        }
      }, {
        key: "isNaN",
        value: function isNaN2() {
          return this.nan;
        }
      }, {
        key: "isInvalidate",
        value: function isInvalidate() {
          return this.isEmpty() || this.isNaN();
        }
      }, {
        key: "equals",
        value: function equals(target) {
          return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
        }
      }, {
        key: "lessEquals",
        value: function lessEquals(target) {
          return this.add(target.negate().toString()).toNumber() <= 0;
        }
      }, {
        key: "toNumber",
        value: function toNumber2() {
          if (this.isNaN()) {
            return NaN;
          }
          return Number(this.toString());
        }
      }, {
        key: "toString",
        value: function toString2() {
          var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          if (!safe) {
            return this.origin;
          }
          if (this.isInvalidate()) {
            return "";
          }
          return trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr;
        }
      }]);
      return BigIntDecimal2;
    }();
    function getMiniDecimal(value) {
      if (supportBigInt()) {
        return new BigIntDecimal(value);
      }
      return new NumberDecimal(value);
    }
    function toFixed(numStr, separatorStr, precision) {
      var cutOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (numStr === "") {
        return "";
      }
      var _trimNumber2 = trimNumber(numStr), negativeStr = _trimNumber2.negativeStr, integerStr = _trimNumber2.integerStr, decimalStr = _trimNumber2.decimalStr;
      var precisionDecimalStr = "".concat(separatorStr).concat(decimalStr);
      var numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
      if (precision >= 0) {
        var advancedNum = Number(decimalStr[precision]);
        if (advancedNum >= 5 && !cutOnly) {
          var advancedDecimal = getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat("0".repeat(precision)).concat(10 - advancedNum));
          return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);
        }
        if (precision === 0) {
          return numberWithoutDecimal;
        }
        return "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, "0").slice(0, precision));
      }
      if (precisionDecimalStr === ".0") {
        return numberWithoutDecimal;
      }
      return "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
    }
    var useMobile = function useMobile2() {
      var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
      reactExports.useLayoutEffect(function() {
        setMobile(isMobile());
      }, []);
      return mobile;
    };
    var STEP_INTERVAL = 200;
    var STEP_DELAY = 600;
    function StepHandler(_ref) {
      var prefixCls = _ref.prefixCls, upNode = _ref.upNode, downNode = _ref.downNode, upDisabled = _ref.upDisabled, downDisabled = _ref.downDisabled, onStep = _ref.onStep;
      var stepTimeoutRef = reactExports.useRef();
      var onStepRef = reactExports.useRef();
      onStepRef.current = onStep;
      var onStepMouseDown = function onStepMouseDown2(e2, up) {
        e2.preventDefault();
        onStepRef.current(up);
        function loopStep() {
          onStepRef.current(up);
          stepTimeoutRef.current = setTimeout(loopStep, STEP_INTERVAL);
        }
        stepTimeoutRef.current = setTimeout(loopStep, STEP_DELAY);
      };
      var onStopStep = function onStopStep2() {
        clearTimeout(stepTimeoutRef.current);
      };
      reactExports.useEffect(function() {
        return onStopStep;
      }, []);
      var isMobile2 = useMobile();
      if (isMobile2) {
        return null;
      }
      var handlerClassName = "".concat(prefixCls, "-handler");
      var upClassName = classNames(handlerClassName, "".concat(handlerClassName, "-up"), _defineProperty$7({}, "".concat(handlerClassName, "-up-disabled"), upDisabled));
      var downClassName = classNames(handlerClassName, "".concat(handlerClassName, "-down"), _defineProperty$7({}, "".concat(handlerClassName, "-down-disabled"), downDisabled));
      var sharedHandlerProps = {
        unselectable: "on",
        role: "button",
        onMouseUp: onStopStep,
        onMouseLeave: onStopStep
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(handlerClassName, "-wrap")
      }, /* @__PURE__ */ reactExports.createElement("span", _extends$2({}, sharedHandlerProps, {
        onMouseDown: function onMouseDown(e2) {
          onStepMouseDown(e2, true);
        },
        "aria-label": "Increase Value",
        "aria-disabled": upDisabled,
        className: upClassName
      }), upNode || /* @__PURE__ */ reactExports.createElement("span", {
        unselectable: "on",
        className: "".concat(prefixCls, "-handler-up-inner")
      })), /* @__PURE__ */ reactExports.createElement("span", _extends$2({}, sharedHandlerProps, {
        onMouseDown: function onMouseDown(e2) {
          onStepMouseDown(e2, false);
        },
        "aria-label": "Decrease Value",
        "aria-disabled": downDisabled,
        className: downClassName
      }), downNode || /* @__PURE__ */ reactExports.createElement("span", {
        unselectable: "on",
        className: "".concat(prefixCls, "-handler-down-inner")
      })));
    }
    function getDecupleSteps(step) {
      var stepStr = typeof step === "number" ? num2str(step) : trimNumber(step).fullStr;
      var hasPoint = stepStr.includes(".");
      if (!hasPoint) {
        return step + "0";
      }
      return trimNumber(stepStr.replace(/(\d)\.(\d)/g, "$1$2.")).fullStr;
    }
    function useCursor(input, focused) {
      var selectionRef = reactExports.useRef(null);
      function recordCursor() {
        try {
          var start2 = input.selectionStart, end2 = input.selectionEnd, value = input.value;
          var beforeTxt = value.substring(0, start2);
          var afterTxt = value.substring(end2);
          selectionRef.current = {
            start: start2,
            end: end2,
            value,
            beforeTxt,
            afterTxt
          };
        } catch (e2) {
        }
      }
      function restoreCursor() {
        if (input && selectionRef.current && focused) {
          try {
            var value = input.value;
            var _selectionRef$current = selectionRef.current, beforeTxt = _selectionRef$current.beforeTxt, afterTxt = _selectionRef$current.afterTxt, start2 = _selectionRef$current.start;
            var startPos = value.length;
            if (value.endsWith(afterTxt)) {
              startPos = value.length - selectionRef.current.afterTxt.length;
            } else if (value.startsWith(beforeTxt)) {
              startPos = beforeTxt.length;
            } else {
              var beforeLastChar = beforeTxt[start2 - 1];
              var newIndex = value.indexOf(beforeLastChar, start2 - 1);
              if (newIndex !== -1) {
                startPos = newIndex + 1;
              }
            }
            input.setSelectionRange(startPos, startPos);
          } catch (e2) {
            warningOnce$1(false, "Something warning of cursor restore. Please fire issue about this: ".concat(e2.message));
          }
        }
      }
      return [recordCursor, restoreCursor];
    }
    const useFrame = function() {
      var idRef = reactExports.useRef(0);
      var cleanUp = function cleanUp2() {
        wrapperRaf.cancel(idRef.current);
      };
      reactExports.useEffect(function() {
        return cleanUp;
      }, []);
      return function(callback) {
        cleanUp();
        idRef.current = wrapperRaf(function() {
          callback();
        });
      };
    };
    var _excluded$e = ["prefixCls", "className", "style", "min", "max", "step", "defaultValue", "value", "disabled", "readOnly", "upHandler", "downHandler", "keyboard", "controls", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep"];
    var getDecimalValue = function getDecimalValue2(stringMode, decimalValue) {
      if (stringMode || decimalValue.isEmpty()) {
        return decimalValue.toString();
      }
      return decimalValue.toNumber();
    };
    var getDecimalIfValidate = function getDecimalIfValidate2(value) {
      var decimal = getMiniDecimal(value);
      return decimal.isInvalidate() ? null : decimal;
    };
    var InputNumber$2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _classNames;
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input-number" : _props$prefixCls, className = props.className, style2 = props.style, min = props.min, max = props.max, _props$step = props.step, step = _props$step === void 0 ? 1 : _props$step, defaultValue = props.defaultValue, value = props.value, disabled = props.disabled, readOnly2 = props.readOnly, upHandler = props.upHandler, downHandler = props.downHandler, keyboard = props.keyboard, _props$controls = props.controls, controls = _props$controls === void 0 ? true : _props$controls, stringMode = props.stringMode, parser2 = props.parser, formatter = props.formatter, precision = props.precision, decimalSeparator = props.decimalSeparator, onChange = props.onChange, onInput = props.onInput, onPressEnter = props.onPressEnter, onStep = props.onStep, inputProps = _objectWithoutProperties$1(props, _excluded$e);
      var inputClassName = "".concat(prefixCls, "-input");
      var inputRef = reactExports.useRef(null);
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focus = _React$useState2[0], setFocus = _React$useState2[1];
      var userTypingRef = reactExports.useRef(false);
      var compositionRef = reactExports.useRef(false);
      var shiftKeyRef = reactExports.useRef(false);
      var _React$useState3 = reactExports.useState(function() {
        return getMiniDecimal(value !== null && value !== void 0 ? value : defaultValue);
      }), _React$useState4 = _slicedToArray(_React$useState3, 2), decimalValue = _React$useState4[0], setDecimalValue = _React$useState4[1];
      function setUncontrolledDecimalValue(newDecimal) {
        if (value === void 0) {
          setDecimalValue(newDecimal);
        }
      }
      var getPrecision = reactExports.useCallback(function(numStr, userTyping) {
        if (userTyping) {
          return void 0;
        }
        if (precision >= 0) {
          return precision;
        }
        return Math.max(getNumberPrecision(numStr), getNumberPrecision(step));
      }, [precision, step]);
      var mergedParser = reactExports.useCallback(function(num) {
        var numStr = String(num);
        if (parser2) {
          return parser2(numStr);
        }
        var parsedStr = numStr;
        if (decimalSeparator) {
          parsedStr = parsedStr.replace(decimalSeparator, ".");
        }
        return parsedStr.replace(/[^\w.-]+/g, "");
      }, [parser2, decimalSeparator]);
      var inputValueRef = reactExports.useRef("");
      var mergedFormatter = reactExports.useCallback(function(number2, userTyping) {
        if (formatter) {
          return formatter(number2, {
            userTyping,
            input: String(inputValueRef.current)
          });
        }
        var str = typeof number2 === "number" ? num2str(number2) : number2;
        if (!userTyping) {
          var mergedPrecision = getPrecision(str, userTyping);
          if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) {
            var separatorStr = decimalSeparator || ".";
            str = toFixed(str, separatorStr, mergedPrecision);
          }
        }
        return str;
      }, [formatter, getPrecision, decimalSeparator]);
      var _React$useState5 = reactExports.useState(function() {
        var initValue = defaultValue !== null && defaultValue !== void 0 ? defaultValue : value;
        if (decimalValue.isInvalidate() && ["string", "number"].includes(_typeof$4(initValue))) {
          return Number.isNaN(initValue) ? "" : initValue;
        }
        return mergedFormatter(decimalValue.toString(), false);
      }), _React$useState6 = _slicedToArray(_React$useState5, 2), inputValue = _React$useState6[0], setInternalInputValue = _React$useState6[1];
      inputValueRef.current = inputValue;
      function setInputValue(newValue, userTyping) {
        setInternalInputValue(mergedFormatter(
          // Invalidate number is sometime passed by external control, we should let it go
          // Otherwise is controlled by internal interactive logic which check by userTyping
          // You can ref 'show limited value when input is not focused' test for more info.
          newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping),
          userTyping
        ));
      }
      var maxDecimal = reactExports.useMemo(function() {
        return getDecimalIfValidate(max);
      }, [max, precision]);
      var minDecimal = reactExports.useMemo(function() {
        return getDecimalIfValidate(min);
      }, [min, precision]);
      var upDisabled = reactExports.useMemo(function() {
        if (!maxDecimal || !decimalValue || decimalValue.isInvalidate()) {
          return false;
        }
        return maxDecimal.lessEquals(decimalValue);
      }, [maxDecimal, decimalValue]);
      var downDisabled = reactExports.useMemo(function() {
        if (!minDecimal || !decimalValue || decimalValue.isInvalidate()) {
          return false;
        }
        return decimalValue.lessEquals(minDecimal);
      }, [minDecimal, decimalValue]);
      var _useCursor = useCursor(inputRef.current, focus), _useCursor2 = _slicedToArray(_useCursor, 2), recordCursor = _useCursor2[0], restoreCursor = _useCursor2[1];
      var getRangeValue = function getRangeValue2(target) {
        if (maxDecimal && !target.lessEquals(maxDecimal)) {
          return maxDecimal;
        }
        if (minDecimal && !minDecimal.lessEquals(target)) {
          return minDecimal;
        }
        return null;
      };
      var isInRange2 = function isInRange3(target) {
        return !getRangeValue(target);
      };
      var triggerValueUpdate = function triggerValueUpdate2(newValue, userTyping) {
        var updateValue = newValue;
        var isRangeValidate = isInRange2(updateValue) || updateValue.isEmpty();
        if (!updateValue.isEmpty() && !userTyping) {
          updateValue = getRangeValue(updateValue) || updateValue;
          isRangeValidate = true;
        }
        if (!readOnly2 && !disabled && isRangeValidate) {
          var numStr = updateValue.toString();
          var mergedPrecision = getPrecision(numStr, userTyping);
          if (mergedPrecision >= 0) {
            updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision));
            if (!isInRange2(updateValue)) {
              updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision, true));
            }
          }
          if (!updateValue.equals(decimalValue)) {
            setUncontrolledDecimalValue(updateValue);
            onChange === null || onChange === void 0 ? void 0 : onChange(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue));
            if (value === void 0) {
              setInputValue(updateValue, userTyping);
            }
          }
          return updateValue;
        }
        return decimalValue;
      };
      var onNextPromise = useFrame();
      var collectInputValue = function collectInputValue2(inputStr) {
        recordCursor();
        setInternalInputValue(inputStr);
        if (!compositionRef.current) {
          var finalValue = mergedParser(inputStr);
          var finalDecimal = getMiniDecimal(finalValue);
          if (!finalDecimal.isNaN()) {
            triggerValueUpdate(finalDecimal, true);
          }
        }
        onInput === null || onInput === void 0 ? void 0 : onInput(inputStr);
        onNextPromise(function() {
          var nextInputStr = inputStr;
          if (!parser2) {
            nextInputStr = inputStr.replace(/。/g, ".");
          }
          if (nextInputStr !== inputStr) {
            collectInputValue2(nextInputStr);
          }
        });
      };
      var onCompositionStart = function onCompositionStart2() {
        compositionRef.current = true;
      };
      var onCompositionEnd = function onCompositionEnd2() {
        compositionRef.current = false;
        collectInputValue(inputRef.current.value);
      };
      var onInternalInput = function onInternalInput2(e2) {
        collectInputValue(e2.target.value);
      };
      var onInternalStep = function onInternalStep2(up) {
        var _inputRef$current;
        if (up && upDisabled || !up && downDisabled) {
          return;
        }
        userTypingRef.current = false;
        var stepDecimal = getMiniDecimal(shiftKeyRef.current ? getDecupleSteps(step) : step);
        if (!up) {
          stepDecimal = stepDecimal.negate();
        }
        var target = (decimalValue || getMiniDecimal(0)).add(stepDecimal.toString());
        var updatedValue = triggerValueUpdate(target, false);
        onStep === null || onStep === void 0 ? void 0 : onStep(getDecimalValue(stringMode, updatedValue), {
          offset: shiftKeyRef.current ? getDecupleSteps(step) : step,
          type: up ? "up" : "down"
        });
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
      };
      var flushInputValue = function flushInputValue2(userTyping) {
        var parsedValue = getMiniDecimal(mergedParser(inputValue));
        var formatValue2 = parsedValue;
        if (!parsedValue.isNaN()) {
          formatValue2 = triggerValueUpdate(parsedValue, userTyping);
        } else {
          formatValue2 = decimalValue;
        }
        if (value !== void 0) {
          setInputValue(decimalValue, false);
        } else if (!formatValue2.isNaN()) {
          setInputValue(formatValue2, false);
        }
      };
      var onBeforeInput = function onBeforeInput2() {
        userTypingRef.current = true;
      };
      var onKeyDown2 = function onKeyDown3(event) {
        var which = event.which, shiftKey = event.shiftKey;
        userTypingRef.current = true;
        if (shiftKey) {
          shiftKeyRef.current = true;
        } else {
          shiftKeyRef.current = false;
        }
        if (which === KeyCode.ENTER) {
          if (!compositionRef.current) {
            userTypingRef.current = false;
          }
          flushInputValue(false);
          onPressEnter === null || onPressEnter === void 0 ? void 0 : onPressEnter(event);
        }
        if (keyboard === false) {
          return;
        }
        if (!compositionRef.current && [KeyCode.UP, KeyCode.DOWN].includes(which)) {
          onInternalStep(KeyCode.UP === which);
          event.preventDefault();
        }
      };
      var onKeyUp = function onKeyUp2() {
        userTypingRef.current = false;
        shiftKeyRef.current = false;
      };
      var onBlur = function onBlur2() {
        flushInputValue(false);
        setFocus(false);
        userTypingRef.current = false;
      };
      useLayoutUpdateEffect(function() {
        if (!decimalValue.isInvalidate()) {
          setInputValue(decimalValue, false);
        }
      }, [precision]);
      useLayoutUpdateEffect(function() {
        var newValue = getMiniDecimal(value);
        setDecimalValue(newValue);
        var currentParsedValue = getMiniDecimal(mergedParser(inputValue));
        if (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter) {
          setInputValue(newValue, userTypingRef.current);
        }
      }, [value]);
      useLayoutUpdateEffect(function() {
        if (formatter) {
          restoreCursor();
        }
      }, [inputValue]);
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(prefixCls, className, (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-focused"), focus), _defineProperty$7(_classNames, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$7(_classNames, "".concat(prefixCls, "-readonly"), readOnly2), _defineProperty$7(_classNames, "".concat(prefixCls, "-not-a-number"), decimalValue.isNaN()), _defineProperty$7(_classNames, "".concat(prefixCls, "-out-of-range"), !decimalValue.isInvalidate() && !isInRange2(decimalValue)), _classNames)),
        style: style2,
        onFocus: function onFocus() {
          setFocus(true);
        },
        onBlur,
        onKeyDown: onKeyDown2,
        onKeyUp,
        onCompositionStart,
        onCompositionEnd,
        onBeforeInput
      }, controls && /* @__PURE__ */ reactExports.createElement(StepHandler, {
        prefixCls,
        upNode: upHandler,
        downNode: downHandler,
        upDisabled,
        downDisabled,
        onStep: onInternalStep
      }), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(inputClassName, "-wrap")
      }, /* @__PURE__ */ reactExports.createElement("input", _extends$2({
        autoComplete: "off",
        role: "spinbutton",
        "aria-valuemin": min,
        "aria-valuemax": max,
        "aria-valuenow": decimalValue.isInvalidate() ? null : decimalValue.toString(),
        step
      }, inputProps, {
        ref: composeRef(inputRef, ref),
        className: inputClassName,
        value: inputValue,
        onChange: onInternalInput,
        disabled,
        readOnly: readOnly2
      }))));
    });
    InputNumber$2.displayName = "InputNumber";
    const genInputNumberStyles = (token2) => {
      const {
        componentCls,
        lineWidth,
        lineType,
        colorBorder,
        borderRadius,
        fontSizeLG,
        controlHeightLG,
        controlHeightSM,
        colorError,
        inputPaddingHorizontalSM,
        colorTextDescription,
        motionDurationMid,
        colorPrimary,
        controlHeight,
        inputPaddingHorizontal,
        colorBgContainer,
        colorTextDisabled,
        borderRadiusSM,
        borderRadiusLG,
        controlWidth,
        handleVisible
      } = token2;
      return [
        {
          [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), genBasicInputStyle(token2)), genStatusStyle(token2, componentCls)), {
            display: "inline-block",
            width: controlWidth,
            margin: 0,
            padding: 0,
            border: `${lineWidth}px ${lineType} ${colorBorder}`,
            borderRadius,
            "&-rtl": {
              direction: "rtl",
              [`${componentCls}-input`]: {
                direction: "rtl"
              }
            },
            "&-lg": {
              padding: 0,
              fontSize: fontSizeLG,
              borderRadius: borderRadiusLG,
              [`input${componentCls}-input`]: {
                height: controlHeightLG - 2 * lineWidth
              }
            },
            "&-sm": {
              padding: 0,
              borderRadius: borderRadiusSM,
              [`input${componentCls}-input`]: {
                height: controlHeightSM - 2 * lineWidth,
                padding: `0 ${inputPaddingHorizontalSM}px`
              }
            },
            "&:hover": Object.assign({}, genHoverStyle(token2)),
            "&-focused": Object.assign({}, genActiveStyle(token2)),
            "&-disabled": Object.assign(Object.assign({}, genDisabledStyle(token2)), {
              [`${componentCls}-input`]: {
                cursor: "not-allowed"
              }
            }),
            // ===================== Out Of Range =====================
            "&-out-of-range": {
              input: {
                color: colorError
              }
            },
            // Style for input-group: input with label, with button or dropdown...
            "&-group": Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), genInputGroupStyle(token2)), {
              "&-wrapper": {
                display: "inline-block",
                textAlign: "start",
                verticalAlign: "top",
                [`${componentCls}-affix-wrapper`]: {
                  width: "100%"
                },
                // Size
                "&-lg": {
                  [`${componentCls}-group-addon`]: {
                    borderRadius: borderRadiusLG
                  }
                },
                "&-sm": {
                  [`${componentCls}-group-addon`]: {
                    borderRadius: borderRadiusSM
                  }
                }
              }
            }),
            [componentCls]: {
              "&-input": Object.assign(Object.assign({
                width: "100%",
                height: controlHeight - 2 * lineWidth,
                padding: `0 ${inputPaddingHorizontal}px`,
                textAlign: "start",
                backgroundColor: "transparent",
                border: 0,
                borderRadius,
                outline: 0,
                transition: `all ${motionDurationMid} linear`,
                appearance: "textfield",
                color: token2.colorText,
                fontSize: "inherit",
                verticalAlign: "top"
              }, genPlaceholderStyle(token2.colorTextPlaceholder)), {
                '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
                  margin: 0,
                  /* stylelint-disable-next-line property-no-vendor-prefix */
                  webkitAppearance: "none",
                  appearance: "none"
                }
              })
            }
          })
        },
        // Handler
        {
          [componentCls]: {
            [`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
              opacity: 1
            },
            [`${componentCls}-handler-wrap`]: {
              position: "absolute",
              insetBlockStart: 0,
              insetInlineEnd: 0,
              width: token2.handleWidth,
              height: "100%",
              background: colorBgContainer,
              borderStartStartRadius: 0,
              borderStartEndRadius: borderRadius,
              borderEndEndRadius: borderRadius,
              borderEndStartRadius: 0,
              opacity: handleVisible === true ? 1 : 0,
              display: "flex",
              flexDirection: "column",
              alignItems: "stretch",
              transition: `opacity ${motionDurationMid} linear ${motionDurationMid}`,
              // Fix input number inside Menu makes icon too large
              // We arise the selector priority by nest selector here
              // https://github.com/ant-design/ant-design/issues/14367
              [`${componentCls}-handler`]: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                flex: "auto",
                height: "40%",
                [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
                  marginInlineEnd: 0,
                  fontSize: token2.handleFontSize
                }
              }
            },
            [`${componentCls}-handler`]: {
              height: "50%",
              overflow: "hidden",
              color: colorTextDescription,
              fontWeight: "bold",
              lineHeight: 0,
              textAlign: "center",
              cursor: "pointer",
              borderInlineStart: `${lineWidth}px ${lineType} ${colorBorder}`,
              transition: `all ${motionDurationMid} linear`,
              "&:active": {
                background: token2.colorFillAlter
              },
              // Hover
              "&:hover": {
                height: `60%`,
                [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
                  color: colorPrimary
                }
              },
              "&-up-inner, &-down-inner": Object.assign(Object.assign({}, resetIcon()), {
                color: colorTextDescription,
                transition: `all ${motionDurationMid} linear`,
                userSelect: "none"
              })
            },
            [`${componentCls}-handler-up`]: {
              borderStartEndRadius: borderRadius
            },
            [`${componentCls}-handler-down`]: {
              borderBlockStart: `${lineWidth}px ${lineType} ${colorBorder}`,
              borderEndEndRadius: borderRadius
            },
            // Disabled
            "&-disabled, &-readonly": {
              [`${componentCls}-handler-wrap`]: {
                display: "none"
              }
            },
            [`
          ${componentCls}-handler-up-disabled,
          ${componentCls}-handler-down-disabled
        `]: {
              cursor: "not-allowed"
            },
            [`
          ${componentCls}-handler-up-disabled:hover &-handler-up-inner,
          ${componentCls}-handler-down-disabled:hover &-handler-down-inner
        `]: {
              color: colorTextDisabled
            }
          }
        },
        // Border-less
        {
          [`${componentCls}-borderless`]: {
            borderColor: "transparent",
            boxShadow: "none",
            [`${componentCls}-handler-down`]: {
              borderBlockStartWidth: 0
            }
          }
        }
      ];
    };
    const genAffixWrapperStyles = (token2) => {
      const {
        componentCls,
        inputPaddingHorizontal,
        inputAffixPadding,
        controlWidth,
        borderRadiusLG,
        borderRadiusSM
      } = token2;
      return {
        [`${componentCls}-affix-wrapper`]: Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), genStatusStyle(token2, `${componentCls}-affix-wrapper`)), {
          // or number handler will cover form status
          position: "relative",
          display: "inline-flex",
          width: controlWidth,
          padding: 0,
          paddingInlineStart: inputPaddingHorizontal,
          "&-lg": {
            borderRadius: borderRadiusLG
          },
          "&-sm": {
            borderRadius: borderRadiusSM
          },
          [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: Object.assign(Object.assign({}, genHoverStyle(token2)), {
            zIndex: 1
          }),
          "&-focused, &:focus": {
            zIndex: 1
          },
          "&-disabled": {
            [`${componentCls}[disabled]`]: {
              background: "transparent"
            }
          },
          [`> div${componentCls}`]: {
            width: "100%",
            border: "none",
            outline: "none",
            [`&${componentCls}-focused`]: {
              boxShadow: "none !important"
            }
          },
          [`input${componentCls}-input`]: {
            padding: 0
          },
          "&::before": {
            width: 0,
            visibility: "hidden",
            content: '"\\a0"'
          },
          [`${componentCls}-handler-wrap`]: {
            zIndex: 2
          },
          [componentCls]: {
            "&-prefix, &-suffix": {
              display: "flex",
              flex: "none",
              alignItems: "center",
              pointerEvents: "none"
            },
            "&-prefix": {
              marginInlineEnd: inputAffixPadding
            },
            "&-suffix": {
              position: "absolute",
              insetBlockStart: 0,
              insetInlineEnd: 0,
              zIndex: 1,
              height: "100%",
              marginInlineEnd: inputPaddingHorizontal,
              marginInlineStart: inputAffixPadding
            }
          }
        })
      };
    };
    const useStyle$c = genComponentStyleHook("InputNumber", (token2) => {
      const inputNumberToken = initInputToken(token2);
      return [
        genInputNumberStyles(inputNumberToken),
        genAffixWrapperStyles(inputNumberToken),
        // =====================================================
        // ==             Space Compact                       ==
        // =====================================================
        genCompactItemStyle(inputNumberToken)
      ];
    }, (token2) => ({
      controlWidth: 90,
      handleWidth: token2.controlHeightSM - token2.lineWidth * 2,
      handleFontSize: token2.fontSize / 2,
      handleVisible: "auto"
    }));
    var __rest$j = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const InputNumber = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const size = reactExports.useContext(SizeContext$2);
      const [focused, setFocus] = reactExports.useState(false);
      const inputRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, () => inputRef.current);
      const {
        className,
        rootClassName,
        size: customizeSize,
        disabled: customDisabled,
        prefixCls: customizePrefixCls,
        addonBefore,
        addonAfter,
        prefix,
        bordered = true,
        readOnly: readOnly2,
        status: customStatus,
        controls
      } = props, others = __rest$j(props, ["className", "rootClassName", "size", "disabled", "prefixCls", "addonBefore", "addonAfter", "prefix", "bordered", "readOnly", "status", "controls"]);
      const prefixCls = getPrefixCls("input-number", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$c(prefixCls);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      let upIcon = /* @__PURE__ */ reactExports.createElement(UpOutlined$1, {
        className: `${prefixCls}-handler-up-inner`
      });
      let downIcon = /* @__PURE__ */ reactExports.createElement(DownOutlined$3, {
        className: `${prefixCls}-handler-down-inner`
      });
      const controlsTemp = typeof controls === "boolean" ? controls : void 0;
      if (typeof controls === "object") {
        upIcon = typeof controls.upIcon === "undefined" ? upIcon : /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-handler-up-inner`
        }, controls.upIcon);
        downIcon = typeof controls.downIcon === "undefined" ? downIcon : /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-handler-down-inner`
        }, controls.downIcon);
      }
      const {
        hasFeedback,
        status: contextStatus,
        isFormItemInput,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      const mergeSize = compactSize || customizeSize || size;
      const hasPrefix = prefix != null || hasFeedback;
      const hasAddon2 = !!(addonBefore || addonAfter);
      const disabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const inputNumberClass = classNames({
        [`${prefixCls}-lg`]: mergeSize === "large",
        [`${prefixCls}-sm`]: mergeSize === "small",
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-borderless`]: !bordered,
        [`${prefixCls}-in-form-item`]: isFormItemInput
      }, getStatusClassNames(prefixCls, mergedStatus), compactItemClassnames, hashId, className, !hasPrefix && !hasAddon2 && rootClassName);
      let element = /* @__PURE__ */ reactExports.createElement(InputNumber$2, Object.assign({
        ref: inputRef,
        disabled: mergedDisabled,
        className: inputNumberClass,
        upHandler: upIcon,
        downHandler: downIcon,
        prefixCls,
        readOnly: readOnly2,
        controls: controlsTemp
      }, others));
      if (hasPrefix) {
        const affixWrapperCls = classNames(
          `${prefixCls}-affix-wrapper`,
          getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus, hasFeedback),
          {
            [`${prefixCls}-affix-wrapper-focused`]: focused,
            [`${prefixCls}-affix-wrapper-disabled`]: props.disabled,
            [`${prefixCls}-affix-wrapper-sm`]: mergeSize === "small",
            [`${prefixCls}-affix-wrapper-lg`]: mergeSize === "large",
            [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-affix-wrapper-readonly`]: readOnly2,
            [`${prefixCls}-affix-wrapper-borderless`]: !bordered
          },
          // className will go to addon wrapper
          !hasAddon2 && className,
          !hasAddon2 && rootClassName,
          hashId
        );
        element = /* @__PURE__ */ reactExports.createElement("div", {
          className: affixWrapperCls,
          style: props.style,
          onMouseUp: () => inputRef.current.focus()
        }, prefix && /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-prefix`
        }, prefix), cloneElement(element, {
          style: null,
          value: props.value,
          onFocus: (event) => {
            var _a;
            setFocus(true);
            (_a = props.onFocus) === null || _a === void 0 ? void 0 : _a.call(props, event);
          },
          onBlur: (event) => {
            var _a;
            setFocus(false);
            (_a = props.onBlur) === null || _a === void 0 ? void 0 : _a.call(props, event);
          }
        }), hasFeedback && /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-suffix`
        }, feedbackIcon));
      }
      if (hasAddon2) {
        const wrapperClassName = `${prefixCls}-group`;
        const addonClassName = `${wrapperClassName}-addon`;
        const addonBeforeNode = addonBefore ? /* @__PURE__ */ reactExports.createElement("div", {
          className: addonClassName
        }, addonBefore) : null;
        const addonAfterNode = addonAfter ? /* @__PURE__ */ reactExports.createElement("div", {
          className: addonClassName
        }, addonAfter) : null;
        const mergedWrapperClassName = classNames(`${prefixCls}-wrapper`, wrapperClassName, hashId, {
          [`${wrapperClassName}-rtl`]: direction === "rtl"
        });
        const mergedGroupClassName = classNames(`${prefixCls}-group-wrapper`, {
          [`${prefixCls}-group-wrapper-sm`]: mergeSize === "small",
          [`${prefixCls}-group-wrapper-lg`]: mergeSize === "large",
          [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl"
        }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId, className, rootClassName);
        element = /* @__PURE__ */ reactExports.createElement("div", {
          className: mergedGroupClassName,
          style: props.style
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: mergedWrapperClassName
        }, addonBeforeNode && /* @__PURE__ */ reactExports.createElement(NoCompactStyle, null, /* @__PURE__ */ reactExports.createElement(NoFormStyle, {
          status: true,
          override: true
        }, addonBeforeNode)), cloneElement(element, {
          style: null,
          disabled: mergedDisabled
        }), addonAfterNode && /* @__PURE__ */ reactExports.createElement(NoCompactStyle, null, /* @__PURE__ */ reactExports.createElement(NoFormStyle, {
          status: true,
          override: true
        }, addonAfterNode))));
      }
      return wrapSSR(element);
    });
    const TypedInputNumber = InputNumber;
    const PureInputNumber = (props) => /* @__PURE__ */ reactExports.createElement(ConfigProvider$1, {
      theme: {
        components: {
          InputNumber: {
            handleVisible: true
          }
        }
      }
    }, /* @__PURE__ */ reactExports.createElement(InputNumber, Object.assign({}, props)));
    TypedInputNumber._InternalPanelDoNotUseOrYouWillBeFired = PureInputNumber;
    const InputNumber$1 = TypedInputNumber;
    const Layout = InternalLayout;
    Layout.Header = Header$4;
    Layout.Footer = Footer$2;
    Layout.Content = Content;
    Layout.Sider = Sider$1;
    const AntdLayout = Layout;
    var DoubleLeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
    const DoubleLeftOutlinedSvg = DoubleLeftOutlined$2;
    var DoubleLeftOutlined = function DoubleLeftOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: DoubleLeftOutlinedSvg
      }));
    };
    DoubleLeftOutlined.displayName = "DoubleLeftOutlined";
    const DoubleLeftOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(DoubleLeftOutlined);
    var DoubleRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
    const DoubleRightOutlinedSvg = DoubleRightOutlined$2;
    var DoubleRightOutlined = function DoubleRightOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: DoubleRightOutlinedSvg
      }));
    };
    DoubleRightOutlined.displayName = "DoubleRightOutlined";
    const DoubleRightOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(DoubleRightOutlined);
    var Pager = function Pager2(props) {
      var _classNames;
      var prefixCls = "".concat(props.rootPrefixCls, "-item");
      var cls = classNames(prefixCls, "".concat(prefixCls, "-").concat(props.page), (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-active"), props.active), _defineProperty$7(_classNames, "".concat(prefixCls, "-disabled"), !props.page), _defineProperty$7(_classNames, props.className, !!props.className), _classNames));
      var handleClick = function handleClick2() {
        props.onClick(props.page);
      };
      var handleKeyPress = function handleKeyPress2(e2) {
        props.onKeyPress(e2, props.onClick, props.page);
      };
      return /* @__PURE__ */ React$3.createElement("li", {
        title: props.showTitle ? props.page : null,
        className: cls,
        onClick: handleClick,
        onKeyPress: handleKeyPress,
        tabIndex: "0"
      }, props.itemRender(props.page, "page", /* @__PURE__ */ React$3.createElement("a", {
        rel: "nofollow"
      }, props.page)));
    };
    const KEYCODE = {
      ZERO: 48,
      NINE: 57,
      NUMPAD_ZERO: 96,
      NUMPAD_NINE: 105,
      BACKSPACE: 8,
      DELETE: 46,
      ENTER: 13,
      ARROW_UP: 38,
      ARROW_DOWN: 40
    };
    var Options = /* @__PURE__ */ function(_React$Component) {
      _inherits(Options2, _React$Component);
      var _super = _createSuper(Options2);
      function Options2() {
        var _this;
        _classCallCheck(this, Options2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.state = {
          goInputText: ""
        };
        _this.buildOptionText = function(value) {
          return "".concat(value, " ").concat(_this.props.locale.items_per_page);
        };
        _this.changeSize = function(value) {
          _this.props.changeSize(Number(value));
        };
        _this.handleChange = function(e2) {
          _this.setState({
            goInputText: e2.target.value
          });
        };
        _this.handleBlur = function(e2) {
          var _this$props = _this.props, goButton = _this$props.goButton, quickGo = _this$props.quickGo, rootPrefixCls = _this$props.rootPrefixCls;
          var goInputText = _this.state.goInputText;
          if (goButton || goInputText === "") {
            return;
          }
          _this.setState({
            goInputText: ""
          });
          if (e2.relatedTarget && (e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item-link")) >= 0 || e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item")) >= 0)) {
            return;
          }
          quickGo(_this.getValidValue());
        };
        _this.go = function(e2) {
          var goInputText = _this.state.goInputText;
          if (goInputText === "") {
            return;
          }
          if (e2.keyCode === KEYCODE.ENTER || e2.type === "click") {
            _this.setState({
              goInputText: ""
            });
            _this.props.quickGo(_this.getValidValue());
          }
        };
        return _this;
      }
      _createClass(Options2, [{
        key: "getValidValue",
        value: function getValidValue() {
          var goInputText = this.state.goInputText;
          return !goInputText || isNaN(goInputText) ? void 0 : Number(goInputText);
        }
      }, {
        key: "getPageSizeOptions",
        value: function getPageSizeOptions() {
          var _this$props2 = this.props, pageSize = _this$props2.pageSize, pageSizeOptions = _this$props2.pageSizeOptions;
          if (pageSizeOptions.some(function(option) {
            return option.toString() === pageSize.toString();
          })) {
            return pageSizeOptions;
          }
          return pageSizeOptions.concat([pageSize.toString()]).sort(function(a, b2) {
            var numberA = isNaN(Number(a)) ? 0 : Number(a);
            var numberB = isNaN(Number(b2)) ? 0 : Number(b2);
            return numberA - numberB;
          });
        }
      }, {
        key: "render",
        value: function render2() {
          var _this2 = this;
          var _this$props3 = this.props, pageSize = _this$props3.pageSize, locale2 = _this$props3.locale, rootPrefixCls = _this$props3.rootPrefixCls, changeSize = _this$props3.changeSize, quickGo = _this$props3.quickGo, goButton = _this$props3.goButton, selectComponentClass = _this$props3.selectComponentClass, buildOptionText = _this$props3.buildOptionText, selectPrefixCls = _this$props3.selectPrefixCls, disabled = _this$props3.disabled;
          var goInputText = this.state.goInputText;
          var prefixCls = "".concat(rootPrefixCls, "-options");
          var Select2 = selectComponentClass;
          var changeSelect = null;
          var goInput = null;
          var gotoButton = null;
          if (!changeSize && !quickGo) {
            return null;
          }
          var pageSizeOptions = this.getPageSizeOptions();
          if (changeSize && Select2) {
            var options = pageSizeOptions.map(function(opt, i2) {
              return /* @__PURE__ */ React$3.createElement(Select2.Option, {
                key: i2,
                value: opt.toString()
              }, (buildOptionText || _this2.buildOptionText)(opt));
            });
            changeSelect = /* @__PURE__ */ React$3.createElement(Select2, {
              disabled,
              prefixCls: selectPrefixCls,
              showSearch: false,
              className: "".concat(prefixCls, "-size-changer"),
              optionLabelProp: "children",
              dropdownMatchSelectWidth: false,
              value: (pageSize || pageSizeOptions[0]).toString(),
              onChange: this.changeSize,
              getPopupContainer: function getPopupContainer(triggerNode) {
                return triggerNode.parentNode;
              },
              "aria-label": locale2.page_size,
              defaultOpen: false
            }, options);
          }
          if (quickGo) {
            if (goButton) {
              gotoButton = typeof goButton === "boolean" ? /* @__PURE__ */ React$3.createElement("button", {
                type: "button",
                onClick: this.go,
                onKeyUp: this.go,
                disabled,
                className: "".concat(prefixCls, "-quick-jumper-button")
              }, locale2.jump_to_confirm) : /* @__PURE__ */ React$3.createElement("span", {
                onClick: this.go,
                onKeyUp: this.go
              }, goButton);
            }
            goInput = /* @__PURE__ */ React$3.createElement("div", {
              className: "".concat(prefixCls, "-quick-jumper")
            }, locale2.jump_to, /* @__PURE__ */ React$3.createElement("input", {
              disabled,
              type: "text",
              value: goInputText,
              onChange: this.handleChange,
              onKeyUp: this.go,
              onBlur: this.handleBlur,
              "aria-label": locale2.page
            }), locale2.page, gotoButton);
          }
          return /* @__PURE__ */ React$3.createElement("li", {
            className: "".concat(prefixCls)
          }, changeSelect, goInput);
        }
      }]);
      return Options2;
    }(React$3.Component);
    Options.defaultProps = {
      pageSizeOptions: ["10", "20", "50", "100"]
    };
    const Pagination$3 = {
      // Options.jsx
      items_per_page: "条/页",
      jump_to: "跳至",
      jump_to_confirm: "确定",
      page: "页",
      // Pagination.jsx
      prev_page: "上一页",
      next_page: "下一页",
      prev_5: "向前 5 页",
      next_5: "向后 5 页",
      prev_3: "向前 3 页",
      next_3: "向后 3 页",
      page_size: "页码"
    };
    function noop$2() {
    }
    function isInteger(v2) {
      var value = Number(v2);
      return (
        // eslint-disable-next-line no-restricted-globals
        typeof value === "number" && !isNaN(value) && isFinite(value) && Math.floor(value) === value
      );
    }
    function defaultItemRender(page, type2, element) {
      return element;
    }
    function calculatePage(p2, state, props) {
      var pageSize = typeof p2 === "undefined" ? state.pageSize : p2;
      return Math.floor((props.total - 1) / pageSize) + 1;
    }
    var Pagination$2 = /* @__PURE__ */ function(_React$Component) {
      _inherits(Pagination2, _React$Component);
      var _super = _createSuper(Pagination2);
      function Pagination2(props) {
        var _this;
        _classCallCheck(this, Pagination2);
        _this = _super.call(this, props);
        _this.getJumpPrevPage = function() {
          return Math.max(1, _this.state.current - (_this.props.showLessItems ? 3 : 5));
        };
        _this.getJumpNextPage = function() {
          return Math.min(calculatePage(void 0, _this.state, _this.props), _this.state.current + (_this.props.showLessItems ? 3 : 5));
        };
        _this.getItemIcon = function(icon, label) {
          var prefixCls = _this.props.prefixCls;
          var iconNode = icon || /* @__PURE__ */ React$3.createElement("button", {
            type: "button",
            "aria-label": label,
            className: "".concat(prefixCls, "-item-link")
          });
          if (typeof icon === "function") {
            iconNode = /* @__PURE__ */ React$3.createElement(icon, _objectSpread2$3({}, _this.props));
          }
          return iconNode;
        };
        _this.savePaginationNode = function(node2) {
          _this.paginationNode = node2;
        };
        _this.isValid = function(page) {
          var total = _this.props.total;
          return isInteger(page) && page !== _this.state.current && isInteger(total) && total > 0;
        };
        _this.shouldDisplayQuickJumper = function() {
          var _this$props = _this.props, showQuickJumper = _this$props.showQuickJumper, total = _this$props.total;
          var pageSize = _this.state.pageSize;
          if (total <= pageSize) {
            return false;
          }
          return showQuickJumper;
        };
        _this.handleKeyDown = function(e2) {
          if (e2.keyCode === KEYCODE.ARROW_UP || e2.keyCode === KEYCODE.ARROW_DOWN) {
            e2.preventDefault();
          }
        };
        _this.handleKeyUp = function(e2) {
          var value = _this.getValidValue(e2);
          var currentInputValue = _this.state.currentInputValue;
          if (value !== currentInputValue) {
            _this.setState({
              currentInputValue: value
            });
          }
          if (e2.keyCode === KEYCODE.ENTER) {
            _this.handleChange(value);
          } else if (e2.keyCode === KEYCODE.ARROW_UP) {
            _this.handleChange(value - 1);
          } else if (e2.keyCode === KEYCODE.ARROW_DOWN) {
            _this.handleChange(value + 1);
          }
        };
        _this.handleBlur = function(e2) {
          var value = _this.getValidValue(e2);
          _this.handleChange(value);
        };
        _this.changePageSize = function(size) {
          var current = _this.state.current;
          var newCurrent = calculatePage(size, _this.state, _this.props);
          current = current > newCurrent ? newCurrent : current;
          if (newCurrent === 0) {
            current = _this.state.current;
          }
          if (typeof size === "number") {
            if (!("pageSize" in _this.props)) {
              _this.setState({
                pageSize: size
              });
            }
            if (!("current" in _this.props)) {
              _this.setState({
                current,
                currentInputValue: current
              });
            }
          }
          _this.props.onShowSizeChange(current, size);
          if ("onChange" in _this.props && _this.props.onChange) {
            _this.props.onChange(current, size);
          }
        };
        _this.handleChange = function(page) {
          var _this$props2 = _this.props, disabled = _this$props2.disabled, onChange = _this$props2.onChange;
          var _this$state = _this.state, pageSize = _this$state.pageSize, current = _this$state.current, currentInputValue = _this$state.currentInputValue;
          if (_this.isValid(page) && !disabled) {
            var currentPage = calculatePage(void 0, _this.state, _this.props);
            var newPage = page;
            if (page > currentPage) {
              newPage = currentPage;
            } else if (page < 1) {
              newPage = 1;
            }
            if (!("current" in _this.props)) {
              _this.setState({
                current: newPage
              });
            }
            if (newPage !== currentInputValue) {
              _this.setState({
                currentInputValue: newPage
              });
            }
            onChange(newPage, pageSize);
            return newPage;
          }
          return current;
        };
        _this.prev = function() {
          if (_this.hasPrev()) {
            _this.handleChange(_this.state.current - 1);
          }
        };
        _this.next = function() {
          if (_this.hasNext()) {
            _this.handleChange(_this.state.current + 1);
          }
        };
        _this.jumpPrev = function() {
          _this.handleChange(_this.getJumpPrevPage());
        };
        _this.jumpNext = function() {
          _this.handleChange(_this.getJumpNextPage());
        };
        _this.hasPrev = function() {
          return _this.state.current > 1;
        };
        _this.hasNext = function() {
          return _this.state.current < calculatePage(void 0, _this.state, _this.props);
        };
        _this.runIfEnter = function(event, callback) {
          if (event.key === "Enter" || event.charCode === 13) {
            for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              restParams[_key - 2] = arguments[_key];
            }
            callback.apply(void 0, restParams);
          }
        };
        _this.runIfEnterPrev = function(e2) {
          _this.runIfEnter(e2, _this.prev);
        };
        _this.runIfEnterNext = function(e2) {
          _this.runIfEnter(e2, _this.next);
        };
        _this.runIfEnterJumpPrev = function(e2) {
          _this.runIfEnter(e2, _this.jumpPrev);
        };
        _this.runIfEnterJumpNext = function(e2) {
          _this.runIfEnter(e2, _this.jumpNext);
        };
        _this.handleGoTO = function(e2) {
          if (e2.keyCode === KEYCODE.ENTER || e2.type === "click") {
            _this.handleChange(_this.state.currentInputValue);
          }
        };
        var hasOnChange = props.onChange !== noop$2;
        var hasCurrent = "current" in props;
        if (hasCurrent && !hasOnChange) {
          console.warn("Warning: You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component.");
        }
        var _current = props.defaultCurrent;
        if ("current" in props) {
          _current = props.current;
        }
        var _pageSize = props.defaultPageSize;
        if ("pageSize" in props) {
          _pageSize = props.pageSize;
        }
        _current = Math.min(_current, calculatePage(_pageSize, void 0, props));
        _this.state = {
          current: _current,
          currentInputValue: _current,
          pageSize: _pageSize
        };
        return _this;
      }
      _createClass(Pagination2, [{
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps, prevState) {
          var prefixCls = this.props.prefixCls;
          if (prevState.current !== this.state.current && this.paginationNode) {
            var lastCurrentNode = this.paginationNode.querySelector(".".concat(prefixCls, "-item-").concat(prevState.current));
            if (lastCurrentNode && document.activeElement === lastCurrentNode) {
              lastCurrentNode.blur();
            }
          }
        }
      }, {
        key: "getValidValue",
        value: function getValidValue(e2) {
          var inputValue = e2.target.value;
          var allPages = calculatePage(void 0, this.state, this.props);
          var currentInputValue = this.state.currentInputValue;
          var value;
          if (inputValue === "") {
            value = inputValue;
          } else if (isNaN(Number(inputValue))) {
            value = currentInputValue;
          } else if (inputValue >= allPages) {
            value = allPages;
          } else {
            value = Number(inputValue);
          }
          return value;
        }
      }, {
        key: "getShowSizeChanger",
        value: function getShowSizeChanger() {
          var _this$props3 = this.props, showSizeChanger = _this$props3.showSizeChanger, total = _this$props3.total, totalBoundaryShowSizeChanger = _this$props3.totalBoundaryShowSizeChanger;
          if (typeof showSizeChanger !== "undefined") {
            return showSizeChanger;
          }
          return total > totalBoundaryShowSizeChanger;
        }
      }, {
        key: "renderPrev",
        value: function renderPrev(prevPage) {
          var _this$props4 = this.props, prevIcon = _this$props4.prevIcon, itemRender = _this$props4.itemRender;
          var prevButton = itemRender(prevPage, "prev", this.getItemIcon(prevIcon, "prev page"));
          var disabled = !this.hasPrev();
          return /* @__PURE__ */ reactExports.isValidElement(prevButton) ? /* @__PURE__ */ reactExports.cloneElement(prevButton, {
            disabled
          }) : prevButton;
        }
      }, {
        key: "renderNext",
        value: function renderNext(nextPage) {
          var _this$props5 = this.props, nextIcon = _this$props5.nextIcon, itemRender = _this$props5.itemRender;
          var nextButton = itemRender(nextPage, "next", this.getItemIcon(nextIcon, "next page"));
          var disabled = !this.hasNext();
          return /* @__PURE__ */ reactExports.isValidElement(nextButton) ? /* @__PURE__ */ reactExports.cloneElement(nextButton, {
            disabled
          }) : nextButton;
        }
      }, {
        key: "render",
        value: function render2() {
          var _this2 = this;
          var _this$props6 = this.props, prefixCls = _this$props6.prefixCls, className = _this$props6.className, style2 = _this$props6.style, disabled = _this$props6.disabled, hideOnSinglePage = _this$props6.hideOnSinglePage, total = _this$props6.total, locale2 = _this$props6.locale, showQuickJumper = _this$props6.showQuickJumper, showLessItems = _this$props6.showLessItems, showTitle = _this$props6.showTitle, showTotal = _this$props6.showTotal, simple = _this$props6.simple, itemRender = _this$props6.itemRender, showPrevNextJumpers = _this$props6.showPrevNextJumpers, jumpPrevIcon = _this$props6.jumpPrevIcon, jumpNextIcon = _this$props6.jumpNextIcon, selectComponentClass = _this$props6.selectComponentClass, selectPrefixCls = _this$props6.selectPrefixCls, pageSizeOptions = _this$props6.pageSizeOptions;
          var _this$state2 = this.state, current = _this$state2.current, pageSize = _this$state2.pageSize, currentInputValue = _this$state2.currentInputValue;
          if (hideOnSinglePage === true && total <= pageSize) {
            return null;
          }
          var allPages = calculatePage(void 0, this.state, this.props);
          var pagerList = [];
          var jumpPrev = null;
          var jumpNext = null;
          var firstPager = null;
          var lastPager = null;
          var gotoButton = null;
          var goButton = showQuickJumper && showQuickJumper.goButton;
          var pageBufferSize = showLessItems ? 1 : 2;
          var prevPage = current - 1 > 0 ? current - 1 : 0;
          var nextPage = current + 1 < allPages ? current + 1 : allPages;
          var dataOrAriaAttributeProps = Object.keys(this.props).reduce(function(prev2, key) {
            if (key.substr(0, 5) === "data-" || key.substr(0, 5) === "aria-" || key === "role") {
              prev2[key] = _this2.props[key];
            }
            return prev2;
          }, {});
          var totalText = showTotal && /* @__PURE__ */ React$3.createElement("li", {
            className: "".concat(prefixCls, "-total-text")
          }, showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize]));
          if (simple) {
            if (goButton) {
              if (typeof goButton === "boolean") {
                gotoButton = /* @__PURE__ */ React$3.createElement("button", {
                  type: "button",
                  onClick: this.handleGoTO,
                  onKeyUp: this.handleGoTO
                }, locale2.jump_to_confirm);
              } else {
                gotoButton = /* @__PURE__ */ React$3.createElement("span", {
                  onClick: this.handleGoTO,
                  onKeyUp: this.handleGoTO
                }, goButton);
              }
              gotoButton = /* @__PURE__ */ React$3.createElement("li", {
                title: showTitle ? "".concat(locale2.jump_to).concat(current, "/").concat(allPages) : null,
                className: "".concat(prefixCls, "-simple-pager")
              }, gotoButton);
            }
            return /* @__PURE__ */ React$3.createElement("ul", _extends$2({
              className: classNames(prefixCls, "".concat(prefixCls, "-simple"), _defineProperty$7({}, "".concat(prefixCls, "-disabled"), disabled), className),
              style: style2,
              ref: this.savePaginationNode
            }, dataOrAriaAttributeProps), totalText, /* @__PURE__ */ React$3.createElement("li", {
              title: showTitle ? locale2.prev_page : null,
              onClick: this.prev,
              tabIndex: this.hasPrev() ? 0 : null,
              onKeyPress: this.runIfEnterPrev,
              className: classNames("".concat(prefixCls, "-prev"), _defineProperty$7({}, "".concat(prefixCls, "-disabled"), !this.hasPrev())),
              "aria-disabled": !this.hasPrev()
            }, this.renderPrev(prevPage)), /* @__PURE__ */ React$3.createElement("li", {
              title: showTitle ? "".concat(current, "/").concat(allPages) : null,
              className: "".concat(prefixCls, "-simple-pager")
            }, /* @__PURE__ */ React$3.createElement("input", {
              type: "text",
              value: currentInputValue,
              disabled,
              onKeyDown: this.handleKeyDown,
              onKeyUp: this.handleKeyUp,
              onChange: this.handleKeyUp,
              onBlur: this.handleBlur,
              size: "3"
            }), /* @__PURE__ */ React$3.createElement("span", {
              className: "".concat(prefixCls, "-slash")
            }, "/"), allPages), /* @__PURE__ */ React$3.createElement("li", {
              title: showTitle ? locale2.next_page : null,
              onClick: this.next,
              tabIndex: this.hasPrev() ? 0 : null,
              onKeyPress: this.runIfEnterNext,
              className: classNames("".concat(prefixCls, "-next"), _defineProperty$7({}, "".concat(prefixCls, "-disabled"), !this.hasNext())),
              "aria-disabled": !this.hasNext()
            }, this.renderNext(nextPage)), gotoButton);
          }
          if (allPages <= 3 + pageBufferSize * 2) {
            var pagerProps = {
              locale: locale2,
              rootPrefixCls: prefixCls,
              onClick: this.handleChange,
              onKeyPress: this.runIfEnter,
              showTitle,
              itemRender
            };
            if (!allPages) {
              pagerList.push(/* @__PURE__ */ React$3.createElement(Pager, _extends$2({}, pagerProps, {
                key: "noPager",
                page: 1,
                className: "".concat(prefixCls, "-item-disabled")
              })));
            }
            for (var i2 = 1; i2 <= allPages; i2 += 1) {
              var active = current === i2;
              pagerList.push(/* @__PURE__ */ React$3.createElement(Pager, _extends$2({}, pagerProps, {
                key: i2,
                page: i2,
                active
              })));
            }
          } else {
            var prevItemTitle = showLessItems ? locale2.prev_3 : locale2.prev_5;
            var nextItemTitle = showLessItems ? locale2.next_3 : locale2.next_5;
            if (showPrevNextJumpers) {
              jumpPrev = /* @__PURE__ */ React$3.createElement("li", {
                title: showTitle ? prevItemTitle : null,
                key: "prev",
                onClick: this.jumpPrev,
                tabIndex: "0",
                onKeyPress: this.runIfEnterJumpPrev,
                className: classNames("".concat(prefixCls, "-jump-prev"), _defineProperty$7({}, "".concat(prefixCls, "-jump-prev-custom-icon"), !!jumpPrevIcon))
              }, itemRender(this.getJumpPrevPage(), "jump-prev", this.getItemIcon(jumpPrevIcon, "prev page")));
              jumpNext = /* @__PURE__ */ React$3.createElement("li", {
                title: showTitle ? nextItemTitle : null,
                key: "next",
                tabIndex: "0",
                onClick: this.jumpNext,
                onKeyPress: this.runIfEnterJumpNext,
                className: classNames("".concat(prefixCls, "-jump-next"), _defineProperty$7({}, "".concat(prefixCls, "-jump-next-custom-icon"), !!jumpNextIcon))
              }, itemRender(this.getJumpNextPage(), "jump-next", this.getItemIcon(jumpNextIcon, "next page")));
            }
            lastPager = /* @__PURE__ */ React$3.createElement(Pager, {
              locale: locale2,
              last: true,
              rootPrefixCls: prefixCls,
              onClick: this.handleChange,
              onKeyPress: this.runIfEnter,
              key: allPages,
              page: allPages,
              active: false,
              showTitle,
              itemRender
            });
            firstPager = /* @__PURE__ */ React$3.createElement(Pager, {
              locale: locale2,
              rootPrefixCls: prefixCls,
              onClick: this.handleChange,
              onKeyPress: this.runIfEnter,
              key: 1,
              page: 1,
              active: false,
              showTitle,
              itemRender
            });
            var left = Math.max(1, current - pageBufferSize);
            var right = Math.min(current + pageBufferSize, allPages);
            if (current - 1 <= pageBufferSize) {
              right = 1 + pageBufferSize * 2;
            }
            if (allPages - current <= pageBufferSize) {
              left = allPages - pageBufferSize * 2;
            }
            for (var _i = left; _i <= right; _i += 1) {
              var _active = current === _i;
              pagerList.push(/* @__PURE__ */ React$3.createElement(Pager, {
                locale: locale2,
                rootPrefixCls: prefixCls,
                onClick: this.handleChange,
                onKeyPress: this.runIfEnter,
                key: _i,
                page: _i,
                active: _active,
                showTitle,
                itemRender
              }));
            }
            if (current - 1 >= pageBufferSize * 2 && current !== 1 + 2) {
              pagerList[0] = /* @__PURE__ */ reactExports.cloneElement(pagerList[0], {
                className: "".concat(prefixCls, "-item-after-jump-prev")
              });
              pagerList.unshift(jumpPrev);
            }
            if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
              pagerList[pagerList.length - 1] = /* @__PURE__ */ reactExports.cloneElement(pagerList[pagerList.length - 1], {
                className: "".concat(prefixCls, "-item-before-jump-next")
              });
              pagerList.push(jumpNext);
            }
            if (left !== 1) {
              pagerList.unshift(firstPager);
            }
            if (right !== allPages) {
              pagerList.push(lastPager);
            }
          }
          var prevDisabled = !this.hasPrev() || !allPages;
          var nextDisabled = !this.hasNext() || !allPages;
          return /* @__PURE__ */ React$3.createElement("ul", _extends$2({
            className: classNames(prefixCls, className, _defineProperty$7({}, "".concat(prefixCls, "-disabled"), disabled)),
            style: style2,
            ref: this.savePaginationNode
          }, dataOrAriaAttributeProps), totalText, /* @__PURE__ */ React$3.createElement("li", {
            title: showTitle ? locale2.prev_page : null,
            onClick: this.prev,
            tabIndex: prevDisabled ? null : 0,
            onKeyPress: this.runIfEnterPrev,
            className: classNames("".concat(prefixCls, "-prev"), _defineProperty$7({}, "".concat(prefixCls, "-disabled"), prevDisabled)),
            "aria-disabled": prevDisabled
          }, this.renderPrev(prevPage)), pagerList, /* @__PURE__ */ React$3.createElement("li", {
            title: showTitle ? locale2.next_page : null,
            onClick: this.next,
            tabIndex: nextDisabled ? null : 0,
            onKeyPress: this.runIfEnterNext,
            className: classNames("".concat(prefixCls, "-next"), _defineProperty$7({}, "".concat(prefixCls, "-disabled"), nextDisabled)),
            "aria-disabled": nextDisabled
          }, this.renderNext(nextPage)), /* @__PURE__ */ React$3.createElement(Options, {
            disabled,
            locale: locale2,
            rootPrefixCls: prefixCls,
            selectComponentClass,
            selectPrefixCls,
            changeSize: this.getShowSizeChanger() ? this.changePageSize : null,
            current,
            pageSize,
            pageSizeOptions,
            quickGo: this.shouldDisplayQuickJumper() ? this.handleChange : null,
            goButton
          }));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(props, prevState) {
          var newState = {};
          if ("current" in props) {
            newState.current = props.current;
            if (props.current !== prevState.current) {
              newState.currentInputValue = newState.current;
            }
          }
          if ("pageSize" in props && props.pageSize !== prevState.pageSize) {
            var current = prevState.current;
            var newCurrent = calculatePage(props.pageSize, prevState, props);
            current = current > newCurrent ? newCurrent : current;
            if (!("current" in props)) {
              newState.current = current;
              newState.currentInputValue = current;
            }
            newState.pageSize = props.pageSize;
          }
          return newState;
        }
      }]);
      return Pagination2;
    }(React$3.Component);
    Pagination$2.defaultProps = {
      defaultCurrent: 1,
      total: 0,
      defaultPageSize: 10,
      onChange: noop$2,
      className: "",
      selectPrefixCls: "rc-select",
      prefixCls: "rc-pagination",
      selectComponentClass: null,
      hideOnSinglePage: false,
      showPrevNextJumpers: true,
      showQuickJumper: false,
      showLessItems: false,
      showTitle: true,
      onShowSizeChange: noop$2,
      locale: Pagination$3,
      style: {},
      itemRender: defaultItemRender,
      totalBoundaryShowSizeChanger: 50
    };
    const MiniSelect = (props) => /* @__PURE__ */ reactExports.createElement(Select$1, Object.assign({}, props, {
      size: "small"
    }));
    const MiddleSelect = (props) => /* @__PURE__ */ reactExports.createElement(Select$1, Object.assign({}, props, {
      size: "middle"
    }));
    MiniSelect.Option = Select$1.Option;
    MiddleSelect.Option = Select$1.Option;
    const genPaginationDisabledStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-disabled`]: {
          "&, &:hover": {
            cursor: "not-allowed",
            [`${componentCls}-item-link`]: {
              color: token2.colorTextDisabled,
              cursor: "not-allowed"
            }
          },
          "&:focus-visible": {
            cursor: "not-allowed",
            [`${componentCls}-item-link`]: {
              color: token2.colorTextDisabled,
              cursor: "not-allowed"
            }
          }
        },
        [`&${componentCls}-disabled`]: {
          cursor: "not-allowed",
          [`${componentCls}-item`]: {
            cursor: "not-allowed",
            "&:hover, &:active": {
              backgroundColor: "transparent"
            },
            a: {
              color: token2.colorTextDisabled,
              backgroundColor: "transparent",
              border: "none",
              cursor: "not-allowed"
            },
            "&-active": {
              borderColor: token2.colorBorder,
              backgroundColor: token2.paginationItemDisabledBgActive,
              "&:hover, &:active": {
                backgroundColor: token2.paginationItemDisabledBgActive
              },
              a: {
                color: token2.paginationItemDisabledColorActive
              }
            }
          },
          [`${componentCls}-item-link`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed",
            "&:hover, &:active": {
              backgroundColor: "transparent"
            },
            [`${componentCls}-simple&`]: {
              backgroundColor: "transparent"
            }
          },
          [`${componentCls}-item-link-icon`]: {
            opacity: 0
          },
          [`${componentCls}-item-ellipsis`]: {
            opacity: 1
          },
          [`${componentCls}-simple-pager`]: {
            color: token2.colorTextDisabled
          }
        }
      };
    };
    const genPaginationMiniStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`&${componentCls}-mini ${componentCls}-total-text, &${componentCls}-mini ${componentCls}-simple-pager`]: {
          height: token2.paginationItemSizeSM,
          lineHeight: `${token2.paginationItemSizeSM}px`
        },
        [`&${componentCls}-mini ${componentCls}-item`]: {
          minWidth: token2.paginationItemSizeSM,
          height: token2.paginationItemSizeSM,
          margin: 0,
          lineHeight: `${token2.paginationItemSizeSM - 2}px`
        },
        [`&${componentCls}-mini ${componentCls}-item:not(${componentCls}-item-active)`]: {
          backgroundColor: "transparent",
          borderColor: "transparent"
        },
        [`&${componentCls}-mini ${componentCls}-prev, &${componentCls}-mini ${componentCls}-next`]: {
          minWidth: token2.paginationItemSizeSM,
          height: token2.paginationItemSizeSM,
          margin: 0,
          lineHeight: `${token2.paginationItemSizeSM}px`
        },
        [`
    &${componentCls}-mini ${componentCls}-prev ${componentCls}-item-link,
    &${componentCls}-mini ${componentCls}-next ${componentCls}-item-link
    `]: {
          backgroundColor: "transparent",
          borderColor: "transparent",
          "&::after": {
            height: token2.paginationItemSizeSM,
            lineHeight: `${token2.paginationItemSizeSM}px`
          }
        },
        [`&${componentCls}-mini ${componentCls}-jump-prev, &${componentCls}-mini ${componentCls}-jump-next`]: {
          height: token2.paginationItemSizeSM,
          marginInlineEnd: 0,
          lineHeight: `${token2.paginationItemSizeSM}px`
        },
        [`&${componentCls}-mini ${componentCls}-options`]: {
          marginInlineStart: token2.paginationMiniOptionsMarginInlineStart,
          [`&-size-changer`]: {
            top: token2.paginationMiniOptionsSizeChangerTop
          },
          [`&-quick-jumper`]: {
            height: token2.paginationItemSizeSM,
            lineHeight: `${token2.paginationItemSizeSM}px`,
            input: Object.assign(Object.assign({}, genInputSmallStyle(token2)), {
              width: token2.paginationMiniQuickJumperInputWidth,
              height: token2.controlHeightSM
            })
          }
        }
      };
    };
    const genPaginationSimpleStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`
    &${componentCls}-simple ${componentCls}-prev,
    &${componentCls}-simple ${componentCls}-next
    `]: {
          height: token2.paginationItemSizeSM,
          lineHeight: `${token2.paginationItemSizeSM}px`,
          verticalAlign: "top",
          [`${componentCls}-item-link`]: {
            height: token2.paginationItemSizeSM,
            backgroundColor: "transparent",
            border: 0,
            "&::after": {
              height: token2.paginationItemSizeSM,
              lineHeight: `${token2.paginationItemSizeSM}px`
            }
          }
        },
        [`&${componentCls}-simple ${componentCls}-simple-pager`]: {
          display: "inline-block",
          height: token2.paginationItemSizeSM,
          marginInlineEnd: token2.marginXS,
          input: {
            boxSizing: "border-box",
            height: "100%",
            marginInlineEnd: token2.marginXS,
            padding: `0 ${token2.paginationItemPaddingInline}px`,
            textAlign: "center",
            backgroundColor: token2.paginationItemInputBg,
            border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
            borderRadius: token2.borderRadius,
            outline: "none",
            transition: `border-color ${token2.motionDurationMid}`,
            color: "inherit",
            "&:hover": {
              borderColor: token2.colorPrimary
            },
            "&:focus": {
              borderColor: token2.colorPrimaryHover,
              boxShadow: `${token2.inputOutlineOffset}px 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`
            },
            "&[disabled]": {
              color: token2.colorTextDisabled,
              backgroundColor: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder,
              cursor: "not-allowed"
            }
          }
        }
      };
    };
    const genPaginationJumpStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
          outline: 0,
          [`${componentCls}-item-container`]: {
            position: "relative",
            [`${componentCls}-item-link-icon`]: {
              color: token2.colorPrimary,
              fontSize: token2.fontSizeSM,
              opacity: 0,
              transition: `all ${token2.motionDurationMid}`,
              "&-svg": {
                top: 0,
                insetInlineEnd: 0,
                bottom: 0,
                insetInlineStart: 0,
                margin: "auto"
              }
            },
            [`${componentCls}-item-ellipsis`]: {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: 0,
              insetInlineStart: 0,
              display: "block",
              margin: "auto",
              color: token2.colorTextDisabled,
              fontFamily: "Arial, Helvetica, sans-serif",
              letterSpacing: token2.paginationEllipsisLetterSpacing,
              textAlign: "center",
              textIndent: token2.paginationEllipsisTextIndent,
              opacity: 1,
              transition: `all ${token2.motionDurationMid}`
            }
          },
          "&:hover": {
            [`${componentCls}-item-link-icon`]: {
              opacity: 1
            },
            [`${componentCls}-item-ellipsis`]: {
              opacity: 0
            }
          },
          "&:focus-visible": Object.assign({
            [`${componentCls}-item-link-icon`]: {
              opacity: 1
            },
            [`${componentCls}-item-ellipsis`]: {
              opacity: 0
            }
          }, genFocusOutline(token2))
        },
        [`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
          marginInlineEnd: token2.marginXS
        },
        [`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
          display: "inline-block",
          minWidth: token2.paginationItemSize,
          height: token2.paginationItemSize,
          color: token2.colorText,
          fontFamily: token2.paginationFontFamily,
          lineHeight: `${token2.paginationItemSize}px`,
          textAlign: "center",
          verticalAlign: "middle",
          listStyle: "none",
          borderRadius: token2.borderRadius,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid}`
        },
        [`${componentCls}-prev, ${componentCls}-next`]: {
          fontFamily: "Arial, Helvetica, sans-serif",
          outline: 0,
          button: {
            color: token2.colorText,
            cursor: "pointer",
            userSelect: "none"
          },
          [`${componentCls}-item-link`]: {
            display: "block",
            width: "100%",
            height: "100%",
            padding: 0,
            fontSize: token2.fontSizeSM,
            textAlign: "center",
            backgroundColor: "transparent",
            border: `${token2.lineWidth}px ${token2.lineType} transparent`,
            borderRadius: token2.borderRadius,
            outline: "none",
            transition: `border ${token2.motionDurationMid}`
          },
          [`&:focus-visible ${componentCls}-item-link`]: Object.assign({}, genFocusOutline(token2)),
          [`&:hover ${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgTextHover
          },
          [`&:active ${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgTextActive
          },
          [`&${componentCls}-disabled:hover`]: {
            [`${componentCls}-item-link`]: {
              backgroundColor: "transparent"
            }
          }
        },
        [`${componentCls}-slash`]: {
          marginInlineEnd: token2.paginationSlashMarginInlineEnd,
          marginInlineStart: token2.paginationSlashMarginInlineStart
        },
        [`${componentCls}-options`]: {
          display: "inline-block",
          marginInlineStart: token2.margin,
          verticalAlign: "middle",
          "&-size-changer.-select": {
            display: "inline-block",
            width: "auto"
          },
          "&-quick-jumper": {
            display: "inline-block",
            height: token2.controlHeight,
            marginInlineStart: token2.marginXS,
            lineHeight: `${token2.controlHeight}px`,
            verticalAlign: "top",
            input: Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
              width: token2.controlHeightLG * 1.25,
              height: token2.controlHeight,
              boxSizing: "border-box",
              margin: 0,
              marginInlineStart: token2.marginXS,
              marginInlineEnd: token2.marginXS
            })
          }
        }
      };
    };
    const genPaginationItemStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-item`]: Object.assign(Object.assign({
          display: "inline-block",
          minWidth: token2.paginationItemSize,
          height: token2.paginationItemSize,
          marginInlineEnd: token2.marginXS,
          fontFamily: token2.paginationFontFamily,
          lineHeight: `${token2.paginationItemSize - 2}px`,
          textAlign: "center",
          verticalAlign: "middle",
          listStyle: "none",
          backgroundColor: "transparent",
          border: `${token2.lineWidth}px ${token2.lineType} transparent`,
          borderRadius: token2.borderRadius,
          outline: 0,
          cursor: "pointer",
          userSelect: "none",
          a: {
            display: "block",
            padding: `0 ${token2.paginationItemPaddingInline}px`,
            color: token2.colorText,
            transition: "none",
            "&:hover": {
              textDecoration: "none"
            }
          },
          [`&:not(${componentCls}-item-active)`]: {
            "&:hover": {
              transition: `all ${token2.motionDurationMid}`,
              backgroundColor: token2.colorBgTextHover
            },
            "&:active": {
              backgroundColor: token2.colorBgTextActive
            }
          }
        }, genFocusStyle(token2)), {
          "&-active": {
            fontWeight: token2.paginationFontWeightActive,
            backgroundColor: token2.paginationItemBgActive,
            borderColor: token2.colorPrimary,
            a: {
              color: token2.colorPrimary
            },
            "&:hover": {
              borderColor: token2.colorPrimaryHover
            },
            "&:hover a": {
              color: token2.colorPrimaryHover
            }
          }
        })
      };
    };
    const genPaginationStyle$2 = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), {
          "ul, ol": {
            margin: 0,
            padding: 0,
            listStyle: "none"
          },
          "&::after": {
            display: "block",
            clear: "both",
            height: 0,
            overflow: "hidden",
            visibility: "hidden",
            content: '""'
          },
          [`${componentCls}-total-text`]: {
            display: "inline-block",
            height: token2.paginationItemSize,
            marginInlineEnd: token2.marginXS,
            lineHeight: `${token2.paginationItemSize - 2}px`,
            verticalAlign: "middle"
          }
        }), genPaginationItemStyle(token2)), genPaginationJumpStyle(token2)), genPaginationSimpleStyle(token2)), genPaginationMiniStyle(token2)), genPaginationDisabledStyle(token2)), {
          // media query style
          [`@media only screen and (max-width: ${token2.screenLG}px)`]: {
            [`${componentCls}-item`]: {
              "&-after-jump-prev, &-before-jump-next": {
                display: "none"
              }
            }
          },
          [`@media only screen and (max-width: ${token2.screenSM}px)`]: {
            [`${componentCls}-options`]: {
              display: "none"
            }
          }
        }),
        // rtl style
        [`&${token2.componentCls}-rtl`]: {
          direction: "rtl"
        }
      };
    };
    const genBorderedStyle$2 = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}${componentCls}-disabled`]: {
          "&, &:hover": {
            [`${componentCls}-item-link`]: {
              borderColor: token2.colorBorder
            }
          },
          "&:focus-visible": {
            [`${componentCls}-item-link`]: {
              borderColor: token2.colorBorder
            }
          },
          [`${componentCls}-item, ${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            [`&:hover:not(${componentCls}-item-active)`]: {
              backgroundColor: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder,
              a: {
                color: token2.colorTextDisabled
              }
            },
            [`&${componentCls}-item-active`]: {
              backgroundColor: token2.paginationItemDisabledBgActive
            }
          },
          [`${componentCls}-prev, ${componentCls}-next`]: {
            "&:hover button": {
              backgroundColor: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder,
              color: token2.colorTextDisabled
            },
            [`${componentCls}-item-link`]: {
              backgroundColor: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder
            }
          }
        },
        [componentCls]: {
          [`${componentCls}-prev, ${componentCls}-next`]: {
            "&:hover button": {
              borderColor: token2.colorPrimaryHover,
              backgroundColor: token2.paginationItemBg
            },
            [`${componentCls}-item-link`]: {
              backgroundColor: token2.paginationItemLinkBg,
              borderColor: token2.colorBorder
            },
            [`&:hover ${componentCls}-item-link`]: {
              borderColor: token2.colorPrimary,
              backgroundColor: token2.paginationItemBg,
              color: token2.colorPrimary
            },
            [`&${componentCls}-disabled`]: {
              [`${componentCls}-item-link`]: {
                borderColor: token2.colorBorder,
                color: token2.colorTextDisabled
              }
            }
          },
          [`${componentCls}-item`]: {
            backgroundColor: token2.paginationItemBg,
            border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
            [`&:hover:not(${componentCls}-item-active)`]: {
              borderColor: token2.colorPrimary,
              backgroundColor: token2.paginationItemBg,
              a: {
                color: token2.colorPrimary
              }
            },
            "&-active": {
              borderColor: token2.colorPrimary
            }
          }
        }
      };
    };
    const useStyle$b = genComponentStyleHook("Pagination", (token2) => {
      const paginationToken = merge$4(token2, {
        paginationItemSize: token2.controlHeight,
        paginationFontFamily: token2.fontFamily,
        paginationItemBg: token2.colorBgContainer,
        paginationItemBgActive: token2.colorBgContainer,
        paginationFontWeightActive: token2.fontWeightStrong,
        paginationItemSizeSM: token2.controlHeightSM,
        paginationItemInputBg: token2.colorBgContainer,
        paginationMiniOptionsSizeChangerTop: 0,
        paginationItemDisabledBgActive: token2.controlItemBgActiveDisabled,
        paginationItemDisabledColorActive: token2.colorTextDisabled,
        paginationItemLinkBg: token2.colorBgContainer,
        inputOutlineOffset: "0 0",
        paginationMiniOptionsMarginInlineStart: token2.marginXXS / 2,
        paginationMiniQuickJumperInputWidth: token2.controlHeightLG * 1.1,
        paginationItemPaddingInline: token2.marginXXS * 1.5,
        paginationEllipsisLetterSpacing: token2.marginXXS / 2,
        paginationSlashMarginInlineStart: token2.marginXXS,
        paginationSlashMarginInlineEnd: token2.marginSM,
        paginationEllipsisTextIndent: "0.13em"
        // magic for ui experience
      }, initInputToken(token2));
      return [genPaginationStyle$2(paginationToken), token2.wireframe && genBorderedStyle$2(paginationToken)];
    });
    var __rest$i = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Pagination = (_a) => {
      var {
        prefixCls: customizePrefixCls,
        selectPrefixCls: customizeSelectPrefixCls,
        className,
        rootClassName,
        size,
        locale: customLocale,
        selectComponentClass,
        responsive,
        showSizeChanger
      } = _a, restProps = __rest$i(_a, ["prefixCls", "selectPrefixCls", "className", "rootClassName", "size", "locale", "selectComponentClass", "responsive", "showSizeChanger"]);
      const {
        xs
      } = useBreakpoint$3(responsive);
      const {
        getPrefixCls,
        direction,
        pagination = {}
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("pagination", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$b(prefixCls);
      const mergedShowSizeChanger = showSizeChanger !== null && showSizeChanger !== void 0 ? showSizeChanger : pagination.showSizeChanger;
      const getIconsProps = () => {
        const ellipsis = /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-item-ellipsis`
        }, "•••");
        let prevIcon = /* @__PURE__ */ reactExports.createElement("button", {
          className: `${prefixCls}-item-link`,
          type: "button",
          tabIndex: -1
        }, /* @__PURE__ */ reactExports.createElement(LeftOutlined$1, null));
        let nextIcon = /* @__PURE__ */ reactExports.createElement("button", {
          className: `${prefixCls}-item-link`,
          type: "button",
          tabIndex: -1
        }, /* @__PURE__ */ reactExports.createElement(RightOutlined$1, null));
        let jumpPrevIcon = /* @__PURE__ */ reactExports.createElement("a", {
          className: `${prefixCls}-item-link`
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-item-container`
        }, /* @__PURE__ */ reactExports.createElement(DoubleLeftOutlined$1, {
          className: `${prefixCls}-item-link-icon`
        }), ellipsis));
        let jumpNextIcon = /* @__PURE__ */ reactExports.createElement("a", {
          className: `${prefixCls}-item-link`
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-item-container`
        }, /* @__PURE__ */ reactExports.createElement(DoubleRightOutlined$1, {
          className: `${prefixCls}-item-link-icon`
        }), ellipsis));
        if (direction === "rtl") {
          [prevIcon, nextIcon] = [nextIcon, prevIcon];
          [jumpPrevIcon, jumpNextIcon] = [jumpNextIcon, jumpPrevIcon];
        }
        return {
          prevIcon,
          nextIcon,
          jumpPrevIcon,
          jumpNextIcon
        };
      };
      const [contextLocale] = useLocale$1("Pagination", enUS$1);
      const locale2 = Object.assign(Object.assign({}, contextLocale), customLocale);
      const isSmall = size === "small" || !!(xs && !size && responsive);
      const selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls);
      const extendedClassName = classNames({
        [`${prefixCls}-mini`]: isSmall,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(Pagination$2, Object.assign({}, getIconsProps(), restProps, {
        prefixCls,
        selectPrefixCls,
        className: extendedClassName,
        selectComponentClass: selectComponentClass || (isSmall ? MiniSelect : MiddleSelect),
        locale: locale2,
        showSizeChanger: mergedShowSizeChanger
      })));
    };
    const Pagination$1 = Pagination;
    const antSpinMove = new Keyframe("antSpinMove", {
      to: {
        opacity: 1
      }
    });
    const antRotate = new Keyframe("antRotate", {
      to: {
        transform: "rotate(405deg)"
      }
    });
    const genSpinStyle = (token2) => ({
      [`${token2.componentCls}`]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
        position: "absolute",
        display: "none",
        color: token2.colorPrimary,
        textAlign: "center",
        verticalAlign: "middle",
        opacity: 0,
        transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
        "&-spinning": {
          position: "static",
          display: "inline-block",
          opacity: 1
        },
        "&-nested-loading": {
          position: "relative",
          [`> div > ${token2.componentCls}`]: {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            zIndex: 4,
            display: "block",
            width: "100%",
            height: "100%",
            maxHeight: token2.contentHeight,
            [`${token2.componentCls}-dot`]: {
              position: "absolute",
              top: "50%",
              insetInlineStart: "50%",
              margin: -token2.spinDotSize / 2
            },
            [`${token2.componentCls}-text`]: {
              position: "absolute",
              top: "50%",
              width: "100%",
              paddingTop: (token2.spinDotSize - token2.fontSize) / 2 + 2,
              textShadow: `0 1px 2px ${token2.colorBgContainer}`
              // FIXME: shadow
            },
            [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
              marginTop: -(token2.spinDotSize / 2) - 10
            },
            "&-sm": {
              [`${token2.componentCls}-dot`]: {
                margin: -token2.spinDotSizeSM / 2
              },
              [`${token2.componentCls}-text`]: {
                paddingTop: (token2.spinDotSizeSM - token2.fontSize) / 2 + 2
              },
              [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
                marginTop: -(token2.spinDotSizeSM / 2) - 10
              }
            },
            "&-lg": {
              [`${token2.componentCls}-dot`]: {
                margin: -(token2.spinDotSizeLG / 2)
              },
              [`${token2.componentCls}-text`]: {
                paddingTop: (token2.spinDotSizeLG - token2.fontSize) / 2 + 2
              },
              [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
                marginTop: -(token2.spinDotSizeLG / 2) - 10
              }
            }
          },
          [`${token2.componentCls}-container`]: {
            position: "relative",
            transition: `opacity ${token2.motionDurationSlow}`,
            "&::after": {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: 0,
              insetInlineStart: 0,
              zIndex: 10,
              width: "100%",
              height: "100%",
              background: token2.colorBgContainer,
              opacity: 0,
              transition: `all ${token2.motionDurationSlow}`,
              content: '""',
              pointerEvents: "none"
            }
          },
          [`${token2.componentCls}-blur`]: {
            clear: "both",
            opacity: 0.5,
            userSelect: "none",
            pointerEvents: "none",
            [`&::after`]: {
              opacity: 0.4,
              pointerEvents: "auto"
            }
          }
        },
        // tip
        // ------------------------------
        [`&-tip`]: {
          color: token2.spinDotDefault
        },
        // dots
        // ------------------------------
        [`${token2.componentCls}-dot`]: {
          position: "relative",
          display: "inline-block",
          fontSize: token2.spinDotSize,
          width: "1em",
          height: "1em",
          "&-item": {
            position: "absolute",
            display: "block",
            width: (token2.spinDotSize - token2.marginXXS / 2) / 2,
            height: (token2.spinDotSize - token2.marginXXS / 2) / 2,
            backgroundColor: token2.colorPrimary,
            borderRadius: "100%",
            transform: "scale(0.75)",
            transformOrigin: "50% 50%",
            opacity: 0.3,
            animationName: antSpinMove,
            animationDuration: "1s",
            animationIterationCount: "infinite",
            animationTimingFunction: "linear",
            animationDirection: "alternate",
            "&:nth-child(1)": {
              top: 0,
              insetInlineStart: 0
            },
            "&:nth-child(2)": {
              top: 0,
              insetInlineEnd: 0,
              animationDelay: "0.4s"
            },
            "&:nth-child(3)": {
              insetInlineEnd: 0,
              bottom: 0,
              animationDelay: "0.8s"
            },
            "&:nth-child(4)": {
              bottom: 0,
              insetInlineStart: 0,
              animationDelay: "1.2s"
            }
          },
          "&-spin": {
            transform: "rotate(45deg)",
            animationName: antRotate,
            animationDuration: "1.2s",
            animationIterationCount: "infinite",
            animationTimingFunction: "linear"
          }
        },
        // Sizes
        // ------------------------------
        // small
        [`&-sm ${token2.componentCls}-dot`]: {
          fontSize: token2.spinDotSizeSM,
          i: {
            width: (token2.spinDotSizeSM - token2.marginXXS / 2) / 2,
            height: (token2.spinDotSizeSM - token2.marginXXS / 2) / 2
          }
        },
        // large
        [`&-lg ${token2.componentCls}-dot`]: {
          fontSize: token2.spinDotSizeLG,
          i: {
            width: (token2.spinDotSizeLG - token2.marginXXS) / 2,
            height: (token2.spinDotSizeLG - token2.marginXXS) / 2
          }
        },
        [`&${token2.componentCls}-show-text ${token2.componentCls}-text`]: {
          display: "block"
        }
      })
    });
    const useStyle$a = genComponentStyleHook("Spin", (token2) => {
      const spinToken = merge$4(token2, {
        spinDotDefault: token2.colorTextDescription,
        spinDotSize: token2.controlHeightLG / 2,
        spinDotSizeSM: token2.controlHeightLG * 0.35,
        spinDotSizeLG: token2.controlHeight
      });
      return [genSpinStyle(spinToken)];
    }, {
      contentHeight: 400
    });
    var __rest$h = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    let defaultIndicator = null;
    function renderIndicator(prefixCls, props) {
      const {
        indicator
      } = props;
      const dotClassName = `${prefixCls}-dot`;
      if (indicator === null) {
        return null;
      }
      if (isValidElement(indicator)) {
        return cloneElement(indicator, {
          className: classNames(indicator.props.className, dotClassName)
        });
      }
      if (isValidElement(defaultIndicator)) {
        return cloneElement(defaultIndicator, {
          className: classNames(defaultIndicator.props.className, dotClassName)
        });
      }
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames(dotClassName, `${prefixCls}-dot-spin`)
      }, /* @__PURE__ */ reactExports.createElement("i", {
        className: `${prefixCls}-dot-item`
      }), /* @__PURE__ */ reactExports.createElement("i", {
        className: `${prefixCls}-dot-item`
      }), /* @__PURE__ */ reactExports.createElement("i", {
        className: `${prefixCls}-dot-item`
      }), /* @__PURE__ */ reactExports.createElement("i", {
        className: `${prefixCls}-dot-item`
      }));
    }
    function shouldDelay(spinning, delay) {
      return !!spinning && !!delay && !isNaN(Number(delay));
    }
    const Spin = (props) => {
      const {
        spinPrefixCls: prefixCls,
        spinning: customSpinning = true,
        delay = 0,
        className,
        rootClassName,
        size = "default",
        tip,
        wrapperClassName,
        style: style2,
        children,
        hashId
      } = props, restProps = __rest$h(props, ["spinPrefixCls", "spinning", "delay", "className", "rootClassName", "size", "tip", "wrapperClassName", "style", "children", "hashId"]);
      const [spinning, setSpinning] = reactExports.useState(() => customSpinning && !shouldDelay(customSpinning, delay));
      reactExports.useEffect(() => {
        if (customSpinning) {
          const showSpinning = debounce(delay, () => {
            setSpinning(true);
          });
          showSpinning();
          return () => {
            var _a;
            (_a = showSpinning === null || showSpinning === void 0 ? void 0 : showSpinning.cancel) === null || _a === void 0 ? void 0 : _a.call(showSpinning);
          };
        }
        setSpinning(false);
      }, [delay, customSpinning]);
      const isNestedPattern = reactExports.useMemo(() => typeof children !== "undefined", [children]);
      const {
        direction
      } = reactExports.useContext(ConfigContext);
      const spinClassName = classNames(prefixCls, {
        [`${prefixCls}-sm`]: size === "small",
        [`${prefixCls}-lg`]: size === "large",
        [`${prefixCls}-spinning`]: spinning,
        [`${prefixCls}-show-text`]: !!tip,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      const containerClassName = classNames(`${prefixCls}-container`, {
        [`${prefixCls}-blur`]: spinning
      });
      const divProps = omit(restProps, ["indicator", "prefixCls"]);
      const spinElement = /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, divProps, {
        style: style2,
        className: spinClassName,
        "aria-live": "polite",
        "aria-busy": spinning
      }), renderIndicator(prefixCls, props), tip ? /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-text`
      }, tip) : null);
      if (isNestedPattern) {
        return /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, divProps, {
          className: classNames(`${prefixCls}-nested-loading`, wrapperClassName, hashId)
        }), spinning && /* @__PURE__ */ reactExports.createElement("div", {
          key: "loading"
        }, spinElement), /* @__PURE__ */ reactExports.createElement("div", {
          className: containerClassName,
          key: "container"
        }, children));
      }
      return spinElement;
    };
    const SpinFC = (props) => {
      const {
        prefixCls: customizePrefixCls
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const spinPrefixCls = getPrefixCls("spin", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$a(spinPrefixCls);
      const spinClassProps = Object.assign(Object.assign({}, props), {
        spinPrefixCls,
        hashId
      });
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(Spin, Object.assign({}, spinClassProps)));
    };
    SpinFC.setDefaultIndicator = (indicator) => {
      defaultIndicator = indicator;
    };
    const la = SpinFC;
    function extendsObject() {
      const result = Object.assign({}, arguments.length <= 0 ? void 0 : arguments[0]);
      for (let i2 = 1; i2 < arguments.length; i2++) {
        const obj = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
        if (obj) {
          Object.keys(obj).forEach((key) => {
            const val = obj[key];
            if (val !== void 0) {
              result[key] = val;
            }
          });
        }
      }
      return result;
    }
    function modalWarn(props) {
      return confirm(withWarn(props));
    }
    const Modal = OriginModal;
    Modal.useModal = useModal$1;
    Modal.info = function infoFn(props) {
      return confirm(withInfo(props));
    };
    Modal.success = function successFn(props) {
      return confirm(withSuccess(props));
    };
    Modal.error = function errorFn(props) {
      return confirm(withError(props));
    };
    Modal.warning = modalWarn;
    Modal.warn = modalWarn;
    Modal.confirm = function confirmFn(props) {
      return confirm(withConfirm(props));
    };
    Modal.destroyAll = function destroyAllFn() {
      while (destroyFns$1.length) {
        const close = destroyFns$1.pop();
        if (close) {
          close();
        }
      }
    };
    Modal.config = modalGlobalConfig;
    Modal._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$a;
    const Modal$1 = Modal;
    let notification = null;
    let act = (callback) => callback();
    let taskQueue = [];
    let defaultGlobalConfig = {};
    function getGlobalContext$1() {
      const {
        prefixCls: globalPrefixCls2,
        getContainer: globalGetContainer,
        rtl,
        maxCount,
        top,
        bottom
      } = defaultGlobalConfig;
      const mergedPrefixCls = globalPrefixCls2 !== null && globalPrefixCls2 !== void 0 ? globalPrefixCls2 : globalConfig().getPrefixCls("notification");
      const mergedContainer = (globalGetContainer === null || globalGetContainer === void 0 ? void 0 : globalGetContainer()) || document.body;
      return {
        prefixCls: mergedPrefixCls,
        container: mergedContainer,
        rtl,
        maxCount,
        top,
        bottom
      };
    }
    const GlobalHolder = /* @__PURE__ */ reactExports.forwardRef((_, ref) => {
      const [prefixCls, setPrefixCls] = reactExports.useState();
      const [container2, setContainer] = reactExports.useState();
      const [maxCount, setMaxCount] = reactExports.useState();
      const [rtl, setRTL] = reactExports.useState();
      const [top, setTop] = reactExports.useState();
      const [bottom, setBottom] = reactExports.useState();
      const [api, holder] = useInternalNotification({
        prefixCls,
        getContainer: () => container2,
        maxCount,
        rtl,
        top,
        bottom
      });
      const global2 = globalConfig();
      const rootPrefixCls = global2.getRootPrefixCls();
      const rootIconPrefixCls = global2.getIconPrefixCls();
      const sync = () => {
        const {
          prefixCls: nextGlobalPrefixCls,
          container: nextGlobalContainer,
          maxCount: nextGlobalMaxCount,
          rtl: nextGlobalRTL,
          top: nextTop,
          bottom: nextBottom
        } = getGlobalContext$1();
        setPrefixCls(nextGlobalPrefixCls);
        setContainer(nextGlobalContainer);
        setMaxCount(nextGlobalMaxCount);
        setRTL(nextGlobalRTL);
        setTop(nextTop);
        setBottom(nextBottom);
      };
      reactExports.useEffect(sync, []);
      reactExports.useImperativeHandle(ref, () => {
        const instance = Object.assign({}, api);
        Object.keys(instance).forEach((method2) => {
          instance[method2] = function() {
            sync();
            return api[method2].apply(api, arguments);
          };
        });
        return {
          instance,
          sync
        };
      });
      return /* @__PURE__ */ reactExports.createElement(ConfigProvider$1, {
        prefixCls: rootPrefixCls,
        iconPrefixCls: rootIconPrefixCls
      }, holder);
    });
    function flushNotice() {
      if (!notification) {
        const holderFragment = document.createDocumentFragment();
        const newNotification = {
          fragment: holderFragment
        };
        notification = newNotification;
        act(() => {
          render(/* @__PURE__ */ reactExports.createElement(GlobalHolder, {
            ref: (node2) => {
              const {
                instance,
                sync
              } = node2 || {};
              Promise.resolve().then(() => {
                if (!newNotification.instance && instance) {
                  newNotification.instance = instance;
                  newNotification.sync = sync;
                  flushNotice();
                }
              });
            }
          }), holderFragment);
        });
        return;
      }
      if (!notification.instance) {
        return;
      }
      taskQueue.forEach((task) => {
        switch (task.type) {
          case "open": {
            act(() => {
              notification.instance.open(Object.assign(Object.assign({}, defaultGlobalConfig), task.config));
            });
            break;
          }
          case "destroy":
            act(() => {
              notification === null || notification === void 0 ? void 0 : notification.instance.destroy(task.key);
            });
            break;
        }
      });
      taskQueue = [];
    }
    function setNotificationGlobalConfig(config) {
      defaultGlobalConfig = Object.assign(Object.assign({}, defaultGlobalConfig), config);
      act(() => {
        var _a;
        (_a = notification === null || notification === void 0 ? void 0 : notification.sync) === null || _a === void 0 ? void 0 : _a.call(notification);
      });
    }
    function open(config) {
      taskQueue.push({
        type: "open",
        config
      });
      flushNotice();
    }
    function destroy(key) {
      taskQueue.push({
        type: "destroy",
        key
      });
      flushNotice();
    }
    const methods = ["success", "info", "warning", "error"];
    const baseStaticMethods = {
      open,
      destroy,
      config: setNotificationGlobalConfig,
      useNotification,
      _InternalPanelDoNotUseOrYouWillBeFired: PurePanel$8
    };
    const staticMethods = baseStaticMethods;
    methods.forEach((type2) => {
      staticMethods[type2] = (config) => open(Object.assign(Object.assign({}, config), {
        type: type2
      }));
    });
    const notification$1 = staticMethods;
    const genBaseStyle$5 = (token2) => {
      const {
        componentCls,
        iconCls,
        zIndexPopup,
        colorText,
        colorWarning,
        marginXS,
        fontSize,
        fontWeightStrong,
        lineHeight
      } = token2;
      return {
        [componentCls]: {
          zIndex: zIndexPopup,
          [`${componentCls}-inner-content`]: {
            color: colorText
          },
          [`${componentCls}-message`]: {
            position: "relative",
            marginBottom: marginXS,
            color: colorText,
            fontSize,
            display: "flex",
            flexWrap: "nowrap",
            alignItems: "start",
            [`> ${componentCls}-message-icon ${iconCls}`]: {
              color: colorWarning,
              fontSize,
              flex: "none",
              lineHeight: 1,
              paddingTop: (Math.round(fontSize * lineHeight) - fontSize) / 2
            },
            "&-title": {
              flex: "auto",
              marginInlineStart: marginXS
            },
            "&-title-only": {
              fontWeight: fontWeightStrong
            }
          },
          [`${componentCls}-description`]: {
            position: "relative",
            marginInlineStart: fontSize + marginXS,
            marginBottom: marginXS,
            color: colorText,
            fontSize
          },
          [`${componentCls}-buttons`]: {
            textAlign: "end",
            button: {
              marginInlineStart: marginXS
            }
          }
        }
      };
    };
    const usePopconfirmStyle = genComponentStyleHook("Popconfirm", (token2) => genBaseStyle$5(token2), (token2) => {
      const {
        zIndexPopupBase
      } = token2;
      return {
        zIndexPopup: zIndexPopupBase + 60
      };
    });
    var __rest$g = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Overlay = (props) => {
      const {
        prefixCls,
        okButtonProps,
        cancelButtonProps,
        title,
        description,
        cancelText,
        okText,
        okType = "primary",
        icon = /* @__PURE__ */ reactExports.createElement(ExclamationCircleFilled$1, null),
        showCancel = true,
        close,
        onConfirm,
        onCancel
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const [contextLocale] = useLocale$1("Popconfirm", defaultLocale.Popconfirm);
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-inner-content`
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-message`
      }, icon && /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-message-icon`
      }, icon), /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(`${prefixCls}-message-title`, {
          [`${prefixCls}-message-title-only`]: !!description
        })
      }, getRenderPropValue(title))), description && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-description`
      }, getRenderPropValue(description)), /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-buttons`
      }, showCancel && /* @__PURE__ */ reactExports.createElement(Button$2, Object.assign({
        onClick: onCancel,
        size: "small"
      }, cancelButtonProps), cancelText !== null && cancelText !== void 0 ? cancelText : contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.cancelText), /* @__PURE__ */ reactExports.createElement(ActionButton$1, {
        buttonProps: Object.assign(Object.assign({
          size: "small"
        }, convertLegacyProps(okType)), okButtonProps),
        actionFn: onConfirm,
        close,
        prefixCls: getPrefixCls("btn"),
        quitOnNullishReturnValue: true,
        emitEvent: true
      }, okText !== null && okText !== void 0 ? okText : contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.okText)));
    };
    function PurePanel$1(props) {
      const {
        prefixCls: customizePrefixCls,
        placement,
        className,
        style: style2
      } = props, restProps = __rest$g(props, ["prefixCls", "placement", "className", "style"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
      const [wrapSSR] = usePopconfirmStyle(prefixCls);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(PurePanel$5, {
        placement,
        className: classNames(prefixCls, className),
        style: style2,
        content: /* @__PURE__ */ reactExports.createElement(Overlay, Object.assign({
          prefixCls
        }, restProps))
      }));
    }
    var __rest$f = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Popconfirm = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const [open2, setOpen] = useMergedState(false, {
        value: props.open,
        defaultValue: props.defaultOpen
      });
      const settingOpen = (value, e2) => {
        var _a;
        setOpen(value, true);
        (_a = props.onOpenChange) === null || _a === void 0 ? void 0 : _a.call(props, value, e2);
      };
      const close = (e2) => {
        settingOpen(false, e2);
      };
      const onConfirm = (e2) => {
        var _a;
        return (_a = props.onConfirm) === null || _a === void 0 ? void 0 : _a.call(globalThis, e2);
      };
      const onCancel = (e2) => {
        var _a;
        settingOpen(false, e2);
        (_a = props.onCancel) === null || _a === void 0 ? void 0 : _a.call(globalThis, e2);
      };
      const onKeyDown2 = (e2) => {
        if (e2.keyCode === KeyCode.ESC && open2) {
          settingOpen(false, e2);
        }
      };
      const onOpenChange = (value) => {
        const {
          disabled = false
        } = props;
        if (disabled) {
          return;
        }
        settingOpen(value);
      };
      const {
        prefixCls: customizePrefixCls,
        placement = "top",
        trigger = "click",
        okType = "primary",
        icon = /* @__PURE__ */ reactExports.createElement(ExclamationCircleFilled$1, null),
        children,
        overlayClassName
      } = props, restProps = __rest$f(props, ["prefixCls", "placement", "trigger", "okType", "icon", "children", "overlayClassName"]);
      const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
      const overlayClassNames = classNames(prefixCls, overlayClassName);
      const [wrapSSR] = usePopconfirmStyle(prefixCls);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(Popover$1, Object.assign({}, omit(restProps, ["title"]), {
        trigger,
        placement,
        onOpenChange,
        open: open2,
        ref,
        overlayClassName: overlayClassNames,
        content: /* @__PURE__ */ reactExports.createElement(Overlay, Object.assign({
          okType,
          icon
        }, props, {
          prefixCls,
          close,
          onConfirm,
          onCancel
        })),
        "data-popover-inject": true
      }), cloneElement(children, {
        onKeyDown: (e2) => {
          var _a, _b;
          if (/* @__PURE__ */ reactExports.isValidElement(children)) {
            (_b = children === null || children === void 0 ? void 0 : (_a = children.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, e2);
          }
          onKeyDown2(e2);
        }
      })));
    });
    Popconfirm._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$1;
    const It = Popconfirm;
    var defaultProps = {
      className: "",
      percent: 0,
      prefixCls: "rc-progress",
      strokeColor: "#2db7f5",
      strokeLinecap: "round",
      strokeWidth: 1,
      style: {},
      trailColor: "#D9D9D9",
      trailWidth: 1,
      gapPosition: "bottom"
    };
    var useTransitionDuration = function useTransitionDuration2() {
      var pathsRef = reactExports.useRef([]);
      var prevTimeStamp = reactExports.useRef(null);
      reactExports.useEffect(function() {
        var now2 = Date.now();
        var updated = false;
        pathsRef.current.forEach(function(path2) {
          if (!path2) {
            return;
          }
          updated = true;
          var pathStyle = path2.style;
          pathStyle.transitionDuration = ".3s, .3s, .3s, .06s";
          if (prevTimeStamp.current && now2 - prevTimeStamp.current < 100) {
            pathStyle.transitionDuration = "0s, 0s";
          }
        });
        if (updated) {
          prevTimeStamp.current = Date.now();
        }
      });
      return pathsRef.current;
    };
    var uuid = 0;
    var isBrowserClient = canUseDom$2();
    function getUUID() {
      var retId;
      if (isBrowserClient) {
        retId = uuid;
        uuid += 1;
      } else {
        retId = "TEST_OR_SSR";
      }
      return retId;
    }
    const useId = function(id2) {
      var _React$useState = reactExports.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
      reactExports.useEffect(function() {
        setInnerId("rc_progress_".concat(getUUID()));
      }, []);
      return id2 || innerId;
    };
    var _excluded$d = ["id", "prefixCls", "steps", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "style", "className", "strokeColor", "percent"];
    function stripPercentToNumber(percent) {
      return +percent.replace("%", "");
    }
    function toArray$1(value) {
      var mergedValue = value !== null && value !== void 0 ? value : [];
      return Array.isArray(mergedValue) ? mergedValue : [mergedValue];
    }
    var VIEW_BOX_SIZE = 100;
    var getCircleStyle = function getCircleStyle2(perimeter, perimeterWithoutGap, offset2, percent, rotateDeg, gapDegree, gapPosition, strokeColor, strokeLinecap, strokeWidth) {
      var stepSpace = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : 0;
      var offsetDeg = offset2 / 100 * 360 * ((360 - gapDegree) / 360);
      var positionDeg = gapDegree === 0 ? 0 : {
        bottom: 0,
        top: 180,
        left: 90,
        right: -90
      }[gapPosition];
      var strokeDashoffset = (100 - percent) / 100 * perimeterWithoutGap;
      if (strokeLinecap === "round" && percent !== 100) {
        strokeDashoffset += strokeWidth / 2;
        if (strokeDashoffset >= perimeterWithoutGap) {
          strokeDashoffset = perimeterWithoutGap - 0.01;
        }
      }
      return {
        stroke: typeof strokeColor === "string" ? strokeColor : void 0,
        strokeDasharray: "".concat(perimeterWithoutGap, "px ").concat(perimeter),
        strokeDashoffset: strokeDashoffset + stepSpace,
        transform: "rotate(".concat(rotateDeg + offsetDeg + positionDeg, "deg)"),
        transformOrigin: "0 0",
        transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s",
        fillOpacity: 0
      };
    };
    var Circle$2 = function Circle2(_ref) {
      var id2 = _ref.id, prefixCls = _ref.prefixCls, steps = _ref.steps, strokeWidth = _ref.strokeWidth, trailWidth = _ref.trailWidth, _ref$gapDegree = _ref.gapDegree, gapDegree = _ref$gapDegree === void 0 ? 0 : _ref$gapDegree, gapPosition = _ref.gapPosition, trailColor = _ref.trailColor, strokeLinecap = _ref.strokeLinecap, style2 = _ref.style, className = _ref.className, strokeColor = _ref.strokeColor, percent = _ref.percent, restProps = _objectWithoutProperties$1(_ref, _excluded$d);
      var mergedId = useId(id2);
      var gradientId = "".concat(mergedId, "-gradient");
      var radius = VIEW_BOX_SIZE / 2 - strokeWidth / 2;
      var perimeter = Math.PI * 2 * radius;
      var rotateDeg = gapDegree > 0 ? 90 + gapDegree / 2 : -90;
      var perimeterWithoutGap = perimeter * ((360 - gapDegree) / 360);
      var _ref2 = _typeof$4(steps) === "object" ? steps : {
        count: steps,
        space: 2
      }, stepCount = _ref2.count, stepSpace = _ref2.space;
      var circleStyle = getCircleStyle(perimeter, perimeterWithoutGap, 0, 100, rotateDeg, gapDegree, gapPosition, trailColor, strokeLinecap, strokeWidth);
      var percentList = toArray$1(percent);
      var strokeColorList = toArray$1(strokeColor);
      var gradient = strokeColorList.find(function(color2) {
        return color2 && _typeof$4(color2) === "object";
      });
      var paths = useTransitionDuration();
      var getStokeList = function getStokeList2() {
        var stackPtg = 0;
        return percentList.map(function(ptg, index2) {
          var color2 = strokeColorList[index2] || strokeColorList[strokeColorList.length - 1];
          var stroke = color2 && _typeof$4(color2) === "object" ? "url(#".concat(gradientId, ")") : void 0;
          var circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, ptg, rotateDeg, gapDegree, gapPosition, color2, strokeLinecap, strokeWidth);
          stackPtg += ptg;
          return /* @__PURE__ */ reactExports.createElement("circle", {
            key: index2,
            className: "".concat(prefixCls, "-circle-path"),
            r: radius,
            cx: 0,
            cy: 0,
            stroke,
            strokeLinecap,
            strokeWidth,
            opacity: ptg === 0 ? 0 : 1,
            style: circleStyleForStack,
            ref: function ref(elem) {
              paths[index2] = elem;
            }
          });
        }).reverse();
      };
      var getStepStokeList = function getStepStokeList2() {
        var current = Math.round(stepCount * (percentList[0] / 100));
        var stepPtg = 100 / stepCount;
        var stackPtg = 0;
        return new Array(stepCount).fill(null).map(function(_, index2) {
          var color2 = index2 <= current - 1 ? strokeColorList[0] : trailColor;
          var stroke = color2 && _typeof$4(color2) === "object" ? "url(#".concat(gradientId, ")") : void 0;
          var circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, stepPtg, rotateDeg, gapDegree, gapPosition, color2, "butt", strokeWidth, stepSpace);
          stackPtg += (perimeterWithoutGap - circleStyleForStack.strokeDashoffset + stepSpace) * 100 / perimeterWithoutGap;
          return /* @__PURE__ */ reactExports.createElement("circle", {
            key: index2,
            className: "".concat(prefixCls, "-circle-path"),
            r: radius,
            cx: 0,
            cy: 0,
            stroke,
            strokeWidth,
            opacity: 1,
            style: circleStyleForStack,
            ref: function ref(elem) {
              paths[index2] = elem;
            }
          });
        });
      };
      return /* @__PURE__ */ reactExports.createElement("svg", _extends$2({
        className: classNames("".concat(prefixCls, "-circle"), className),
        viewBox: "".concat(-VIEW_BOX_SIZE / 2, " ").concat(-VIEW_BOX_SIZE / 2, " ").concat(VIEW_BOX_SIZE, " ").concat(VIEW_BOX_SIZE),
        style: style2,
        id: id2,
        role: "presentation"
      }, restProps), gradient && /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("linearGradient", {
        id: gradientId,
        x1: "100%",
        y1: "0%",
        x2: "0%",
        y2: "0%"
      }, Object.keys(gradient).sort(function(a, b2) {
        return stripPercentToNumber(a) - stripPercentToNumber(b2);
      }).map(function(key, index2) {
        return /* @__PURE__ */ reactExports.createElement("stop", {
          key: index2,
          offset: key,
          stopColor: gradient[key]
        });
      }))), !stepCount && /* @__PURE__ */ reactExports.createElement("circle", {
        className: "".concat(prefixCls, "-circle-trail"),
        r: radius,
        cx: 0,
        cy: 0,
        stroke: trailColor,
        strokeLinecap,
        strokeWidth: trailWidth || strokeWidth,
        style: circleStyle
      }), stepCount ? getStepStokeList() : getStokeList());
    };
    Circle$2.defaultProps = defaultProps;
    Circle$2.displayName = "Circle";
    function validProgress(progress) {
      if (!progress || progress < 0) {
        return 0;
      }
      if (progress > 100) {
        return 100;
      }
      return progress;
    }
    function getSuccessPercent(_ref) {
      let {
        success,
        successPercent
      } = _ref;
      let percent = successPercent;
      if (success && "progress" in success) {
        percent = success.progress;
      }
      if (success && "percent" in success) {
        percent = success.percent;
      }
      return percent;
    }
    const getPercentage = (_ref2) => {
      let {
        percent,
        success,
        successPercent
      } = _ref2;
      const realSuccessPercent = validProgress(getSuccessPercent({
        success,
        successPercent
      }));
      return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
    };
    const getStrokeColor = (_ref3) => {
      let {
        success = {},
        strokeColor
      } = _ref3;
      const {
        strokeColor: successColor
      } = success;
      return [successColor || presetPrimaryColors$1.green, strokeColor || null];
    };
    const getSize = (size, type2, extra) => {
      var _a, _b, _c, _d;
      let width = -1;
      let height = -1;
      if (type2 === "step") {
        const steps = extra.steps;
        const strokeWidth = extra.strokeWidth;
        if (typeof size === "string" || typeof size === "undefined") {
          width = size === "small" ? 2 : 14;
          height = strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 8;
        } else if (typeof size === "number") {
          [width, height] = [size, size];
        } else {
          [width = 14, height = 8] = size;
        }
        width *= steps;
      } else if (type2 === "line") {
        const strokeWidth = extra === null || extra === void 0 ? void 0 : extra.strokeWidth;
        if (typeof size === "string" || typeof size === "undefined") {
          height = strokeWidth || (size === "small" ? 6 : 8);
        } else if (typeof size === "number") {
          [width, height] = [size, size];
        } else {
          [width = -1, height = 8] = size;
        }
      } else if (type2 === "circle" || type2 === "dashboard") {
        if (typeof size === "string" || typeof size === "undefined") {
          [width, height] = size === "small" ? [60, 60] : [120, 120];
        } else if (typeof size === "number") {
          [width, height] = [size, size];
        } else {
          width = (_b = (_a = size[0]) !== null && _a !== void 0 ? _a : size[1]) !== null && _b !== void 0 ? _b : 120;
          height = (_d = (_c = size[0]) !== null && _c !== void 0 ? _c : size[1]) !== null && _d !== void 0 ? _d : 120;
        }
      }
      return [width, height];
    };
    const CIRCLE_MIN_STROKE_WIDTH = 3;
    const getMinPercent = (width) => CIRCLE_MIN_STROKE_WIDTH / width * 100;
    const Circle = (props) => {
      const {
        prefixCls,
        trailColor = null,
        strokeLinecap = "round",
        gapPosition,
        gapDegree,
        width: originWidth = 120,
        type: type2,
        children,
        success,
        size
      } = props;
      const mergedSize = size !== null && size !== void 0 ? size : [originWidth, originWidth];
      const [width, height] = getSize(mergedSize, "circle");
      let {
        strokeWidth
      } = props;
      if (strokeWidth === void 0) {
        strokeWidth = Math.max(getMinPercent(width), 6);
      }
      const circleStyle = {
        width,
        height,
        fontSize: width * 0.15 + 6
      };
      const realGapDegree = reactExports.useMemo(() => {
        if (gapDegree || gapDegree === 0) {
          return gapDegree;
        }
        if (type2 === "dashboard") {
          return 75;
        }
        return void 0;
      }, [gapDegree, type2]);
      const gapPos = gapPosition || type2 === "dashboard" && "bottom" || void 0;
      const isGradient = Object.prototype.toString.call(props.strokeColor) === "[object Object]";
      const strokeColor = getStrokeColor({
        success,
        strokeColor: props.strokeColor
      });
      const wrapperClassName = classNames(`${prefixCls}-inner`, {
        [`${prefixCls}-circle-gradient`]: isGradient
      });
      const circleContent = /* @__PURE__ */ reactExports.createElement(Circle$2, {
        percent: getPercentage(props),
        strokeWidth,
        trailWidth: strokeWidth,
        strokeColor,
        strokeLinecap,
        trailColor,
        prefixCls,
        gapDegree: realGapDegree,
        gapPosition: gapPos
      });
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: wrapperClassName,
        style: circleStyle
      }, width <= 20 ? /* @__PURE__ */ reactExports.createElement(pn, {
        title: children
      }, /* @__PURE__ */ reactExports.createElement("span", null, circleContent)) : /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, circleContent, children));
    };
    const Circle$1 = Circle;
    var __rest$e = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const sortGradient = (gradients) => {
      let tempArr = [];
      Object.keys(gradients).forEach((key) => {
        const formattedKey = parseFloat(key.replace(/%/g, ""));
        if (!isNaN(formattedKey)) {
          tempArr.push({
            key: formattedKey,
            value: gradients[key]
          });
        }
      });
      tempArr = tempArr.sort((a, b2) => a.key - b2.key);
      return tempArr.map((_ref) => {
        let {
          key,
          value
        } = _ref;
        return `${value} ${key}%`;
      }).join(", ");
    };
    const handleGradient = (strokeColor, directionConfig) => {
      const {
        from: from2 = presetPrimaryColors$1.blue,
        to = presetPrimaryColors$1.blue,
        direction = directionConfig === "rtl" ? "to left" : "to right"
      } = strokeColor, rest = __rest$e(strokeColor, ["from", "to", "direction"]);
      if (Object.keys(rest).length !== 0) {
        const sortedGradients = sortGradient(rest);
        return {
          backgroundImage: `linear-gradient(${direction}, ${sortedGradients})`
        };
      }
      return {
        backgroundImage: `linear-gradient(${direction}, ${from2}, ${to})`
      };
    };
    const Line = (props) => {
      const {
        prefixCls,
        direction: directionConfig,
        percent,
        size,
        strokeWidth,
        strokeColor,
        strokeLinecap = "round",
        children,
        trailColor = null,
        success
      } = props;
      const backgroundProps = strokeColor && typeof strokeColor !== "string" ? handleGradient(strokeColor, directionConfig) : {
        backgroundColor: strokeColor
      };
      const borderRadius = strokeLinecap === "square" || strokeLinecap === "butt" ? 0 : void 0;
      const trailStyle = {
        backgroundColor: trailColor || void 0,
        borderRadius
      };
      const mergedSize = size !== null && size !== void 0 ? size : [-1, strokeWidth || (size === "small" ? 6 : 8)];
      const [width, height] = getSize(mergedSize, "line", {
        strokeWidth
      });
      const percentStyle = Object.assign({
        width: `${validProgress(percent)}%`,
        height,
        borderRadius
      }, backgroundProps);
      const successPercent = getSuccessPercent(props);
      const successPercentStyle = {
        width: `${validProgress(successPercent)}%`,
        height,
        borderRadius,
        backgroundColor: success === null || success === void 0 ? void 0 : success.strokeColor
      };
      const outerStyle = {
        width: width < 0 ? "100%" : width,
        height
      };
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-outer`,
        style: outerStyle
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-inner`,
        style: trailStyle
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-bg`,
        style: percentStyle
      }), successPercent !== void 0 ? /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-success-bg`,
        style: successPercentStyle
      }) : null)), children);
    };
    const Line$1 = Line;
    const Steps = (props) => {
      const {
        size,
        steps,
        percent = 0,
        strokeWidth = 8,
        strokeColor,
        trailColor = null,
        prefixCls,
        children
      } = props;
      const current = Math.round(steps * (percent / 100));
      const stepWidth = size === "small" ? 2 : 14;
      const mergedSize = size !== null && size !== void 0 ? size : [stepWidth, strokeWidth];
      const [width, height] = getSize(mergedSize, "step", {
        steps,
        strokeWidth
      });
      const unitWidth = width / steps;
      const styledSteps = new Array(steps);
      for (let i2 = 0; i2 < steps; i2++) {
        const color2 = Array.isArray(strokeColor) ? strokeColor[i2] : strokeColor;
        styledSteps[i2] = /* @__PURE__ */ reactExports.createElement("div", {
          key: i2,
          className: classNames(`${prefixCls}-steps-item`, {
            [`${prefixCls}-steps-item-active`]: i2 <= current - 1
          }),
          style: {
            backgroundColor: i2 <= current - 1 ? color2 : trailColor,
            width: unitWidth,
            height
          }
        });
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-steps-outer`
      }, styledSteps, children);
    };
    const Steps$1 = Steps;
    const antProgressActive = new Keyframe("antProgressActive", {
      "0%": {
        transform: "translateX(-100%) scaleX(0)",
        opacity: 0.1
      },
      "20%": {
        transform: "translateX(-100%) scaleX(0)",
        opacity: 0.5
      },
      to: {
        transform: "translateX(0) scaleX(1)",
        opacity: 0
      }
    });
    const genBaseStyle$4 = (token2) => {
      const {
        componentCls: progressCls,
        iconCls: iconPrefixCls
      } = token2;
      return {
        [progressCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
          display: "inline-block",
          "&-rtl": {
            direction: "rtl"
          },
          "&-line": {
            position: "relative",
            width: "100%",
            fontSize: token2.fontSize,
            marginInlineEnd: token2.marginXS,
            marginBottom: token2.marginXS
          },
          [`${progressCls}-outer`]: {
            display: "inline-block",
            width: "100%"
          },
          [`&${progressCls}-show-info`]: {
            [`${progressCls}-outer`]: {
              marginInlineEnd: `calc(-2em - ${token2.marginXS}px)`,
              paddingInlineEnd: `calc(2em + ${token2.paddingXS}px)`
            }
          },
          [`${progressCls}-inner`]: {
            position: "relative",
            display: "inline-block",
            width: "100%",
            overflow: "hidden",
            verticalAlign: "middle",
            backgroundColor: token2.progressRemainingColor,
            borderRadius: token2.progressLineRadius
          },
          [`${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
            [`${progressCls}-circle-path`]: {
              stroke: token2.colorInfo
            }
          },
          [`${progressCls}-success-bg, ${progressCls}-bg`]: {
            position: "relative",
            backgroundColor: token2.colorInfo,
            borderRadius: token2.progressLineRadius,
            transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`
          },
          [`${progressCls}-success-bg`]: {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineStart: 0,
            backgroundColor: token2.colorSuccess
          },
          [`${progressCls}-text`]: {
            display: "inline-block",
            width: "2em",
            marginInlineStart: token2.marginXS,
            color: token2.progressInfoTextColor,
            lineHeight: 1,
            whiteSpace: "nowrap",
            textAlign: "start",
            verticalAlign: "middle",
            wordBreak: "normal",
            [iconPrefixCls]: {
              fontSize: token2.fontSize
            }
          },
          [`&${progressCls}-status-active`]: {
            [`${progressCls}-bg::before`]: {
              position: "absolute",
              inset: 0,
              backgroundColor: token2.colorBgContainer,
              borderRadius: token2.progressLineRadius,
              opacity: 0,
              animationName: antProgressActive,
              animationDuration: token2.progressActiveMotionDuration,
              animationTimingFunction: token2.motionEaseOutQuint,
              animationIterationCount: "infinite",
              content: '""'
            }
          },
          [`&${progressCls}-status-exception`]: {
            [`${progressCls}-bg`]: {
              backgroundColor: token2.colorError
            },
            [`${progressCls}-text`]: {
              color: token2.colorError
            }
          },
          [`&${progressCls}-status-exception ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
            [`${progressCls}-circle-path`]: {
              stroke: token2.colorError
            }
          },
          [`&${progressCls}-status-success`]: {
            [`${progressCls}-bg`]: {
              backgroundColor: token2.colorSuccess
            },
            [`${progressCls}-text`]: {
              color: token2.colorSuccess
            }
          },
          [`&${progressCls}-status-success ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
            [`${progressCls}-circle-path`]: {
              stroke: token2.colorSuccess
            }
          }
        })
      };
    };
    const genCircleStyle = (token2) => {
      const {
        componentCls: progressCls,
        iconCls: iconPrefixCls
      } = token2;
      return {
        [progressCls]: {
          [`${progressCls}-circle-trail`]: {
            stroke: token2.progressRemainingColor
          },
          [`&${progressCls}-circle ${progressCls}-inner`]: {
            position: "relative",
            lineHeight: 1,
            backgroundColor: "transparent"
          },
          [`&${progressCls}-circle ${progressCls}-text`]: {
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineStart: 0,
            width: "100%",
            margin: 0,
            padding: 0,
            color: token2.colorText,
            lineHeight: 1,
            whiteSpace: "normal",
            textAlign: "center",
            transform: "translateY(-50%)",
            [iconPrefixCls]: {
              fontSize: `${token2.fontSize / token2.fontSizeSM}em`
            }
          },
          [`${progressCls}-circle&-status-exception`]: {
            [`${progressCls}-text`]: {
              color: token2.colorError
            }
          },
          [`${progressCls}-circle&-status-success`]: {
            [`${progressCls}-text`]: {
              color: token2.colorSuccess
            }
          }
        },
        [`${progressCls}-inline-circle`]: {
          lineHeight: 1,
          [`${progressCls}-inner`]: {
            verticalAlign: "bottom"
          }
        }
      };
    };
    const genStepStyle = (token2) => {
      const {
        componentCls: progressCls
      } = token2;
      return {
        [progressCls]: {
          [`${progressCls}-steps`]: {
            display: "inline-block",
            "&-outer": {
              display: "flex",
              flexDirection: "row",
              alignItems: "center"
            },
            "&-item": {
              flexShrink: 0,
              minWidth: token2.progressStepMinWidth,
              marginInlineEnd: token2.progressStepMarginInlineEnd,
              backgroundColor: token2.progressRemainingColor,
              transition: `all ${token2.motionDurationSlow}`,
              "&-active": {
                backgroundColor: token2.colorInfo
              }
            }
          }
        }
      };
    };
    const genSmallLine = (token2) => {
      const {
        componentCls: progressCls,
        iconCls: iconPrefixCls
      } = token2;
      return {
        [progressCls]: {
          [`${progressCls}-small&-line, ${progressCls}-small&-line ${progressCls}-text ${iconPrefixCls}`]: {
            fontSize: token2.fontSizeSM
          }
        }
      };
    };
    const useStyle$9 = genComponentStyleHook("Progress", (token2) => {
      const progressStepMarginInlineEnd = token2.marginXXS / 2;
      const progressToken = merge$4(token2, {
        progressLineRadius: 100,
        progressInfoTextColor: token2.colorText,
        progressDefaultColor: token2.colorInfo,
        progressRemainingColor: token2.colorFillSecondary,
        progressStepMarginInlineEnd,
        progressStepMinWidth: progressStepMarginInlineEnd,
        progressActiveMotionDuration: "2.4s"
      });
      return [genBaseStyle$4(progressToken), genCircleStyle(progressToken), genStepStyle(progressToken), genSmallLine(progressToken)];
    });
    var __rest$d = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const ProgressStatuses = ["normal", "exception", "active", "success"];
    const Progress = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        steps,
        strokeColor,
        percent = 0,
        size = "default",
        showInfo = true,
        type: type2 = "line",
        status,
        format: format2
      } = props, restProps = __rest$d(props, ["prefixCls", "className", "rootClassName", "steps", "strokeColor", "percent", "size", "showInfo", "type", "status", "format"]);
      const percentNumber = reactExports.useMemo(() => {
        var _a, _b;
        const successPercent = getSuccessPercent(props);
        return parseInt(successPercent !== void 0 ? (_a = successPercent !== null && successPercent !== void 0 ? successPercent : 0) === null || _a === void 0 ? void 0 : _a.toString() : (_b = percent !== null && percent !== void 0 ? percent : 0) === null || _b === void 0 ? void 0 : _b.toString(), 10);
      }, [percent, props.success, props.successPercent]);
      const progressStatus = reactExports.useMemo(() => {
        if (!ProgressStatuses.includes(status) && percentNumber >= 100) {
          return "success";
        }
        return status || "normal";
      }, [status, percentNumber]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("progress", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$9(prefixCls);
      const progressInfo = reactExports.useMemo(() => {
        if (!showInfo) {
          return null;
        }
        const successPercent = getSuccessPercent(props);
        let text2;
        const textFormatter = format2 || ((number2) => `${number2}%`);
        const isLineType = type2 === "line";
        if (format2 || progressStatus !== "exception" && progressStatus !== "success") {
          text2 = textFormatter(validProgress(percent), validProgress(successPercent));
        } else if (progressStatus === "exception") {
          text2 = isLineType ? /* @__PURE__ */ reactExports.createElement(CloseCircleFilled$1, null) : /* @__PURE__ */ reactExports.createElement(CloseOutlined$1, null);
        } else if (progressStatus === "success") {
          text2 = isLineType ? /* @__PURE__ */ reactExports.createElement(CheckCircleFilled$1, null) : /* @__PURE__ */ reactExports.createElement(CheckOutlined$2, null);
        }
        return /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-text`,
          title: typeof text2 === "string" ? text2 : void 0
        }, text2);
      }, [showInfo, percent, percentNumber, progressStatus, type2, prefixCls, format2]);
      const strokeColorNotArray = Array.isArray(strokeColor) ? strokeColor[0] : strokeColor;
      const strokeColorNotGradient = typeof strokeColor === "string" || Array.isArray(strokeColor) ? strokeColor : void 0;
      let progress;
      if (type2 === "line") {
        progress = steps ? /* @__PURE__ */ reactExports.createElement(Steps$1, Object.assign({}, props, {
          strokeColor: strokeColorNotGradient,
          prefixCls,
          steps
        }), progressInfo) : /* @__PURE__ */ reactExports.createElement(Line$1, Object.assign({}, props, {
          strokeColor: strokeColorNotArray,
          prefixCls,
          direction
        }), progressInfo);
      } else if (type2 === "circle" || type2 === "dashboard") {
        progress = /* @__PURE__ */ reactExports.createElement(Circle$1, Object.assign({}, props, {
          strokeColor: strokeColorNotArray,
          prefixCls,
          progressStatus
        }), progressInfo);
      }
      const classString = classNames(prefixCls, {
        [`${prefixCls}-inline-circle`]: type2 === "circle" && getSize(size, "circle")[0] <= 20,
        [`${prefixCls}-${type2 === "dashboard" && "circle" || steps && "steps" || type2}`]: true,
        [`${prefixCls}-status-${progressStatus}`]: true,
        [`${prefixCls}-show-info`]: showInfo,
        [`${prefixCls}-${size}`]: typeof size === "string",
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        className: classString,
        role: "progressbar"
      }, omit(restProps, ["trailColor", "strokeWidth", "width", "gapDegree", "gapPosition", "strokeLinecap", "success", "successPercent"])), progress));
    };
    const Progress$1 = Progress;
    var ArrowLeftOutlined$6 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M872 474H286.9l350.2-304c5.6-4.9 2.2-14-5.2-14h-88.5c-3.9 0-7.6 1.4-10.5 3.9L155 487.8a31.96 31.96 0 000 48.3L535.1 866c1.5 1.3 3.3 2 5.2 2h91.5c7.4 0 10.8-9.2 5.2-14L286.9 550H872c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, "name": "arrow-left", "theme": "outlined" };
    const ArrowLeftOutlinedSvg = ArrowLeftOutlined$6;
    var CaretDownFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "filled" };
    const CaretDownFilledSvg = CaretDownFilled$2;
    var CaretDownFilled = function CaretDownFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: CaretDownFilledSvg
      }));
    };
    CaretDownFilled.displayName = "CaretDownFilled";
    const CaretDownFilled$1 = /* @__PURE__ */ reactExports.forwardRef(CaretDownFilled);
    var CaretDownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "outlined" };
    const CaretDownOutlinedSvg = CaretDownOutlined$2;
    var CaretDownOutlined = function CaretDownOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: CaretDownOutlinedSvg
      }));
    };
    CaretDownOutlined.displayName = "CaretDownOutlined";
    const CaretDownOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CaretDownOutlined);
    var CaretUpOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, "name": "caret-up", "theme": "outlined" };
    const CaretUpOutlinedSvg = CaretUpOutlined$2;
    var CaretUpOutlined = function CaretUpOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: CaretUpOutlinedSvg
      }));
    };
    CaretUpOutlined.displayName = "CaretUpOutlined";
    const CaretUpOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CaretUpOutlined);
    var CloseCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M685.4 354.8c0-4.4-3.6-8-8-8l-66 .3L512 465.6l-99.3-118.4-66.1-.3c-4.4 0-8 3.5-8 8 0 1.9.7 3.7 1.9 5.2l130.1 155L340.5 670a8.32 8.32 0 00-1.9 5.2c0 4.4 3.6 8 8 8l66.1-.3L512 564.4l99.3 118.4 66 .3c4.4 0 8-3.5 8-8 0-1.9-.7-3.7-1.9-5.2L553.5 515l130.1-155c1.2-1.4 1.8-3.3 1.8-5.2z" } }, { "tag": "path", "attrs": { "d": "M512 65C264.6 65 64 265.6 64 513s200.6 448 448 448 448-200.6 448-448S759.4 65 512 65zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, "name": "close-circle", "theme": "outlined" };
    const CloseCircleOutlinedSvg = CloseCircleOutlined$2;
    var CopyOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, "name": "copy", "theme": "outlined" };
    const CopyOutlinedSvg = CopyOutlined$2;
    var CopyOutlined = function CopyOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: CopyOutlinedSvg
      }));
    };
    CopyOutlined.displayName = "CopyOutlined";
    const CopyOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CopyOutlined);
    var CrownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M899.6 276.5L705 396.4 518.4 147.5a8.06 8.06 0 00-12.9 0L319 396.4 124.3 276.5c-5.7-3.5-13.1 1.2-12.2 7.9L188.5 865c1.1 7.9 7.9 14 16 14h615.1c8 0 14.9-6 15.9-14l76.4-580.6c.8-6.7-6.5-11.4-12.3-7.9zm-126 534.1H250.3l-53.8-409.4 139.8 86.1L512 252.9l175.7 234.4 139.8-86.1-53.9 409.4zM512 509c-62.1 0-112.6 50.5-112.6 112.6S449.9 734.2 512 734.2s112.6-50.5 112.6-112.6S574.1 509 512 509zm0 160.9c-26.6 0-48.2-21.6-48.2-48.3 0-26.6 21.6-48.3 48.2-48.3s48.2 21.6 48.2 48.3c0 26.6-21.6 48.3-48.2 48.3z" } }] }, "name": "crown", "theme": "outlined" };
    const CrownOutlinedSvg = CrownOutlined$2;
    var DashboardOutlined$3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M924.8 385.6a446.7 446.7 0 00-96-142.4 446.7 446.7 0 00-142.4-96C631.1 123.8 572.5 112 512 112s-119.1 11.8-174.4 35.2a446.7 446.7 0 00-142.4 96 446.7 446.7 0 00-96 142.4C75.8 440.9 64 499.5 64 560c0 132.7 58.3 257.7 159.9 343.1l1.7 1.4c5.8 4.8 13.1 7.5 20.6 7.5h531.7c7.5 0 14.8-2.7 20.6-7.5l1.7-1.4C901.7 817.7 960 692.7 960 560c0-60.5-11.9-119.1-35.2-174.4zM761.4 836H262.6A371.12 371.12 0 01140 560c0-99.4 38.7-192.8 109-263 70.3-70.3 163.7-109 263-109 99.4 0 192.8 38.7 263 109 70.3 70.3 109 163.7 109 263 0 105.6-44.5 205.5-122.6 276zM623.5 421.5a8.03 8.03 0 00-11.3 0L527.7 506c-18.7-5-39.4-.2-54.1 14.5a55.95 55.95 0 000 79.2 55.95 55.95 0 0079.2 0 55.87 55.87 0 0014.5-54.1l84.5-84.5c3.1-3.1 3.1-8.2 0-11.3l-28.3-28.3zM490 320h44c4.4 0 8-3.6 8-8v-80c0-4.4-3.6-8-8-8h-44c-4.4 0-8 3.6-8 8v80c0 4.4 3.6 8 8 8zm260 218v44c0 4.4 3.6 8 8 8h80c4.4 0 8-3.6 8-8v-44c0-4.4-3.6-8-8-8h-80c-4.4 0-8 3.6-8 8zm12.7-197.2l-31.1-31.1a8.03 8.03 0 00-11.3 0l-56.6 56.6a8.03 8.03 0 000 11.3l31.1 31.1c3.1 3.1 8.2 3.1 11.3 0l56.6-56.6c3.1-3.1 3.1-8.2 0-11.3zm-458.6-31.1a8.03 8.03 0 00-11.3 0l-31.1 31.1a8.03 8.03 0 000 11.3l56.6 56.6c3.1 3.1 8.2 3.1 11.3 0l31.1-31.1c3.1-3.1 3.1-8.2 0-11.3l-56.6-56.6zM262 530h-80c-4.4 0-8 3.6-8 8v44c0 4.4 3.6 8 8 8h80c4.4 0 8-3.6 8-8v-44c0-4.4-3.6-8-8-8z" } }] }, "name": "dashboard", "theme": "outlined" };
    const DashboardOutlinedSvg = DashboardOutlined$3;
    var DashboardOutlined$1 = function DashboardOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: DashboardOutlinedSvg
      }));
    };
    DashboardOutlined$1.displayName = "DashboardOutlined";
    const DashboardOutlined$2 = /* @__PURE__ */ reactExports.forwardRef(DashboardOutlined$1);
    var DeleteOutlined$3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, "name": "delete", "theme": "outlined" };
    const DeleteOutlinedSvg = DeleteOutlined$3;
    var DeleteOutlined$1 = function DeleteOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: DeleteOutlinedSvg
      }));
    };
    DeleteOutlined$1.displayName = "DeleteOutlined";
    const DeleteOutlined$2 = /* @__PURE__ */ reactExports.forwardRef(DeleteOutlined$1);
    var DownloadOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, "name": "download", "theme": "outlined" };
    const DownloadOutlinedSvg = DownloadOutlined$2;
    var DownloadOutlined = function DownloadOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: DownloadOutlinedSvg
      }));
    };
    DownloadOutlined.displayName = "DownloadOutlined";
    const DownloadOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(DownloadOutlined);
    var EditOutlined$3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, "name": "edit", "theme": "outlined" };
    const EditOutlinedSvg = EditOutlined$3;
    var EditOutlined$1 = function EditOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: EditOutlinedSvg
      }));
    };
    EditOutlined$1.displayName = "EditOutlined";
    const EditOutlined$2 = /* @__PURE__ */ reactExports.forwardRef(EditOutlined$1);
    var EnterOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, "name": "enter", "theme": "outlined" };
    const EnterOutlinedSvg = EnterOutlined$2;
    var EnterOutlined = function EnterOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: EnterOutlinedSvg
      }));
    };
    EnterOutlined.displayName = "EnterOutlined";
    const EnterOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(EnterOutlined);
    var FacebookOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-32 736H663.9V602.2h104l15.6-120.7H663.9v-77.1c0-35 9.7-58.8 59.8-58.8h63.9v-108c-11.1-1.5-49-4.8-93.2-4.8-92.2 0-155.3 56.3-155.3 159.6v89H434.9v120.7h104.3V848H176V176h672v672z" } }] }, "name": "facebook", "theme": "outlined" };
    const FacebookOutlinedSvg = FacebookOutlined$2;
    var FileOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, "name": "file", "theme": "outlined" };
    const FileOutlinedSvg = FileOutlined$2;
    var FileOutlined = function FileOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: FileOutlinedSvg
      }));
    };
    FileOutlined.displayName = "FileOutlined";
    const FileOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(FileOutlined);
    var FileTwoTone$2 = { "icon": function render2(primaryColor, secondaryColor) {
      return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z", "fill": primaryColor } }] };
    }, "name": "file", "theme": "twotone" };
    const FileTwoToneSvg = FileTwoTone$2;
    var FileTwoTone = function FileTwoTone2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: FileTwoToneSvg
      }));
    };
    FileTwoTone.displayName = "FileTwoTone";
    const FileTwoTone$1 = /* @__PURE__ */ reactExports.forwardRef(FileTwoTone);
    var FilterFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, "name": "filter", "theme": "filled" };
    const FilterFilledSvg = FilterFilled$2;
    var FilterFilled = function FilterFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: FilterFilledSvg
      }));
    };
    FilterFilled.displayName = "FilterFilled";
    const FilterFilled$1 = /* @__PURE__ */ reactExports.forwardRef(FilterFilled);
    var FilterOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880.1 154H143.9c-24.5 0-39.8 26.7-27.5 48L349 597.4V838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V597.4L907.7 202c12.2-21.3-3.1-48-27.6-48zM603.4 798H420.6V642h182.9v156zm9.6-236.6l-9.5 16.6h-183l-9.5-16.6L212.7 226h598.6L613 561.4z" } }] }, "name": "filter", "theme": "outlined" };
    const FilterOutlinedSvg = FilterOutlined$1;
    var FolderOpenOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, "name": "folder-open", "theme": "outlined" };
    const FolderOpenOutlinedSvg = FolderOpenOutlined$2;
    var FolderOpenOutlined = function FolderOpenOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: FolderOpenOutlinedSvg
      }));
    };
    FolderOpenOutlined.displayName = "FolderOpenOutlined";
    const FolderOpenOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(FolderOpenOutlined);
    var FolderOutlined$3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, "name": "folder", "theme": "outlined" };
    const FolderOutlinedSvg = FolderOutlined$3;
    var FolderOutlined$1 = function FolderOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: FolderOutlinedSvg
      }));
    };
    FolderOutlined$1.displayName = "FolderOutlined";
    const FolderOutlined$2 = /* @__PURE__ */ reactExports.forwardRef(FolderOutlined$1);
    var GoogleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M881 442.4H519.7v148.5h206.4c-8.9 48-35.9 88.6-76.6 115.8-34.4 23-78.3 36.6-129.9 36.6-99.9 0-184.4-67.5-214.6-158.2-7.6-23-12-47.6-12-72.9s4.4-49.9 12-72.9c30.3-90.6 114.8-158.1 214.7-158.1 56.3 0 106.8 19.4 146.6 57.4l110-110.1c-66.5-62-153.2-100-256.6-100-149.9 0-279.6 86-342.7 211.4-26 51.8-40.8 110.4-40.8 172.4S151 632.8 177 684.6C240.1 810 369.8 896 519.7 896c103.6 0 190.4-34.4 253.8-93 72.5-66.8 114.4-165.2 114.4-282.1 0-27.2-2.4-53.3-6.9-78.5z" } }] }, "name": "google", "theme": "outlined" };
    const GoogleOutlinedSvg = GoogleOutlined$2;
    var HolderOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M300 276.5a56 56 0 1056-97 56 56 0 00-56 97zm0 284a56 56 0 1056-97 56 56 0 00-56 97zM640 228a56 56 0 10112 0 56 56 0 00-112 0zm0 284a56 56 0 10112 0 56 56 0 00-112 0zM300 844.5a56 56 0 1056-97 56 56 0 00-56 97zM640 796a56 56 0 10112 0 56 56 0 00-112 0z" } }] }, "name": "holder", "theme": "outlined" };
    const HolderOutlinedSvg = HolderOutlined$2;
    var HolderOutlined = function HolderOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: HolderOutlinedSvg
      }));
    };
    HolderOutlined.displayName = "HolderOutlined";
    const HolderOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(HolderOutlined);
    var HomeOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M946.5 505L560.1 118.8l-25.9-25.9a31.5 31.5 0 00-44.4 0L77.5 505a63.9 63.9 0 00-18.8 46c.4 35.2 29.7 63.3 64.9 63.3h42.5V940h691.8V614.3h43.4c17.1 0 33.2-6.7 45.3-18.8a63.6 63.6 0 0018.7-45.3c0-17-6.7-33.1-18.8-45.2zM568 868H456V664h112v204zm217.9-325.7V868H632V640c0-22.1-17.9-40-40-40H432c-22.1 0-40 17.9-40 40v228H238.1V542.3h-96l370-369.7 23.1 23.1L882 542.3h-96.1z" } }] }, "name": "home", "theme": "outlined" };
    const HomeOutlinedSvg = HomeOutlined$1;
    var InfoCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z" } }] }, "name": "info-circle", "theme": "outlined" };
    const InfoCircleOutlinedSvg = InfoCircleOutlined$1;
    var KeyOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M608 112c-167.9 0-304 136.1-304 304 0 70.3 23.9 135 63.9 186.5l-41.1 41.1-62.3-62.3a8.15 8.15 0 00-11.4 0l-39.8 39.8a8.15 8.15 0 000 11.4l62.3 62.3-44.9 44.9-62.3-62.3a8.15 8.15 0 00-11.4 0l-39.8 39.8a8.15 8.15 0 000 11.4l62.3 62.3-65.3 65.3a8.03 8.03 0 000 11.3l42.3 42.3c3.1 3.1 8.2 3.1 11.3 0l253.6-253.6A304.06 304.06 0 00608 720c167.9 0 304-136.1 304-304S775.9 112 608 112zm161.2 465.2C726.2 620.3 668.9 644 608 644c-60.9 0-118.2-23.7-161.2-66.8-43.1-43-66.8-100.3-66.8-161.2 0-60.9 23.7-118.2 66.8-161.2 43-43.1 100.3-66.8 161.2-66.8 60.9 0 118.2 23.7 161.2 66.8 43.1 43 66.8 100.3 66.8 161.2 0 60.9-23.7 118.2-66.8 161.2z" } }] }, "name": "key", "theme": "outlined" };
    const KeyOutlinedSvg = KeyOutlined$2;
    var LockOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 464h-68V240c0-70.7-57.3-128-128-128H388c-70.7 0-128 57.3-128 128v224h-68c-17.7 0-32 14.3-32 32v384c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V496c0-17.7-14.3-32-32-32zM332 240c0-30.9 25.1-56 56-56h248c30.9 0 56 25.1 56 56v224H332V240zm460 600H232V536h560v304zM484 701v53c0 4.4 3.6 8 8 8h40c4.4 0 8-3.6 8-8v-53a48.01 48.01 0 10-56 0z" } }] }, "name": "lock", "theme": "outlined" };
    const LockOutlinedSvg = LockOutlined$2;
    var LogoutOutlined$3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M868 732h-70.3c-4.8 0-9.3 2.1-12.3 5.8-7 8.5-14.5 16.7-22.4 24.5a353.84 353.84 0 01-112.7 75.9A352.8 352.8 0 01512.4 866c-47.9 0-94.3-9.4-137.9-27.8a353.84 353.84 0 01-112.7-75.9 353.28 353.28 0 01-76-112.5C167.3 606.2 158 559.9 158 512s9.4-94.2 27.8-137.8c17.8-42.1 43.4-80 76-112.5s70.5-58.1 112.7-75.9c43.6-18.4 90-27.8 137.9-27.8 47.9 0 94.3 9.3 137.9 27.8 42.2 17.8 80.1 43.4 112.7 75.9 7.9 7.9 15.3 16.1 22.4 24.5 3 3.7 7.6 5.8 12.3 5.8H868c6.3 0 10.2-7 6.7-12.3C798 160.5 663.8 81.6 511.3 82 271.7 82.6 79.6 277.1 82 516.4 84.4 751.9 276.2 942 512.4 942c152.1 0 285.7-78.8 362.3-197.7 3.4-5.3-.4-12.3-6.7-12.3zm88.9-226.3L815 393.7c-5.3-4.2-13-.4-13 6.3v76H488c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h314v76c0 6.7 7.8 10.5 13 6.3l141.9-112a8 8 0 000-12.6z" } }] }, "name": "logout", "theme": "outlined" };
    const LogoutOutlinedSvg = LogoutOutlined$3;
    var LogoutOutlined$1 = function LogoutOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: LogoutOutlinedSvg
      }));
    };
    LogoutOutlined$1.displayName = "LogoutOutlined";
    const LogoutOutlined$2 = /* @__PURE__ */ reactExports.forwardRef(LogoutOutlined$1);
    var MailOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 110.8V792H136V270.8l-27.6-21.5 39.3-50.5 42.8 33.3h643.1l42.8-33.3 39.3 50.5-27.7 21.5zM833.6 232L512 482 190.4 232l-42.8-33.3-39.3 50.5 27.6 21.5 341.6 265.6a55.99 55.99 0 0068.7 0L888 270.8l27.6-21.5-39.3-50.5-42.7 33.2z" } }] }, "name": "mail", "theme": "outlined" };
    const MailOutlinedSvg = MailOutlined$2;
    var MinusSquareOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "minus-square", "theme": "outlined" };
    const MinusSquareOutlinedSvg = MinusSquareOutlined$2;
    var MinusSquareOutlined = function MinusSquareOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: MinusSquareOutlinedSvg
      }));
    };
    MinusSquareOutlined.displayName = "MinusSquareOutlined";
    const MinusSquareOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(MinusSquareOutlined);
    var MoreOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M456 231a56 56 0 10112 0 56 56 0 10-112 0zm0 280a56 56 0 10112 0 56 56 0 10-112 0zm0 280a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "more", "theme": "outlined" };
    const MoreOutlinedSvg = MoreOutlined$2;
    var PaperClipOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" } }] }, "name": "paper-clip", "theme": "outlined" };
    const PaperClipOutlinedSvg = PaperClipOutlined$2;
    var PaperClipOutlined = function PaperClipOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: PaperClipOutlinedSvg
      }));
    };
    PaperClipOutlined.displayName = "PaperClipOutlined";
    const PaperClipOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(PaperClipOutlined);
    var PhoneOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M877.1 238.7L770.6 132.3c-13-13-30.4-20.3-48.8-20.3s-35.8 7.2-48.8 20.3L558.3 246.8c-13 13-20.3 30.5-20.3 48.9 0 18.5 7.2 35.8 20.3 48.9l89.6 89.7a405.46 405.46 0 01-86.4 127.3c-36.7 36.9-79.6 66-127.2 86.6l-89.6-89.7c-13-13-30.4-20.3-48.8-20.3a68.2 68.2 0 00-48.8 20.3L132.3 673c-13 13-20.3 30.5-20.3 48.9 0 18.5 7.2 35.8 20.3 48.9l106.4 106.4c22.2 22.2 52.8 34.9 84.2 34.9 6.5 0 12.8-.5 19.2-1.6 132.4-21.8 263.8-92.3 369.9-198.3C818 606 888.4 474.6 910.4 342.1c6.3-37.6-6.3-76.3-33.3-103.4zm-37.6 91.5c-19.5 117.9-82.9 235.5-178.4 331s-213 158.9-330.9 178.4c-14.8 2.5-30-2.5-40.8-13.2L184.9 721.9 295.7 611l119.8 120 .9.9 21.6-8a481.29 481.29 0 00285.7-285.8l8-21.6-120.8-120.7 110.8-110.9 104.5 104.5c10.8 10.8 15.8 26 13.3 40.8z" } }] }, "name": "phone", "theme": "outlined" };
    const PhoneOutlinedSvg = PhoneOutlined$2;
    var PictureTwoTone$2 = { "icon": function render2(primaryColor, secondaryColor) {
      return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z", "fill": primaryColor } }, { "tag": "path", "attrs": { "d": "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M276 368a28 28 0 1056 0 28 28 0 10-56 0z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z", "fill": primaryColor } }] };
    }, "name": "picture", "theme": "twotone" };
    const PictureTwoToneSvg = PictureTwoTone$2;
    var PictureTwoTone = function PictureTwoTone2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: PictureTwoToneSvg
      }));
    };
    PictureTwoTone.displayName = "PictureTwoTone";
    const PictureTwoTone$1 = /* @__PURE__ */ reactExports.forwardRef(PictureTwoTone);
    var PlusCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M696 480H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8z" } }, { "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, "name": "plus-circle", "theme": "outlined" };
    const PlusCircleOutlinedSvg = PlusCircleOutlined$2;
    var PlusSquareOutlined$3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "plus-square", "theme": "outlined" };
    const PlusSquareOutlinedSvg = PlusSquareOutlined$3;
    var PlusSquareOutlined$1 = function PlusSquareOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: PlusSquareOutlinedSvg
      }));
    };
    PlusSquareOutlined$1.displayName = "PlusSquareOutlined";
    const PlusSquareOutlined$2 = /* @__PURE__ */ reactExports.forwardRef(PlusSquareOutlined$1);
    var ReadOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 161H699.2c-49.1 0-97.1 14.1-138.4 40.7L512 233l-48.8-31.3A255.2 255.2 0 00324.8 161H96c-17.7 0-32 14.3-32 32v568c0 17.7 14.3 32 32 32h228.8c49.1 0 97.1 14.1 138.4 40.7l44.4 28.6c1.3.8 2.8 1.3 4.3 1.3s3-.4 4.3-1.3l44.4-28.6C602 807.1 650.1 793 699.2 793H928c17.7 0 32-14.3 32-32V193c0-17.7-14.3-32-32-32zM324.8 721H136V233h188.8c35.4 0 69.8 10.1 99.5 29.2l48.8 31.3 6.9 4.5v462c-47.6-25.6-100.8-39-155.2-39zm563.2 0H699.2c-54.4 0-107.6 13.4-155.2 39V298l6.9-4.5 48.8-31.3c29.7-19.1 64.1-29.2 99.5-29.2H888v488zM396.9 361H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm223.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c0-4.1-3.2-7.5-7.1-7.5H627.1c-3.9 0-7.1 3.4-7.1 7.5zM396.9 501H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm416 0H627.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5z" } }] }, "name": "read", "theme": "outlined" };
    const ReadOutlinedSvg = ReadOutlined$1;
    var RedoOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M758.2 839.1C851.8 765.9 912 651.9 912 523.9 912 303 733.5 124.3 512.6 124 291.4 123.7 112 302.8 112 523.9c0 125.2 57.5 236.9 147.6 310.2 3.5 2.8 8.6 2.2 11.4-1.3l39.4-50.5c2.7-3.4 2.1-8.3-1.2-11.1-8.1-6.6-15.9-13.7-23.4-21.2a318.64 318.64 0 01-68.6-101.7C200.4 609 192 567.1 192 523.9s8.4-85.1 25.1-124.5c16.1-38.1 39.2-72.3 68.6-101.7 29.4-29.4 63.6-52.5 101.7-68.6C426.9 212.4 468.8 204 512 204s85.1 8.4 124.5 25.1c38.1 16.1 72.3 39.2 101.7 68.6 29.4 29.4 52.5 63.6 68.6 101.7 16.7 39.4 25.1 81.3 25.1 124.5s-8.4 85.1-25.1 124.5a318.64 318.64 0 01-68.6 101.7c-9.3 9.3-19.1 18-29.3 26L668.2 724a8 8 0 00-14.1 3l-39.6 162.2c-1.2 5 2.6 9.9 7.7 9.9l167 .8c6.7 0 10.5-7.7 6.3-12.9l-37.3-47.9z" } }] }, "name": "redo", "theme": "outlined" };
    const RedoOutlinedSvg = RedoOutlined$1;
    var SaveOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M893.3 293.3L730.7 130.7c-7.5-7.5-16.7-13-26.7-16V112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V338.5c0-17-6.7-33.2-18.7-45.2zM384 184h256v104H384V184zm456 656H184V184h136v136c0 17.7 14.3 32 32 32h320c17.7 0 32-14.3 32-32V205.8l136 136V840zM512 442c-79.5 0-144 64.5-144 144s64.5 144 144 144 144-64.5 144-144-64.5-144-144-144zm0 224c-44.2 0-80-35.8-80-80s35.8-80 80-80 80 35.8 80 80-35.8 80-80 80z" } }] }, "name": "save", "theme": "outlined" };
    const SaveOutlinedSvg = SaveOutlined$1;
    var SelectOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h360c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H184V184h656v320c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V144c0-17.7-14.3-32-32-32zM653.3 599.4l52.2-52.2a8.01 8.01 0 00-4.7-13.6l-179.4-21c-5.1-.6-9.5 3.7-8.9 8.9l21 179.4c.8 6.6 8.9 9.4 13.6 4.7l52.4-52.4 256.2 256.2c3.1 3.1 8.2 3.1 11.3 0l42.4-42.4c3.1-3.1 3.1-8.2 0-11.3L653.3 599.4z" } }] }, "name": "select", "theme": "outlined" };
    const SelectOutlinedSvg = SelectOutlined$2;
    var TeamOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M824.2 699.9a301.55 301.55 0 00-86.4-60.4C783.1 602.8 812 546.8 812 484c0-110.8-92.4-201.7-203.2-200-109.1 1.7-197 90.6-197 200 0 62.8 29 118.8 74.2 155.5a300.95 300.95 0 00-86.4 60.4C345 754.6 314 826.8 312 903.8a8 8 0 008 8.2h56c4.3 0 7.9-3.4 8-7.7 1.9-58 25.4-112.3 66.7-153.5A226.62 226.62 0 01612 684c60.9 0 118.2 23.7 161.3 66.8C814.5 792 838 846.3 840 904.3c.1 4.3 3.7 7.7 8 7.7h56a8 8 0 008-8.2c-2-77-33-149.2-87.8-203.9zM612 612c-34.2 0-66.4-13.3-90.5-37.5a126.86 126.86 0 01-37.5-91.8c.3-32.8 13.4-64.5 36.3-88 24-24.6 56.1-38.3 90.4-38.7 33.9-.3 66.8 12.9 91 36.6 24.8 24.3 38.4 56.8 38.4 91.4 0 34.2-13.3 66.3-37.5 90.5A127.3 127.3 0 01612 612zM361.5 510.4c-.9-8.7-1.4-17.5-1.4-26.4 0-15.9 1.5-31.4 4.3-46.5.7-3.6-1.2-7.3-4.5-8.8-13.6-6.1-26.1-14.5-36.9-25.1a127.54 127.54 0 01-38.7-95.4c.9-32.1 13.8-62.6 36.3-85.6 24.7-25.3 57.9-39.1 93.2-38.7 31.9.3 62.7 12.6 86 34.4 7.9 7.4 14.7 15.6 20.4 24.4 2 3.1 5.9 4.4 9.3 3.2 17.6-6.1 36.2-10.4 55.3-12.4 5.6-.6 8.8-6.6 6.3-11.6-32.5-64.3-98.9-108.7-175.7-109.9-110.9-1.7-203.3 89.2-203.3 199.9 0 62.8 28.9 118.8 74.2 155.5-31.8 14.7-61.1 35-86.5 60.4-54.8 54.7-85.8 126.9-87.8 204a8 8 0 008 8.2h56.1c4.3 0 7.9-3.4 8-7.7 1.9-58 25.4-112.3 66.7-153.5 29.4-29.4 65.4-49.8 104.7-59.7 3.9-1 6.5-4.7 6-8.7z" } }] }, "name": "team", "theme": "outlined" };
    const TeamOutlinedSvg = TeamOutlined$1;
    var UndoOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M511.4 124C290.5 124.3 112 303 112 523.9c0 128 60.2 242 153.8 315.2l-37.5 48c-4.1 5.3-.3 13 6.3 12.9l167-.8c5.2 0 9-4.9 7.7-9.9L369.8 727a8 8 0 00-14.1-3L315 776.1c-10.2-8-20-16.7-29.3-26a318.64 318.64 0 01-68.6-101.7C200.4 609 192 567.1 192 523.9s8.4-85.1 25.1-124.5c16.1-38.1 39.2-72.3 68.6-101.7 29.4-29.4 63.6-52.5 101.7-68.6C426.9 212.4 468.8 204 512 204s85.1 8.4 124.5 25.1c38.1 16.1 72.3 39.2 101.7 68.6 29.4 29.4 52.5 63.6 68.6 101.7 16.7 39.4 25.1 81.3 25.1 124.5s-8.4 85.1-25.1 124.5a318.64 318.64 0 01-68.6 101.7c-7.5 7.5-15.3 14.5-23.4 21.2a7.93 7.93 0 00-1.2 11.1l39.4 50.5c2.8 3.5 7.9 4.1 11.4 1.3C854.5 760.8 912 649.1 912 523.9c0-221.1-179.4-400.2-400.6-399.9z" } }] }, "name": "undo", "theme": "outlined" };
    const UndoOutlinedSvg = UndoOutlined$1;
    var UnorderedListOutlined$3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "unordered-list", "theme": "outlined" };
    const UnorderedListOutlinedSvg = UnorderedListOutlined$3;
    var UnorderedListOutlined$1 = function UnorderedListOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: UnorderedListOutlinedSvg
      }));
    };
    UnorderedListOutlined$1.displayName = "UnorderedListOutlined";
    const UnorderedListOutlined$2 = /* @__PURE__ */ reactExports.forwardRef(UnorderedListOutlined$1);
    var WarningFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48zM480 416c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v184c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V416zm32 352a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "warning", "theme": "filled" };
    const WarningFilledSvg = WarningFilled$2;
    var WarningFilled = function WarningFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$2, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: WarningFilledSvg
      }));
    };
    WarningFilled.displayName = "WarningFilled";
    const WarningFilled$1 = /* @__PURE__ */ reactExports.forwardRef(WarningFilled);
    const NoFound = () => /* @__PURE__ */ reactExports.createElement("svg", {
      width: "252",
      height: "294"
    }, /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("path", {
      d: "M0 .387h251.772v251.772H0z"
    })), /* @__PURE__ */ reactExports.createElement("g", {
      fill: "none",
      fillRule: "evenodd"
    }, /* @__PURE__ */ reactExports.createElement("g", {
      transform: "translate(0 .012)"
    }, /* @__PURE__ */ reactExports.createElement("mask", {
      fill: "#fff"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M0 127.32v-2.095C0 56.279 55.892.387 124.838.387h2.096c68.946 0 124.838 55.892 124.838 124.838v2.096c0 68.946-55.892 124.838-124.838 124.838h-2.096C55.892 252.16 0 196.267 0 127.321",
      fill: "#E4EBF7",
      mask: "url(#b)"
    })), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M39.755 130.84a8.276 8.276 0 1 1-16.468-1.66 8.276 8.276 0 0 1 16.468 1.66",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M36.975 134.297l10.482 5.943M48.373 146.508l-12.648 10.788",
      stroke: "#FFF",
      strokeWidth: "2"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M39.875 159.352a5.667 5.667 0 1 1-11.277-1.136 5.667 5.667 0 0 1 11.277 1.136M57.588 143.247a5.708 5.708 0 1 1-11.358-1.145 5.708 5.708 0 0 1 11.358 1.145M99.018 26.875l29.82-.014a4.587 4.587 0 1 0-.003-9.175l-29.82.013a4.587 4.587 0 1 0 .003 9.176M110.424 45.211l29.82-.013a4.588 4.588 0 0 0-.004-9.175l-29.82.013a4.587 4.587 0 1 0 .004 9.175",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M112.798 26.861v-.002l15.784-.006a4.588 4.588 0 1 0 .003 9.175l-15.783.007v-.002a4.586 4.586 0 0 0-.004-9.172M184.523 135.668c-.553 5.485-5.447 9.483-10.931 8.93-5.485-.553-9.483-5.448-8.93-10.932.552-5.485 5.447-9.483 10.932-8.93 5.485.553 9.483 5.447 8.93 10.932",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M179.26 141.75l12.64 7.167M193.006 156.477l-15.255 13.011",
      stroke: "#FFF",
      strokeWidth: "2"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M184.668 170.057a6.835 6.835 0 1 1-13.6-1.372 6.835 6.835 0 0 1 13.6 1.372M203.34 153.325a6.885 6.885 0 1 1-13.7-1.382 6.885 6.885 0 0 1 13.7 1.382",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M151.931 192.324a2.222 2.222 0 1 1-4.444 0 2.222 2.222 0 0 1 4.444 0zM225.27 116.056a2.222 2.222 0 1 1-4.445 0 2.222 2.222 0 0 1 4.444 0zM216.38 151.08a2.223 2.223 0 1 1-4.446-.001 2.223 2.223 0 0 1 4.446 0zM176.917 107.636a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM195.291 92.165a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM202.058 180.711a2.223 2.223 0 1 1-4.446 0 2.223 2.223 0 0 1 4.446 0z",
      stroke: "#FFF",
      strokeWidth: "2"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      stroke: "#FFF",
      strokeWidth: "2",
      d: "M214.404 153.302l-1.912 20.184-10.928 5.99M173.661 174.792l-6.356 9.814h-11.36l-4.508 6.484M174.941 125.168v-15.804M220.824 117.25l-12.84 7.901-15.31-7.902V94.39"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M166.588 65.936h-3.951a4.756 4.756 0 0 1-4.743-4.742 4.756 4.756 0 0 1 4.743-4.743h3.951a4.756 4.756 0 0 1 4.743 4.743 4.756 4.756 0 0 1-4.743 4.742",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M174.823 30.03c0-16.281 13.198-29.48 29.48-29.48 16.28 0 29.48 13.199 29.48 29.48 0 16.28-13.2 29.48-29.48 29.48-16.282 0-29.48-13.2-29.48-29.48",
      fill: "#1890FF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M205.952 38.387c.5.5.785 1.142.785 1.928s-.286 1.465-.785 1.964c-.572.5-1.214.75-2 .75-.785 0-1.429-.285-1.929-.785-.572-.5-.82-1.143-.82-1.929s.248-1.428.82-1.928c.5-.5 1.144-.75 1.93-.75.785 0 1.462.25 1.999.75m4.285-19.463c1.428 1.249 2.143 2.963 2.143 5.142 0 1.712-.427 3.13-1.219 4.25-.067.096-.137.18-.218.265-.416.429-1.41 1.346-2.956 2.699a5.07 5.07 0 0 0-1.428 1.75 5.207 5.207 0 0 0-.536 2.357v.5h-4.107v-.5c0-1.357.215-2.536.714-3.5.464-.964 1.857-2.464 4.178-4.536l.43-.5c.643-.785.964-1.643.964-2.535 0-1.18-.358-2.108-1-2.785-.678-.68-1.643-1.001-2.858-1.001-1.536 0-2.642.464-3.357 1.43-.37.5-.621 1.135-.76 1.904a1.999 1.999 0 0 1-1.971 1.63h-.004c-1.277 0-2.257-1.183-1.98-2.43.337-1.518 1.02-2.78 2.073-3.784 1.536-1.5 3.607-2.25 6.25-2.25 2.32 0 4.214.607 5.642 1.894",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M52.04 76.131s21.81 5.36 27.307 15.945c5.575 10.74-6.352 9.26-15.73 4.935-10.86-5.008-24.7-11.822-11.577-20.88",
      fill: "#FFB594"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M90.483 67.504l-.449 2.893c-.753.49-4.748-2.663-4.748-2.663l-1.645.748-1.346-5.684s6.815-4.589 8.917-5.018c2.452-.501 9.884.94 10.7 2.278 0 0 1.32.486-2.227.69-3.548.203-5.043.447-6.79 3.132-1.747 2.686-2.412 3.624-2.412 3.624",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M128.055 111.367c-2.627-7.724-6.15-13.18-8.917-15.478-3.5-2.906-9.34-2.225-11.366-4.187-1.27-1.231-3.215-1.197-3.215-1.197s-14.98-3.158-16.828-3.479c-2.37-.41-2.124-.714-6.054-1.405-1.57-1.907-2.917-1.122-2.917-1.122l-7.11-1.383c-.853-1.472-2.423-1.023-2.423-1.023l-2.468-.897c-1.645 9.976-7.74 13.796-7.74 13.796 1.795 1.122 15.703 8.3 15.703 8.3l5.107 37.11s-3.321 5.694 1.346 9.109c0 0 19.883-3.743 34.921-.329 0 0 3.047-2.546.972-8.806.523-3.01 1.394-8.263 1.736-11.622.385.772 2.019 1.918 3.14 3.477 0 0 9.407-7.365 11.052-14.012-.832-.723-1.598-1.585-2.267-2.453-.567-.736-.358-2.056-.765-2.717-.669-1.084-1.804-1.378-1.907-1.682",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M101.09 289.998s4.295 2.041 7.354 1.021c2.821-.94 4.53.668 7.08 1.178 2.55.51 6.874 1.1 11.686-1.26-.103-5.51-6.889-3.98-11.96-6.713-2.563-1.38-3.784-4.722-3.598-8.799h-9.402s-1.392 10.52-1.16 14.573",
      fill: "#CBD1D1"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M101.067 289.826s2.428 1.271 6.759.653c3.058-.437 3.712.481 7.423 1.031 3.712.55 10.724-.069 11.823-.894.413 1.1-.343 2.063-.343 2.063s-1.512.603-4.812.824c-2.03.136-5.8.291-7.607-.503-1.787-1.375-5.247-1.903-5.728-.241-3.918.95-7.355-.286-7.355-.286l-.16-2.647z",
      fill: "#2B0849"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M108.341 276.044h3.094s-.103 6.702 4.536 8.558c-4.64.618-8.558-2.303-7.63-8.558",
      fill: "#A4AABA"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M57.542 272.401s-2.107 7.416-4.485 12.306c-1.798 3.695-4.225 7.492 5.465 7.492 6.648 0 8.953-.48 7.423-6.599-1.53-6.12.266-13.199.266-13.199h-8.669z",
      fill: "#CBD1D1"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M51.476 289.793s2.097 1.169 6.633 1.169c6.083 0 8.249-1.65 8.249-1.65s.602 1.114-.619 2.165c-.993.855-3.597 1.591-7.39 1.546-4.145-.048-5.832-.566-6.736-1.168-.825-.55-.687-1.58-.137-2.062",
      fill: "#2B0849"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M58.419 274.304s.033 1.519-.314 2.93c-.349 1.42-1.078 3.104-1.13 4.139-.058 1.151 4.537 1.58 5.155.034.62-1.547 1.294-6.427 1.913-7.252.619-.825-4.903-2.119-5.624.15",
      fill: "#A4AABA"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M99.66 278.514l13.378.092s1.298-54.52 1.853-64.403c.554-9.882 3.776-43.364 1.002-63.128l-12.547-.644-22.849.78s-.434 3.966-1.195 9.976c-.063.496-.682.843-.749 1.365-.075.585.423 1.354.32 1.966-2.364 14.08-6.377 33.104-8.744 46.677-.116.666-1.234 1.009-1.458 2.691-.04.302.211 1.525.112 1.795-6.873 18.744-10.949 47.842-14.277 61.885l14.607-.014s2.197-8.57 4.03-16.97c2.811-12.886 23.111-85.01 23.111-85.01l3.016-.521 1.043 46.35s-.224 1.234.337 2.02c.56.785-.56 1.123-.392 2.244l.392 1.794s-.449 7.178-.898 11.89c-.448 4.71-.092 39.165-.092 39.165",
      fill: "#7BB2F9"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M76.085 221.626c1.153.094 4.038-2.019 6.955-4.935M106.36 225.142s2.774-1.11 6.103-3.883",
      stroke: "#648BD8",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M107.275 222.1s2.773-1.11 6.102-3.884",
      stroke: "#648BD8",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M74.74 224.767s2.622-.591 6.505-3.365M86.03 151.634c-.27 3.106.3 8.525-4.336 9.123M103.625 149.88s.11 14.012-1.293 15.065c-2.219 1.664-2.99 1.944-2.99 1.944M99.79 150.438s.035 12.88-1.196 24.377M93.673 175.911s7.212-1.664 9.431-1.664M74.31 205.861a212.013 212.013 0 0 1-.979 4.56s-1.458 1.832-1.009 3.776c.449 1.944-.947 2.045-4.985 15.355-1.696 5.59-4.49 18.591-6.348 27.597l-.231 1.12M75.689 197.807a320.934 320.934 0 0 1-.882 4.754M82.591 152.233L81.395 162.7s-1.097.15-.5 2.244c.113 1.346-2.674 15.775-5.18 30.43M56.12 274.418h13.31",
      stroke: "#648BD8",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M116.241 148.22s-17.047-3.104-35.893.2c.158 2.514-.003 4.15-.003 4.15s14.687-2.818 35.67-.312c.252-2.355.226-4.038.226-4.038",
      fill: "#192064"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M106.322 151.165l.003-4.911a.81.81 0 0 0-.778-.815c-2.44-.091-5.066-.108-7.836-.014a.818.818 0 0 0-.789.815l-.003 4.906a.81.81 0 0 0 .831.813c2.385-.06 4.973-.064 7.73.017a.815.815 0 0 0 .842-.81",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M105.207 150.233l.002-3.076a.642.642 0 0 0-.619-.646 94.321 94.321 0 0 0-5.866-.01.65.65 0 0 0-.63.647v3.072a.64.64 0 0 0 .654.644 121.12 121.12 0 0 1 5.794.011c.362.01.665-.28.665-.642",
      fill: "#192064"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M100.263 275.415h12.338M101.436 270.53c.006 3.387.042 5.79.111 6.506M101.451 264.548a915.75 915.75 0 0 0-.015 4.337M100.986 174.965l.898 44.642s.673 1.57-.225 2.692c-.897 1.122 2.468.673.898 2.243-1.57 1.57.897 1.122 0 3.365-.596 1.489-.994 21.1-1.096 35.146",
      stroke: "#648BD8",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M46.876 83.427s-.516 6.045 7.223 5.552c11.2-.712 9.218-9.345 31.54-21.655-.786-2.708-2.447-4.744-2.447-4.744s-11.068 3.11-22.584 8.046c-6.766 2.9-13.395 6.352-13.732 12.801M104.46 91.057l.941-5.372-8.884-11.43-5.037 5.372-1.74 7.834a.321.321 0 0 0 .108.32c.965.8 6.5 5.013 14.347 3.544a.332.332 0 0 0 .264-.268",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M93.942 79.387s-4.533-2.853-2.432-6.855c1.623-3.09 4.513 1.133 4.513 1.133s.52-3.642 3.121-3.642c.52-1.04 1.561-4.162 1.561-4.162s11.445 2.601 13.526 3.121c0 5.203-2.304 19.424-7.84 19.861-8.892.703-12.449-9.456-12.449-9.456",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M113.874 73.446c2.601-2.081 3.47-9.722 3.47-9.722s-2.479-.49-6.64-2.05c-4.683-2.081-12.798-4.747-17.48.976-9.668 3.223-2.05 19.823-2.05 19.823l2.713-3.021s-3.935-3.287-2.08-6.243c2.17-3.462 3.92 1.073 3.92 1.073s.637-2.387 3.581-3.342c.355-.71 1.036-2.674 1.432-3.85a1.073 1.073 0 0 1 1.263-.704c2.4.558 8.677 2.019 11.356 2.662.522.125.871.615.82 1.15l-.305 3.248z",
      fill: "#520038"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M104.977 76.064c-.103.61-.582 1.038-1.07.956-.489-.083-.801-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.644.698 1.254M112.132 77.694c-.103.61-.582 1.038-1.07.956-.488-.083-.8-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.643.698 1.254",
      fill: "#552950"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      stroke: "#DB836E",
      strokeWidth: "1.118",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      d: "M110.13 74.84l-.896 1.61-.298 4.357h-2.228"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M110.846 74.481s1.79-.716 2.506.537",
      stroke: "#5C2552",
      strokeWidth: "1.118",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M92.386 74.282s.477-1.114 1.113-.716c.637.398 1.274 1.433.558 1.99-.717.556.159 1.67.159 1.67",
      stroke: "#DB836E",
      strokeWidth: "1.118",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M103.287 72.93s1.83 1.113 4.137.954",
      stroke: "#5C2552",
      strokeWidth: "1.118",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M103.685 81.762s2.227 1.193 4.376 1.193M104.64 84.308s.954.398 1.511.318M94.693 81.205s2.308 7.4 10.424 7.639",
      stroke: "#DB836E",
      strokeWidth: "1.118",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M81.45 89.384s.45 5.647-4.935 12.787M69 82.654s-.726 9.282-8.204 14.206",
      stroke: "#E4EBF7",
      strokeWidth: "1.101",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M129.405 122.865s-5.272 7.403-9.422 10.768",
      stroke: "#E4EBF7",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M119.306 107.329s.452 4.366-2.127 32.062",
      stroke: "#E4EBF7",
      strokeWidth: "1.101",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M150.028 151.232h-49.837a1.01 1.01 0 0 1-1.01-1.01v-31.688c0-.557.452-1.01 1.01-1.01h49.837c.558 0 1.01.453 1.01 1.01v31.688a1.01 1.01 0 0 1-1.01 1.01",
      fill: "#F2D7AD"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M150.29 151.232h-19.863v-33.707h20.784v32.786a.92.92 0 0 1-.92.92",
      fill: "#F4D19D"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M123.554 127.896H92.917a.518.518 0 0 1-.425-.816l6.38-9.113c.193-.277.51-.442.85-.442h31.092l-7.26 10.371z",
      fill: "#F2D7AD"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      fill: "#CC9B6E",
      d: "M123.689 128.447H99.25v-.519h24.169l7.183-10.26.424.298z"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M158.298 127.896h-18.669a2.073 2.073 0 0 1-1.659-.83l-7.156-9.541h19.965c.49 0 .95.23 1.244.622l6.69 8.92a.519.519 0 0 1-.415.83",
      fill: "#F4D19D"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      fill: "#CC9B6E",
      d: "M157.847 128.479h-19.384l-7.857-10.475.415-.31 7.7 10.266h19.126zM130.554 150.685l-.032-8.177.519-.002.032 8.177z"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      fill: "#CC9B6E",
      d: "M130.511 139.783l-.08-21.414.519-.002.08 21.414zM111.876 140.932l-.498-.143 1.479-5.167.498.143zM108.437 141.06l-2.679-2.935 2.665-3.434.41.318-2.397 3.089 2.384 2.612zM116.607 141.06l-.383-.35 2.383-2.612-2.397-3.089.41-.318 2.665 3.434z"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M154.316 131.892l-3.114-1.96.038 3.514-1.043.092c-1.682.115-3.634.23-4.789.23-1.902 0-2.693 2.258 2.23 2.648l-2.645-.596s-2.168 1.317.504 2.3c0 0-1.58 1.217.561 2.58-.584 3.504 5.247 4.058 7.122 3.59 1.876-.47 4.233-2.359 4.487-5.16.28-3.085-.89-5.432-3.35-7.238",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M153.686 133.577s-6.522.47-8.36.372c-1.836-.098-1.904 2.19 2.359 2.264 3.739.15 5.451-.044 5.451-.044",
      stroke: "#DB836E",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M145.16 135.877c-1.85 1.346.561 2.355.561 2.355s3.478.898 6.73.617",
      stroke: "#DB836E",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M151.89 141.71s-6.28.111-6.73-2.132c-.223-1.346.45-1.402.45-1.402M146.114 140.868s-1.103 3.16 5.44 3.533M151.202 129.932v3.477M52.838 89.286c3.533-.337 8.423-1.248 13.582-7.754",
      stroke: "#DB836E",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M168.567 248.318a6.647 6.647 0 0 1-6.647-6.647v-66.466a6.647 6.647 0 1 1 13.294 0v66.466a6.647 6.647 0 0 1-6.647 6.647",
      fill: "#5BA02E"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M176.543 247.653a6.647 6.647 0 0 1-6.646-6.647v-33.232a6.647 6.647 0 1 1 13.293 0v33.232a6.647 6.647 0 0 1-6.647 6.647",
      fill: "#92C110"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M186.443 293.613H158.92a3.187 3.187 0 0 1-3.187-3.187v-46.134a3.187 3.187 0 0 1 3.187-3.187h27.524a3.187 3.187 0 0 1 3.187 3.187v46.134a3.187 3.187 0 0 1-3.187 3.187",
      fill: "#F2D7AD"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M88.979 89.48s7.776 5.384 16.6 2.842",
      stroke: "#E4EBF7",
      strokeWidth: "1.101",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })));
    const noFound = NoFound;
    const ServerError = () => /* @__PURE__ */ reactExports.createElement("svg", {
      width: "254",
      height: "294"
    }, /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("path", {
      d: "M0 .335h253.49v253.49H0z"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M0 293.665h253.49V.401H0z"
    })), /* @__PURE__ */ reactExports.createElement("g", {
      fill: "none",
      fillRule: "evenodd"
    }, /* @__PURE__ */ reactExports.createElement("g", {
      transform: "translate(0 .067)"
    }, /* @__PURE__ */ reactExports.createElement("mask", {
      fill: "#fff"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M0 128.134v-2.11C0 56.608 56.273.334 125.69.334h2.11c69.416 0 125.69 56.274 125.69 125.69v2.11c0 69.417-56.274 125.69-125.69 125.69h-2.11C56.273 253.824 0 197.551 0 128.134",
      fill: "#E4EBF7",
      mask: "url(#b)"
    })), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M39.989 132.108a8.332 8.332 0 1 1-16.581-1.671 8.332 8.332 0 0 1 16.58 1.671",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M37.19 135.59l10.553 5.983M48.665 147.884l-12.734 10.861",
      stroke: "#FFF",
      strokeWidth: "2"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M40.11 160.816a5.706 5.706 0 1 1-11.354-1.145 5.706 5.706 0 0 1 11.354 1.145M57.943 144.6a5.747 5.747 0 1 1-11.436-1.152 5.747 5.747 0 0 1 11.436 1.153M99.656 27.434l30.024-.013a4.619 4.619 0 1 0-.004-9.238l-30.024.013a4.62 4.62 0 0 0 .004 9.238M111.14 45.896l30.023-.013a4.62 4.62 0 1 0-.004-9.238l-30.024.013a4.619 4.619 0 1 0 .004 9.238",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M113.53 27.421v-.002l15.89-.007a4.619 4.619 0 1 0 .005 9.238l-15.892.007v-.002a4.618 4.618 0 0 0-.004-9.234M150.167 70.091h-3.979a4.789 4.789 0 0 1-4.774-4.775 4.788 4.788 0 0 1 4.774-4.774h3.979a4.789 4.789 0 0 1 4.775 4.774 4.789 4.789 0 0 1-4.775 4.775",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M171.687 30.234c0-16.392 13.289-29.68 29.681-29.68 16.392 0 29.68 13.288 29.68 29.68 0 16.393-13.288 29.681-29.68 29.681s-29.68-13.288-29.68-29.68",
      fill: "#FF603B"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M203.557 19.435l-.676 15.035a1.514 1.514 0 0 1-3.026 0l-.675-15.035a2.19 2.19 0 1 1 4.377 0m-.264 19.378c.513.477.77 1.1.77 1.87s-.257 1.393-.77 1.907c-.55.476-1.21.733-1.943.733a2.545 2.545 0 0 1-1.87-.77c-.55-.514-.806-1.136-.806-1.87 0-.77.256-1.393.806-1.87.513-.513 1.137-.733 1.87-.733.77 0 1.43.22 1.943.733",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M119.3 133.275c4.426-.598 3.612-1.204 4.079-4.778.675-5.18-3.108-16.935-8.262-25.118-1.088-10.72-12.598-11.24-12.598-11.24s4.312 4.895 4.196 16.199c1.398 5.243.804 14.45.804 14.45s5.255 11.369 11.78 10.487",
      fill: "#FFB594"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M100.944 91.61s1.463-.583 3.211.582c8.08 1.398 10.368 6.706 11.3 11.368 1.864 1.282 1.864 2.33 1.864 3.496.365.777 1.515 3.03 1.515 3.03s-7.225 1.748-10.954 6.758c-1.399-6.41-6.936-25.235-6.936-25.235",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M94.008 90.5l1.019-5.815-9.23-11.874-5.233 5.581-2.593 9.863s8.39 5.128 16.037 2.246",
      fill: "#FFB594"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M82.931 78.216s-4.557-2.868-2.445-6.892c1.632-3.107 4.537 1.139 4.537 1.139s.524-3.662 3.139-3.662c.523-1.046 1.569-4.184 1.569-4.184s11.507 2.615 13.6 3.138c-.001 5.23-2.317 19.529-7.884 19.969-8.94.706-12.516-9.508-12.516-9.508",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M102.971 72.243c2.616-2.093 3.489-9.775 3.489-9.775s-2.492-.492-6.676-2.062c-4.708-2.092-12.867-4.771-17.575.982-9.54 4.41-2.062 19.93-2.062 19.93l2.729-3.037s-3.956-3.304-2.092-6.277c2.183-3.48 3.943 1.08 3.943 1.08s.64-2.4 3.6-3.36c.356-.714 1.04-2.69 1.44-3.872a1.08 1.08 0 0 1 1.27-.707c2.41.56 8.723 2.03 11.417 2.676.524.126.876.619.825 1.156l-.308 3.266z",
      fill: "#520038"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M101.22 76.514c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.961.491.083.805.647.702 1.26M94.26 75.074c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.96.491.082.805.646.702 1.26",
      fill: "#552950"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      stroke: "#DB836E",
      strokeWidth: "1.063",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      d: "M99.206 73.644l-.9 1.62-.3 4.38h-2.24"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M99.926 73.284s1.8-.72 2.52.54",
      stroke: "#5C2552",
      strokeWidth: "1.117",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M81.367 73.084s.48-1.12 1.12-.72c.64.4 1.28 1.44.56 2s.16 1.68.16 1.68",
      stroke: "#DB836E",
      strokeWidth: "1.117",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M92.326 71.724s1.84 1.12 4.16.96",
      stroke: "#5C2552",
      strokeWidth: "1.117",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M92.726 80.604s2.24 1.2 4.4 1.2M93.686 83.164s.96.4 1.52.32M83.687 80.044s1.786 6.547 9.262 7.954",
      stroke: "#DB836E",
      strokeWidth: "1.063",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M95.548 91.663s-1.068 2.821-8.298 2.105c-7.23-.717-10.29-5.044-10.29-5.044",
      stroke: "#E4EBF7",
      strokeWidth: "1.136",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M78.126 87.478s6.526 4.972 16.47 2.486c0 0 9.577 1.02 11.536 5.322 5.36 11.77.543 36.835 0 39.962 3.496 4.055-.466 8.483-.466 8.483-15.624-3.548-35.81-.6-35.81-.6-4.849-3.546-1.223-9.044-1.223-9.044L62.38 110.32c-2.485-15.227.833-19.803 3.549-20.743 3.03-1.049 8.04-1.282 8.04-1.282.496-.058 1.08-.076 1.37-.233 2.36-1.282 2.787-.583 2.787-.583",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M65.828 89.81s-6.875.465-7.59 8.156c-.466 8.857 3.03 10.954 3.03 10.954s6.075 22.102 16.796 22.957c8.39-2.176 4.758-6.702 4.661-11.42-.233-11.304-7.108-16.897-7.108-16.897s-4.212-13.75-9.789-13.75",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M71.716 124.225s.855 11.264 9.828 6.486c4.765-2.536 7.581-13.828 9.789-22.568 1.456-5.768 2.58-12.197 2.58-12.197l-4.973-1.709s-2.408 5.516-7.769 12.275c-4.335 5.467-9.144 11.11-9.455 17.713",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M108.463 105.191s1.747 2.724-2.331 30.535c2.376 2.216 1.053 6.012-.233 7.51",
      stroke: "#E4EBF7",
      strokeWidth: "1.085",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M123.262 131.527s-.427 2.732-11.77 1.981c-15.187-1.006-25.326-3.25-25.326-3.25l.933-5.8s.723.215 9.71-.068c11.887-.373 18.714-6.07 24.964-1.022 4.039 3.263 1.489 8.16 1.489 8.16",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M70.24 90.974s-5.593-4.739-11.054 2.68c-3.318 7.223.517 15.284 2.664 19.578-.31 3.729 2.33 4.311 2.33 4.311s.108.895 1.516 2.68c4.078-7.03 6.72-9.166 13.711-12.546-.328-.656-1.877-3.265-1.825-3.767.175-1.69-1.282-2.623-1.282-2.623s-.286-.156-1.165-2.738c-.788-2.313-2.036-5.177-4.895-7.575",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M90.232 288.027s4.855 2.308 8.313 1.155c3.188-1.063 5.12.755 8.002 1.331 2.881.577 7.769 1.243 13.207-1.424-.117-6.228-7.786-4.499-13.518-7.588-2.895-1.56-4.276-5.336-4.066-9.944H91.544s-1.573 11.89-1.312 16.47",
      fill: "#CBD1D1"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M90.207 287.833s2.745 1.437 7.639.738c3.456-.494 3.223.66 7.418 1.282 4.195.621 13.092-.194 14.334-1.126.466 1.242-.388 2.33-.388 2.33s-1.709.682-5.438.932c-2.295.154-8.098.276-10.14-.621-2.02-1.554-4.894-1.515-6.06-.234-4.427 1.075-7.184-.31-7.184-.31l-.181-2.991z",
      fill: "#2B0849"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M98.429 272.257h3.496s-.117 7.574 5.127 9.671c-5.244.7-9.672-2.602-8.623-9.671",
      fill: "#A4AABA"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M44.425 272.046s-2.208 7.774-4.702 12.899c-1.884 3.874-4.428 7.854 5.729 7.854 6.97 0 9.385-.503 7.782-6.917-1.604-6.415.279-13.836.279-13.836h-9.088z",
      fill: "#CBD1D1"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M38.066 290.277s2.198 1.225 6.954 1.225c6.376 0 8.646-1.73 8.646-1.73s.63 1.168-.649 2.27c-1.04.897-3.77 1.668-7.745 1.621-4.347-.05-6.115-.593-7.062-1.224-.864-.577-.72-1.657-.144-2.162",
      fill: "#2B0849"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M45.344 274.041s.035 1.592-.329 3.07c-.365 1.49-1.13 3.255-1.184 4.34-.061 1.206 4.755 1.657 5.403.036.65-1.622 1.357-6.737 2.006-7.602.648-.865-5.14-2.222-5.896.156",
      fill: "#A4AABA"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M89.476 277.57l13.899.095s1.349-56.643 1.925-66.909c.576-10.267 3.923-45.052 1.042-65.585l-13.037-.669-23.737.81s-.452 4.12-1.243 10.365c-.065.515-.708.874-.777 1.417-.078.608.439 1.407.332 2.044-2.455 14.627-5.797 32.736-8.256 46.837-.121.693-1.282 1.048-1.515 2.796-.042.314.22 1.584.116 1.865-7.14 19.473-12.202 52.601-15.66 67.19l15.176-.015s2.282-10.145 4.185-18.871c2.922-13.389 24.012-88.32 24.012-88.32l3.133-.954-.158 48.568s-.233 1.282.35 2.098c.583.815-.581 1.167-.408 2.331l.408 1.864s-.466 7.458-.932 12.352c-.467 4.895 1.145 40.69 1.145 40.69",
      fill: "#7BB2F9"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M64.57 218.881c1.197.099 4.195-2.097 7.225-5.127M96.024 222.534s2.881-1.152 6.34-4.034",
      stroke: "#648BD8",
      strokeWidth: "1.085",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M96.973 219.373s2.882-1.153 6.34-4.034",
      stroke: "#648BD8",
      strokeWidth: "1.032",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M63.172 222.144s2.724-.614 6.759-3.496M74.903 146.166c-.281 3.226.31 8.856-4.506 9.478M93.182 144.344s.115 14.557-1.344 15.65c-2.305 1.73-3.107 2.02-3.107 2.02M89.197 144.923s.269 13.144-1.01 25.088M83.525 170.71s6.81-1.051 9.116-1.051M46.026 270.045l-.892 4.538M46.937 263.289l-.815 4.157M62.725 202.503c-.33 1.618-.102 1.904-.449 3.438 0 0-2.756 1.903-2.29 3.923.466 2.02-.31 3.424-4.505 17.252-1.762 5.807-4.233 18.922-6.165 28.278-.03.144-.521 2.646-1.14 5.8M64.158 194.136c-.295 1.658-.6 3.31-.917 4.938M71.33 146.787l-1.244 10.877s-1.14.155-.519 2.33c.117 1.399-2.778 16.39-5.382 31.615M44.242 273.727H58.07",
      stroke: "#648BD8",
      strokeWidth: "1.085",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M106.18 142.117c-3.028-.489-18.825-2.744-36.219.2a.625.625 0 0 0-.518.644c.063 1.307.044 2.343.015 2.995a.617.617 0 0 0 .716.636c3.303-.534 17.037-2.412 35.664-.266.347.04.66-.214.692-.56.124-1.347.16-2.425.17-3.029a.616.616 0 0 0-.52-.62",
      fill: "#192064"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M96.398 145.264l.003-5.102a.843.843 0 0 0-.809-.847 114.104 114.104 0 0 0-8.141-.014.85.85 0 0 0-.82.847l-.003 5.097c0 .476.388.857.864.845 2.478-.064 5.166-.067 8.03.017a.848.848 0 0 0 .876-.843",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M95.239 144.296l.002-3.195a.667.667 0 0 0-.643-.672c-1.9-.061-3.941-.073-6.094-.01a.675.675 0 0 0-.654.672l-.002 3.192c0 .376.305.677.68.669 1.859-.042 3.874-.043 6.02.012.376.01.69-.291.691-.668",
      fill: "#192064"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M90.102 273.522h12.819M91.216 269.761c.006 3.519-.072 5.55 0 6.292M90.923 263.474c-.009 1.599-.016 2.558-.016 4.505M90.44 170.404l.932 46.38s.7 1.631-.233 2.796c-.932 1.166 2.564.7.932 2.33-1.63 1.633.933 1.166 0 3.497-.618 1.546-1.031 21.921-1.138 36.513",
      stroke: "#648BD8",
      strokeWidth: "1.085",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M73.736 98.665l2.214 4.312s2.098.816 1.865 2.68l.816 2.214M64.297 116.611c.233-.932 2.176-7.147 12.585-10.488M77.598 90.042s7.691 6.137 16.547 2.72",
      stroke: "#E4EBF7",
      strokeWidth: "1.085",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M91.974 86.954s5.476-.816 7.574-4.545c1.297-.345.72 2.212-.33 3.671-.7.971-1.01 1.554-1.01 1.554s.194.31.155.816c-.053.697-.175.653-.272 1.048-.081.335.108.657 0 1.049-.046.17-.198.5-.382.878-.12.249-.072.687-.2.948-.231.469-1.562 1.87-2.622 2.855-3.826 3.554-5.018 1.644-6.001-.408-.894-1.865-.661-5.127-.874-6.875-.35-2.914-2.622-3.03-1.923-4.429.343-.685 2.87.69 3.263 1.748.757 2.04 2.952 1.807 2.622 1.69",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M99.8 82.429c-.465.077-.35.272-.97 1.243-.622.971-4.817 2.932-6.39 3.224-2.589.48-2.278-1.56-4.254-2.855-1.69-1.107-3.562-.638-1.398 1.398.99.932.932 1.107 1.398 3.205.335 1.506-.64 3.67.7 5.593",
      stroke: "#DB836E",
      strokeWidth: ".774",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M79.543 108.673c-2.1 2.926-4.266 6.175-5.557 8.762",
      stroke: "#E59788",
      strokeWidth: ".774",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M87.72 124.768s-2.098-1.942-5.127-2.719c-3.03-.777-3.574-.155-5.516.078-1.942.233-3.885-.932-3.652.7.233 1.63 5.05 1.01 5.206 2.097.155 1.087-6.37 2.796-8.313 2.175-.777.777.466 1.864 2.02 2.175.233 1.554 2.253 1.554 2.253 1.554s.699 1.01 2.641 1.088c2.486 1.32 8.934-.7 10.954-1.554 2.02-.855-.466-5.594-.466-5.594",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M73.425 122.826s.66 1.127 3.167 1.418c2.315.27 2.563.583 2.563.583s-2.545 2.894-9.07 2.272M72.416 129.274s3.826.097 4.933-.718M74.98 130.75s1.961.136 3.36-.505M77.232 131.916s1.748.019 2.914-.505M73.328 122.321s-.595-1.032 1.262-.427c1.671.544 2.833.055 5.128.155 1.389.061 3.067-.297 3.982.15 1.606.784 3.632 2.181 3.632 2.181s10.526 1.204 19.033-1.127M78.864 108.104s-8.39 2.758-13.168 12.12",
      stroke: "#E59788",
      strokeWidth: ".774",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M109.278 112.533s3.38-3.613 7.575-4.662",
      stroke: "#E4EBF7",
      strokeWidth: "1.085",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M107.375 123.006s9.697-2.745 11.445-.88",
      stroke: "#E59788",
      strokeWidth: ".774",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M194.605 83.656l3.971-3.886M187.166 90.933l3.736-3.655M191.752 84.207l-4.462-4.56M198.453 91.057l-4.133-4.225M129.256 163.074l3.718-3.718M122.291 170.039l3.498-3.498M126.561 163.626l-4.27-4.27M132.975 170.039l-3.955-3.955",
      stroke: "#BFCDDD",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M190.156 211.779h-1.604a4.023 4.023 0 0 1-4.011-4.011V175.68a4.023 4.023 0 0 1 4.01-4.01h1.605a4.023 4.023 0 0 1 4.011 4.01v32.088a4.023 4.023 0 0 1-4.01 4.01",
      fill: "#A3B4C6"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M237.824 212.977a4.813 4.813 0 0 1-4.813 4.813h-86.636a4.813 4.813 0 0 1 0-9.626h86.636a4.813 4.813 0 0 1 4.813 4.813",
      fill: "#A3B4C6"
    }), /* @__PURE__ */ reactExports.createElement("mask", {
      fill: "#fff"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      fill: "#A3B4C6",
      mask: "url(#d)",
      d: "M154.098 190.096h70.513v-84.617h-70.513z"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M224.928 190.096H153.78a3.219 3.219 0 0 1-3.208-3.209V167.92a3.219 3.219 0 0 1 3.208-3.21h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.219 3.219 0 0 1-3.21 3.209M224.928 130.832H153.78a3.218 3.218 0 0 1-3.208-3.208v-18.968a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.218 3.218 0 0 1-3.21 3.208",
      fill: "#BFCDDD",
      mask: "url(#d)"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M159.563 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 120.546h-22.461a.802.802 0 0 1-.802-.802v-3.208c0-.443.359-.803.802-.803h22.46c.444 0 .803.36.803.803v3.208c0 .443-.36.802-.802.802",
      fill: "#FFF",
      mask: "url(#d)"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M224.928 160.464H153.78a3.218 3.218 0 0 1-3.208-3.209v-18.967a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.209v18.967a3.218 3.218 0 0 1-3.21 3.209",
      fill: "#BFCDDD",
      mask: "url(#d)"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M173.455 130.832h49.301M164.984 130.832h6.089M155.952 130.832h6.75M173.837 160.613h49.3M165.365 160.613h6.089M155.57 160.613h6.751",
      stroke: "#7C90A5",
      strokeWidth: "1.124",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      mask: "url(#d)"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M159.563 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M166.98 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M174.397 151.038a2.407 2.407 0 1 1 .001-4.814 2.407 2.407 0 0 1 0 4.814M222.539 151.038h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802M159.563 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 179.987h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802",
      fill: "#FFF",
      mask: "url(#d)"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M203.04 221.108h-27.372a2.413 2.413 0 0 1-2.406-2.407v-11.448a2.414 2.414 0 0 1 2.406-2.407h27.372a2.414 2.414 0 0 1 2.407 2.407V218.7a2.413 2.413 0 0 1-2.407 2.407",
      fill: "#BFCDDD",
      mask: "url(#d)"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M177.259 207.217v11.52M201.05 207.217v11.52",
      stroke: "#A3B4C6",
      strokeWidth: "1.124",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      mask: "url(#d)"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M162.873 267.894a9.422 9.422 0 0 1-9.422-9.422v-14.82a9.423 9.423 0 0 1 18.845 0v14.82a9.423 9.423 0 0 1-9.423 9.422",
      fill: "#5BA02E",
      mask: "url(#d)"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M171.22 267.83a9.422 9.422 0 0 1-9.422-9.423v-3.438a9.423 9.423 0 0 1 18.845 0v3.438a9.423 9.423 0 0 1-9.422 9.423",
      fill: "#92C110",
      mask: "url(#d)"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M181.31 293.666h-27.712a3.209 3.209 0 0 1-3.209-3.21V269.79a3.209 3.209 0 0 1 3.209-3.21h27.711a3.209 3.209 0 0 1 3.209 3.21v20.668a3.209 3.209 0 0 1-3.209 3.209",
      fill: "#F2D7AD",
      mask: "url(#d)"
    })));
    const serverError = ServerError;
    const Unauthorized = () => /* @__PURE__ */ reactExports.createElement("svg", {
      width: "251",
      height: "294"
    }, /* @__PURE__ */ reactExports.createElement("g", {
      fill: "none",
      fillRule: "evenodd"
    }, /* @__PURE__ */ reactExports.createElement("path", {
      d: "M0 129.023v-2.084C0 58.364 55.591 2.774 124.165 2.774h2.085c68.574 0 124.165 55.59 124.165 124.165v2.084c0 68.575-55.59 124.166-124.165 124.166h-2.085C55.591 253.189 0 197.598 0 129.023",
      fill: "#E4EBF7"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M41.417 132.92a8.231 8.231 0 1 1-16.38-1.65 8.231 8.231 0 0 1 16.38 1.65",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M38.652 136.36l10.425 5.91M49.989 148.505l-12.58 10.73",
      stroke: "#FFF",
      strokeWidth: "2"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M41.536 161.28a5.636 5.636 0 1 1-11.216-1.13 5.636 5.636 0 0 1 11.216 1.13M59.154 145.261a5.677 5.677 0 1 1-11.297-1.138 5.677 5.677 0 0 1 11.297 1.138M100.36 29.516l29.66-.013a4.562 4.562 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 0 0 .005 9.126M111.705 47.754l29.659-.013a4.563 4.563 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 1 0 .005 9.126",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M114.066 29.503V29.5l15.698-.007a4.563 4.563 0 1 0 .004 9.126l-15.698.007v-.002a4.562 4.562 0 0 0-.004-9.122M185.405 137.723c-.55 5.455-5.418 9.432-10.873 8.882-5.456-.55-9.432-5.418-8.882-10.873.55-5.455 5.418-9.432 10.873-8.882 5.455.55 9.432 5.418 8.882 10.873",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M180.17 143.772l12.572 7.129M193.841 158.42L178.67 171.36",
      stroke: "#FFF",
      strokeWidth: "2"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M185.55 171.926a6.798 6.798 0 1 1-13.528-1.363 6.798 6.798 0 0 1 13.527 1.363M204.12 155.285a6.848 6.848 0 1 1-13.627-1.375 6.848 6.848 0 0 1 13.626 1.375",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M152.988 194.074a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0zM225.931 118.217a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM217.09 153.051a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.42 0zM177.84 109.842a2.21 2.21 0 1 1-4.422 0 2.21 2.21 0 0 1 4.421 0zM196.114 94.454a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM202.844 182.523a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0z",
      stroke: "#FFF",
      strokeWidth: "2"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      stroke: "#FFF",
      strokeWidth: "2",
      d: "M215.125 155.262l-1.902 20.075-10.87 5.958M174.601 176.636l-6.322 9.761H156.98l-4.484 6.449M175.874 127.28V111.56M221.51 119.404l-12.77 7.859-15.228-7.86V96.668"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M180.68 29.32C180.68 13.128 193.806 0 210 0c16.193 0 29.32 13.127 29.32 29.32 0 16.194-13.127 29.322-29.32 29.322-16.193 0-29.32-13.128-29.32-29.321",
      fill: "#A26EF4"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M221.45 41.706l-21.563-.125a1.744 1.744 0 0 1-1.734-1.754l.071-12.23a1.744 1.744 0 0 1 1.754-1.734l21.562.125c.964.006 1.74.791 1.735 1.755l-.071 12.229a1.744 1.744 0 0 1-1.754 1.734",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M215.106 29.192c-.015 2.577-2.049 4.654-4.543 4.64-2.494-.014-4.504-2.115-4.489-4.693l.04-6.925c.016-2.577 2.05-4.654 4.543-4.64 2.494.015 4.504 2.116 4.49 4.693l-.04 6.925zm-4.53-14.074a6.877 6.877 0 0 0-6.916 6.837l-.043 7.368a6.877 6.877 0 0 0 13.754.08l.042-7.368a6.878 6.878 0 0 0-6.837-6.917zM167.566 68.367h-3.93a4.73 4.73 0 0 1-4.717-4.717 4.73 4.73 0 0 1 4.717-4.717h3.93a4.73 4.73 0 0 1 4.717 4.717 4.73 4.73 0 0 1-4.717 4.717",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M168.214 248.838a6.611 6.611 0 0 1-6.61-6.611v-66.108a6.611 6.611 0 0 1 13.221 0v66.108a6.611 6.611 0 0 1-6.61 6.61",
      fill: "#5BA02E"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M176.147 248.176a6.611 6.611 0 0 1-6.61-6.61v-33.054a6.611 6.611 0 1 1 13.221 0v33.053a6.611 6.611 0 0 1-6.61 6.611",
      fill: "#92C110"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M185.994 293.89h-27.376a3.17 3.17 0 0 1-3.17-3.17v-45.887a3.17 3.17 0 0 1 3.17-3.17h27.376a3.17 3.17 0 0 1 3.17 3.17v45.886a3.17 3.17 0 0 1-3.17 3.17",
      fill: "#F2D7AD"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M81.972 147.673s6.377-.927 17.566-1.28c11.729-.371 17.57 1.086 17.57 1.086s3.697-3.855.968-8.424c1.278-12.077 5.982-32.827.335-48.273-1.116-1.339-3.743-1.512-7.536-.62-1.337.315-7.147-.149-7.983-.1l-15.311-.347s-3.487-.17-8.035-.508c-1.512-.113-4.227-1.683-5.458-.338-.406.443-2.425 5.669-1.97 16.077l8.635 35.642s-3.141 3.61 1.219 7.085",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M75.768 73.325l-.9-6.397 11.982-6.52s7.302-.118 8.038 1.205c.737 1.324-5.616.993-5.616.993s-1.836 1.388-2.615 2.5c-1.654 2.363-.986 6.471-8.318 5.986-1.708.284-2.57 2.233-2.57 2.233",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M52.44 77.672s14.217 9.406 24.973 14.444c1.061.497-2.094 16.183-11.892 11.811-7.436-3.318-20.162-8.44-21.482-14.496-.71-3.258 2.543-7.643 8.401-11.76M141.862 80.113s-6.693 2.999-13.844 6.876c-3.894 2.11-10.137 4.704-12.33 7.988-6.224 9.314 3.536 11.22 12.947 7.503 6.71-2.651 28.999-12.127 13.227-22.367",
      fill: "#FFB594"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M76.166 66.36l3.06 3.881s-2.783 2.67-6.31 5.747c-7.103 6.195-12.803 14.296-15.995 16.44-3.966 2.662-9.754 3.314-12.177-.118-3.553-5.032.464-14.628 31.422-25.95",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M64.674 85.116s-2.34 8.413-8.912 14.447c.652.548 18.586 10.51 22.144 10.056 5.238-.669 6.417-18.968 1.145-20.531-.702-.208-5.901-1.286-8.853-2.167-.87-.26-1.611-1.71-3.545-.936l-1.98-.869zM128.362 85.826s5.318 1.956 7.325 13.734c-.546.274-17.55 12.35-21.829 7.805-6.534-6.94-.766-17.393 4.275-18.61 4.646-1.121 5.03-1.37 10.23-2.929",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M78.18 94.656s.911 7.41-4.914 13.078",
      stroke: "#E4EBF7",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M87.397 94.68s3.124 2.572 10.263 2.572c7.14 0 9.074-3.437 9.074-3.437",
      stroke: "#E4EBF7",
      strokeWidth: ".932",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M117.184 68.639l-6.781-6.177s-5.355-4.314-9.223-.893c-3.867 3.422 4.463 2.083 5.653 4.165 1.19 2.082.848 1.143-2.083.446-5.603-1.331-2.082.893 2.975 5.355 2.091 1.845 6.992.955 6.992.955l2.467-3.851z",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M105.282 91.315l-.297-10.937-15.918-.027-.53 10.45c-.026.403.17.788.515.999 2.049 1.251 9.387 5.093 15.799.424.287-.21.443-.554.431-.91",
      fill: "#FFB594"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M107.573 74.24c.817-1.147.982-9.118 1.015-11.928a1.046 1.046 0 0 0-.965-1.055l-4.62-.365c-7.71-1.044-17.071.624-18.253 6.346-5.482 5.813-.421 13.244-.421 13.244s1.963 3.566 4.305 6.791c.756 1.041.398-3.731 3.04-5.929 5.524-4.594 15.899-7.103 15.899-7.103",
      fill: "#5C2552"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M88.426 83.206s2.685 6.202 11.602 6.522c7.82.28 8.973-7.008 7.434-17.505l-.909-5.483c-6.118-2.897-15.478.54-15.478.54s-.576 2.044-.19 5.504c-2.276 2.066-1.824 5.618-1.824 5.618s-.905-1.922-1.98-2.321c-.86-.32-1.897.089-2.322 1.98-1.04 4.632 3.667 5.145 3.667 5.145",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      stroke: "#DB836E",
      strokeWidth: "1.145",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      d: "M100.843 77.099l1.701-.928-1.015-4.324.674-1.406"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M105.546 74.092c-.022.713-.452 1.279-.96 1.263-.51-.016-.904-.607-.882-1.32.021-.713.452-1.278.96-1.263.51.016.904.607.882 1.32M97.592 74.349c-.022.713-.452 1.278-.961 1.263-.509-.016-.904-.607-.882-1.32.022-.713.452-1.279.961-1.263.51.016.904.606.882 1.32",
      fill: "#552950"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M91.132 86.786s5.269 4.957 12.679 2.327",
      stroke: "#DB836E",
      strokeWidth: "1.145",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M99.776 81.903s-3.592.232-1.44-2.79c1.59-1.496 4.897-.46 4.897-.46s1.156 3.906-3.457 3.25",
      fill: "#DB836E"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M102.88 70.6s2.483.84 3.402.715M93.883 71.975s2.492-1.144 4.778-1.073",
      stroke: "#5C2552",
      strokeWidth: "1.526",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M86.32 77.374s.961.879 1.458 2.106c-.377.48-1.033 1.152-.236 1.809M99.337 83.719s1.911.151 2.509-.254",
      stroke: "#DB836E",
      strokeWidth: "1.145",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M87.782 115.821l15.73-3.012M100.165 115.821l10.04-2.008",
      stroke: "#E4EBF7",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M66.508 86.763s-1.598 8.83-6.697 14.078",
      stroke: "#E4EBF7",
      strokeWidth: "1.114",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M128.31 87.934s3.013 4.121 4.06 11.785",
      stroke: "#E4EBF7",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M64.09 84.816s-6.03 9.912-13.607 9.903",
      stroke: "#DB836E",
      strokeWidth: ".795",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M112.366 65.909l-.142 5.32s5.993 4.472 11.945 9.202c4.482 3.562 8.888 7.455 10.985 8.662 4.804 2.766 8.9 3.355 11.076 1.808 4.071-2.894 4.373-9.878-8.136-15.263-4.271-1.838-16.144-6.36-25.728-9.73",
      fill: "#FFC6A0"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M130.532 85.488s4.588 5.757 11.619 6.214",
      stroke: "#DB836E",
      strokeWidth: ".75",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M121.708 105.73s-.393 8.564-1.34 13.612",
      stroke: "#E4EBF7",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M115.784 161.512s-3.57-1.488-2.678-7.14",
      stroke: "#648BD8",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M101.52 290.246s4.326 2.057 7.408 1.03c2.842-.948 4.564.673 7.132 1.186 2.57.514 6.925 1.108 11.772-1.269-.104-5.551-6.939-4.01-12.048-6.763-2.582-1.39-3.812-4.757-3.625-8.863h-9.471s-1.402 10.596-1.169 14.68",
      fill: "#CBD1D1"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M101.496 290.073s2.447 1.281 6.809.658c3.081-.44 3.74.485 7.479 1.039 3.739.554 10.802-.07 11.91-.9.415 1.108-.347 2.077-.347 2.077s-1.523.608-4.847.831c-2.045.137-5.843.293-7.663-.507-1.8-1.385-5.286-1.917-5.77-.243-3.947.958-7.41-.288-7.41-.288l-.16-2.667z",
      fill: "#2B0849"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M108.824 276.19h3.116s-.103 6.751 4.57 8.62c-4.673.624-8.62-2.32-7.686-8.62",
      fill: "#A4AABA"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M57.65 272.52s-2.122 7.47-4.518 12.396c-1.811 3.724-4.255 7.548 5.505 7.548 6.698 0 9.02-.483 7.479-6.648-1.541-6.164.268-13.296.268-13.296H57.65z",
      fill: "#CBD1D1"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M51.54 290.04s2.111 1.178 6.682 1.178c6.128 0 8.31-1.662 8.31-1.662s.605 1.122-.624 2.18c-1 .862-3.624 1.603-7.444 1.559-4.177-.049-5.876-.57-6.786-1.177-.831-.554-.692-1.593-.138-2.078",
      fill: "#2B0849"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M58.533 274.438s.034 1.529-.315 2.95c-.352 1.431-1.087 3.127-1.139 4.17-.058 1.16 4.57 1.592 5.194.035.623-1.559 1.303-6.475 1.927-7.306.622-.831-4.94-2.135-5.667.15",
      fill: "#A4AABA"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M100.885 277.015l13.306.092s1.291-54.228 1.843-64.056c.552-9.828 3.756-43.13.997-62.788l-12.48-.64-22.725.776s-.433 3.944-1.19 9.921c-.062.493-.677.838-.744 1.358-.075.582.42 1.347.318 1.956-2.35 14.003-6.343 32.926-8.697 46.425-.116.663-1.227 1.004-1.45 2.677-.04.3.21 1.516.112 1.785-6.836 18.643-10.89 47.584-14.2 61.551l14.528-.014s2.185-8.524 4.008-16.878c2.796-12.817 22.987-84.553 22.987-84.553l3-.517 1.037 46.1s-.223 1.228.334 2.008c.558.782-.556 1.117-.39 2.233l.39 1.784s-.446 7.14-.892 11.826c-.446 4.685-.092 38.954-.092 38.954",
      fill: "#7BB2F9"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M77.438 220.434c1.146.094 4.016-2.008 6.916-4.91M107.55 223.931s2.758-1.103 6.069-3.862",
      stroke: "#648BD8",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M108.459 220.905s2.759-1.104 6.07-3.863",
      stroke: "#648BD8",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M76.099 223.557s2.608-.587 6.47-3.346M87.33 150.82c-.27 3.088.297 8.478-4.315 9.073M104.829 149.075s.11 13.936-1.286 14.983c-2.207 1.655-2.975 1.934-2.975 1.934M101.014 149.63s.035 12.81-1.19 24.245M94.93 174.965s7.174-1.655 9.38-1.655M75.671 204.754c-.316 1.55-.64 3.067-.973 4.535 0 0-1.45 1.822-1.003 3.756.446 1.934-.943 2.034-4.96 15.273-1.686 5.559-4.464 18.49-6.313 27.447-.078.38-4.018 18.06-4.093 18.423M77.043 196.743a313.269 313.269 0 0 1-.877 4.729M83.908 151.414l-1.19 10.413s-1.091.148-.496 2.23c.111 1.34-2.66 15.692-5.153 30.267M57.58 272.94h13.238",
      stroke: "#648BD8",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M117.377 147.423s-16.955-3.087-35.7.199c.157 2.501-.002 4.128-.002 4.128s14.607-2.802 35.476-.31c.251-2.342.226-4.017.226-4.017",
      fill: "#192064"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M107.511 150.353l.004-4.885a.807.807 0 0 0-.774-.81c-2.428-.092-5.04-.108-7.795-.014a.814.814 0 0 0-.784.81l-.003 4.88c0 .456.371.82.827.808a140.76 140.76 0 0 1 7.688.017.81.81 0 0 0 .837-.806",
      fill: "#FFF"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M106.402 149.426l.002-3.06a.64.64 0 0 0-.616-.643 94.135 94.135 0 0 0-5.834-.009.647.647 0 0 0-.626.643l-.001 3.056c0 .36.291.648.651.64 1.78-.04 3.708-.041 5.762.012.36.009.662-.279.662-.64",
      fill: "#192064"
    }), /* @__PURE__ */ reactExports.createElement("path", {
      d: "M101.485 273.933h12.272M102.652 269.075c.006 3.368.04 5.759.11 6.47M102.667 263.125c-.009 1.53-.015 2.98-.016 4.313M102.204 174.024l.893 44.402s.669 1.561-.224 2.677c-.892 1.116 2.455.67.893 2.231-1.562 1.562.893 1.116 0 3.347-.592 1.48-.988 20.987-1.09 34.956",
      stroke: "#648BD8",
      strokeWidth: "1.051",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })));
    const unauthorized = Unauthorized;
    const genBaseStyle$3 = (token2) => {
      const {
        componentCls,
        lineHeightHeading3,
        iconCls,
        padding,
        paddingXL,
        paddingXS,
        paddingLG,
        marginXS,
        lineHeight
      } = token2;
      return {
        // Result
        [componentCls]: {
          padding: `${paddingLG * 2}px ${paddingXL}px`,
          // RTL
          "&-rtl": {
            direction: "rtl"
          }
        },
        // Exception Status image
        [`${componentCls} ${componentCls}-image`]: {
          width: token2.imageWidth,
          height: token2.imageHeight,
          margin: "auto"
        },
        [`${componentCls} ${componentCls}-icon`]: {
          marginBottom: paddingLG,
          textAlign: "center",
          [`& > ${iconCls}`]: {
            fontSize: token2.resultIconFontSize
          }
        },
        [`${componentCls} ${componentCls}-title`]: {
          color: token2.colorTextHeading,
          fontSize: token2.resultTitleFontSize,
          lineHeight: lineHeightHeading3,
          marginBlock: marginXS,
          textAlign: "center"
        },
        [`${componentCls} ${componentCls}-subtitle`]: {
          color: token2.colorTextDescription,
          fontSize: token2.resultSubtitleFontSize,
          lineHeight,
          textAlign: "center"
        },
        [`${componentCls} ${componentCls}-content`]: {
          marginTop: paddingLG,
          padding: `${paddingLG}px ${padding * 2.5}px`,
          backgroundColor: token2.colorFillAlter
        },
        [`${componentCls} ${componentCls}-extra`]: {
          margin: token2.resultExtraMargin,
          textAlign: "center",
          "& > *": {
            marginInlineEnd: paddingXS,
            "&:last-child": {
              marginInlineEnd: 0
            }
          }
        }
      };
    };
    const genStatusIconStyle = (token2) => {
      const {
        componentCls,
        iconCls
      } = token2;
      return {
        [`${componentCls}-success ${componentCls}-icon > ${iconCls}`]: {
          color: token2.resultSuccessIconColor
        },
        [`${componentCls}-error ${componentCls}-icon > ${iconCls}`]: {
          color: token2.resultErrorIconColor
        },
        [`${componentCls}-info ${componentCls}-icon > ${iconCls}`]: {
          color: token2.resultInfoIconColor
        },
        [`${componentCls}-warning ${componentCls}-icon > ${iconCls}`]: {
          color: token2.resultWarningIconColor
        }
      };
    };
    const genResultStyle = (token2) => [genBaseStyle$3(token2), genStatusIconStyle(token2)];
    const getStyle = (token2) => genResultStyle(token2);
    const useStyle$8 = genComponentStyleHook("Result", (token2) => {
      const {
        paddingLG,
        fontSizeHeading3
      } = token2;
      const resultSubtitleFontSize = token2.fontSize;
      const resultExtraMargin = `${paddingLG}px 0 0 0`;
      const resultInfoIconColor = token2.colorInfo;
      const resultErrorIconColor = token2.colorError;
      const resultSuccessIconColor = token2.colorSuccess;
      const resultWarningIconColor = token2.colorWarning;
      const resultToken = merge$4(token2, {
        resultTitleFontSize: fontSizeHeading3,
        resultSubtitleFontSize,
        resultIconFontSize: fontSizeHeading3 * 3,
        resultExtraMargin,
        resultInfoIconColor,
        resultErrorIconColor,
        resultSuccessIconColor,
        resultWarningIconColor
      });
      return [getStyle(resultToken)];
    }, {
      imageWidth: 250,
      imageHeight: 295
    });
    const IconMap = {
      success: CheckCircleFilled$1,
      error: CloseCircleFilled$1,
      info: ExclamationCircleFilled$1,
      warning: WarningFilled$1
    };
    const ExceptionMap = {
      "404": noFound,
      "500": serverError,
      "403": unauthorized
    };
    const ExceptionStatus = Object.keys(ExceptionMap);
    const Icon$5 = (_ref) => {
      let {
        prefixCls,
        icon,
        status
      } = _ref;
      const className = classNames(`${prefixCls}-icon`);
      if (ExceptionStatus.includes(`${status}`)) {
        const SVGComponent = ExceptionMap[status];
        return /* @__PURE__ */ reactExports.createElement("div", {
          className: `${className} ${prefixCls}-image`
        }, /* @__PURE__ */ reactExports.createElement(SVGComponent, null));
      }
      const iconNode = /* @__PURE__ */ reactExports.createElement(IconMap[status]);
      if (icon === null || icon === false) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className
      }, icon || iconNode);
    };
    const Extra = (_ref2) => {
      let {
        prefixCls,
        extra
      } = _ref2;
      if (!extra) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-extra`
      }, extra);
    };
    const Result = (_ref3) => {
      let {
        prefixCls: customizePrefixCls,
        className: customizeClassName,
        rootClassName,
        subTitle,
        title,
        style: style2,
        children,
        status = "info",
        icon,
        extra
      } = _ref3;
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("result", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$8(prefixCls);
      const className = classNames(prefixCls, `${prefixCls}-${status}`, customizeClassName, rootClassName, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", {
        className,
        style: style2
      }, /* @__PURE__ */ reactExports.createElement(Icon$5, {
        prefixCls,
        status,
        icon
      }), /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-title`
      }, title), subTitle && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-subtitle`
      }, subTitle), /* @__PURE__ */ reactExports.createElement(Extra, {
        prefixCls,
        extra
      }), children && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-content`
      }, children)));
    };
    Result.PRESENTED_IMAGE_403 = ExceptionMap["403"];
    Result.PRESENTED_IMAGE_404 = ExceptionMap["404"];
    Result.PRESENTED_IMAGE_500 = ExceptionMap["500"];
    const ln = Result;
    var _excluded$c = ["prefixCls", "className", "checked", "defaultChecked", "disabled", "loadingIcon", "checkedChildren", "unCheckedChildren", "onClick", "onChange", "onKeyDown"];
    var Switch$2 = /* @__PURE__ */ reactExports.forwardRef(function(_ref, ref) {
      var _classNames;
      var _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-switch" : _ref$prefixCls, className = _ref.className, checked = _ref.checked, defaultChecked = _ref.defaultChecked, disabled = _ref.disabled, loadingIcon = _ref.loadingIcon, checkedChildren = _ref.checkedChildren, unCheckedChildren = _ref.unCheckedChildren, onClick = _ref.onClick, onChange = _ref.onChange, onKeyDown2 = _ref.onKeyDown, restProps = _objectWithoutProperties$1(_ref, _excluded$c);
      var _useMergedState = useMergedState(false, {
        value: checked,
        defaultValue: defaultChecked
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), innerChecked = _useMergedState2[0], setInnerChecked = _useMergedState2[1];
      function triggerChange(newChecked, event) {
        var mergedChecked = innerChecked;
        if (!disabled) {
          mergedChecked = newChecked;
          setInnerChecked(mergedChecked);
          onChange === null || onChange === void 0 ? void 0 : onChange(mergedChecked, event);
        }
        return mergedChecked;
      }
      function onInternalKeyDown(e2) {
        if (e2.which === KeyCode.LEFT) {
          triggerChange(false, e2);
        } else if (e2.which === KeyCode.RIGHT) {
          triggerChange(true, e2);
        }
        onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(e2);
      }
      function onInternalClick(e2) {
        var ret = triggerChange(!innerChecked, e2);
        onClick === null || onClick === void 0 ? void 0 : onClick(ret, e2);
      }
      var switchClassName = classNames(prefixCls, className, (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-checked"), innerChecked), _defineProperty$7(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
      return /* @__PURE__ */ reactExports.createElement("button", _extends$2({}, restProps, {
        type: "button",
        role: "switch",
        "aria-checked": innerChecked,
        disabled,
        className: switchClassName,
        ref,
        onKeyDown: onInternalKeyDown,
        onClick: onInternalClick
      }), loadingIcon, /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-inner")
      }, /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-inner-checked")
      }, checkedChildren), /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-inner-unchecked")
      }, unCheckedChildren)));
    });
    Switch$2.displayName = "Switch";
    const genSwitchSmallStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const switchInnerCls = `${componentCls}-inner`;
      return {
        [componentCls]: {
          [`&${componentCls}-small`]: {
            minWidth: token2.switchMinWidthSM,
            height: token2.switchHeightSM,
            lineHeight: `${token2.switchHeightSM}px`,
            [`${componentCls}-inner`]: {
              paddingInlineStart: token2.switchInnerMarginMaxSM,
              paddingInlineEnd: token2.switchInnerMarginMinSM,
              [`${switchInnerCls}-checked`]: {
                marginInlineStart: `calc(-100% + ${token2.switchPinSizeSM + token2.switchPadding * 2}px - ${token2.switchInnerMarginMaxSM * 2}px)`,
                marginInlineEnd: `calc(100% - ${token2.switchPinSizeSM + token2.switchPadding * 2}px + ${token2.switchInnerMarginMaxSM * 2}px)`
              },
              [`${switchInnerCls}-unchecked`]: {
                marginTop: -token2.switchHeightSM,
                marginInlineStart: 0,
                marginInlineEnd: 0
              }
            },
            [`${componentCls}-handle`]: {
              width: token2.switchPinSizeSM,
              height: token2.switchPinSizeSM
            },
            [`${componentCls}-loading-icon`]: {
              top: (token2.switchPinSizeSM - token2.switchLoadingIconSize) / 2,
              fontSize: token2.switchLoadingIconSize
            },
            [`&${componentCls}-checked`]: {
              [`${componentCls}-inner`]: {
                paddingInlineStart: token2.switchInnerMarginMinSM,
                paddingInlineEnd: token2.switchInnerMarginMaxSM,
                [`${switchInnerCls}-checked`]: {
                  marginInlineStart: 0,
                  marginInlineEnd: 0
                },
                [`${switchInnerCls}-unchecked`]: {
                  marginInlineStart: `calc(100% - ${token2.switchPinSizeSM + token2.switchPadding * 2}px + ${token2.switchInnerMarginMaxSM * 2}px)`,
                  marginInlineEnd: `calc(-100% + ${token2.switchPinSizeSM + token2.switchPadding * 2}px - ${token2.switchInnerMarginMaxSM * 2}px)`
                }
              },
              [`${componentCls}-handle`]: {
                insetInlineStart: `calc(100% - ${token2.switchPinSizeSM + token2.switchPadding}px)`
              }
            },
            [`&:not(${componentCls}-disabled):active`]: {
              [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
                [`${switchInnerCls}-unchecked`]: {
                  marginInlineStart: token2.marginXXS / 2,
                  marginInlineEnd: -token2.marginXXS / 2
                }
              },
              [`&${componentCls}-checked ${switchInnerCls}`]: {
                [`${switchInnerCls}-checked`]: {
                  marginInlineStart: -token2.marginXXS / 2,
                  marginInlineEnd: token2.marginXXS / 2
                }
              }
            }
          }
        }
      };
    };
    const genSwitchLoadingStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          [`${componentCls}-loading-icon${token2.iconCls}`]: {
            position: "relative",
            top: (token2.switchPinSize - token2.fontSize) / 2,
            color: token2.switchLoadingIconColor,
            verticalAlign: "top"
          },
          [`&${componentCls}-checked ${componentCls}-loading-icon`]: {
            color: token2.switchColor
          }
        }
      };
    };
    const genSwitchHandleStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const switchHandleCls = `${componentCls}-handle`;
      return {
        [componentCls]: {
          [switchHandleCls]: {
            position: "absolute",
            top: token2.switchPadding,
            insetInlineStart: token2.switchPadding,
            width: token2.switchPinSize,
            height: token2.switchPinSize,
            transition: `all ${token2.switchDuration} ease-in-out`,
            "&::before": {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: 0,
              insetInlineStart: 0,
              backgroundColor: token2.colorWhite,
              borderRadius: token2.switchPinSize / 2,
              boxShadow: token2.switchHandleShadow,
              transition: `all ${token2.switchDuration} ease-in-out`,
              content: '""'
            }
          },
          [`&${componentCls}-checked ${switchHandleCls}`]: {
            insetInlineStart: `calc(100% - ${token2.switchPinSize + token2.switchPadding}px)`
          },
          [`&:not(${componentCls}-disabled):active`]: {
            [`${switchHandleCls}::before`]: {
              insetInlineEnd: token2.switchHandleActiveInset,
              insetInlineStart: 0
            },
            [`&${componentCls}-checked ${switchHandleCls}::before`]: {
              insetInlineEnd: 0,
              insetInlineStart: token2.switchHandleActiveInset
            }
          }
        }
      };
    };
    const genSwitchInnerStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const switchInnerCls = `${componentCls}-inner`;
      return {
        [componentCls]: {
          [switchInnerCls]: {
            display: "block",
            overflow: "hidden",
            borderRadius: 100,
            height: "100%",
            paddingInlineStart: token2.switchInnerMarginMax,
            paddingInlineEnd: token2.switchInnerMarginMin,
            transition: `padding-inline-start ${token2.switchDuration} ease-in-out, padding-inline-end ${token2.switchDuration} ease-in-out`,
            [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
              display: "block",
              color: token2.colorTextLightSolid,
              fontSize: token2.fontSizeSM,
              transition: `margin-inline-start ${token2.switchDuration} ease-in-out, margin-inline-end ${token2.switchDuration} ease-in-out`,
              pointerEvents: "none"
            },
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: `calc(-100% + ${token2.switchPinSize + token2.switchPadding * 2}px - ${token2.switchInnerMarginMax * 2}px)`,
              marginInlineEnd: `calc(100% - ${token2.switchPinSize + token2.switchPadding * 2}px + ${token2.switchInnerMarginMax * 2}px)`
            },
            [`${switchInnerCls}-unchecked`]: {
              marginTop: -token2.switchHeight,
              marginInlineStart: 0,
              marginInlineEnd: 0
            }
          },
          [`&${componentCls}-checked ${switchInnerCls}`]: {
            paddingInlineStart: token2.switchInnerMarginMin,
            paddingInlineEnd: token2.switchInnerMarginMax,
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: 0,
              marginInlineEnd: 0
            },
            [`${switchInnerCls}-unchecked`]: {
              marginInlineStart: `calc(100% - ${token2.switchPinSize + token2.switchPadding * 2}px + ${token2.switchInnerMarginMax * 2}px)`,
              marginInlineEnd: `calc(-100% + ${token2.switchPinSize + token2.switchPadding * 2}px - ${token2.switchInnerMarginMax * 2}px)`
            }
          },
          [`&:not(${componentCls}-disabled):active`]: {
            [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
              [`${switchInnerCls}-unchecked`]: {
                marginInlineStart: token2.switchPadding * 2,
                marginInlineEnd: -token2.switchPadding * 2
              }
            },
            [`&${componentCls}-checked ${switchInnerCls}`]: {
              [`${switchInnerCls}-checked`]: {
                marginInlineStart: -token2.switchPadding * 2,
                marginInlineEnd: token2.switchPadding * 2
              }
            }
          }
        }
      };
    };
    const genSwitchStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent$1(token2)), {
          position: "relative",
          display: "inline-block",
          boxSizing: "border-box",
          minWidth: token2.switchMinWidth,
          height: token2.switchHeight,
          lineHeight: `${token2.switchHeight}px`,
          verticalAlign: "middle",
          background: token2.colorTextQuaternary,
          border: "0",
          borderRadius: 100,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid}`,
          userSelect: "none",
          [`&:hover:not(${componentCls}-disabled)`]: {
            background: token2.colorTextTertiary
          }
        }), genFocusStyle(token2)), {
          [`&${componentCls}-checked`]: {
            background: token2.switchColor,
            [`&:hover:not(${componentCls}-disabled)`]: {
              background: token2.colorPrimaryHover
            }
          },
          [`&${componentCls}-loading, &${componentCls}-disabled`]: {
            cursor: "not-allowed",
            opacity: token2.switchDisabledOpacity,
            "*": {
              boxShadow: "none",
              cursor: "not-allowed"
            }
          },
          // rtl style
          [`&${componentCls}-rtl`]: {
            direction: "rtl"
          }
        })
      };
    };
    const useStyle$7 = genComponentStyleHook("Switch", (token2) => {
      const switchHeight = token2.fontSize * token2.lineHeight;
      const switchHeightSM = token2.controlHeight / 2;
      const switchPadding = 2;
      const switchPinSize = switchHeight - switchPadding * 2;
      const switchPinSizeSM = switchHeightSM - switchPadding * 2;
      const switchToken = merge$4(token2, {
        switchMinWidth: switchPinSize * 2 + switchPadding * 4,
        switchHeight,
        switchDuration: token2.motionDurationMid,
        switchColor: token2.colorPrimary,
        switchDisabledOpacity: token2.opacityLoading,
        switchInnerMarginMin: switchPinSize / 2,
        switchInnerMarginMax: switchPinSize + switchPadding + switchPadding * 2,
        switchPadding,
        switchPinSize,
        switchBg: token2.colorBgContainer,
        switchMinWidthSM: switchPinSizeSM * 2 + switchPadding * 2,
        switchHeightSM,
        switchInnerMarginMinSM: switchPinSizeSM / 2,
        switchInnerMarginMaxSM: switchPinSizeSM + switchPadding + switchPadding * 2,
        switchPinSizeSM,
        switchHandleShadow: `0 2px 4px 0 ${new TinyColor("#00230b").setAlpha(0.2).toRgbString()}`,
        switchLoadingIconSize: token2.fontSizeIcon * 0.75,
        switchLoadingIconColor: `rgba(0, 0, 0, ${token2.opacityLoading})`,
        switchHandleActiveInset: "-30%"
      });
      return [
        genSwitchStyle(switchToken),
        // inner style
        genSwitchInnerStyle(switchToken),
        // handle style
        genSwitchHandleStyle(switchToken),
        // loading style
        genSwitchLoadingStyle(switchToken),
        // small style
        genSwitchSmallStyle(switchToken)
      ];
    });
    var __rest$c = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Switch = /* @__PURE__ */ reactExports.forwardRef((_a, ref) => {
      var {
        prefixCls: customizePrefixCls,
        size: customizeSize,
        disabled: customDisabled,
        loading,
        className,
        rootClassName
      } = _a, props = __rest$c(_a, ["prefixCls", "size", "disabled", "loading", "className", "rootClassName"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const size = reactExports.useContext(SizeContext$2);
      const disabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = (customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled) || loading;
      const prefixCls = getPrefixCls("switch", customizePrefixCls);
      const loadingIcon = /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-handle`
      }, loading && /* @__PURE__ */ reactExports.createElement(LoadingOutlined$1, {
        className: `${prefixCls}-loading-icon`
      }));
      const [wrapSSR, hashId] = useStyle$7(prefixCls);
      const classes = classNames({
        [`${prefixCls}-small`]: (customizeSize || size) === "small",
        [`${prefixCls}-loading`]: loading,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(Wave$1, null, /* @__PURE__ */ reactExports.createElement(Switch$2, Object.assign({}, props, {
        prefixCls,
        className: classes,
        disabled: mergedDisabled,
        ref,
        loadingIcon
      }))));
    });
    Switch.__ANT_SWITCH = true;
    const Switch$1 = Switch;
    var EXPAND_COLUMN = {};
    function createContext(defaultValue) {
      var Context2 = /* @__PURE__ */ reactExports.createContext(void 0);
      var Provider = function Provider2(_ref) {
        var value = _ref.value, children = _ref.children;
        var valueRef = reactExports.useRef(value);
        valueRef.current = value;
        var _React$useState = reactExports.useState(function() {
          return {
            getValue: function getValue2() {
              return valueRef.current;
            },
            listeners: /* @__PURE__ */ new Set()
          };
        }), _React$useState2 = _slicedToArray(_React$useState, 1), context = _React$useState2[0];
        useLayoutEffect$1(function() {
          reactDomExports.unstable_batchedUpdates(function() {
            context.listeners.forEach(function(listener) {
              listener(value);
            });
          });
        }, [value]);
        return /* @__PURE__ */ reactExports.createElement(Context2.Provider, {
          value: context
        }, children);
      };
      return {
        Context: Context2,
        Provider,
        defaultValue
      };
    }
    function useContext(holder, selector) {
      var eventSelector = useEvent(typeof selector === "function" ? selector : function(ctx) {
        if (selector === void 0) {
          return ctx;
        }
        if (!Array.isArray(selector)) {
          return ctx[selector];
        }
        var obj = {};
        selector.forEach(function(key) {
          obj[key] = ctx[key];
        });
        return obj;
      });
      var context = reactExports.useContext(holder === null || holder === void 0 ? void 0 : holder.Context);
      var _ref2 = context || {}, listeners = _ref2.listeners, getValue2 = _ref2.getValue;
      var valueRef = reactExports.useRef();
      valueRef.current = eventSelector(context ? getValue2() : holder === null || holder === void 0 ? void 0 : holder.defaultValue);
      var _React$useState3 = reactExports.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), forceUpdate = _React$useState4[1];
      useLayoutEffect$1(function() {
        if (!context) {
          return;
        }
        function trigger(nextValue) {
          var nextSelectorValue = eventSelector(nextValue);
          if (!isEqual$1(valueRef.current, nextSelectorValue, true)) {
            forceUpdate({});
          }
        }
        listeners.add(trigger);
        return function() {
          listeners.delete(trigger);
        };
      }, [context]);
      return valueRef.current;
    }
    var ImmutableContext = /* @__PURE__ */ reactExports.createContext(0);
    function useImmutableMark() {
      return reactExports.useContext(ImmutableContext);
    }
    function makeImmutable(Component, shouldTriggerRender) {
      var refAble = supportRef(Component);
      var ImmutableComponent = function ImmutableComponent2(props, ref) {
        var refProps = refAble ? {
          ref
        } : {};
        var renderTimesRef = reactExports.useRef(0);
        var prevProps = reactExports.useRef(props);
        if (
          // Always trigger re-render if not provide `notTriggerRender`
          !shouldTriggerRender || shouldTriggerRender(prevProps.current, props)
        ) {
          renderTimesRef.current += 1;
        }
        prevProps.current = props;
        return /* @__PURE__ */ reactExports.createElement(ImmutableContext.Provider, {
          value: renderTimesRef.current
        }, /* @__PURE__ */ reactExports.createElement(Component, _extends$2({}, props, refProps)));
      };
      return refAble ? /* @__PURE__ */ reactExports.forwardRef(ImmutableComponent) : ImmutableComponent;
    }
    function responseImmutable(Component, propsAreEqual) {
      var refAble = supportRef(Component);
      var ImmutableComponent = function ImmutableComponent2(props, ref) {
        var refProps = refAble ? {
          ref
        } : {};
        useImmutableMark();
        return /* @__PURE__ */ reactExports.createElement(Component, _extends$2({}, props, refProps));
      };
      return refAble ? /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(ImmutableComponent), propsAreEqual) : /* @__PURE__ */ reactExports.memo(ImmutableComponent, propsAreEqual);
    }
    var TableContext = createContext();
    function useRenderTimes(props, debug) {
      var timesRef = reactExports.useRef(0);
      timesRef.current += 1;
      var propsRef = reactExports.useRef(props);
      var keys2 = [];
      Object.keys(props || {}).map(function(key) {
        var _propsRef$current;
        if ((props === null || props === void 0 ? void 0 : props[key]) !== ((_propsRef$current = propsRef.current) === null || _propsRef$current === void 0 ? void 0 : _propsRef$current[key])) {
          keys2.push(key);
        }
      });
      propsRef.current = props;
      var keysRef = reactExports.useRef([]);
      if (keys2.length) {
        keysRef.current = keys2;
      }
      reactExports.useDebugValue(timesRef.current);
      reactExports.useDebugValue(keysRef.current.join(", "));
      if (debug) {
        console.log("".concat(debug, ":"), timesRef.current, keysRef.current);
      }
      return timesRef.current;
    }
    var RenderBlock = /* @__PURE__ */ reactExports.memo(function() {
      var times = useRenderTimes();
      return /* @__PURE__ */ reactExports.createElement("h1", null, "Render Times: ", times);
    });
    RenderBlock.displayName = "RenderBlock";
    var PerfContext = /* @__PURE__ */ reactExports.createContext({
      renderWithProps: false
    });
    var INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
    function toArray(arr) {
      if (arr === void 0 || arr === null) {
        return [];
      }
      return Array.isArray(arr) ? arr : [arr];
    }
    function getColumnsKey(columns) {
      var columnKeys = [];
      var keys2 = {};
      columns.forEach(function(column2) {
        var _ref = column2 || {}, key = _ref.key, dataIndex = _ref.dataIndex;
        var mergedKey = key || toArray(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
        while (keys2[mergedKey]) {
          mergedKey = "".concat(mergedKey, "_next");
        }
        keys2[mergedKey] = true;
        columnKeys.push(mergedKey);
      });
      return columnKeys;
    }
    function validateValue(val) {
      return val !== null && val !== void 0;
    }
    function isRenderCell(data2) {
      return data2 && _typeof$4(data2) === "object" && !Array.isArray(data2) && !/* @__PURE__ */ reactExports.isValidElement(data2);
    }
    function useCellRender(record, dataIndex, renderIndex, children, render2, shouldCellUpdate) {
      var perfRecord = reactExports.useContext(PerfContext);
      var mark2 = useImmutableMark();
      var retData = useMemo(function() {
        if (validateValue(children)) {
          return [children];
        }
        var path2 = dataIndex === null || dataIndex === void 0 || dataIndex === "" ? [] : Array.isArray(dataIndex) ? dataIndex : [dataIndex];
        var value = get$2(record, path2);
        var returnChildNode = value;
        var returnCellProps = void 0;
        if (render2) {
          var renderData = render2(value, record, renderIndex);
          if (isRenderCell(renderData)) {
            returnChildNode = renderData.children;
            returnCellProps = renderData.props;
            perfRecord.renderWithProps = true;
          } else {
            returnChildNode = renderData;
          }
        }
        return [returnChildNode, returnCellProps];
      }, [
        // Force update deps
        mark2,
        // Normal deps
        record,
        children,
        dataIndex,
        render2,
        renderIndex
      ], function(prev2, next2) {
        if (shouldCellUpdate) {
          var _prev = _slicedToArray(prev2, 2), prevRecord = _prev[1];
          var _next = _slicedToArray(next2, 2), nextRecord = _next[1];
          return shouldCellUpdate(nextRecord, prevRecord);
        }
        if (perfRecord.renderWithProps) {
          return true;
        }
        return !isEqual$1(prev2, next2, true);
      });
      return retData;
    }
    function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
      var cellEndRow = cellStartRow + cellRowSpan - 1;
      return cellStartRow <= endRow && cellEndRow >= startRow;
    }
    function useHoverState(rowIndex, rowSpan) {
      return useContext(TableContext, function(ctx) {
        var hovering = inHoverRange(rowIndex, rowSpan || 1, ctx.hoverStartRow, ctx.hoverEndRow);
        return [hovering, ctx.onHover];
      });
    }
    var getTitleFromCellRenderChildren = function getTitleFromCellRenderChildren2(_ref) {
      var ellipsis = _ref.ellipsis, rowType = _ref.rowType, children = _ref.children;
      var title;
      var ellipsisConfig = ellipsis === true ? {
        showTitle: true
      } : ellipsis;
      if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
        if (typeof children === "string" || typeof children === "number") {
          title = children.toString();
        } else if (/* @__PURE__ */ reactExports.isValidElement(children) && typeof children.props.children === "string") {
          title = children.props.children;
        }
      }
      return title;
    };
    function Cell(props) {
      var _ref2, _ref3, _legacyCellProps$colS, _ref4, _ref5, _legacyCellProps$rowS, _additionalProps$titl, _classNames;
      var Component = props.component, children = props.children, ellipsis = props.ellipsis, scope2 = props.scope, prefixCls = props.prefixCls, className = props.className, align = props.align, record = props.record, render2 = props.render, dataIndex = props.dataIndex, renderIndex = props.renderIndex, shouldCellUpdate = props.shouldCellUpdate, index2 = props.index, rowType = props.rowType, colSpan = props.colSpan, rowSpan = props.rowSpan, fixLeft = props.fixLeft, fixRight = props.fixRight, firstFixLeft = props.firstFixLeft, lastFixLeft = props.lastFixLeft, firstFixRight = props.firstFixRight, lastFixRight = props.lastFixRight, appendNode = props.appendNode, _props$additionalProp = props.additionalProps, additionalProps = _props$additionalProp === void 0 ? {} : _props$additionalProp, isSticky = props.isSticky;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var _useContext = useContext(TableContext, ["supportSticky", "allColumnsFixedLeft"]), supportSticky = _useContext.supportSticky, allColumnsFixedLeft = _useContext.allColumnsFixedLeft;
      var _useCellRender = useCellRender(record, dataIndex, renderIndex, children, render2, shouldCellUpdate), _useCellRender2 = _slicedToArray(_useCellRender, 2), childNode = _useCellRender2[0], legacyCellProps = _useCellRender2[1];
      var fixedStyle = {};
      var isFixLeft = typeof fixLeft === "number" && supportSticky;
      var isFixRight = typeof fixRight === "number" && supportSticky;
      if (isFixLeft) {
        fixedStyle.position = "sticky";
        fixedStyle.left = fixLeft;
      }
      if (isFixRight) {
        fixedStyle.position = "sticky";
        fixedStyle.right = fixRight;
      }
      var mergedColSpan = (_ref2 = (_ref3 = (_legacyCellProps$colS = legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.colSpan) !== null && _legacyCellProps$colS !== void 0 ? _legacyCellProps$colS : additionalProps.colSpan) !== null && _ref3 !== void 0 ? _ref3 : colSpan) !== null && _ref2 !== void 0 ? _ref2 : 1;
      var mergedRowSpan = (_ref4 = (_ref5 = (_legacyCellProps$rowS = legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.rowSpan) !== null && _legacyCellProps$rowS !== void 0 ? _legacyCellProps$rowS : additionalProps.rowSpan) !== null && _ref5 !== void 0 ? _ref5 : rowSpan) !== null && _ref4 !== void 0 ? _ref4 : 1;
      var _useHoverState = useHoverState(index2, mergedRowSpan), _useHoverState2 = _slicedToArray(_useHoverState, 2), hovering = _useHoverState2[0], onHover = _useHoverState2[1];
      var onMouseEnter = function onMouseEnter2(event) {
        var _additionalProps$onMo;
        if (record) {
          onHover(index2, index2 + mergedRowSpan - 1);
        }
        additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onMo = additionalProps.onMouseEnter) === null || _additionalProps$onMo === void 0 ? void 0 : _additionalProps$onMo.call(additionalProps, event);
      };
      var onMouseLeave = function onMouseLeave2(event) {
        var _additionalProps$onMo2;
        if (record) {
          onHover(-1, -1);
        }
        additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onMo2 = additionalProps.onMouseLeave) === null || _additionalProps$onMo2 === void 0 ? void 0 : _additionalProps$onMo2.call(additionalProps, event);
      };
      if (mergedColSpan === 0 || mergedRowSpan === 0) {
        return null;
      }
      var title = (_additionalProps$titl = additionalProps.title) !== null && _additionalProps$titl !== void 0 ? _additionalProps$titl : getTitleFromCellRenderChildren({
        rowType,
        ellipsis,
        children: childNode
      });
      var mergedClassName = classNames(cellPrefixCls, className, (_classNames = {}, _defineProperty$7(_classNames, "".concat(cellPrefixCls, "-fix-left"), isFixLeft && supportSticky), _defineProperty$7(_classNames, "".concat(cellPrefixCls, "-fix-left-first"), firstFixLeft && supportSticky), _defineProperty$7(_classNames, "".concat(cellPrefixCls, "-fix-left-last"), lastFixLeft && supportSticky), _defineProperty$7(_classNames, "".concat(cellPrefixCls, "-fix-left-all"), lastFixLeft && allColumnsFixedLeft && supportSticky), _defineProperty$7(_classNames, "".concat(cellPrefixCls, "-fix-right"), isFixRight && supportSticky), _defineProperty$7(_classNames, "".concat(cellPrefixCls, "-fix-right-first"), firstFixRight && supportSticky), _defineProperty$7(_classNames, "".concat(cellPrefixCls, "-fix-right-last"), lastFixRight && supportSticky), _defineProperty$7(_classNames, "".concat(cellPrefixCls, "-ellipsis"), ellipsis), _defineProperty$7(_classNames, "".concat(cellPrefixCls, "-with-append"), appendNode), _defineProperty$7(_classNames, "".concat(cellPrefixCls, "-fix-sticky"), (isFixLeft || isFixRight) && isSticky && supportSticky), _defineProperty$7(_classNames, "".concat(cellPrefixCls, "-row-hover"), !legacyCellProps && hovering), _classNames), additionalProps.className, legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.className);
      var alignStyle = {};
      if (align) {
        alignStyle.textAlign = align;
      }
      var mergedStyle = _objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, additionalProps.style), alignStyle), fixedStyle), legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.style);
      var mergedChildNode = childNode;
      if (_typeof$4(mergedChildNode) === "object" && !Array.isArray(mergedChildNode) && !/* @__PURE__ */ reactExports.isValidElement(mergedChildNode)) {
        mergedChildNode = null;
      }
      if (ellipsis && (lastFixLeft || firstFixRight)) {
        mergedChildNode = /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(cellPrefixCls, "-content")
        }, mergedChildNode);
      }
      return /* @__PURE__ */ reactExports.createElement(Component, _extends$2({}, legacyCellProps, additionalProps, {
        className: mergedClassName,
        style: mergedStyle,
        title,
        scope: scope2,
        onMouseEnter,
        onMouseLeave,
        colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
        rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null
      }), appendNode, mergedChildNode);
    }
    const Cell$1 = /* @__PURE__ */ reactExports.memo(Cell);
    function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets, direction, curColumns) {
      var startColumn = columns[colStart] || {};
      var endColumn = columns[colEnd] || {};
      var fixLeft;
      var fixRight;
      if (startColumn.fixed === "left") {
        fixLeft = stickyOffsets.left[colStart];
      } else if (endColumn.fixed === "right") {
        fixRight = stickyOffsets.right[colEnd];
      }
      var lastFixLeft = false;
      var firstFixRight = false;
      var lastFixRight = false;
      var firstFixLeft = false;
      var nextColumn = columns[colEnd + 1];
      var prevColumn = columns[colStart - 1];
      var canLastFix = !(curColumns !== null && curColumns !== void 0 && curColumns.children);
      if (direction === "rtl") {
        if (fixLeft !== void 0) {
          var prevFixLeft = prevColumn && prevColumn.fixed === "left";
          firstFixLeft = !prevFixLeft && canLastFix;
        } else if (fixRight !== void 0) {
          var nextFixRight = nextColumn && nextColumn.fixed === "right";
          lastFixRight = !nextFixRight && canLastFix;
        }
      } else if (fixLeft !== void 0) {
        var nextFixLeft = nextColumn && nextColumn.fixed === "left";
        lastFixLeft = !nextFixLeft && canLastFix;
      } else if (fixRight !== void 0) {
        var prevFixRight = prevColumn && prevColumn.fixed === "right";
        firstFixRight = !prevFixRight && canLastFix;
      }
      return {
        fixLeft,
        fixRight,
        lastFixLeft,
        firstFixRight,
        lastFixRight,
        firstFixLeft,
        isSticky: stickyOffsets.isSticky
      };
    }
    var SummaryContext = /* @__PURE__ */ reactExports.createContext({});
    function SummaryCell(_ref) {
      var className = _ref.className, index2 = _ref.index, children = _ref.children, _ref$colSpan = _ref.colSpan, colSpan = _ref$colSpan === void 0 ? 1 : _ref$colSpan, rowSpan = _ref.rowSpan, align = _ref.align;
      var _useContext = useContext(TableContext, ["prefixCls", "direction"]), prefixCls = _useContext.prefixCls, direction = _useContext.direction;
      var _React$useContext = reactExports.useContext(SummaryContext), scrollColumnIndex = _React$useContext.scrollColumnIndex, stickyOffsets = _React$useContext.stickyOffsets, flattenColumns = _React$useContext.flattenColumns, columns = _React$useContext.columns;
      var lastIndex = index2 + colSpan - 1;
      var mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
      var fixedInfo = getCellFixedInfo(index2, index2 + mergedColSpan - 1, flattenColumns, stickyOffsets, direction, columns === null || columns === void 0 ? void 0 : columns[index2]);
      return /* @__PURE__ */ reactExports.createElement(Cell$1, _extends$2({
        className,
        index: index2,
        component: "td",
        prefixCls,
        record: null,
        dataIndex: null,
        align,
        colSpan: mergedColSpan,
        rowSpan,
        render: function render2() {
          return children;
        }
      }, fixedInfo));
    }
    var _excluded$b = ["children"];
    function FooterRow(_ref) {
      var children = _ref.children, props = _objectWithoutProperties$1(_ref, _excluded$b);
      return /* @__PURE__ */ reactExports.createElement("tr", props, children);
    }
    function Summary(_ref) {
      var children = _ref.children;
      return children;
    }
    Summary.Row = FooterRow;
    Summary.Cell = SummaryCell;
    function Footer(props) {
      var children = props.children, stickyOffsets = props.stickyOffsets, flattenColumns = props.flattenColumns, columns = props.columns;
      var prefixCls = useContext(TableContext, "prefixCls");
      var lastColumnIndex = flattenColumns.length - 1;
      var scrollColumn = flattenColumns[lastColumnIndex];
      var summaryContext = reactExports.useMemo(function() {
        return {
          stickyOffsets,
          flattenColumns,
          scrollColumnIndex: scrollColumn !== null && scrollColumn !== void 0 && scrollColumn.scrollbar ? lastColumnIndex : null,
          columns
        };
      }, [scrollColumn, flattenColumns, lastColumnIndex, stickyOffsets, columns]);
      return /* @__PURE__ */ reactExports.createElement(SummaryContext.Provider, {
        value: summaryContext
      }, /* @__PURE__ */ reactExports.createElement("tfoot", {
        className: "".concat(prefixCls, "-summary")
      }, children));
    }
    const Footer$1 = responseImmutable(Footer);
    var FooterComponents = Summary;
    function Column$1(_) {
      return null;
    }
    function ColumnGroup$1(_) {
      return null;
    }
    function flatRecord(record, indent, childrenColumnName, expandedKeys, getRowKey, index2) {
      var arr = [];
      arr.push({
        record,
        indent,
        index: index2
      });
      var key = getRowKey(record);
      var expanded = expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.has(key);
      if (record && Array.isArray(record[childrenColumnName]) && expanded) {
        for (var i2 = 0; i2 < record[childrenColumnName].length; i2 += 1) {
          var tempArr = flatRecord(record[childrenColumnName][i2], indent + 1, childrenColumnName, expandedKeys, getRowKey, i2);
          arr.push.apply(arr, _toConsumableArray(tempArr));
        }
      }
      return arr;
    }
    function useFlattenRecords(data2, childrenColumnName, expandedKeys, getRowKey) {
      var arr = reactExports.useMemo(function() {
        if (expandedKeys !== null && expandedKeys !== void 0 && expandedKeys.size) {
          var temp = [];
          for (var i2 = 0; i2 < (data2 === null || data2 === void 0 ? void 0 : data2.length); i2 += 1) {
            var record = data2[i2];
            temp.push.apply(temp, _toConsumableArray(flatRecord(record, 0, childrenColumnName, expandedKeys, getRowKey, i2)));
          }
          return temp;
        }
        return data2 === null || data2 === void 0 ? void 0 : data2.map(function(item, index2) {
          return {
            record: item,
            indent: 0,
            index: index2
          };
        });
      }, [data2, childrenColumnName, expandedKeys, getRowKey]);
      return arr;
    }
    function ExpandedRow(props) {
      var prefixCls = props.prefixCls, children = props.children, Component = props.component, cellComponent = props.cellComponent, className = props.className, expanded = props.expanded, colSpan = props.colSpan, isEmpty2 = props.isEmpty;
      var _useContext = useContext(TableContext, ["scrollbarSize", "fixHeader", "fixColumn", "componentWidth", "horizonScroll"]), scrollbarSize = _useContext.scrollbarSize, fixHeader = _useContext.fixHeader, fixColumn = _useContext.fixColumn, componentWidth = _useContext.componentWidth, horizonScroll = _useContext.horizonScroll;
      var contentNode = children;
      if (isEmpty2 ? horizonScroll : fixColumn) {
        contentNode = /* @__PURE__ */ reactExports.createElement("div", {
          style: {
            width: componentWidth - (fixHeader ? scrollbarSize : 0),
            position: "sticky",
            left: 0,
            overflow: "hidden"
          },
          className: "".concat(prefixCls, "-expanded-row-fixed")
        }, componentWidth !== 0 && contentNode);
      }
      return /* @__PURE__ */ reactExports.createElement(Component, {
        className,
        style: {
          display: expanded ? null : "none"
        }
      }, /* @__PURE__ */ reactExports.createElement(Cell$1, {
        component: cellComponent,
        prefixCls,
        colSpan
      }, contentNode));
    }
    function BodyRow(props) {
      var className = props.className, style2 = props.style, record = props.record, index2 = props.index, renderIndex = props.renderIndex, rowKey = props.rowKey, rowExpandable = props.rowExpandable, expandedKeys = props.expandedKeys, onRow = props.onRow, _props$indent = props.indent, indent = _props$indent === void 0 ? 0 : _props$indent, RowComponent = props.rowComponent, cellComponent = props.cellComponent, scopeCellComponent = props.scopeCellComponent, childrenColumnName = props.childrenColumnName;
      var _useContext = useContext(TableContext, ["prefixCls", "fixedInfoList", "flattenColumns", "expandableType", "expandRowByClick", "onTriggerExpand", "rowClassName", "expandedRowClassName", "indentSize", "expandIcon", "expandedRowRender", "expandIconColumnIndex"]), prefixCls = _useContext.prefixCls, fixedInfoList = _useContext.fixedInfoList, flattenColumns = _useContext.flattenColumns, expandableType = _useContext.expandableType, expandRowByClick = _useContext.expandRowByClick, onTriggerExpand = _useContext.onTriggerExpand, rowClassName = _useContext.rowClassName, expandedRowClassName = _useContext.expandedRowClassName, indentSize = _useContext.indentSize, expandIcon = _useContext.expandIcon, expandedRowRender = _useContext.expandedRowRender, expandIconColumnIndex = _useContext.expandIconColumnIndex;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), expandRended = _React$useState2[0], setExpandRended = _React$useState2[1];
      var expanded = expandedKeys && expandedKeys.has(rowKey);
      reactExports.useEffect(function() {
        if (expanded) {
          setExpandRended(true);
        }
      }, [expanded]);
      var rowSupportExpand = expandableType === "row" && (!rowExpandable || rowExpandable(record));
      var nestExpandable = expandableType === "nest";
      var hasNestChildren = childrenColumnName && record && record[childrenColumnName];
      var mergedExpandable = rowSupportExpand || nestExpandable;
      var onExpandRef = reactExports.useRef(onTriggerExpand);
      onExpandRef.current = onTriggerExpand;
      var onInternalTriggerExpand = function onInternalTriggerExpand2() {
        onExpandRef.current.apply(onExpandRef, arguments);
      };
      var additionalProps = onRow === null || onRow === void 0 ? void 0 : onRow(record, index2);
      var onClick = function onClick2(event) {
        var _additionalProps$onCl;
        if (expandRowByClick && mergedExpandable) {
          onInternalTriggerExpand(record, event);
        }
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onCl = additionalProps.onClick) === null || _additionalProps$onCl === void 0 ? void 0 : _additionalProps$onCl.call.apply(_additionalProps$onCl, [additionalProps, event].concat(args));
      };
      var computeRowClassName;
      if (typeof rowClassName === "string") {
        computeRowClassName = rowClassName;
      } else if (typeof rowClassName === "function") {
        computeRowClassName = rowClassName(record, index2, indent);
      }
      var columnsKey = getColumnsKey(flattenColumns);
      var baseRowNode = /* @__PURE__ */ reactExports.createElement(RowComponent, _extends$2({}, additionalProps, {
        "data-row-key": rowKey,
        className: classNames(className, "".concat(prefixCls, "-row"), "".concat(prefixCls, "-row-level-").concat(indent), computeRowClassName, additionalProps && additionalProps.className),
        style: _objectSpread2$3(_objectSpread2$3({}, style2), additionalProps ? additionalProps.style : null),
        onClick
      }), flattenColumns.map(function(column2, colIndex) {
        var render2 = column2.render, dataIndex = column2.dataIndex, columnClassName = column2.className;
        var key = columnsKey[colIndex];
        var fixedInfo = fixedInfoList[colIndex];
        var appendCellNode;
        if (colIndex === (expandIconColumnIndex || 0) && nestExpandable) {
          appendCellNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("span", {
            style: {
              paddingLeft: "".concat(indentSize * indent, "px")
            },
            className: "".concat(prefixCls, "-row-indent indent-level-").concat(indent)
          }), expandIcon({
            prefixCls,
            expanded,
            expandable: hasNestChildren,
            record,
            onExpand: onInternalTriggerExpand
          }));
        }
        var additionalCellProps;
        if (column2.onCell) {
          additionalCellProps = column2.onCell(record, index2);
        }
        return /* @__PURE__ */ reactExports.createElement(Cell$1, _extends$2({
          className: columnClassName,
          ellipsis: column2.ellipsis,
          align: column2.align,
          scope: column2.rowScope,
          component: column2.rowScope ? scopeCellComponent : cellComponent,
          prefixCls,
          key,
          record,
          index: index2,
          renderIndex,
          dataIndex,
          render: render2,
          shouldCellUpdate: column2.shouldCellUpdate,
          expanded: appendCellNode && expanded
        }, fixedInfo, {
          appendNode: appendCellNode,
          additionalProps: additionalCellProps
        }));
      }));
      var expandRowNode;
      if (rowSupportExpand && (expandRended || expanded)) {
        var expandContent = expandedRowRender(record, index2, indent + 1, expanded);
        var computedExpandedRowClassName = expandedRowClassName && expandedRowClassName(record, index2, indent);
        expandRowNode = /* @__PURE__ */ reactExports.createElement(ExpandedRow, {
          expanded,
          className: classNames("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), computedExpandedRowClassName),
          prefixCls,
          component: RowComponent,
          cellComponent,
          colSpan: flattenColumns.length,
          isEmpty: false
        }, expandContent);
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, baseRowNode, expandRowNode);
    }
    BodyRow.displayName = "BodyRow";
    const BodyRow$1 = responseImmutable(BodyRow);
    function MeasureCell(_ref) {
      var columnKey = _ref.columnKey, onColumnResize = _ref.onColumnResize;
      var cellRef = reactExports.useRef();
      reactExports.useEffect(function() {
        if (cellRef.current) {
          onColumnResize(columnKey, cellRef.current.offsetWidth);
        }
      }, []);
      return /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        data: columnKey
      }, /* @__PURE__ */ reactExports.createElement("td", {
        ref: cellRef,
        style: {
          padding: 0,
          border: 0,
          height: 0
        }
      }, /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          height: 0,
          overflow: "hidden"
        }
      }, " ")));
    }
    function MeasureRow(_ref) {
      var prefixCls = _ref.prefixCls, columnsKey = _ref.columnsKey, onColumnResize = _ref.onColumnResize;
      return /* @__PURE__ */ reactExports.createElement("tr", {
        "aria-hidden": "true",
        className: "".concat(prefixCls, "-measure-row"),
        style: {
          height: 0,
          fontSize: 0
        }
      }, /* @__PURE__ */ reactExports.createElement(RefResizeObserver.Collection, {
        onBatchResize: function onBatchResize(infoList) {
          infoList.forEach(function(_ref2) {
            var columnKey = _ref2.data, size = _ref2.size;
            onColumnResize(columnKey, size.offsetWidth);
          });
        }
      }, columnsKey.map(function(columnKey) {
        return /* @__PURE__ */ reactExports.createElement(MeasureCell, {
          key: columnKey,
          columnKey,
          onColumnResize
        });
      })));
    }
    function Body(props) {
      var data2 = props.data, getRowKey = props.getRowKey, measureColumnWidth = props.measureColumnWidth, expandedKeys = props.expandedKeys, onRow = props.onRow, rowExpandable = props.rowExpandable, emptyNode = props.emptyNode, childrenColumnName = props.childrenColumnName;
      var _useContext = useContext(TableContext, ["prefixCls", "getComponent", "onColumnResize", "flattenColumns"]), prefixCls = _useContext.prefixCls, getComponent = _useContext.getComponent, onColumnResize = _useContext.onColumnResize, flattenColumns = _useContext.flattenColumns;
      var flattenData2 = useFlattenRecords(data2, childrenColumnName, expandedKeys, getRowKey);
      var perfRef = reactExports.useRef({
        renderWithProps: false
      });
      var WrapperComponent = getComponent(["body", "wrapper"], "tbody");
      var trComponent = getComponent(["body", "row"], "tr");
      var tdComponent = getComponent(["body", "cell"], "td");
      var thComponent = getComponent(["body", "cell"], "th");
      var rows;
      if (data2.length) {
        rows = flattenData2.map(function(item, idx) {
          var record = item.record, indent = item.indent, renderIndex = item.index;
          var key = getRowKey(record, idx);
          return /* @__PURE__ */ reactExports.createElement(BodyRow$1, {
            key,
            rowKey: key,
            record,
            index: idx,
            renderIndex,
            rowComponent: trComponent,
            cellComponent: tdComponent,
            scopeCellComponent: thComponent,
            expandedKeys,
            onRow,
            getRowKey,
            rowExpandable,
            childrenColumnName,
            indent
          });
        });
      } else {
        rows = /* @__PURE__ */ reactExports.createElement(ExpandedRow, {
          expanded: true,
          className: "".concat(prefixCls, "-placeholder"),
          prefixCls,
          component: trComponent,
          cellComponent: tdComponent,
          colSpan: flattenColumns.length,
          isEmpty: true
        }, emptyNode);
      }
      var columnsKey = getColumnsKey(flattenColumns);
      return /* @__PURE__ */ reactExports.createElement(PerfContext.Provider, {
        value: perfRef.current
      }, /* @__PURE__ */ reactExports.createElement(WrapperComponent, {
        className: "".concat(prefixCls, "-tbody")
      }, measureColumnWidth && /* @__PURE__ */ reactExports.createElement(MeasureRow, {
        prefixCls,
        columnsKey,
        onColumnResize
      }), rows));
    }
    Body.displayName = "Body";
    const Body$1 = responseImmutable(Body);
    var _excluded$a = ["expandable"];
    var INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
    function getExpandableProps(props) {
      var expandable = props.expandable, legacyExpandableConfig = _objectWithoutProperties$1(props, _excluded$a);
      var config;
      if ("expandable" in props) {
        config = _objectSpread2$3(_objectSpread2$3({}, legacyExpandableConfig), expandable);
      } else {
        config = legacyExpandableConfig;
      }
      if (config.showExpandColumn === false) {
        config.expandIconColumnIndex = -1;
      }
      return config;
    }
    var _excluded$9 = ["columnType"];
    function ColGroup(_ref) {
      var colWidths = _ref.colWidths, columns = _ref.columns, columCount = _ref.columCount;
      var cols = [];
      var len = columCount || columns.length;
      var mustInsert = false;
      for (var i2 = len - 1; i2 >= 0; i2 -= 1) {
        var width = colWidths[i2];
        var column2 = columns && columns[i2];
        var additionalProps = column2 && column2[INTERNAL_COL_DEFINE];
        if (width || additionalProps || mustInsert) {
          var _ref2 = additionalProps || {};
          _ref2.columnType;
          var restAdditionalProps = _objectWithoutProperties$1(_ref2, _excluded$9);
          cols.unshift(/* @__PURE__ */ reactExports.createElement("col", _extends$2({
            key: i2,
            style: {
              width
            }
          }, restAdditionalProps)));
          mustInsert = true;
        }
      }
      return /* @__PURE__ */ reactExports.createElement("colgroup", null, cols);
    }
    var _excluded$8 = ["className", "noData", "columns", "flattenColumns", "colWidths", "columCount", "stickyOffsets", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName", "onScroll", "maxContentScroll", "children"];
    function useColumnWidth(colWidths, columCount) {
      return reactExports.useMemo(function() {
        var cloneColumns = [];
        for (var i2 = 0; i2 < columCount; i2 += 1) {
          var val = colWidths[i2];
          if (val !== void 0) {
            cloneColumns[i2] = val;
          } else {
            return null;
          }
        }
        return cloneColumns;
      }, [colWidths.join("_"), columCount]);
    }
    var FixedHolder = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var className = props.className, noData = props.noData, columns = props.columns, flattenColumns = props.flattenColumns, colWidths = props.colWidths, columCount = props.columCount, stickyOffsets = props.stickyOffsets, direction = props.direction, fixHeader = props.fixHeader, stickyTopOffset = props.stickyTopOffset, stickyBottomOffset = props.stickyBottomOffset, stickyClassName = props.stickyClassName, onScroll = props.onScroll, maxContentScroll = props.maxContentScroll, children = props.children, restProps = _objectWithoutProperties$1(props, _excluded$8);
      var _useContext = useContext(TableContext, ["prefixCls", "scrollbarSize", "isSticky"]), prefixCls = _useContext.prefixCls, scrollbarSize = _useContext.scrollbarSize, isSticky = _useContext.isSticky;
      var combinationScrollBarSize = isSticky && !fixHeader ? 0 : scrollbarSize;
      var scrollRef = reactExports.useRef(null);
      var setScrollRef = reactExports.useCallback(function(element) {
        fillRef(ref, element);
        fillRef(scrollRef, element);
      }, []);
      reactExports.useEffect(function() {
        var _scrollRef$current;
        function onWheel(e2) {
          var _ref = e2, currentTarget = _ref.currentTarget, deltaX = _ref.deltaX;
          if (deltaX) {
            onScroll({
              currentTarget,
              scrollLeft: currentTarget.scrollLeft + deltaX
            });
            e2.preventDefault();
          }
        }
        (_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 ? void 0 : _scrollRef$current.addEventListener("wheel", onWheel);
        return function() {
          var _scrollRef$current2;
          (_scrollRef$current2 = scrollRef.current) === null || _scrollRef$current2 === void 0 ? void 0 : _scrollRef$current2.removeEventListener("wheel", onWheel);
        };
      }, []);
      var allFlattenColumnsWithWidth = reactExports.useMemo(function() {
        return flattenColumns.every(function(column2) {
          return column2.width >= 0;
        });
      }, [flattenColumns]);
      var lastColumn = flattenColumns[flattenColumns.length - 1];
      var ScrollBarColumn = {
        fixed: lastColumn ? lastColumn.fixed : null,
        scrollbar: true,
        onHeaderCell: function onHeaderCell() {
          return {
            className: "".concat(prefixCls, "-cell-scrollbar")
          };
        }
      };
      var columnsWithScrollbar = reactExports.useMemo(function() {
        return combinationScrollBarSize ? [].concat(_toConsumableArray(columns), [ScrollBarColumn]) : columns;
      }, [combinationScrollBarSize, columns]);
      var flattenColumnsWithScrollbar = reactExports.useMemo(function() {
        return combinationScrollBarSize ? [].concat(_toConsumableArray(flattenColumns), [ScrollBarColumn]) : flattenColumns;
      }, [combinationScrollBarSize, flattenColumns]);
      var headerStickyOffsets = reactExports.useMemo(function() {
        var right = stickyOffsets.right, left = stickyOffsets.left;
        return _objectSpread2$3(_objectSpread2$3({}, stickyOffsets), {}, {
          left: direction === "rtl" ? [].concat(_toConsumableArray(left.map(function(width) {
            return width + combinationScrollBarSize;
          })), [0]) : left,
          right: direction === "rtl" ? right : [].concat(_toConsumableArray(right.map(function(width) {
            return width + combinationScrollBarSize;
          })), [0]),
          isSticky
        });
      }, [combinationScrollBarSize, stickyOffsets, isSticky]);
      var mergedColumnWidth = useColumnWidth(colWidths, columCount);
      return /* @__PURE__ */ reactExports.createElement("div", {
        style: _objectSpread2$3({
          overflow: "hidden"
        }, isSticky ? {
          top: stickyTopOffset,
          bottom: stickyBottomOffset
        } : {}),
        ref: setScrollRef,
        className: classNames(className, _defineProperty$7({}, stickyClassName, !!stickyClassName))
      }, /* @__PURE__ */ reactExports.createElement("table", {
        style: {
          tableLayout: "fixed",
          visibility: noData || mergedColumnWidth ? null : "hidden"
        }
      }, (!noData || !maxContentScroll || allFlattenColumnsWithWidth) && /* @__PURE__ */ reactExports.createElement(ColGroup, {
        colWidths: mergedColumnWidth ? [].concat(_toConsumableArray(mergedColumnWidth), [combinationScrollBarSize]) : [],
        columCount: columCount + 1,
        columns: flattenColumnsWithScrollbar
      }), children(_objectSpread2$3(_objectSpread2$3({}, restProps), {}, {
        stickyOffsets: headerStickyOffsets,
        columns: columnsWithScrollbar,
        flattenColumns: flattenColumnsWithScrollbar
      }))));
    });
    FixedHolder.displayName = "FixedHolder";
    const FixedHolder$1 = /* @__PURE__ */ reactExports.memo(FixedHolder);
    function HeaderRow(_ref) {
      var cells = _ref.cells, stickyOffsets = _ref.stickyOffsets, flattenColumns = _ref.flattenColumns, RowComponent = _ref.rowComponent, CellComponent = _ref.cellComponent, tdCellComponent = _ref.tdCellComponent, onHeaderRow = _ref.onHeaderRow, index2 = _ref.index;
      var _useContext = useContext(TableContext, ["prefixCls", "direction"]), prefixCls = _useContext.prefixCls, direction = _useContext.direction;
      var rowProps;
      if (onHeaderRow) {
        rowProps = onHeaderRow(cells.map(function(cell) {
          return cell.column;
        }), index2);
      }
      var columnsKey = getColumnsKey(cells.map(function(cell) {
        return cell.column;
      }));
      return /* @__PURE__ */ reactExports.createElement(RowComponent, rowProps, cells.map(function(cell, cellIndex) {
        var column2 = cell.column;
        var fixedInfo = getCellFixedInfo(cell.colStart, cell.colEnd, flattenColumns, stickyOffsets, direction, column2);
        var additionalProps;
        if (column2 && column2.onHeaderCell) {
          additionalProps = cell.column.onHeaderCell(column2);
        }
        return /* @__PURE__ */ reactExports.createElement(Cell$1, _extends$2({}, cell, {
          scope: column2.title ? cell.colSpan > 1 ? "colgroup" : "col" : null,
          ellipsis: column2.ellipsis,
          align: column2.align,
          component: column2.title ? CellComponent : tdCellComponent,
          prefixCls,
          key: columnsKey[cellIndex]
        }, fixedInfo, {
          additionalProps,
          rowType: "header"
        }));
      }));
    }
    HeaderRow.displayName = "HeaderRow";
    function parseHeaderRows(rootColumns) {
      var rows = [];
      function fillRowCells(columns, colIndex) {
        var rowIndex2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        rows[rowIndex2] = rows[rowIndex2] || [];
        var currentColIndex = colIndex;
        var colSpans = columns.filter(Boolean).map(function(column2) {
          var cell = {
            key: column2.key,
            className: column2.className || "",
            children: column2.title,
            column: column2,
            colStart: currentColIndex
          };
          var colSpan = 1;
          var subColumns = column2.children;
          if (subColumns && subColumns.length > 0) {
            colSpan = fillRowCells(subColumns, currentColIndex, rowIndex2 + 1).reduce(function(total, count) {
              return total + count;
            }, 0);
            cell.hasSubColumns = true;
          }
          if ("colSpan" in column2) {
            colSpan = column2.colSpan;
          }
          if ("rowSpan" in column2) {
            cell.rowSpan = column2.rowSpan;
          }
          cell.colSpan = colSpan;
          cell.colEnd = cell.colStart + colSpan - 1;
          rows[rowIndex2].push(cell);
          currentColIndex += colSpan;
          return colSpan;
        });
        return colSpans;
      }
      fillRowCells(rootColumns, 0);
      var rowCount = rows.length;
      var _loop = function _loop2(rowIndex2) {
        rows[rowIndex2].forEach(function(cell) {
          if (!("rowSpan" in cell) && !cell.hasSubColumns) {
            cell.rowSpan = rowCount - rowIndex2;
          }
        });
      };
      for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
        _loop(rowIndex);
      }
      return rows;
    }
    function Header$1(props) {
      var stickyOffsets = props.stickyOffsets, columns = props.columns, flattenColumns = props.flattenColumns, onHeaderRow = props.onHeaderRow;
      var _useContext = useContext(TableContext, ["prefixCls", "getComponent"]), prefixCls = _useContext.prefixCls, getComponent = _useContext.getComponent;
      var rows = reactExports.useMemo(function() {
        return parseHeaderRows(columns);
      }, [columns]);
      var WrapperComponent = getComponent(["header", "wrapper"], "thead");
      var trComponent = getComponent(["header", "row"], "tr");
      var thComponent = getComponent(["header", "cell"], "th");
      var tdComponent = getComponent(["header", "cell"], "td");
      return /* @__PURE__ */ reactExports.createElement(WrapperComponent, {
        className: "".concat(prefixCls, "-thead")
      }, rows.map(function(row, rowIndex) {
        var rowNode = /* @__PURE__ */ reactExports.createElement(HeaderRow, {
          key: rowIndex,
          flattenColumns,
          cells: row,
          stickyOffsets,
          rowComponent: trComponent,
          cellComponent: thComponent,
          tdCellComponent: tdComponent,
          onHeaderRow,
          index: rowIndex
        });
        return rowNode;
      }));
    }
    const Header$2 = responseImmutable(Header$1);
    var _excluded$7 = ["children"], _excluded2 = ["fixed"];
    function convertChildrenToColumns(children) {
      return toArray$8(children).filter(function(node2) {
        return /* @__PURE__ */ reactExports.isValidElement(node2);
      }).map(function(_ref) {
        var key = _ref.key, props = _ref.props;
        var nodeChildren = props.children, restProps = _objectWithoutProperties$1(props, _excluded$7);
        var column2 = _objectSpread2$3({
          key
        }, restProps);
        if (nodeChildren) {
          column2.children = convertChildrenToColumns(nodeChildren);
        }
        return column2;
      });
    }
    function flatColumns(columns) {
      return columns.filter(function(column2) {
        return column2 && _typeof$4(column2) === "object";
      }).reduce(function(list2, column2) {
        var fixed = column2.fixed;
        var parsedFixed = fixed === true ? "left" : fixed;
        var subColumns = column2.children;
        if (subColumns && subColumns.length > 0) {
          return [].concat(_toConsumableArray(list2), _toConsumableArray(flatColumns(subColumns).map(function(subColum) {
            return _objectSpread2$3({
              fixed: parsedFixed
            }, subColum);
          })));
        }
        return [].concat(_toConsumableArray(list2), [_objectSpread2$3(_objectSpread2$3({}, column2), {}, {
          fixed: parsedFixed
        })]);
      }, []);
    }
    function revertForRtl(columns) {
      return columns.map(function(column2) {
        var fixed = column2.fixed, restProps = _objectWithoutProperties$1(column2, _excluded2);
        var parsedFixed = fixed;
        if (fixed === "left") {
          parsedFixed = "right";
        } else if (fixed === "right") {
          parsedFixed = "left";
        }
        return _objectSpread2$3({
          fixed: parsedFixed
        }, restProps);
      });
    }
    function useColumns(_ref2, transformColumns) {
      var prefixCls = _ref2.prefixCls, columns = _ref2.columns, children = _ref2.children, expandable = _ref2.expandable, expandedKeys = _ref2.expandedKeys, columnTitle = _ref2.columnTitle, getRowKey = _ref2.getRowKey, onTriggerExpand = _ref2.onTriggerExpand, expandIcon = _ref2.expandIcon, rowExpandable = _ref2.rowExpandable, expandIconColumnIndex = _ref2.expandIconColumnIndex, direction = _ref2.direction, expandRowByClick = _ref2.expandRowByClick, columnWidth = _ref2.columnWidth, fixed = _ref2.fixed;
      var baseColumns = reactExports.useMemo(function() {
        return columns || convertChildrenToColumns(children);
      }, [columns, children]);
      var withExpandColumns = reactExports.useMemo(function() {
        if (expandable) {
          var _expandColumn;
          var cloneColumns = baseColumns.slice();
          if (!cloneColumns.includes(EXPAND_COLUMN)) {
            var expandColIndex = expandIconColumnIndex || 0;
            if (expandColIndex >= 0) {
              cloneColumns.splice(expandColIndex, 0, EXPAND_COLUMN);
            }
          }
          var expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
          cloneColumns = cloneColumns.filter(function(column2, index2) {
            return column2 !== EXPAND_COLUMN || index2 === expandColumnIndex;
          });
          var prevColumn = baseColumns[expandColumnIndex];
          var fixedColumn;
          if ((fixed === "left" || fixed) && !expandIconColumnIndex) {
            fixedColumn = "left";
          } else if ((fixed === "right" || fixed) && expandIconColumnIndex === baseColumns.length) {
            fixedColumn = "right";
          } else {
            fixedColumn = prevColumn ? prevColumn.fixed : null;
          }
          var expandColumn = (_expandColumn = {}, _defineProperty$7(_expandColumn, INTERNAL_COL_DEFINE, {
            className: "".concat(prefixCls, "-expand-icon-col"),
            columnType: "EXPAND_COLUMN"
          }), _defineProperty$7(_expandColumn, "title", columnTitle), _defineProperty$7(_expandColumn, "fixed", fixedColumn), _defineProperty$7(_expandColumn, "className", "".concat(prefixCls, "-row-expand-icon-cell")), _defineProperty$7(_expandColumn, "width", columnWidth), _defineProperty$7(_expandColumn, "render", function render2(_, record, index2) {
            var rowKey = getRowKey(record, index2);
            var expanded = expandedKeys.has(rowKey);
            var recordExpandable = rowExpandable ? rowExpandable(record) : true;
            var icon = expandIcon({
              prefixCls,
              expanded,
              expandable: recordExpandable,
              record,
              onExpand: onTriggerExpand
            });
            if (expandRowByClick) {
              return /* @__PURE__ */ reactExports.createElement("span", {
                onClick: function onClick(e2) {
                  return e2.stopPropagation();
                }
              }, icon);
            }
            return icon;
          }), _expandColumn);
          return cloneColumns.map(function(col) {
            return col === EXPAND_COLUMN ? expandColumn : col;
          });
        }
        return baseColumns.filter(function(col) {
          return col !== EXPAND_COLUMN;
        });
      }, [expandable, baseColumns, getRowKey, expandedKeys, expandIcon, direction]);
      var mergedColumns = reactExports.useMemo(function() {
        var finalColumns = withExpandColumns;
        if (transformColumns) {
          finalColumns = transformColumns(finalColumns);
        }
        if (!finalColumns.length) {
          finalColumns = [{
            render: function render2() {
              return null;
            }
          }];
        }
        return finalColumns;
      }, [transformColumns, withExpandColumns, direction]);
      var flattenColumns = reactExports.useMemo(function() {
        if (direction === "rtl") {
          return revertForRtl(flatColumns(mergedColumns));
        }
        return flatColumns(mergedColumns);
      }, [mergedColumns, direction]);
      return [mergedColumns, flattenColumns];
    }
    function renderExpandIcon$1(_ref) {
      var _classNames;
      var prefixCls = _ref.prefixCls, record = _ref.record, onExpand = _ref.onExpand, expanded = _ref.expanded, expandable = _ref.expandable;
      var expandClassName = "".concat(prefixCls, "-row-expand-icon");
      if (!expandable) {
        return /* @__PURE__ */ reactExports.createElement("span", {
          className: classNames(expandClassName, "".concat(prefixCls, "-row-spaced"))
        });
      }
      var onClick = function onClick2(event) {
        onExpand(record, event);
        event.stopPropagation();
      };
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames(expandClassName, (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-row-expanded"), expanded), _defineProperty$7(_classNames, "".concat(prefixCls, "-row-collapsed"), !expanded), _classNames)),
        onClick
      });
    }
    function findAllChildrenKeys(data2, getRowKey, childrenColumnName) {
      var keys2 = [];
      function dig(list2) {
        (list2 || []).forEach(function(item, index2) {
          keys2.push(getRowKey(item, index2));
          dig(item[childrenColumnName]);
        });
      }
      dig(data2);
      return keys2;
    }
    function useExpand(props, mergedData, getRowKey) {
      var expandableConfig = getExpandableProps(props);
      var expandIcon = expandableConfig.expandIcon, expandedRowKeys = expandableConfig.expandedRowKeys, defaultExpandedRowKeys = expandableConfig.defaultExpandedRowKeys, defaultExpandAllRows = expandableConfig.defaultExpandAllRows, expandedRowRender = expandableConfig.expandedRowRender, onExpand = expandableConfig.onExpand, onExpandedRowsChange = expandableConfig.onExpandedRowsChange, childrenColumnName = expandableConfig.childrenColumnName;
      var mergedExpandIcon = expandIcon || renderExpandIcon$1;
      var mergedChildrenColumnName = childrenColumnName || "children";
      var expandableType = reactExports.useMemo(function() {
        if (expandedRowRender) {
          return "row";
        }
        if (props.expandable && props.internalHooks === INTERNAL_HOOKS && props.expandable.__PARENT_RENDER_ICON__ || mergedData.some(function(record) {
          return record && _typeof$4(record) === "object" && record[mergedChildrenColumnName];
        })) {
          return "nest";
        }
        return false;
      }, [!!expandedRowRender, mergedData]);
      var _React$useState = reactExports.useState(function() {
        if (defaultExpandedRowKeys) {
          return defaultExpandedRowKeys;
        }
        if (defaultExpandAllRows) {
          return findAllChildrenKeys(mergedData, getRowKey, mergedChildrenColumnName);
        }
        return [];
      }), _React$useState2 = _slicedToArray(_React$useState, 2), innerExpandedKeys = _React$useState2[0], setInnerExpandedKeys = _React$useState2[1];
      var mergedExpandedKeys = reactExports.useMemo(function() {
        return new Set(expandedRowKeys || innerExpandedKeys || []);
      }, [expandedRowKeys, innerExpandedKeys]);
      var onTriggerExpand = reactExports.useCallback(function(record) {
        var key = getRowKey(record, mergedData.indexOf(record));
        var newExpandedKeys;
        var hasKey = mergedExpandedKeys.has(key);
        if (hasKey) {
          mergedExpandedKeys.delete(key);
          newExpandedKeys = _toConsumableArray(mergedExpandedKeys);
        } else {
          newExpandedKeys = [].concat(_toConsumableArray(mergedExpandedKeys), [key]);
        }
        setInnerExpandedKeys(newExpandedKeys);
        if (onExpand) {
          onExpand(!hasKey, record);
        }
        if (onExpandedRowsChange) {
          onExpandedRowsChange(newExpandedKeys);
        }
      }, [getRowKey, mergedExpandedKeys, mergedData, onExpand, onExpandedRowsChange]);
      return [expandableConfig, expandableType, mergedExpandedKeys, mergedExpandIcon, mergedChildrenColumnName, onTriggerExpand];
    }
    function useFixedInfo(flattenColumns, stickyOffsets, direction, columns) {
      var fixedInfoList = flattenColumns.map(function(_, colIndex) {
        return getCellFixedInfo(colIndex, colIndex, flattenColumns, stickyOffsets, direction, columns === null || columns === void 0 ? void 0 : columns[colIndex]);
      });
      return useMemo(function() {
        return fixedInfoList;
      }, [fixedInfoList], function(prev2, next2) {
        return !isEqual$1(prev2, next2);
      });
    }
    function useLayoutState(defaultState) {
      var stateRef = reactExports.useRef(defaultState);
      var _useState = reactExports.useState({}), _useState2 = _slicedToArray(_useState, 2), forceUpdate = _useState2[1];
      var lastPromiseRef = reactExports.useRef(null);
      var updateBatchRef = reactExports.useRef([]);
      function setFrameState(updater) {
        updateBatchRef.current.push(updater);
        var promise = Promise.resolve();
        lastPromiseRef.current = promise;
        promise.then(function() {
          if (lastPromiseRef.current === promise) {
            var prevBatch = updateBatchRef.current;
            var prevState = stateRef.current;
            updateBatchRef.current = [];
            prevBatch.forEach(function(batchUpdater) {
              stateRef.current = batchUpdater(stateRef.current);
            });
            lastPromiseRef.current = null;
            if (prevState !== stateRef.current) {
              forceUpdate({});
            }
          }
        });
      }
      reactExports.useEffect(function() {
        return function() {
          lastPromiseRef.current = null;
        };
      }, []);
      return [stateRef.current, setFrameState];
    }
    function useTimeoutLock(defaultState) {
      var frameRef = reactExports.useRef(defaultState || null);
      var timeoutRef = reactExports.useRef();
      function cleanUp() {
        window.clearTimeout(timeoutRef.current);
      }
      function setState(newState) {
        frameRef.current = newState;
        cleanUp();
        timeoutRef.current = window.setTimeout(function() {
          frameRef.current = null;
          timeoutRef.current = void 0;
        }, 100);
      }
      function getState() {
        return frameRef.current;
      }
      reactExports.useEffect(function() {
        return cleanUp;
      }, []);
      return [setState, getState];
    }
    function useHover() {
      var _React$useState = reactExports.useState(-1), _React$useState2 = _slicedToArray(_React$useState, 2), startRow = _React$useState2[0], setStartRow = _React$useState2[1];
      var _React$useState3 = reactExports.useState(-1), _React$useState4 = _slicedToArray(_React$useState3, 2), endRow = _React$useState4[0], setEndRow = _React$useState4[1];
      var onHover = reactExports.useCallback(function(start2, end2) {
        setStartRow(start2);
        setEndRow(end2);
      }, []);
      return [startRow, endRow, onHover];
    }
    var defaultContainer = canUseDom$2() ? window : null;
    function useSticky(sticky, prefixCls) {
      var _ref = _typeof$4(sticky) === "object" ? sticky : {}, _ref$offsetHeader = _ref.offsetHeader, offsetHeader = _ref$offsetHeader === void 0 ? 0 : _ref$offsetHeader, _ref$offsetSummary = _ref.offsetSummary, offsetSummary = _ref$offsetSummary === void 0 ? 0 : _ref$offsetSummary, _ref$offsetScroll = _ref.offsetScroll, offsetScroll = _ref$offsetScroll === void 0 ? 0 : _ref$offsetScroll, _ref$getContainer = _ref.getContainer, getContainer2 = _ref$getContainer === void 0 ? function() {
        return defaultContainer;
      } : _ref$getContainer;
      var container2 = getContainer2() || defaultContainer;
      return reactExports.useMemo(function() {
        var isSticky = !!sticky;
        return {
          isSticky,
          stickyClassName: isSticky ? "".concat(prefixCls, "-sticky-holder") : "",
          offsetHeader,
          offsetSummary,
          offsetScroll,
          container: container2
        };
      }, [offsetScroll, offsetHeader, offsetSummary, prefixCls, container2]);
    }
    function useStickyOffsets(colWidths, columnCount, direction) {
      var stickyOffsets = reactExports.useMemo(function() {
        var leftOffsets = [];
        var rightOffsets = [];
        var left = 0;
        var right = 0;
        for (var start2 = 0; start2 < columnCount; start2 += 1) {
          if (direction === "rtl") {
            rightOffsets[start2] = right;
            right += colWidths[start2] || 0;
            var end2 = columnCount - start2 - 1;
            leftOffsets[end2] = left;
            left += colWidths[end2] || 0;
          } else {
            leftOffsets[start2] = left;
            left += colWidths[start2] || 0;
            var _end = columnCount - start2 - 1;
            rightOffsets[_end] = right;
            right += colWidths[_end] || 0;
          }
        }
        return {
          left: leftOffsets,
          right: rightOffsets
        };
      }, [colWidths, columnCount, direction]);
      return stickyOffsets;
    }
    function Panel(_ref) {
      var className = _ref.className, children = _ref.children;
      return /* @__PURE__ */ reactExports.createElement("div", {
        className
      }, children);
    }
    var StickyScrollBar = function StickyScrollBar2(_ref, ref) {
      var _scrollBodyRef$curren, _scrollBodyRef$curren2;
      var scrollBodyRef = _ref.scrollBodyRef, onScroll = _ref.onScroll, offsetScroll = _ref.offsetScroll, container2 = _ref.container;
      var prefixCls = useContext(TableContext, "prefixCls");
      var bodyScrollWidth = ((_scrollBodyRef$curren = scrollBodyRef.current) === null || _scrollBodyRef$curren === void 0 ? void 0 : _scrollBodyRef$curren.scrollWidth) || 0;
      var bodyWidth = ((_scrollBodyRef$curren2 = scrollBodyRef.current) === null || _scrollBodyRef$curren2 === void 0 ? void 0 : _scrollBodyRef$curren2.clientWidth) || 0;
      var scrollBarWidth = bodyScrollWidth && bodyWidth * (bodyWidth / bodyScrollWidth);
      var scrollBarRef = reactExports.useRef();
      var _useLayoutState = useLayoutState({
        scrollLeft: 0,
        isHiddenScrollBar: false
      }), _useLayoutState2 = _slicedToArray(_useLayoutState, 2), scrollState = _useLayoutState2[0], setScrollState = _useLayoutState2[1];
      var refState = reactExports.useRef({
        delta: 0,
        x: 0
      });
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), isActive2 = _React$useState2[0], setActive = _React$useState2[1];
      var onMouseUp = function onMouseUp2() {
        setActive(false);
      };
      var onMouseDown = function onMouseDown2(event) {
        event.persist();
        refState.current.delta = event.pageX - scrollState.scrollLeft;
        refState.current.x = 0;
        setActive(true);
        event.preventDefault();
      };
      var onMouseMove = function onMouseMove2(event) {
        var _window;
        var _ref2 = event || ((_window = window) === null || _window === void 0 ? void 0 : _window.event), buttons = _ref2.buttons;
        if (!isActive2 || buttons === 0) {
          if (isActive2) {
            setActive(false);
          }
          return;
        }
        var left = refState.current.x + event.pageX - refState.current.x - refState.current.delta;
        if (left <= 0) {
          left = 0;
        }
        if (left + scrollBarWidth >= bodyWidth) {
          left = bodyWidth - scrollBarWidth;
        }
        onScroll({
          scrollLeft: left / bodyWidth * (bodyScrollWidth + 2)
        });
        refState.current.x = event.pageX;
      };
      var onContainerScroll = function onContainerScroll2() {
        if (!scrollBodyRef.current) {
          return;
        }
        var tableOffsetTop = getOffset(scrollBodyRef.current).top;
        var tableBottomOffset = tableOffsetTop + scrollBodyRef.current.offsetHeight;
        var currentClientOffset = container2 === window ? document.documentElement.scrollTop + window.innerHeight : getOffset(container2).top + container2.clientHeight;
        if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - offsetScroll) {
          setScrollState(function(state) {
            return _objectSpread2$3(_objectSpread2$3({}, state), {}, {
              isHiddenScrollBar: true
            });
          });
        } else {
          setScrollState(function(state) {
            return _objectSpread2$3(_objectSpread2$3({}, state), {}, {
              isHiddenScrollBar: false
            });
          });
        }
      };
      var setScrollLeft = function setScrollLeft2(left) {
        setScrollState(function(state) {
          return _objectSpread2$3(_objectSpread2$3({}, state), {}, {
            scrollLeft: left / bodyScrollWidth * bodyWidth || 0
          });
        });
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          setScrollLeft
        };
      });
      reactExports.useEffect(function() {
        var onMouseUpListener = addEventListenerWrap(document.body, "mouseup", onMouseUp, false);
        var onMouseMoveListener = addEventListenerWrap(document.body, "mousemove", onMouseMove, false);
        onContainerScroll();
        return function() {
          onMouseUpListener.remove();
          onMouseMoveListener.remove();
        };
      }, [scrollBarWidth, isActive2]);
      reactExports.useEffect(function() {
        var onScrollListener = addEventListenerWrap(container2, "scroll", onContainerScroll, false);
        var onResizeListener = addEventListenerWrap(window, "resize", onContainerScroll, false);
        return function() {
          onScrollListener.remove();
          onResizeListener.remove();
        };
      }, [container2]);
      reactExports.useEffect(function() {
        if (!scrollState.isHiddenScrollBar) {
          setScrollState(function(state) {
            var bodyNode = scrollBodyRef.current;
            if (!bodyNode) {
              return state;
            }
            return _objectSpread2$3(_objectSpread2$3({}, state), {}, {
              scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
            });
          });
        }
      }, [scrollState.isHiddenScrollBar]);
      if (bodyScrollWidth <= bodyWidth || !scrollBarWidth || scrollState.isHiddenScrollBar) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          height: getScrollBarSize(),
          width: bodyWidth,
          bottom: offsetScroll
        },
        className: "".concat(prefixCls, "-sticky-scroll")
      }, /* @__PURE__ */ reactExports.createElement("div", {
        onMouseDown,
        ref: scrollBarRef,
        className: classNames("".concat(prefixCls, "-sticky-scroll-bar"), _defineProperty$7({}, "".concat(prefixCls, "-sticky-scroll-bar-active"), isActive2)),
        style: {
          width: "".concat(scrollBarWidth, "px"),
          transform: "translate3d(".concat(scrollState.scrollLeft, "px, 0, 0)")
        }
      }));
    };
    const StickyScrollBar$1 = /* @__PURE__ */ reactExports.forwardRef(StickyScrollBar);
    var EMPTY_DATA = [];
    var EMPTY_SCROLL_TARGET = {};
    var INTERNAL_HOOKS = "rc-table-internal-hook";
    function defaultEmpty() {
      return "No Data";
    }
    function Table$2(tableProps) {
      var _classNames;
      var props = _objectSpread2$3({
        rowKey: "key",
        prefixCls: "rc-table",
        emptyText: defaultEmpty
      }, tableProps);
      var prefixCls = props.prefixCls, className = props.className, rowClassName = props.rowClassName, style2 = props.style, data2 = props.data, rowKey = props.rowKey, scroll = props.scroll, tableLayout = props.tableLayout, direction = props.direction, title = props.title, footer2 = props.footer, summary = props.summary, caption = props.caption, id2 = props.id, showHeader = props.showHeader, components = props.components, emptyText = props.emptyText, onRow = props.onRow, onHeaderRow = props.onHeaderRow, internalHooks = props.internalHooks, transformColumns = props.transformColumns, internalRefs = props.internalRefs, sticky = props.sticky;
      var mergedData = data2 || EMPTY_DATA;
      var hasData = !!mergedData.length;
      var getComponent = reactExports.useCallback(function(path2, defaultComponent) {
        return get$2(components, path2) || defaultComponent;
      }, [components]);
      var getRowKey = reactExports.useMemo(function() {
        if (typeof rowKey === "function") {
          return rowKey;
        }
        return function(record) {
          var key = record && record[rowKey];
          return key;
        };
      }, [rowKey]);
      var _useHover = useHover(), _useHover2 = _slicedToArray(_useHover, 3), startRow = _useHover2[0], endRow = _useHover2[1], onHover = _useHover2[2];
      var _useExpand = useExpand(props, mergedData, getRowKey), _useExpand2 = _slicedToArray(_useExpand, 6), expandableConfig = _useExpand2[0], expandableType = _useExpand2[1], mergedExpandedKeys = _useExpand2[2], mergedExpandIcon = _useExpand2[3], mergedChildrenColumnName = _useExpand2[4], onTriggerExpand = _useExpand2[5];
      var _React$useState = reactExports.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), componentWidth = _React$useState2[0], setComponentWidth = _React$useState2[1];
      var _useColumns = useColumns(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, props), expandableConfig), {}, {
        expandable: !!expandableConfig.expandedRowRender,
        columnTitle: expandableConfig.columnTitle,
        expandedKeys: mergedExpandedKeys,
        getRowKey,
        // https://github.com/ant-design/ant-design/issues/23894
        onTriggerExpand,
        expandIcon: mergedExpandIcon,
        expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
        direction
      }), internalHooks === INTERNAL_HOOKS ? transformColumns : null), _useColumns2 = _slicedToArray(_useColumns, 2), columns = _useColumns2[0], flattenColumns = _useColumns2[1];
      var columnContext = reactExports.useMemo(function() {
        return {
          columns,
          flattenColumns
        };
      }, [columns, flattenColumns]);
      var fullTableRef = reactExports.useRef();
      var scrollHeaderRef = reactExports.useRef();
      var scrollBodyRef = reactExports.useRef();
      var scrollBodyContainerRef = reactExports.useRef();
      var scrollSummaryRef = reactExports.useRef();
      var _React$useState3 = reactExports.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), pingedLeft = _React$useState4[0], setPingedLeft = _React$useState4[1];
      var _React$useState5 = reactExports.useState(false), _React$useState6 = _slicedToArray(_React$useState5, 2), pingedRight = _React$useState6[0], setPingedRight = _React$useState6[1];
      var _useLayoutState = useLayoutState(/* @__PURE__ */ new Map()), _useLayoutState2 = _slicedToArray(_useLayoutState, 2), colsWidths = _useLayoutState2[0], updateColsWidths = _useLayoutState2[1];
      var colsKeys = getColumnsKey(flattenColumns);
      var pureColWidths = colsKeys.map(function(columnKey) {
        return colsWidths.get(columnKey);
      });
      var colWidths = reactExports.useMemo(function() {
        return pureColWidths;
      }, [pureColWidths.join("_")]);
      var stickyOffsets = useStickyOffsets(colWidths, flattenColumns.length, direction);
      var fixHeader = scroll && validateValue(scroll.y);
      var horizonScroll = scroll && validateValue(scroll.x) || Boolean(expandableConfig.fixed);
      var fixColumn = horizonScroll && flattenColumns.some(function(_ref) {
        var fixed = _ref.fixed;
        return fixed;
      });
      var stickyRef = reactExports.useRef();
      var _useSticky = useSticky(sticky, prefixCls), isSticky = _useSticky.isSticky, offsetHeader = _useSticky.offsetHeader, offsetSummary = _useSticky.offsetSummary, offsetScroll = _useSticky.offsetScroll, stickyClassName = _useSticky.stickyClassName, container2 = _useSticky.container;
      var summaryNode = reactExports.useMemo(function() {
        return summary === null || summary === void 0 ? void 0 : summary(mergedData);
      }, [summary, mergedData]);
      var fixFooter = (fixHeader || isSticky) && /* @__PURE__ */ reactExports.isValidElement(summaryNode) && summaryNode.type === Summary && summaryNode.props.fixed;
      var scrollXStyle;
      var scrollYStyle;
      var scrollTableStyle;
      if (fixHeader) {
        scrollYStyle = {
          overflowY: "scroll",
          maxHeight: scroll.y
        };
      }
      if (horizonScroll) {
        scrollXStyle = {
          overflowX: "auto"
        };
        if (!fixHeader) {
          scrollYStyle = {
            overflowY: "hidden"
          };
        }
        scrollTableStyle = {
          width: (scroll === null || scroll === void 0 ? void 0 : scroll.x) === true ? "auto" : scroll === null || scroll === void 0 ? void 0 : scroll.x,
          minWidth: "100%"
        };
      }
      var onColumnResize = reactExports.useCallback(function(columnKey, width) {
        if (isVisible$1(fullTableRef.current)) {
          updateColsWidths(function(widths) {
            if (widths.get(columnKey) !== width) {
              var newWidths = new Map(widths);
              newWidths.set(columnKey, width);
              return newWidths;
            }
            return widths;
          });
        }
      }, []);
      var _useTimeoutLock = useTimeoutLock(null), _useTimeoutLock2 = _slicedToArray(_useTimeoutLock, 2), setScrollTarget = _useTimeoutLock2[0], getScrollTarget = _useTimeoutLock2[1];
      function forceScroll(scrollLeft, target) {
        if (!target) {
          return;
        }
        if (typeof target === "function") {
          target(scrollLeft);
        } else if (target.scrollLeft !== scrollLeft) {
          target.scrollLeft = scrollLeft;
          if (target.scrollLeft !== scrollLeft) {
            setTimeout(function() {
              target.scrollLeft = scrollLeft;
            }, 0);
          }
        }
      }
      var onScroll = useEvent(function(_ref2) {
        var currentTarget = _ref2.currentTarget, scrollLeft = _ref2.scrollLeft;
        var isRTL = direction === "rtl";
        var mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
        var compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
        if (!getScrollTarget() || getScrollTarget() === compareTarget) {
          var _stickyRef$current;
          setScrollTarget(compareTarget);
          forceScroll(mergedScrollLeft, scrollHeaderRef.current);
          forceScroll(mergedScrollLeft, scrollBodyRef.current);
          forceScroll(mergedScrollLeft, scrollSummaryRef.current);
          forceScroll(mergedScrollLeft, (_stickyRef$current = stickyRef.current) === null || _stickyRef$current === void 0 ? void 0 : _stickyRef$current.setScrollLeft);
        }
        if (currentTarget) {
          var scrollWidth = currentTarget.scrollWidth, clientWidth = currentTarget.clientWidth;
          if (scrollWidth === clientWidth) {
            setPingedLeft(false);
            setPingedRight(false);
            return;
          }
          if (isRTL) {
            setPingedLeft(-mergedScrollLeft < scrollWidth - clientWidth);
            setPingedRight(-mergedScrollLeft > 0);
          } else {
            setPingedLeft(mergedScrollLeft > 0);
            setPingedRight(mergedScrollLeft < scrollWidth - clientWidth);
          }
        }
      });
      var triggerOnScroll = function triggerOnScroll2() {
        if (horizonScroll && scrollBodyRef.current) {
          onScroll({
            currentTarget: scrollBodyRef.current
          });
        } else {
          setPingedLeft(false);
          setPingedRight(false);
        }
      };
      var onFullTableResize = function onFullTableResize2(_ref3) {
        var width = _ref3.width;
        if (width !== componentWidth) {
          triggerOnScroll();
          setComponentWidth(fullTableRef.current ? fullTableRef.current.offsetWidth : width);
        }
      };
      var mounted = reactExports.useRef(false);
      reactExports.useEffect(function() {
        if (mounted.current) {
          triggerOnScroll();
        }
      }, [horizonScroll, data2, columns.length]);
      reactExports.useEffect(function() {
        mounted.current = true;
      }, []);
      var _React$useState7 = reactExports.useState(0), _React$useState8 = _slicedToArray(_React$useState7, 2), scrollbarSize = _React$useState8[0], setScrollbarSize = _React$useState8[1];
      var _React$useState9 = reactExports.useState(true), _React$useState10 = _slicedToArray(_React$useState9, 2), supportSticky = _React$useState10[0], setSupportSticky = _React$useState10[1];
      reactExports.useEffect(function() {
        if (scrollBodyRef.current instanceof Element) {
          setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.current).width);
        } else {
          setScrollbarSize(getTargetScrollBarSize(scrollBodyContainerRef.current).width);
        }
        setSupportSticky(isStyleSupport("position", "sticky"));
      }, []);
      reactExports.useEffect(function() {
        if (internalHooks === INTERNAL_HOOKS && internalRefs) {
          internalRefs.body.current = scrollBodyRef.current;
        }
      });
      var renderFixedHeaderTable = reactExports.useCallback(function(fixedHolderPassProps) {
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Header$2, fixedHolderPassProps), fixFooter === "top" && /* @__PURE__ */ reactExports.createElement(Footer$1, fixedHolderPassProps, summaryNode));
      }, [fixFooter, summaryNode]);
      var renderFixedFooterTable = reactExports.useCallback(function(fixedHolderPassProps) {
        return /* @__PURE__ */ reactExports.createElement(Footer$1, fixedHolderPassProps, summaryNode);
      }, [summaryNode]);
      var TableComponent = getComponent(["table"], "table");
      var mergedTableLayout = reactExports.useMemo(function() {
        if (tableLayout) {
          return tableLayout;
        }
        if (fixColumn) {
          return (scroll === null || scroll === void 0 ? void 0 : scroll.x) === "max-content" ? "auto" : "fixed";
        }
        if (fixHeader || isSticky || flattenColumns.some(function(_ref4) {
          var ellipsis = _ref4.ellipsis;
          return ellipsis;
        })) {
          return "fixed";
        }
        return "auto";
      }, [fixHeader, fixColumn, flattenColumns, tableLayout, isSticky]);
      var groupTableNode;
      var headerProps = {
        colWidths,
        columCount: flattenColumns.length,
        stickyOffsets,
        onHeaderRow,
        fixHeader,
        scroll
      };
      var emptyNode = reactExports.useMemo(function() {
        if (hasData) {
          return null;
        }
        if (typeof emptyText === "function") {
          return emptyText();
        }
        return emptyText;
      }, [hasData, emptyText]);
      var bodyTable = /* @__PURE__ */ reactExports.createElement(Body$1, {
        data: mergedData,
        measureColumnWidth: fixHeader || horizonScroll || isSticky,
        expandedKeys: mergedExpandedKeys,
        rowExpandable: expandableConfig.rowExpandable,
        getRowKey,
        onRow,
        emptyNode,
        childrenColumnName: mergedChildrenColumnName
      });
      var bodyColGroup = /* @__PURE__ */ reactExports.createElement(ColGroup, {
        colWidths: flattenColumns.map(function(_ref5) {
          var width = _ref5.width;
          return width;
        }),
        columns: flattenColumns
      });
      var captionElement = caption !== null && caption !== void 0 ? /* @__PURE__ */ reactExports.createElement("caption", {
        className: "".concat(prefixCls, "-caption")
      }, caption) : void 0;
      var customizeScrollBody = getComponent(["body"]);
      var dataProps = pickAttrs(props, {
        data: true
      });
      var ariaProps = pickAttrs(props, {
        aria: true
      });
      if (fixHeader || isSticky) {
        var bodyContent;
        if (typeof customizeScrollBody === "function") {
          bodyContent = customizeScrollBody(mergedData, {
            scrollbarSize,
            ref: scrollBodyRef,
            onScroll
          });
          headerProps.colWidths = flattenColumns.map(function(_ref6, index2) {
            var width = _ref6.width;
            var colWidth = index2 === columns.length - 1 ? width - scrollbarSize : width;
            if (typeof colWidth === "number" && !Number.isNaN(colWidth)) {
              return colWidth;
            }
            warningOnce$1(false, "When use `components.body` with render props. Each column should have a fixed `width` value.");
            return 0;
          });
        } else {
          bodyContent = /* @__PURE__ */ reactExports.createElement("div", {
            style: _objectSpread2$3(_objectSpread2$3({}, scrollXStyle), scrollYStyle),
            onScroll,
            ref: scrollBodyRef,
            className: classNames("".concat(prefixCls, "-body"))
          }, /* @__PURE__ */ reactExports.createElement(TableComponent, _extends$2({
            style: _objectSpread2$3(_objectSpread2$3({}, scrollTableStyle), {}, {
              tableLayout: mergedTableLayout
            })
          }, ariaProps), captionElement, bodyColGroup, bodyTable, !fixFooter && summaryNode && /* @__PURE__ */ reactExports.createElement(Footer$1, {
            stickyOffsets,
            flattenColumns,
            columns
          }, summaryNode)));
        }
        var fixedHolderProps = _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({
          noData: !mergedData.length,
          maxContentScroll: horizonScroll && scroll.x === "max-content"
        }, headerProps), columnContext), {}, {
          direction,
          stickyClassName,
          onScroll
        });
        groupTableNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, showHeader !== false && /* @__PURE__ */ reactExports.createElement(FixedHolder$1, _extends$2({}, fixedHolderProps, {
          stickyTopOffset: offsetHeader,
          className: "".concat(prefixCls, "-header"),
          ref: scrollHeaderRef
        }), renderFixedHeaderTable), bodyContent, fixFooter && fixFooter !== "top" && /* @__PURE__ */ reactExports.createElement(FixedHolder$1, _extends$2({}, fixedHolderProps, {
          stickyBottomOffset: offsetSummary,
          className: "".concat(prefixCls, "-summary"),
          ref: scrollSummaryRef
        }), renderFixedFooterTable), isSticky && /* @__PURE__ */ reactExports.createElement(StickyScrollBar$1, {
          ref: stickyRef,
          offsetScroll,
          scrollBodyRef,
          onScroll,
          container: container2
        }));
      } else {
        groupTableNode = /* @__PURE__ */ reactExports.createElement("div", {
          style: _objectSpread2$3(_objectSpread2$3({}, scrollXStyle), scrollYStyle),
          className: classNames("".concat(prefixCls, "-content")),
          onScroll,
          ref: scrollBodyRef
        }, /* @__PURE__ */ reactExports.createElement(TableComponent, _extends$2({
          style: _objectSpread2$3(_objectSpread2$3({}, scrollTableStyle), {}, {
            tableLayout: mergedTableLayout
          })
        }, ariaProps), captionElement, bodyColGroup, showHeader !== false && /* @__PURE__ */ reactExports.createElement(Header$2, _extends$2({}, headerProps, columnContext)), bodyTable, summaryNode && /* @__PURE__ */ reactExports.createElement(Footer$1, {
          stickyOffsets,
          flattenColumns,
          columns
        }, summaryNode)));
      }
      var fullTable = /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        className: classNames(prefixCls, className, (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$7(_classNames, "".concat(prefixCls, "-ping-left"), pingedLeft), _defineProperty$7(_classNames, "".concat(prefixCls, "-ping-right"), pingedRight), _defineProperty$7(_classNames, "".concat(prefixCls, "-layout-fixed"), tableLayout === "fixed"), _defineProperty$7(_classNames, "".concat(prefixCls, "-fixed-header"), fixHeader), _defineProperty$7(_classNames, "".concat(prefixCls, "-fixed-column"), fixColumn), _defineProperty$7(_classNames, "".concat(prefixCls, "-scroll-horizontal"), horizonScroll), _defineProperty$7(_classNames, "".concat(prefixCls, "-has-fix-left"), flattenColumns[0] && flattenColumns[0].fixed), _defineProperty$7(_classNames, "".concat(prefixCls, "-has-fix-right"), flattenColumns[flattenColumns.length - 1] && flattenColumns[flattenColumns.length - 1].fixed === "right"), _classNames)),
        style: style2,
        id: id2,
        ref: fullTableRef
      }, dataProps), title && /* @__PURE__ */ reactExports.createElement(Panel, {
        className: "".concat(prefixCls, "-title")
      }, title(mergedData)), /* @__PURE__ */ reactExports.createElement("div", {
        ref: scrollBodyContainerRef,
        className: "".concat(prefixCls, "-container")
      }, groupTableNode), footer2 && /* @__PURE__ */ reactExports.createElement(Panel, {
        className: "".concat(prefixCls, "-footer")
      }, footer2(mergedData)));
      if (horizonScroll) {
        fullTable = /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
          onResize: onFullTableResize
        }, fullTable);
      }
      var fixedInfoList = useFixedInfo(flattenColumns, stickyOffsets, direction, columns);
      var TableContextValue = reactExports.useMemo(function() {
        return {
          // Table
          prefixCls,
          getComponent,
          scrollbarSize,
          direction,
          fixedInfoList,
          isSticky,
          supportSticky,
          componentWidth,
          fixHeader,
          fixColumn,
          horizonScroll,
          // Body
          tableLayout: mergedTableLayout,
          rowClassName,
          expandedRowClassName: expandableConfig.expandedRowClassName,
          expandIcon: mergedExpandIcon,
          expandableType,
          expandRowByClick: expandableConfig.expandRowByClick,
          expandedRowRender: expandableConfig.expandedRowRender,
          onTriggerExpand,
          expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
          indentSize: expandableConfig.indentSize,
          allColumnsFixedLeft: flattenColumns.every(function(col) {
            return col.fixed === "left";
          }),
          // Column
          columns,
          flattenColumns,
          onColumnResize,
          // Row
          hoverStartRow: startRow,
          hoverEndRow: endRow,
          onHover
        };
      }, [
        // Table
        prefixCls,
        getComponent,
        scrollbarSize,
        direction,
        fixedInfoList,
        isSticky,
        supportSticky,
        componentWidth,
        fixHeader,
        fixColumn,
        horizonScroll,
        // Body
        mergedTableLayout,
        rowClassName,
        expandableConfig.expandedRowClassName,
        mergedExpandIcon,
        expandableType,
        expandableConfig.expandRowByClick,
        expandableConfig.expandedRowRender,
        onTriggerExpand,
        expandableConfig.expandIconColumnIndex,
        expandableConfig.indentSize,
        // Column
        columns,
        flattenColumns,
        onColumnResize,
        // Row
        startRow,
        endRow,
        onHover
      ]);
      return /* @__PURE__ */ reactExports.createElement(TableContext.Provider, {
        value: TableContextValue
      }, fullTable);
    }
    function genTable(shouldTriggerRender) {
      return makeImmutable(Table$2, shouldTriggerRender);
    }
    var ImmutableTable = genTable();
    ImmutableTable.EXPAND_COLUMN = EXPAND_COLUMN;
    ImmutableTable.Column = Column$1;
    ImmutableTable.ColumnGroup = ColumnGroup$1;
    ImmutableTable.Summary = FooterComponents;
    function Column(_) {
      return null;
    }
    function ColumnGroup(_) {
      return null;
    }
    function renderExpandIcon(locale2) {
      return function expandIcon(_ref) {
        let {
          prefixCls,
          onExpand,
          record,
          expanded,
          expandable
        } = _ref;
        const iconPrefix = `${prefixCls}-row-expand-icon`;
        return /* @__PURE__ */ reactExports.createElement("button", {
          type: "button",
          onClick: (e2) => {
            onExpand(record, e2);
            e2.stopPropagation();
          },
          className: classNames(iconPrefix, {
            [`${iconPrefix}-spaced`]: !expandable,
            [`${iconPrefix}-expanded`]: expandable && expanded,
            [`${iconPrefix}-collapsed`]: expandable && !expanded
          }),
          "aria-label": expanded ? locale2.collapse : locale2.expand,
          "aria-expanded": expanded
        });
      };
    }
    function getColumnKey(column2, defaultKey) {
      if ("key" in column2 && column2.key !== void 0 && column2.key !== null) {
        return column2.key;
      }
      if (column2.dataIndex) {
        return Array.isArray(column2.dataIndex) ? column2.dataIndex.join(".") : column2.dataIndex;
      }
      return defaultKey;
    }
    function getColumnPos(index2, pos) {
      return pos ? `${pos}-${index2}` : `${index2}`;
    }
    function renderColumnTitle(title, props) {
      if (typeof title === "function") {
        return title(props);
      }
      return title;
    }
    function safeColumnTitle(title, props) {
      const res = renderColumnTitle(title, props);
      if (Object.prototype.toString.call(res) === "[object Object]")
        return "";
      return res;
    }
    function _objectDestructuringEmpty(obj) {
      if (obj == null)
        throw new TypeError("Cannot destructure " + obj);
    }
    var _excluded$6 = ["className", "style", "motion", "motionNodes", "motionType", "onMotionStart", "onMotionEnd", "active", "treeNodeRequiredProps"];
    var MotionTreeNode = function MotionTreeNode2(_ref, ref) {
      var className = _ref.className, style2 = _ref.style, motion2 = _ref.motion, motionNodes = _ref.motionNodes, motionType = _ref.motionType, onOriginMotionStart = _ref.onMotionStart, onOriginMotionEnd = _ref.onMotionEnd, active = _ref.active, treeNodeRequiredProps = _ref.treeNodeRequiredProps, props = _objectWithoutProperties$1(_ref, _excluded$6);
      var _React$useState = reactExports.useState(true), _React$useState2 = _slicedToArray(_React$useState, 2), visible = _React$useState2[0], setVisible = _React$useState2[1];
      var _React$useContext = reactExports.useContext(TreeContext), prefixCls = _React$useContext.prefixCls;
      var motionedRef = reactExports.useRef(false);
      var onMotionEnd = function onMotionEnd2() {
        if (!motionedRef.current) {
          onOriginMotionEnd();
        }
        motionedRef.current = true;
      };
      reactExports.useEffect(function() {
        if (motionNodes && motionType === "hide" && visible) {
          setVisible(false);
        }
      }, [motionNodes]);
      reactExports.useEffect(function() {
        if (motionNodes) {
          onOriginMotionStart();
        }
        return function() {
          if (motionNodes) {
            onMotionEnd();
          }
        };
      }, []);
      if (motionNodes) {
        return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$2({
          ref,
          visible
        }, motion2, {
          motionAppear: motionType === "show",
          onAppearEnd: onMotionEnd,
          onLeaveEnd: onMotionEnd
        }), function(_ref2, motionRef) {
          var motionClassName = _ref2.className, motionStyle = _ref2.style;
          return /* @__PURE__ */ reactExports.createElement("div", {
            ref: motionRef,
            className: classNames("".concat(prefixCls, "-treenode-motion"), motionClassName),
            style: motionStyle
          }, motionNodes.map(function(treeNode) {
            var restProps = _extends$2({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
            delete restProps.children;
            var treeNodeProps = getTreeNodeProps(key, treeNodeRequiredProps);
            return /* @__PURE__ */ reactExports.createElement(ContextTreeNode, _extends$2({}, restProps, treeNodeProps, {
              title,
              active,
              data: treeNode.data,
              key,
              isStart,
              isEnd
            }));
          }));
        });
      }
      return /* @__PURE__ */ reactExports.createElement(ContextTreeNode, _extends$2({
        domRef: ref,
        className,
        style: style2
      }, props, {
        active
      }));
    };
    MotionTreeNode.displayName = "MotionTreeNode";
    var RefMotionTreeNode = /* @__PURE__ */ reactExports.forwardRef(MotionTreeNode);
    function findExpandedKeys() {
      var prev2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var next2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var prevLen = prev2.length;
      var nextLen = next2.length;
      if (Math.abs(prevLen - nextLen) !== 1) {
        return {
          add: false,
          key: null
        };
      }
      function find(shorter, longer) {
        var cache2 = /* @__PURE__ */ new Map();
        shorter.forEach(function(key) {
          cache2.set(key, true);
        });
        var keys2 = longer.filter(function(key) {
          return !cache2.has(key);
        });
        return keys2.length === 1 ? keys2[0] : null;
      }
      if (prevLen < nextLen) {
        return {
          add: true,
          key: find(prev2, next2)
        };
      }
      return {
        add: false,
        key: find(next2, prev2)
      };
    }
    function getExpandRange(shorter, longer, key) {
      var shorterStartIndex = shorter.findIndex(function(data2) {
        return data2.key === key;
      });
      var shorterEndNode = shorter[shorterStartIndex + 1];
      var longerStartIndex = longer.findIndex(function(data2) {
        return data2.key === key;
      });
      if (shorterEndNode) {
        var longerEndIndex = longer.findIndex(function(data2) {
          return data2.key === shorterEndNode.key;
        });
        return longer.slice(longerStartIndex + 1, longerEndIndex);
      }
      return longer.slice(longerStartIndex + 1);
    }
    var _excluded$5 = ["prefixCls", "data", "selectable", "checkable", "expandedKeys", "selectedKeys", "checkedKeys", "loadedKeys", "loadingKeys", "halfCheckedKeys", "keyEntities", "disabled", "dragging", "dragOverNodeKey", "dropPosition", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabIndex", "onKeyDown", "onFocus", "onBlur", "onActiveChange", "onListChangeStart", "onListChangeEnd"];
    var HIDDEN_STYLE = {
      width: 0,
      height: 0,
      display: "flex",
      overflow: "hidden",
      opacity: 0,
      border: 0,
      padding: 0,
      margin: 0
    };
    var noop$1 = function noop2() {
    };
    var MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random());
    var MotionNode = {
      key: MOTION_KEY
    };
    var MotionEntity = {
      key: MOTION_KEY,
      level: 0,
      index: 0,
      pos: "0",
      node: MotionNode,
      nodes: [MotionNode]
    };
    var MotionFlattenData = {
      parent: null,
      children: [],
      pos: MotionEntity.pos,
      data: MotionNode,
      title: null,
      key: MOTION_KEY,
      /** Hold empty list here since we do not use it */
      isStart: [],
      isEnd: []
    };
    function getMinimumRangeTransitionRange(list2, virtual, height, itemHeight) {
      if (virtual === false || !height) {
        return list2;
      }
      return list2.slice(0, Math.ceil(height / itemHeight) + 1);
    }
    function itemKey(item) {
      var key = item.key, pos = item.pos;
      return getKey(key, pos);
    }
    function getAccessibilityPath(item) {
      var path2 = String(item.data.key);
      var current = item;
      while (current.parent) {
        current = current.parent;
        path2 = "".concat(current.data.key, " > ").concat(path2);
      }
      return path2;
    }
    var NodeList = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, data2 = props.data;
      props.selectable;
      props.checkable;
      var expandedKeys = props.expandedKeys, selectedKeys = props.selectedKeys, checkedKeys = props.checkedKeys, loadedKeys = props.loadedKeys, loadingKeys = props.loadingKeys, halfCheckedKeys = props.halfCheckedKeys, keyEntities = props.keyEntities, disabled = props.disabled, dragging = props.dragging, dragOverNodeKey = props.dragOverNodeKey, dropPosition = props.dropPosition, motion2 = props.motion, height = props.height, itemHeight = props.itemHeight, virtual = props.virtual, focusable2 = props.focusable, activeItem = props.activeItem, focused = props.focused, tabIndex = props.tabIndex, onKeyDown2 = props.onKeyDown, onFocus = props.onFocus, onBlur = props.onBlur, onActiveChange = props.onActiveChange, onListChangeStart = props.onListChangeStart, onListChangeEnd = props.onListChangeEnd, domProps = _objectWithoutProperties$1(props, _excluded$5);
      var listRef = reactExports.useRef(null);
      var indentMeasurerRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, function() {
        return {
          scrollTo: function scrollTo2(scroll) {
            listRef.current.scrollTo(scroll);
          },
          getIndentWidth: function getIndentWidth() {
            return indentMeasurerRef.current.offsetWidth;
          }
        };
      });
      var _React$useState = reactExports.useState(expandedKeys), _React$useState2 = _slicedToArray(_React$useState, 2), prevExpandedKeys = _React$useState2[0], setPrevExpandedKeys = _React$useState2[1];
      var _React$useState3 = reactExports.useState(data2), _React$useState4 = _slicedToArray(_React$useState3, 2), prevData = _React$useState4[0], setPrevData = _React$useState4[1];
      var _React$useState5 = reactExports.useState(data2), _React$useState6 = _slicedToArray(_React$useState5, 2), transitionData = _React$useState6[0], setTransitionData = _React$useState6[1];
      var _React$useState7 = reactExports.useState([]), _React$useState8 = _slicedToArray(_React$useState7, 2), transitionRange = _React$useState8[0], setTransitionRange = _React$useState8[1];
      var _React$useState9 = reactExports.useState(null), _React$useState10 = _slicedToArray(_React$useState9, 2), motionType = _React$useState10[0], setMotionType = _React$useState10[1];
      var dataRef = reactExports.useRef(data2);
      dataRef.current = data2;
      function onMotionEnd() {
        var latestData = dataRef.current;
        setPrevData(latestData);
        setTransitionData(latestData);
        setTransitionRange([]);
        setMotionType(null);
        onListChangeEnd();
      }
      reactExports.useEffect(function() {
        setPrevExpandedKeys(expandedKeys);
        var diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
        if (diffExpanded.key !== null) {
          if (diffExpanded.add) {
            var keyIndex = prevData.findIndex(function(_ref) {
              var key = _ref.key;
              return key === diffExpanded.key;
            });
            var rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data2, diffExpanded.key), virtual, height, itemHeight);
            var newTransitionData = prevData.slice();
            newTransitionData.splice(keyIndex + 1, 0, MotionFlattenData);
            setTransitionData(newTransitionData);
            setTransitionRange(rangeNodes);
            setMotionType("show");
          } else {
            var _keyIndex = data2.findIndex(function(_ref2) {
              var key = _ref2.key;
              return key === diffExpanded.key;
            });
            var _rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data2, prevData, diffExpanded.key), virtual, height, itemHeight);
            var _newTransitionData = data2.slice();
            _newTransitionData.splice(_keyIndex + 1, 0, MotionFlattenData);
            setTransitionData(_newTransitionData);
            setTransitionRange(_rangeNodes);
            setMotionType("hide");
          }
        } else if (prevData !== data2) {
          setPrevData(data2);
          setTransitionData(data2);
        }
      }, [expandedKeys, data2]);
      reactExports.useEffect(function() {
        if (!dragging) {
          onMotionEnd();
        }
      }, [dragging]);
      var mergedData = motion2 ? transitionData : data2;
      var treeNodeRequiredProps = {
        expandedKeys,
        selectedKeys,
        loadedKeys,
        loadingKeys,
        checkedKeys,
        halfCheckedKeys,
        dragOverNodeKey,
        dropPosition,
        keyEntities
      };
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, focused && activeItem && /* @__PURE__ */ reactExports.createElement("span", {
        style: HIDDEN_STYLE,
        "aria-live": "assertive"
      }, getAccessibilityPath(activeItem)), /* @__PURE__ */ reactExports.createElement("div", null, /* @__PURE__ */ reactExports.createElement("input", {
        style: HIDDEN_STYLE,
        disabled: focusable2 === false || disabled,
        tabIndex: focusable2 !== false ? tabIndex : null,
        onKeyDown: onKeyDown2,
        onFocus,
        onBlur,
        value: "",
        onChange: noop$1,
        "aria-label": "for screen reader"
      })), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-treenode"),
        "aria-hidden": true,
        style: {
          position: "absolute",
          pointerEvents: "none",
          visibility: "hidden",
          height: 0,
          overflow: "hidden",
          border: 0,
          padding: 0
        }
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-indent")
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: indentMeasurerRef,
        className: "".concat(prefixCls, "-indent-unit")
      }))), /* @__PURE__ */ reactExports.createElement(List$1, _extends$2({}, domProps, {
        data: mergedData,
        itemKey,
        height,
        fullHeight: false,
        virtual,
        itemHeight,
        prefixCls: "".concat(prefixCls, "-list"),
        ref: listRef,
        onVisibleChange: function onVisibleChange(originList, fullList) {
          var originSet = new Set(originList);
          var restList = fullList.filter(function(item) {
            return !originSet.has(item);
          });
          if (restList.some(function(item) {
            return itemKey(item) === MOTION_KEY;
          })) {
            onMotionEnd();
          }
        }
      }), function(treeNode) {
        var pos = treeNode.pos, restProps = _extends$2({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
        var mergedKey = getKey(key, pos);
        delete restProps.key;
        delete restProps.children;
        var treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
        return /* @__PURE__ */ reactExports.createElement(RefMotionTreeNode, _extends$2({}, restProps, treeNodeProps, {
          title,
          active: !!activeItem && key === activeItem.key,
          pos,
          data: treeNode.data,
          isStart,
          isEnd,
          motion: motion2,
          motionNodes: key === MOTION_KEY ? transitionRange : null,
          motionType,
          onMotionStart: onListChangeStart,
          onMotionEnd,
          treeNodeRequiredProps,
          onMouseMove: function onMouseMove() {
            onActiveChange(null);
          }
        }));
      }));
    });
    NodeList.displayName = "NodeList";
    function DropIndicator(_ref) {
      var dropPosition = _ref.dropPosition, dropLevelOffset = _ref.dropLevelOffset, indent = _ref.indent;
      var style2 = {
        pointerEvents: "none",
        position: "absolute",
        right: 0,
        backgroundColor: "red",
        height: 2
      };
      switch (dropPosition) {
        case -1:
          style2.top = 0;
          style2.left = -dropLevelOffset * indent;
          break;
        case 1:
          style2.bottom = 0;
          style2.left = -dropLevelOffset * indent;
          break;
        case 0:
          style2.bottom = 0;
          style2.left = indent;
          break;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        style: style2
      });
    }
    var MAX_RETRY_TIMES = 10;
    var Tree$3 = /* @__PURE__ */ function(_React$Component) {
      _inherits(Tree2, _React$Component);
      var _super = _createSuper(Tree2);
      function Tree2() {
        var _this;
        _classCallCheck(this, Tree2);
        for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
          _args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(_args));
        _this.destroyed = false;
        _this.delayedDragEnterLogic = void 0;
        _this.loadingRetryTimes = {};
        _this.state = {
          keyEntities: {},
          indent: null,
          selectedKeys: [],
          checkedKeys: [],
          halfCheckedKeys: [],
          loadedKeys: [],
          loadingKeys: [],
          expandedKeys: [],
          draggingNodeKey: null,
          dragChildrenKeys: [],
          // dropTargetKey is the key of abstract-drop-node
          // the abstract-drop-node is the real drop node when drag and drop
          // not the DOM drag over node
          dropTargetKey: null,
          dropPosition: null,
          dropContainerKey: null,
          dropLevelOffset: null,
          dropTargetPos: null,
          dropAllowed: true,
          // the abstract-drag-over-node
          // if mouse is on the bottom of top dom node or no the top of the bottom dom node
          // abstract-drag-over-node is the top node
          dragOverNodeKey: null,
          treeData: [],
          flattenNodes: [],
          focused: false,
          activeKey: null,
          listChanging: false,
          prevProps: null,
          fieldNames: fillFieldNames()
        };
        _this.dragStartMousePosition = null;
        _this.dragNode = void 0;
        _this.currentMouseOverDroppableNodeKey = null;
        _this.listRef = /* @__PURE__ */ reactExports.createRef();
        _this.onNodeDragStart = function(event, node2) {
          var _this$state = _this.state, expandedKeys = _this$state.expandedKeys, keyEntities = _this$state.keyEntities;
          var onDragStart = _this.props.onDragStart;
          var eventKey = node2.props.eventKey;
          _this.dragNode = node2;
          _this.dragStartMousePosition = {
            x: event.clientX,
            y: event.clientY
          };
          var newExpandedKeys = arrDel(expandedKeys, eventKey);
          _this.setState({
            draggingNodeKey: eventKey,
            dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
            indent: _this.listRef.current.getIndentWidth()
          });
          _this.setExpandedKeys(newExpandedKeys);
          window.addEventListener("dragend", _this.onWindowDragEnd);
          onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart({
            event,
            node: convertNodePropsToEventData(node2.props)
          });
        };
        _this.onNodeDragEnter = function(event, node2) {
          var _this$state2 = _this.state, expandedKeys = _this$state2.expandedKeys, keyEntities = _this$state2.keyEntities, dragChildrenKeys = _this$state2.dragChildrenKeys, flattenNodes = _this$state2.flattenNodes, indent = _this$state2.indent;
          var _this$props = _this.props, onDragEnter = _this$props.onDragEnter, onExpand = _this$props.onExpand, allowDrop = _this$props.allowDrop, direction = _this$props.direction;
          var _node$props = node2.props, pos = _node$props.pos, eventKey = _node$props.eventKey;
          var _assertThisInitialize = _assertThisInitialized(_this), dragNode = _assertThisInitialize.dragNode;
          if (_this.currentMouseOverDroppableNodeKey !== eventKey) {
            _this.currentMouseOverDroppableNodeKey = eventKey;
          }
          if (!dragNode) {
            _this.resetDragState();
            return;
          }
          var _calcDropPosition = calcDropPosition(event, dragNode, node2, indent, _this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition.dropPosition, dropLevelOffset = _calcDropPosition.dropLevelOffset, dropTargetKey = _calcDropPosition.dropTargetKey, dropContainerKey = _calcDropPosition.dropContainerKey, dropTargetPos = _calcDropPosition.dropTargetPos, dropAllowed = _calcDropPosition.dropAllowed, dragOverNodeKey = _calcDropPosition.dragOverNodeKey;
          if (
            // don't allow drop inside its children
            dragChildrenKeys.indexOf(dropTargetKey) !== -1 || // don't allow drop when drop is not allowed caculated by calcDropPosition
            !dropAllowed
          ) {
            _this.resetDragState();
            return;
          }
          if (!_this.delayedDragEnterLogic) {
            _this.delayedDragEnterLogic = {};
          }
          Object.keys(_this.delayedDragEnterLogic).forEach(function(key) {
            clearTimeout(_this.delayedDragEnterLogic[key]);
          });
          if (dragNode.props.eventKey !== node2.props.eventKey) {
            event.persist();
            _this.delayedDragEnterLogic[pos] = window.setTimeout(function() {
              if (_this.state.draggingNodeKey === null)
                return;
              var newExpandedKeys = _toConsumableArray(expandedKeys);
              var entity = keyEntities[node2.props.eventKey];
              if (entity && (entity.children || []).length) {
                newExpandedKeys = arrAdd(expandedKeys, node2.props.eventKey);
              }
              if (!("expandedKeys" in _this.props)) {
                _this.setExpandedKeys(newExpandedKeys);
              }
              onExpand === null || onExpand === void 0 ? void 0 : onExpand(newExpandedKeys, {
                node: convertNodePropsToEventData(node2.props),
                expanded: true,
                nativeEvent: event.nativeEvent
              });
            }, 800);
          }
          if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
            _this.resetDragState();
            return;
          }
          _this.setState({
            dragOverNodeKey,
            dropPosition,
            dropLevelOffset,
            dropTargetKey,
            dropContainerKey,
            dropTargetPos,
            dropAllowed
          });
          onDragEnter === null || onDragEnter === void 0 ? void 0 : onDragEnter({
            event,
            node: convertNodePropsToEventData(node2.props),
            expandedKeys
          });
        };
        _this.onNodeDragOver = function(event, node2) {
          var _this$state3 = _this.state, dragChildrenKeys = _this$state3.dragChildrenKeys, flattenNodes = _this$state3.flattenNodes, keyEntities = _this$state3.keyEntities, expandedKeys = _this$state3.expandedKeys, indent = _this$state3.indent;
          var _this$props2 = _this.props, onDragOver = _this$props2.onDragOver, allowDrop = _this$props2.allowDrop, direction = _this$props2.direction;
          var _assertThisInitialize2 = _assertThisInitialized(_this), dragNode = _assertThisInitialize2.dragNode;
          if (!dragNode) {
            return;
          }
          var _calcDropPosition2 = calcDropPosition(event, dragNode, node2, indent, _this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition2.dropPosition, dropLevelOffset = _calcDropPosition2.dropLevelOffset, dropTargetKey = _calcDropPosition2.dropTargetKey, dropContainerKey = _calcDropPosition2.dropContainerKey, dropAllowed = _calcDropPosition2.dropAllowed, dropTargetPos = _calcDropPosition2.dropTargetPos, dragOverNodeKey = _calcDropPosition2.dragOverNodeKey;
          if (dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
            return;
          }
          if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
            if (!(_this.state.dropPosition === null && _this.state.dropLevelOffset === null && _this.state.dropTargetKey === null && _this.state.dropContainerKey === null && _this.state.dropTargetPos === null && _this.state.dropAllowed === false && _this.state.dragOverNodeKey === null)) {
              _this.resetDragState();
            }
          } else if (!(dropPosition === _this.state.dropPosition && dropLevelOffset === _this.state.dropLevelOffset && dropTargetKey === _this.state.dropTargetKey && dropContainerKey === _this.state.dropContainerKey && dropTargetPos === _this.state.dropTargetPos && dropAllowed === _this.state.dropAllowed && dragOverNodeKey === _this.state.dragOverNodeKey)) {
            _this.setState({
              dropPosition,
              dropLevelOffset,
              dropTargetKey,
              dropContainerKey,
              dropTargetPos,
              dropAllowed,
              dragOverNodeKey
            });
          }
          onDragOver === null || onDragOver === void 0 ? void 0 : onDragOver({
            event,
            node: convertNodePropsToEventData(node2.props)
          });
        };
        _this.onNodeDragLeave = function(event, node2) {
          if (_this.currentMouseOverDroppableNodeKey === node2.props.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
            _this.resetDragState();
            _this.currentMouseOverDroppableNodeKey = null;
          }
          var onDragLeave = _this.props.onDragLeave;
          onDragLeave === null || onDragLeave === void 0 ? void 0 : onDragLeave({
            event,
            node: convertNodePropsToEventData(node2.props)
          });
        };
        _this.onWindowDragEnd = function(event) {
          _this.onNodeDragEnd(event, null, true);
          window.removeEventListener("dragend", _this.onWindowDragEnd);
        };
        _this.onNodeDragEnd = function(event, node2) {
          var onDragEnd = _this.props.onDragEnd;
          _this.setState({
            dragOverNodeKey: null
          });
          _this.cleanDragState();
          onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd({
            event,
            node: convertNodePropsToEventData(node2.props)
          });
          _this.dragNode = null;
          window.removeEventListener("dragend", _this.onWindowDragEnd);
        };
        _this.onNodeDrop = function(event, node2) {
          var _this$getActiveItem;
          var outsideTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var _this$state4 = _this.state, dragChildrenKeys = _this$state4.dragChildrenKeys, dropPosition = _this$state4.dropPosition, dropTargetKey = _this$state4.dropTargetKey, dropTargetPos = _this$state4.dropTargetPos, dropAllowed = _this$state4.dropAllowed;
          if (!dropAllowed)
            return;
          var onDrop = _this.props.onDrop;
          _this.setState({
            dragOverNodeKey: null
          });
          _this.cleanDragState();
          if (dropTargetKey === null)
            return;
          var abstractDropNodeProps = _objectSpread2$3(_objectSpread2$3({}, getTreeNodeProps(dropTargetKey, _this.getTreeNodeRequiredProps())), {}, {
            active: ((_this$getActiveItem = _this.getActiveItem()) === null || _this$getActiveItem === void 0 ? void 0 : _this$getActiveItem.key) === dropTargetKey,
            data: _this.state.keyEntities[dropTargetKey].node
          });
          var dropToChild = dragChildrenKeys.indexOf(dropTargetKey) !== -1;
          warningOnce$1(!dropToChild, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
          var posArr = posToArr(dropTargetPos);
          var dropResult = {
            event,
            node: convertNodePropsToEventData(abstractDropNodeProps),
            dragNode: _this.dragNode ? convertNodePropsToEventData(_this.dragNode.props) : null,
            dragNodesKeys: [_this.dragNode.props.eventKey].concat(dragChildrenKeys),
            dropToGap: dropPosition !== 0,
            dropPosition: dropPosition + Number(posArr[posArr.length - 1])
          };
          if (!outsideTree) {
            onDrop === null || onDrop === void 0 ? void 0 : onDrop(dropResult);
          }
          _this.dragNode = null;
        };
        _this.cleanDragState = function() {
          var draggingNodeKey = _this.state.draggingNodeKey;
          if (draggingNodeKey !== null) {
            _this.setState({
              draggingNodeKey: null,
              dropPosition: null,
              dropContainerKey: null,
              dropTargetKey: null,
              dropLevelOffset: null,
              dropAllowed: true,
              dragOverNodeKey: null
            });
          }
          _this.dragStartMousePosition = null;
          _this.currentMouseOverDroppableNodeKey = null;
        };
        _this.triggerExpandActionExpand = function(e2, treeNode) {
          var _this$state5 = _this.state, expandedKeys = _this$state5.expandedKeys, flattenNodes = _this$state5.flattenNodes;
          var expanded = treeNode.expanded, key = treeNode.key, isLeaf = treeNode.isLeaf;
          if (isLeaf || e2.shiftKey || e2.metaKey || e2.ctrlKey) {
            return;
          }
          var node2 = flattenNodes.filter(function(nodeItem) {
            return nodeItem.key === key;
          })[0];
          var eventNode = convertNodePropsToEventData(_objectSpread2$3(_objectSpread2$3({}, getTreeNodeProps(key, _this.getTreeNodeRequiredProps())), {}, {
            data: node2.data
          }));
          _this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));
          _this.onNodeExpand(e2, eventNode);
        };
        _this.onNodeClick = function(e2, treeNode) {
          var _this$props3 = _this.props, onClick = _this$props3.onClick, expandAction = _this$props3.expandAction;
          if (expandAction === "click") {
            _this.triggerExpandActionExpand(e2, treeNode);
          }
          onClick === null || onClick === void 0 ? void 0 : onClick(e2, treeNode);
        };
        _this.onNodeDoubleClick = function(e2, treeNode) {
          var _this$props4 = _this.props, onDoubleClick = _this$props4.onDoubleClick, expandAction = _this$props4.expandAction;
          if (expandAction === "doubleClick") {
            _this.triggerExpandActionExpand(e2, treeNode);
          }
          onDoubleClick === null || onDoubleClick === void 0 ? void 0 : onDoubleClick(e2, treeNode);
        };
        _this.onNodeSelect = function(e2, treeNode) {
          var selectedKeys = _this.state.selectedKeys;
          var _this$state6 = _this.state, keyEntities = _this$state6.keyEntities, fieldNames = _this$state6.fieldNames;
          var _this$props5 = _this.props, onSelect = _this$props5.onSelect, multiple = _this$props5.multiple;
          var selected = treeNode.selected;
          var key = treeNode[fieldNames.key];
          var targetSelected = !selected;
          if (!targetSelected) {
            selectedKeys = arrDel(selectedKeys, key);
          } else if (!multiple) {
            selectedKeys = [key];
          } else {
            selectedKeys = arrAdd(selectedKeys, key);
          }
          var selectedNodes = selectedKeys.map(function(selectedKey) {
            var entity = keyEntities[selectedKey];
            if (!entity)
              return null;
            return entity.node;
          }).filter(function(node2) {
            return node2;
          });
          _this.setUncontrolledState({
            selectedKeys
          });
          onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectedKeys, {
            event: "select",
            selected: targetSelected,
            node: treeNode,
            selectedNodes,
            nativeEvent: e2.nativeEvent
          });
        };
        _this.onNodeCheck = function(e2, treeNode, checked) {
          var _this$state7 = _this.state, keyEntities = _this$state7.keyEntities, oriCheckedKeys = _this$state7.checkedKeys, oriHalfCheckedKeys = _this$state7.halfCheckedKeys;
          var _this$props6 = _this.props, checkStrictly = _this$props6.checkStrictly, onCheck = _this$props6.onCheck;
          var key = treeNode.key;
          var checkedObj;
          var eventObj = {
            event: "check",
            node: treeNode,
            checked,
            nativeEvent: e2.nativeEvent
          };
          if (checkStrictly) {
            var checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);
            var halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);
            checkedObj = {
              checked: checkedKeys,
              halfChecked: halfCheckedKeys
            };
            eventObj.checkedNodes = checkedKeys.map(function(checkedKey) {
              return keyEntities[checkedKey];
            }).filter(function(entity) {
              return entity;
            }).map(function(entity) {
              return entity.node;
            });
            _this.setUncontrolledState({
              checkedKeys
            });
          } else {
            var _conductCheck = conductCheck([].concat(_toConsumableArray(oriCheckedKeys), [key]), true, keyEntities), _checkedKeys = _conductCheck.checkedKeys, _halfCheckedKeys = _conductCheck.halfCheckedKeys;
            if (!checked) {
              var keySet = new Set(_checkedKeys);
              keySet.delete(key);
              var _conductCheck2 = conductCheck(Array.from(keySet), {
                checked: false,
                halfCheckedKeys: _halfCheckedKeys
              }, keyEntities);
              _checkedKeys = _conductCheck2.checkedKeys;
              _halfCheckedKeys = _conductCheck2.halfCheckedKeys;
            }
            checkedObj = _checkedKeys;
            eventObj.checkedNodes = [];
            eventObj.checkedNodesPositions = [];
            eventObj.halfCheckedKeys = _halfCheckedKeys;
            _checkedKeys.forEach(function(checkedKey) {
              var entity = keyEntities[checkedKey];
              if (!entity)
                return;
              var node2 = entity.node, pos = entity.pos;
              eventObj.checkedNodes.push(node2);
              eventObj.checkedNodesPositions.push({
                node: node2,
                pos
              });
            });
            _this.setUncontrolledState({
              checkedKeys: _checkedKeys
            }, false, {
              halfCheckedKeys: _halfCheckedKeys
            });
          }
          onCheck === null || onCheck === void 0 ? void 0 : onCheck(checkedObj, eventObj);
        };
        _this.onNodeLoad = function(treeNode) {
          var key = treeNode.key;
          var loadPromise = new Promise(function(resolve, reject) {
            _this.setState(function(_ref) {
              var _ref$loadedKeys = _ref.loadedKeys, loadedKeys = _ref$loadedKeys === void 0 ? [] : _ref$loadedKeys, _ref$loadingKeys = _ref.loadingKeys, loadingKeys = _ref$loadingKeys === void 0 ? [] : _ref$loadingKeys;
              var _this$props7 = _this.props, loadData = _this$props7.loadData, onLoad = _this$props7.onLoad;
              if (!loadData || loadedKeys.indexOf(key) !== -1 || loadingKeys.indexOf(key) !== -1) {
                return null;
              }
              var promise = loadData(treeNode);
              promise.then(function() {
                var currentLoadedKeys = _this.state.loadedKeys;
                var newLoadedKeys = arrAdd(currentLoadedKeys, key);
                onLoad === null || onLoad === void 0 ? void 0 : onLoad(newLoadedKeys, {
                  event: "load",
                  node: treeNode
                });
                _this.setUncontrolledState({
                  loadedKeys: newLoadedKeys
                });
                _this.setState(function(prevState) {
                  return {
                    loadingKeys: arrDel(prevState.loadingKeys, key)
                  };
                });
                resolve();
              }).catch(function(e2) {
                _this.setState(function(prevState) {
                  return {
                    loadingKeys: arrDel(prevState.loadingKeys, key)
                  };
                });
                _this.loadingRetryTimes[key] = (_this.loadingRetryTimes[key] || 0) + 1;
                if (_this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {
                  var currentLoadedKeys = _this.state.loadedKeys;
                  warningOnce$1(false, "Retry for `loadData` many times but still failed. No more retry.");
                  _this.setUncontrolledState({
                    loadedKeys: arrAdd(currentLoadedKeys, key)
                  });
                  resolve();
                }
                reject(e2);
              });
              return {
                loadingKeys: arrAdd(loadingKeys, key)
              };
            });
          });
          loadPromise.catch(function() {
          });
          return loadPromise;
        };
        _this.onNodeMouseEnter = function(event, node2) {
          var onMouseEnter = _this.props.onMouseEnter;
          onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
            event,
            node: node2
          });
        };
        _this.onNodeMouseLeave = function(event, node2) {
          var onMouseLeave = _this.props.onMouseLeave;
          onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
            event,
            node: node2
          });
        };
        _this.onNodeContextMenu = function(event, node2) {
          var onRightClick = _this.props.onRightClick;
          if (onRightClick) {
            event.preventDefault();
            onRightClick({
              event,
              node: node2
            });
          }
        };
        _this.onFocus = function() {
          var onFocus = _this.props.onFocus;
          _this.setState({
            focused: true
          });
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          onFocus === null || onFocus === void 0 ? void 0 : onFocus.apply(void 0, args);
        };
        _this.onBlur = function() {
          var onBlur = _this.props.onBlur;
          _this.setState({
            focused: false
          });
          _this.onActiveChange(null);
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          onBlur === null || onBlur === void 0 ? void 0 : onBlur.apply(void 0, args);
        };
        _this.getTreeNodeRequiredProps = function() {
          var _this$state8 = _this.state, expandedKeys = _this$state8.expandedKeys, selectedKeys = _this$state8.selectedKeys, loadedKeys = _this$state8.loadedKeys, loadingKeys = _this$state8.loadingKeys, checkedKeys = _this$state8.checkedKeys, halfCheckedKeys = _this$state8.halfCheckedKeys, dragOverNodeKey = _this$state8.dragOverNodeKey, dropPosition = _this$state8.dropPosition, keyEntities = _this$state8.keyEntities;
          return {
            expandedKeys: expandedKeys || [],
            selectedKeys: selectedKeys || [],
            loadedKeys: loadedKeys || [],
            loadingKeys: loadingKeys || [],
            checkedKeys: checkedKeys || [],
            halfCheckedKeys: halfCheckedKeys || [],
            dragOverNodeKey,
            dropPosition,
            keyEntities
          };
        };
        _this.setExpandedKeys = function(expandedKeys) {
          var _this$state9 = _this.state, treeData = _this$state9.treeData, fieldNames = _this$state9.fieldNames;
          var flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);
          _this.setUncontrolledState({
            expandedKeys,
            flattenNodes
          }, true);
        };
        _this.onNodeExpand = function(e2, treeNode) {
          var expandedKeys = _this.state.expandedKeys;
          var _this$state10 = _this.state, listChanging = _this$state10.listChanging, fieldNames = _this$state10.fieldNames;
          var _this$props8 = _this.props, onExpand = _this$props8.onExpand, loadData = _this$props8.loadData;
          var expanded = treeNode.expanded;
          var key = treeNode[fieldNames.key];
          if (listChanging) {
            return;
          }
          var index2 = expandedKeys.indexOf(key);
          var targetExpanded = !expanded;
          warningOnce$1(expanded && index2 !== -1 || !expanded && index2 === -1, "Expand state not sync with index check");
          if (targetExpanded) {
            expandedKeys = arrAdd(expandedKeys, key);
          } else {
            expandedKeys = arrDel(expandedKeys, key);
          }
          _this.setExpandedKeys(expandedKeys);
          onExpand === null || onExpand === void 0 ? void 0 : onExpand(expandedKeys, {
            node: treeNode,
            expanded: targetExpanded,
            nativeEvent: e2.nativeEvent
          });
          if (targetExpanded && loadData) {
            var loadPromise = _this.onNodeLoad(treeNode);
            if (loadPromise) {
              loadPromise.then(function() {
                var newFlattenTreeData = flattenTreeData(_this.state.treeData, expandedKeys, fieldNames);
                _this.setUncontrolledState({
                  flattenNodes: newFlattenTreeData
                });
              }).catch(function() {
                var currentExpandedKeys = _this.state.expandedKeys;
                var expandedKeysToRestore = arrDel(currentExpandedKeys, key);
                _this.setExpandedKeys(expandedKeysToRestore);
              });
            }
          }
        };
        _this.onListChangeStart = function() {
          _this.setUncontrolledState({
            listChanging: true
          });
        };
        _this.onListChangeEnd = function() {
          setTimeout(function() {
            _this.setUncontrolledState({
              listChanging: false
            });
          });
        };
        _this.onActiveChange = function(newActiveKey) {
          var activeKey = _this.state.activeKey;
          var onActiveChange = _this.props.onActiveChange;
          if (activeKey === newActiveKey) {
            return;
          }
          _this.setState({
            activeKey: newActiveKey
          });
          if (newActiveKey !== null) {
            _this.scrollTo({
              key: newActiveKey
            });
          }
          onActiveChange === null || onActiveChange === void 0 ? void 0 : onActiveChange(newActiveKey);
        };
        _this.getActiveItem = function() {
          var _this$state11 = _this.state, activeKey = _this$state11.activeKey, flattenNodes = _this$state11.flattenNodes;
          if (activeKey === null) {
            return null;
          }
          return flattenNodes.find(function(_ref2) {
            var key = _ref2.key;
            return key === activeKey;
          }) || null;
        };
        _this.offsetActiveKey = function(offset2) {
          var _this$state12 = _this.state, flattenNodes = _this$state12.flattenNodes, activeKey = _this$state12.activeKey;
          var index2 = flattenNodes.findIndex(function(_ref3) {
            var key2 = _ref3.key;
            return key2 === activeKey;
          });
          if (index2 === -1 && offset2 < 0) {
            index2 = flattenNodes.length;
          }
          index2 = (index2 + offset2 + flattenNodes.length) % flattenNodes.length;
          var item = flattenNodes[index2];
          if (item) {
            var key = item.key;
            _this.onActiveChange(key);
          } else {
            _this.onActiveChange(null);
          }
        };
        _this.onKeyDown = function(event) {
          var _this$state13 = _this.state, activeKey = _this$state13.activeKey, expandedKeys = _this$state13.expandedKeys, checkedKeys = _this$state13.checkedKeys, fieldNames = _this$state13.fieldNames;
          var _this$props9 = _this.props, onKeyDown2 = _this$props9.onKeyDown, checkable = _this$props9.checkable, selectable = _this$props9.selectable;
          switch (event.which) {
            case KeyCode.UP: {
              _this.offsetActiveKey(-1);
              event.preventDefault();
              break;
            }
            case KeyCode.DOWN: {
              _this.offsetActiveKey(1);
              event.preventDefault();
              break;
            }
          }
          var activeItem = _this.getActiveItem();
          if (activeItem && activeItem.data) {
            var treeNodeRequiredProps = _this.getTreeNodeRequiredProps();
            var expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
            var eventNode = convertNodePropsToEventData(_objectSpread2$3(_objectSpread2$3({}, getTreeNodeProps(activeKey, treeNodeRequiredProps)), {}, {
              data: activeItem.data,
              active: true
            }));
            switch (event.which) {
              case KeyCode.LEFT: {
                if (expandable && expandedKeys.includes(activeKey)) {
                  _this.onNodeExpand({}, eventNode);
                } else if (activeItem.parent) {
                  _this.onActiveChange(activeItem.parent.key);
                }
                event.preventDefault();
                break;
              }
              case KeyCode.RIGHT: {
                if (expandable && !expandedKeys.includes(activeKey)) {
                  _this.onNodeExpand({}, eventNode);
                } else if (activeItem.children && activeItem.children.length) {
                  _this.onActiveChange(activeItem.children[0].key);
                }
                event.preventDefault();
                break;
              }
              case KeyCode.ENTER:
              case KeyCode.SPACE: {
                if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
                  _this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));
                } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
                  _this.onNodeSelect({}, eventNode);
                }
                break;
              }
            }
          }
          onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(event);
        };
        _this.setUncontrolledState = function(state) {
          var atomic = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var forceState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (!_this.destroyed) {
            var needSync = false;
            var allPassed = true;
            var newState = {};
            Object.keys(state).forEach(function(name) {
              if (name in _this.props) {
                allPassed = false;
                return;
              }
              needSync = true;
              newState[name] = state[name];
            });
            if (needSync && (!atomic || allPassed)) {
              _this.setState(_objectSpread2$3(_objectSpread2$3({}, newState), forceState));
            }
          }
        };
        _this.scrollTo = function(scroll) {
          _this.listRef.current.scrollTo(scroll);
        };
        return _this;
      }
      _createClass(Tree2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.destroyed = false;
          this.onUpdated();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          this.onUpdated();
        }
      }, {
        key: "onUpdated",
        value: function onUpdated() {
          var activeKey = this.props.activeKey;
          if (activeKey !== void 0 && activeKey !== this.state.activeKey) {
            this.setState({
              activeKey
            });
            if (activeKey !== null) {
              this.scrollTo({
                key: activeKey
              });
            }
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          window.removeEventListener("dragend", this.onWindowDragEnd);
          this.destroyed = true;
        }
      }, {
        key: "resetDragState",
        value: function resetDragState() {
          this.setState({
            dragOverNodeKey: null,
            dropPosition: null,
            dropLevelOffset: null,
            dropTargetKey: null,
            dropContainerKey: null,
            dropTargetPos: null,
            dropAllowed: false
          });
        }
      }, {
        key: "render",
        value: function render2() {
          var _classNames;
          var _this$state14 = this.state, focused = _this$state14.focused, flattenNodes = _this$state14.flattenNodes, keyEntities = _this$state14.keyEntities, draggingNodeKey = _this$state14.draggingNodeKey, activeKey = _this$state14.activeKey, dropLevelOffset = _this$state14.dropLevelOffset, dropContainerKey = _this$state14.dropContainerKey, dropTargetKey = _this$state14.dropTargetKey, dropPosition = _this$state14.dropPosition, dragOverNodeKey = _this$state14.dragOverNodeKey, indent = _this$state14.indent;
          var _this$props10 = this.props, prefixCls = _this$props10.prefixCls, className = _this$props10.className, style2 = _this$props10.style, showLine = _this$props10.showLine, focusable2 = _this$props10.focusable, _this$props10$tabInde = _this$props10.tabIndex, tabIndex = _this$props10$tabInde === void 0 ? 0 : _this$props10$tabInde, selectable = _this$props10.selectable, showIcon = _this$props10.showIcon, icon = _this$props10.icon, switcherIcon = _this$props10.switcherIcon, draggable = _this$props10.draggable, checkable = _this$props10.checkable, checkStrictly = _this$props10.checkStrictly, disabled = _this$props10.disabled, motion2 = _this$props10.motion, loadData = _this$props10.loadData, filterTreeNode = _this$props10.filterTreeNode, height = _this$props10.height, itemHeight = _this$props10.itemHeight, virtual = _this$props10.virtual, titleRender = _this$props10.titleRender, dropIndicatorRender2 = _this$props10.dropIndicatorRender, onContextMenu = _this$props10.onContextMenu, onScroll = _this$props10.onScroll, direction = _this$props10.direction, rootClassName = _this$props10.rootClassName, rootStyle = _this$props10.rootStyle;
          var domProps = pickAttrs(this.props, {
            aria: true,
            data: true
          });
          var draggableConfig;
          if (draggable) {
            if (_typeof$4(draggable) === "object") {
              draggableConfig = draggable;
            } else if (typeof draggable === "function") {
              draggableConfig = {
                nodeDraggable: draggable
              };
            } else {
              draggableConfig = {};
            }
          }
          return /* @__PURE__ */ reactExports.createElement(TreeContext.Provider, {
            value: {
              prefixCls,
              selectable,
              showIcon,
              icon,
              switcherIcon,
              draggable: draggableConfig,
              draggingNodeKey,
              checkable,
              checkStrictly,
              disabled,
              keyEntities,
              dropLevelOffset,
              dropContainerKey,
              dropTargetKey,
              dropPosition,
              dragOverNodeKey,
              indent,
              direction,
              dropIndicatorRender: dropIndicatorRender2,
              loadData,
              filterTreeNode,
              titleRender,
              onNodeClick: this.onNodeClick,
              onNodeDoubleClick: this.onNodeDoubleClick,
              onNodeExpand: this.onNodeExpand,
              onNodeSelect: this.onNodeSelect,
              onNodeCheck: this.onNodeCheck,
              onNodeLoad: this.onNodeLoad,
              onNodeMouseEnter: this.onNodeMouseEnter,
              onNodeMouseLeave: this.onNodeMouseLeave,
              onNodeContextMenu: this.onNodeContextMenu,
              onNodeDragStart: this.onNodeDragStart,
              onNodeDragEnter: this.onNodeDragEnter,
              onNodeDragOver: this.onNodeDragOver,
              onNodeDragLeave: this.onNodeDragLeave,
              onNodeDragEnd: this.onNodeDragEnd,
              onNodeDrop: this.onNodeDrop
            }
          }, /* @__PURE__ */ reactExports.createElement("div", {
            role: "tree",
            className: classNames(prefixCls, className, rootClassName, (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-show-line"), showLine), _defineProperty$7(_classNames, "".concat(prefixCls, "-focused"), focused), _defineProperty$7(_classNames, "".concat(prefixCls, "-active-focused"), activeKey !== null), _classNames)),
            style: rootStyle
          }, /* @__PURE__ */ reactExports.createElement(NodeList, _extends$2({
            ref: this.listRef,
            prefixCls,
            style: style2,
            data: flattenNodes,
            disabled,
            selectable,
            checkable: !!checkable,
            motion: motion2,
            dragging: draggingNodeKey !== null,
            height,
            itemHeight,
            virtual,
            focusable: focusable2,
            focused,
            tabIndex,
            activeItem: this.getActiveItem(),
            onFocus: this.onFocus,
            onBlur: this.onBlur,
            onKeyDown: this.onKeyDown,
            onActiveChange: this.onActiveChange,
            onListChangeStart: this.onListChangeStart,
            onListChangeEnd: this.onListChangeEnd,
            onContextMenu,
            onScroll
          }, this.getTreeNodeRequiredProps(), domProps))));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(props, prevState) {
          var prevProps = prevState.prevProps;
          var newState = {
            prevProps: props
          };
          function needSync(name) {
            return !prevProps && name in props || prevProps && prevProps[name] !== props[name];
          }
          var treeData;
          var fieldNames = prevState.fieldNames;
          if (needSync("fieldNames")) {
            fieldNames = fillFieldNames(props.fieldNames);
            newState.fieldNames = fieldNames;
          }
          if (needSync("treeData")) {
            treeData = props.treeData;
          } else if (needSync("children")) {
            warningOnce$1(false, "`children` of Tree is deprecated. Please use `treeData` instead.");
            treeData = convertTreeToData(props.children);
          }
          if (treeData) {
            newState.treeData = treeData;
            var entitiesMap = convertDataToEntities(treeData, {
              fieldNames
            });
            newState.keyEntities = _objectSpread2$3(_defineProperty$7({}, MOTION_KEY, MotionEntity), entitiesMap.keyEntities);
          }
          var keyEntities = newState.keyEntities || prevState.keyEntities;
          if (needSync("expandedKeys") || prevProps && needSync("autoExpandParent")) {
            newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
          } else if (!prevProps && props.defaultExpandAll) {
            var cloneKeyEntities = _objectSpread2$3({}, keyEntities);
            delete cloneKeyEntities[MOTION_KEY];
            newState.expandedKeys = Object.keys(cloneKeyEntities).map(function(key) {
              return cloneKeyEntities[key].key;
            });
          } else if (!prevProps && props.defaultExpandedKeys) {
            newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
          }
          if (!newState.expandedKeys) {
            delete newState.expandedKeys;
          }
          if (treeData || newState.expandedKeys) {
            var flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
            newState.flattenNodes = flattenNodes;
          }
          if (props.selectable) {
            if (needSync("selectedKeys")) {
              newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
            } else if (!prevProps && props.defaultSelectedKeys) {
              newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
            }
          }
          if (props.checkable) {
            var checkedKeyEntity;
            if (needSync("checkedKeys")) {
              checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
            } else if (!prevProps && props.defaultCheckedKeys) {
              checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
            } else if (treeData) {
              checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
                checkedKeys: prevState.checkedKeys,
                halfCheckedKeys: prevState.halfCheckedKeys
              };
            }
            if (checkedKeyEntity) {
              var _checkedKeyEntity = checkedKeyEntity, _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys, checkedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che, _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys, halfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;
              if (!props.checkStrictly) {
                var conductKeys = conductCheck(checkedKeys, true, keyEntities);
                checkedKeys = conductKeys.checkedKeys;
                halfCheckedKeys = conductKeys.halfCheckedKeys;
              }
              newState.checkedKeys = checkedKeys;
              newState.halfCheckedKeys = halfCheckedKeys;
            }
          }
          if (needSync("loadedKeys")) {
            newState.loadedKeys = props.loadedKeys;
          }
          return newState;
        }
      }]);
      return Tree2;
    }(reactExports.Component);
    Tree$3.defaultProps = {
      prefixCls: "rc-tree",
      showLine: false,
      showIcon: true,
      selectable: true,
      multiple: false,
      checkable: false,
      disabled: false,
      checkStrictly: false,
      draggable: false,
      defaultExpandParent: true,
      autoExpandParent: false,
      defaultExpandAll: false,
      defaultExpandedKeys: [],
      defaultCheckedKeys: [],
      defaultSelectedKeys: [],
      dropIndicatorRender: DropIndicator,
      allowDrop: function allowDrop() {
        return true;
      },
      expandAction: false
    };
    Tree$3.TreeNode = ContextTreeNode;
    const offset = 4;
    function dropIndicatorRender(props) {
      const {
        dropPosition,
        dropLevelOffset,
        prefixCls,
        indent,
        direction = "ltr"
      } = props;
      const startPosition = direction === "ltr" ? "left" : "right";
      const endPosition = direction === "ltr" ? "right" : "left";
      const style2 = {
        [startPosition]: -dropLevelOffset * indent + offset,
        [endPosition]: 0
      };
      switch (dropPosition) {
        case -1:
          style2.top = -3;
          break;
        case 1:
          style2.bottom = -3;
          break;
        default:
          style2.bottom = -3;
          style2[startPosition] = indent + offset;
          break;
      }
      return /* @__PURE__ */ React$3.createElement("div", {
        style: style2,
        className: `${prefixCls}-drop-indicator`
      });
    }
    function renderSwitcherIcon(prefixCls, switcherIcon, treeNodeProps, showLine) {
      const {
        isLeaf,
        expanded,
        loading
      } = treeNodeProps;
      if (loading) {
        return /* @__PURE__ */ reactExports.createElement(LoadingOutlined$1, {
          className: `${prefixCls}-switcher-loading-icon`
        });
      }
      let showLeafIcon;
      if (showLine && typeof showLine === "object") {
        showLeafIcon = showLine.showLeafIcon;
      }
      if (isLeaf) {
        if (!showLine) {
          return null;
        }
        if (typeof showLeafIcon !== "boolean" && !!showLeafIcon) {
          const leafIcon = typeof showLeafIcon === "function" ? showLeafIcon(treeNodeProps) : showLeafIcon;
          const leafCls = `${prefixCls}-switcher-line-custom-icon`;
          if (isValidElement(leafIcon)) {
            return cloneElement(leafIcon, {
              className: classNames(leafIcon.props.className || "", leafCls)
            });
          }
          return leafIcon;
        }
        return showLeafIcon ? /* @__PURE__ */ reactExports.createElement(FileOutlined$1, {
          className: `${prefixCls}-switcher-line-icon`
        }) : /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-switcher-leaf-line`
        });
      }
      const switcherCls = `${prefixCls}-switcher-icon`;
      const switcher = typeof switcherIcon === "function" ? switcherIcon(treeNodeProps) : switcherIcon;
      if (isValidElement(switcher)) {
        return cloneElement(switcher, {
          className: classNames(switcher.props.className || "", switcherCls)
        });
      }
      if (switcher) {
        return switcher;
      }
      if (showLine) {
        return expanded ? /* @__PURE__ */ reactExports.createElement(MinusSquareOutlined$1, {
          className: `${prefixCls}-switcher-line-icon`
        }) : /* @__PURE__ */ reactExports.createElement(PlusSquareOutlined$2, {
          className: `${prefixCls}-switcher-line-icon`
        });
      }
      return /* @__PURE__ */ reactExports.createElement(CaretDownFilled$1, {
        className: switcherCls
      });
    }
    const treeNodeFX = new Keyframe("ant-tree-node-fx-do-not-use", {
      "0%": {
        opacity: 0
      },
      "100%": {
        opacity: 1
      }
    });
    const getSwitchStyle = (prefixCls, token2) => ({
      [`.${prefixCls}-switcher-icon`]: {
        display: "inline-block",
        fontSize: 10,
        verticalAlign: "baseline",
        svg: {
          transition: `transform ${token2.motionDurationSlow}`
        }
      }
    });
    const getDropIndicatorStyle = (prefixCls, token2) => ({
      [`.${prefixCls}-drop-indicator`]: {
        position: "absolute",
        // it should displayed over the following node
        zIndex: 1,
        height: 2,
        backgroundColor: token2.colorPrimary,
        borderRadius: 1,
        pointerEvents: "none",
        "&:after": {
          position: "absolute",
          top: -3,
          insetInlineStart: -6,
          width: 8,
          height: 8,
          backgroundColor: "transparent",
          border: `${token2.lineWidthBold}px solid ${token2.colorPrimary}`,
          borderRadius: "50%",
          content: '""'
        }
      }
    });
    const genBaseStyle$2 = (prefixCls, token2) => {
      const {
        treeCls,
        treeNodeCls,
        treeNodePadding,
        treeTitleHeight
      } = token2;
      const treeCheckBoxMarginVertical = (treeTitleHeight - token2.fontSizeLG) / 2;
      const treeCheckBoxMarginHorizontal = token2.paddingXS;
      return {
        [treeCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
          background: token2.colorBgContainer,
          borderRadius: token2.borderRadius,
          transition: `background-color ${token2.motionDurationSlow}`,
          [`&${treeCls}-rtl`]: {
            // >>> Switcher
            [`${treeCls}-switcher`]: {
              "&_close": {
                [`${treeCls}-switcher-icon`]: {
                  svg: {
                    transform: "rotate(90deg)"
                  }
                }
              }
            }
          },
          [`&-focused:not(:hover):not(${treeCls}-active-focused)`]: Object.assign({}, genFocusOutline(token2)),
          // =================== Virtual List ===================
          [`${treeCls}-list-holder-inner`]: {
            alignItems: "flex-start"
          },
          [`&${treeCls}-block-node`]: {
            [`${treeCls}-list-holder-inner`]: {
              alignItems: "stretch",
              // >>> Title
              [`${treeCls}-node-content-wrapper`]: {
                flex: "auto"
              },
              // >>> Drag
              [`${treeNodeCls}.dragging`]: {
                position: "relative",
                "&:after": {
                  position: "absolute",
                  top: 0,
                  insetInlineEnd: 0,
                  bottom: treeNodePadding,
                  insetInlineStart: 0,
                  border: `1px solid ${token2.colorPrimary}`,
                  opacity: 0,
                  animationName: treeNodeFX,
                  animationDuration: token2.motionDurationSlow,
                  animationPlayState: "running",
                  animationFillMode: "forwards",
                  content: '""',
                  pointerEvents: "none"
                }
              }
            }
          },
          // ===================== TreeNode =====================
          [`${treeNodeCls}`]: {
            display: "flex",
            alignItems: "flex-start",
            padding: `0 0 ${treeNodePadding}px 0`,
            outline: "none",
            "&-rtl": {
              direction: "rtl"
            },
            // Disabled
            "&-disabled": {
              // >>> Title
              [`${treeCls}-node-content-wrapper`]: {
                color: token2.colorTextDisabled,
                cursor: "not-allowed",
                "&:hover": {
                  background: "transparent"
                }
              }
            },
            [`&-active ${treeCls}-node-content-wrapper`]: Object.assign({}, genFocusOutline(token2)),
            [`&:not(${treeNodeCls}-disabled).filter-node ${treeCls}-title`]: {
              color: "inherit",
              fontWeight: 500
            },
            "&-draggable": {
              [`${treeCls}-draggable-icon`]: {
                width: treeTitleHeight,
                lineHeight: `${treeTitleHeight}px`,
                textAlign: "center",
                visibility: "visible",
                opacity: 0.2,
                transition: `opacity ${token2.motionDurationSlow}`,
                [`${treeNodeCls}:hover &`]: {
                  opacity: 0.45
                }
              },
              [`&${treeNodeCls}-disabled`]: {
                [`${treeCls}-draggable-icon`]: {
                  visibility: "hidden"
                }
              }
            }
          },
          // >>> Indent
          [`${treeCls}-indent`]: {
            alignSelf: "stretch",
            whiteSpace: "nowrap",
            userSelect: "none",
            "&-unit": {
              display: "inline-block",
              width: treeTitleHeight
            }
          },
          // >>> Drag Handler
          [`${treeCls}-draggable-icon`]: {
            visibility: "hidden"
          },
          // >>> Switcher
          [`${treeCls}-switcher`]: Object.assign(Object.assign({}, getSwitchStyle(prefixCls, token2)), {
            position: "relative",
            flex: "none",
            alignSelf: "stretch",
            width: treeTitleHeight,
            margin: 0,
            lineHeight: `${treeTitleHeight}px`,
            textAlign: "center",
            cursor: "pointer",
            userSelect: "none",
            "&-noop": {
              cursor: "default"
            },
            "&_close": {
              [`${treeCls}-switcher-icon`]: {
                svg: {
                  transform: "rotate(-90deg)"
                }
              }
            },
            "&-loading-icon": {
              color: token2.colorPrimary
            },
            "&-leaf-line": {
              position: "relative",
              zIndex: 1,
              display: "inline-block",
              width: "100%",
              height: "100%",
              // https://github.com/ant-design/ant-design/issues/31884
              "&:before": {
                position: "absolute",
                top: 0,
                insetInlineEnd: treeTitleHeight / 2,
                bottom: -treeNodePadding,
                marginInlineStart: -1,
                borderInlineEnd: `1px solid ${token2.colorBorder}`,
                content: '""'
              },
              "&:after": {
                position: "absolute",
                width: treeTitleHeight / 2 * 0.8,
                height: treeTitleHeight / 2,
                borderBottom: `1px solid ${token2.colorBorder}`,
                content: '""'
              }
            }
          }),
          // >>> Checkbox
          [`${treeCls}-checkbox`]: {
            top: "initial",
            marginInlineEnd: treeCheckBoxMarginHorizontal,
            marginBlockStart: treeCheckBoxMarginVertical
          },
          // >>> Title
          // add `${treeCls}-checkbox + span` to cover checkbox `${checkboxCls} + span`
          [`${treeCls}-node-content-wrapper, ${treeCls}-checkbox + span`]: {
            position: "relative",
            zIndex: "auto",
            minHeight: treeTitleHeight,
            margin: 0,
            padding: `0 ${token2.paddingXS / 2}px`,
            color: "inherit",
            lineHeight: `${treeTitleHeight}px`,
            background: "transparent",
            borderRadius: token2.borderRadius,
            cursor: "pointer",
            transition: `all ${token2.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`,
            "&:hover": {
              backgroundColor: token2.controlItemBgHover
            },
            [`&${treeCls}-node-selected`]: {
              backgroundColor: token2.controlItemBgActive
            },
            // Icon
            [`${treeCls}-iconEle`]: {
              display: "inline-block",
              width: treeTitleHeight,
              height: treeTitleHeight,
              lineHeight: `${treeTitleHeight}px`,
              textAlign: "center",
              verticalAlign: "top",
              "&:empty": {
                display: "none"
              }
            }
          },
          // https://github.com/ant-design/ant-design/issues/28217
          [`${treeCls}-unselectable ${treeCls}-node-content-wrapper:hover`]: {
            backgroundColor: "transparent"
          },
          // ==================== Draggable =====================
          [`${treeCls}-node-content-wrapper`]: Object.assign({
            lineHeight: `${treeTitleHeight}px`,
            userSelect: "none"
          }, getDropIndicatorStyle(prefixCls, token2)),
          [`${treeNodeCls}.drop-container`]: {
            "> [draggable]": {
              boxShadow: `0 0 0 2px ${token2.colorPrimary}`
            }
          },
          // ==================== Show Line =====================
          "&-show-line": {
            // ================ Indent lines ================
            [`${treeCls}-indent`]: {
              "&-unit": {
                position: "relative",
                height: "100%",
                "&:before": {
                  position: "absolute",
                  top: 0,
                  insetInlineEnd: treeTitleHeight / 2,
                  bottom: -treeNodePadding,
                  borderInlineEnd: `1px solid ${token2.colorBorder}`,
                  content: '""'
                },
                "&-end": {
                  "&:before": {
                    display: "none"
                  }
                }
              }
            },
            // ============== Cover Background ==============
            [`${treeCls}-switcher`]: {
              background: "transparent",
              "&-line-icon": {
                // https://github.com/ant-design/ant-design/issues/32813
                verticalAlign: "-0.15em"
              }
            }
          },
          [`${treeNodeCls}-leaf-last`]: {
            [`${treeCls}-switcher`]: {
              "&-leaf-line": {
                "&:before": {
                  top: "auto !important",
                  bottom: "auto !important",
                  height: `${treeTitleHeight / 2}px !important`
                }
              }
            }
          }
        })
      };
    };
    const genDirectoryStyle = (token2) => {
      const {
        treeCls,
        treeNodeCls,
        treeNodePadding
      } = token2;
      return {
        [`${treeCls}${treeCls}-directory`]: {
          // ================== TreeNode ==================
          [treeNodeCls]: {
            position: "relative",
            // Hover color
            "&:before": {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: treeNodePadding,
              insetInlineStart: 0,
              transition: `background-color ${token2.motionDurationMid}`,
              content: '""',
              pointerEvents: "none"
            },
            "&:hover": {
              "&:before": {
                background: token2.controlItemBgHover
              }
            },
            // Elements
            "> *": {
              zIndex: 1
            },
            // >>> Switcher
            [`${treeCls}-switcher`]: {
              transition: `color ${token2.motionDurationMid}`
            },
            // >>> Title
            [`${treeCls}-node-content-wrapper`]: {
              borderRadius: 0,
              userSelect: "none",
              "&:hover": {
                background: "transparent"
              },
              [`&${treeCls}-node-selected`]: {
                color: token2.colorTextLightSolid,
                background: "transparent"
              }
            },
            // ============= Selected =============
            "&-selected": {
              [`
            &:hover::before,
            &::before
          `]: {
                background: token2.colorPrimary
              },
              // >>> Switcher
              [`${treeCls}-switcher`]: {
                color: token2.colorTextLightSolid
              },
              // >>> Title
              [`${treeCls}-node-content-wrapper`]: {
                color: token2.colorTextLightSolid,
                background: "transparent"
              }
            }
          }
        }
      };
    };
    const genTreeStyle = (prefixCls, token2) => {
      const treeCls = `.${prefixCls}`;
      const treeNodeCls = `${treeCls}-treenode`;
      const treeNodePadding = token2.paddingXS / 2;
      const treeTitleHeight = token2.controlHeightSM;
      const treeToken = merge$4(token2, {
        treeCls,
        treeNodeCls,
        treeNodePadding,
        treeTitleHeight
      });
      return [
        // Basic
        genBaseStyle$2(prefixCls, treeToken),
        // Directory
        genDirectoryStyle(treeToken)
      ];
    };
    const useStyle$6 = genComponentStyleHook("Tree", (token2, _ref) => {
      let {
        prefixCls
      } = _ref;
      return [{
        [token2.componentCls]: getStyle$1(`${prefixCls}-checkbox`, token2)
      }, genTreeStyle(prefixCls, token2), genCollapseMotion$1(token2)];
    });
    const Tree$2 = /* @__PURE__ */ React$3.forwardRef((props, ref) => {
      const {
        getPrefixCls,
        direction,
        virtual
      } = React$3.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        className,
        showIcon = false,
        showLine,
        switcherIcon,
        blockNode = false,
        children,
        checkable = false,
        selectable = true,
        draggable,
        motion: customMotion
      } = props;
      const prefixCls = getPrefixCls("tree", customizePrefixCls);
      const rootPrefixCls = getPrefixCls();
      const motion2 = customMotion !== null && customMotion !== void 0 ? customMotion : Object.assign(Object.assign({}, initCollapseMotion$1(rootPrefixCls)), {
        motionAppear: false
      });
      const newProps = Object.assign(Object.assign({}, props), {
        checkable,
        selectable,
        showIcon,
        motion: motion2,
        blockNode,
        showLine: Boolean(showLine),
        dropIndicatorRender
      });
      const [wrapSSR, hashId] = useStyle$6(prefixCls);
      const draggableConfig = React$3.useMemo(() => {
        if (!draggable) {
          return false;
        }
        let mergedDraggable = {};
        switch (typeof draggable) {
          case "function":
            mergedDraggable.nodeDraggable = draggable;
            break;
          case "object":
            mergedDraggable = Object.assign({}, draggable);
            break;
        }
        if (mergedDraggable.icon !== false) {
          mergedDraggable.icon = mergedDraggable.icon || /* @__PURE__ */ React$3.createElement(HolderOutlined$1, null);
        }
        return mergedDraggable;
      }, [draggable]);
      return wrapSSR(/* @__PURE__ */ React$3.createElement(Tree$3, Object.assign({
        itemHeight: 20,
        ref,
        virtual
      }, newProps, {
        prefixCls,
        className: classNames({
          [`${prefixCls}-icon-hide`]: !showIcon,
          [`${prefixCls}-block-node`]: blockNode,
          [`${prefixCls}-unselectable`]: !selectable,
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, className, hashId),
        direction,
        checkable: checkable ? /* @__PURE__ */ React$3.createElement("span", {
          className: `${prefixCls}-checkbox-inner`
        }) : checkable,
        selectable,
        switcherIcon: (nodeProps) => renderSwitcherIcon(prefixCls, switcherIcon, nodeProps, showLine),
        draggable: draggableConfig
      }), children));
    });
    const TreePure = Tree$2;
    var Record;
    (function(Record2) {
      Record2[Record2["None"] = 0] = "None";
      Record2[Record2["Start"] = 1] = "Start";
      Record2[Record2["End"] = 2] = "End";
    })(Record || (Record = {}));
    function traverseNodesKey(treeData, callback) {
      function processNode(dataNode) {
        const {
          key,
          children
        } = dataNode;
        if (callback(key, dataNode) !== false) {
          traverseNodesKey(children || [], callback);
        }
      }
      treeData.forEach(processNode);
    }
    function calcRangeKeys(_ref) {
      let {
        treeData,
        expandedKeys,
        startKey,
        endKey
      } = _ref;
      const keys2 = [];
      let record = Record.None;
      if (startKey && startKey === endKey) {
        return [startKey];
      }
      if (!startKey || !endKey) {
        return [];
      }
      function matchKey(key) {
        return key === startKey || key === endKey;
      }
      traverseNodesKey(treeData, (key) => {
        if (record === Record.End) {
          return false;
        }
        if (matchKey(key)) {
          keys2.push(key);
          if (record === Record.None) {
            record = Record.Start;
          } else if (record === Record.Start) {
            record = Record.End;
            return false;
          }
        } else if (record === Record.Start) {
          keys2.push(key);
        }
        return expandedKeys.includes(key);
      });
      return keys2;
    }
    function convertDirectoryKeysToNodes(treeData, keys2) {
      const restKeys = _toConsumableArray(keys2);
      const nodes = [];
      traverseNodesKey(treeData, (key, node2) => {
        const index2 = restKeys.indexOf(key);
        if (index2 !== -1) {
          nodes.push(node2);
          restKeys.splice(index2, 1);
        }
        return !!restKeys.length;
      });
      return nodes;
    }
    var __rest$b = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function getIcon(props) {
      const {
        isLeaf,
        expanded
      } = props;
      if (isLeaf) {
        return /* @__PURE__ */ reactExports.createElement(FileOutlined$1, null);
      }
      return expanded ? /* @__PURE__ */ reactExports.createElement(FolderOpenOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(FolderOutlined$2, null);
    }
    function getTreeData(_ref) {
      let {
        treeData,
        children
      } = _ref;
      return treeData || convertTreeToData(children);
    }
    const DirectoryTree = (_a, ref) => {
      var {
        defaultExpandAll,
        defaultExpandParent,
        defaultExpandedKeys
      } = _a, props = __rest$b(_a, ["defaultExpandAll", "defaultExpandParent", "defaultExpandedKeys"]);
      const lastSelectedKey = reactExports.useRef();
      const cachedSelectedKeys = reactExports.useRef();
      const getInitExpandedKeys = () => {
        const {
          keyEntities
        } = convertDataToEntities(getTreeData(props));
        let initExpandedKeys;
        if (defaultExpandAll) {
          initExpandedKeys = Object.keys(keyEntities);
        } else if (defaultExpandParent) {
          initExpandedKeys = conductExpandParent(props.expandedKeys || defaultExpandedKeys || [], keyEntities);
        } else {
          initExpandedKeys = props.expandedKeys || defaultExpandedKeys;
        }
        return initExpandedKeys;
      };
      const [selectedKeys, setSelectedKeys] = reactExports.useState(props.selectedKeys || props.defaultSelectedKeys || []);
      const [expandedKeys, setExpandedKeys] = reactExports.useState(() => getInitExpandedKeys());
      reactExports.useEffect(() => {
        if ("selectedKeys" in props) {
          setSelectedKeys(props.selectedKeys);
        }
      }, [props.selectedKeys]);
      reactExports.useEffect(() => {
        if ("expandedKeys" in props) {
          setExpandedKeys(props.expandedKeys);
        }
      }, [props.expandedKeys]);
      const onExpand = (keys2, info2) => {
        var _a2;
        if (!("expandedKeys" in props)) {
          setExpandedKeys(keys2);
        }
        return (_a2 = props.onExpand) === null || _a2 === void 0 ? void 0 : _a2.call(props, keys2, info2);
      };
      const onSelect = (keys2, event) => {
        var _a2;
        const {
          multiple
        } = props;
        const {
          node: node2,
          nativeEvent
        } = event;
        const {
          key = ""
        } = node2;
        const treeData = getTreeData(props);
        const newEvent = Object.assign(Object.assign({}, event), {
          selected: true
        });
        const ctrlPick = (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.ctrlKey) || (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.metaKey);
        const shiftPick = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.shiftKey;
        let newSelectedKeys;
        if (multiple && ctrlPick) {
          newSelectedKeys = keys2;
          lastSelectedKey.current = key;
          cachedSelectedKeys.current = newSelectedKeys;
          newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys);
        } else if (multiple && shiftPick) {
          newSelectedKeys = Array.from(new Set([].concat(_toConsumableArray(cachedSelectedKeys.current || []), _toConsumableArray(calcRangeKeys({
            treeData,
            expandedKeys,
            startKey: key,
            endKey: lastSelectedKey.current
          })))));
          newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys);
        } else {
          newSelectedKeys = [key];
          lastSelectedKey.current = key;
          cachedSelectedKeys.current = newSelectedKeys;
          newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys);
        }
        (_a2 = props.onSelect) === null || _a2 === void 0 ? void 0 : _a2.call(props, newSelectedKeys, newEvent);
        if (!("selectedKeys" in props)) {
          setSelectedKeys(newSelectedKeys);
        }
      };
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        className,
        showIcon = true,
        expandAction = "click"
      } = props, otherProps = __rest$b(props, ["prefixCls", "className", "showIcon", "expandAction"]);
      const prefixCls = getPrefixCls("tree", customizePrefixCls);
      const connectClassName = classNames(`${prefixCls}-directory`, {
        [`${prefixCls}-directory-rtl`]: direction === "rtl"
      }, className);
      return /* @__PURE__ */ reactExports.createElement(TreePure, Object.assign({
        icon: getIcon,
        ref,
        blockNode: true
      }, otherProps, {
        showIcon,
        expandAction,
        prefixCls,
        className: connectClassName,
        expandedKeys,
        selectedKeys,
        onSelect,
        onExpand
      }));
    };
    const ForwardDirectoryTree = /* @__PURE__ */ reactExports.forwardRef(DirectoryTree);
    const DirectoryTree$1 = ForwardDirectoryTree;
    const Tree = TreePure;
    Tree.DirectoryTree = DirectoryTree$1;
    Tree.TreeNode = ContextTreeNode;
    const Tree$1 = Tree;
    function useSyncState(initialValue) {
      const ref = reactExports.useRef(initialValue);
      const forceUpdate = useForceUpdate();
      return [() => ref.current, (newValue) => {
        ref.current = newValue;
        forceUpdate();
      }];
    }
    function FilterSearch(_ref) {
      let {
        value,
        onChange,
        filterSearch,
        tablePrefixCls,
        locale: locale2
      } = _ref;
      if (!filterSearch) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: `${tablePrefixCls}-filter-dropdown-search`
      }, /* @__PURE__ */ reactExports.createElement(Input$1, {
        prefix: /* @__PURE__ */ reactExports.createElement(SearchOutlined$1, null),
        placeholder: locale2.filterSearchPlaceholder,
        onChange,
        value,
        // for skip min-width of input
        htmlSize: 1,
        className: `${tablePrefixCls}-filter-dropdown-search-input`
      }));
    }
    const onKeyDown = (event) => {
      const {
        keyCode
      } = event;
      if (keyCode === KeyCode.ENTER) {
        event.stopPropagation();
      }
    };
    const FilterDropdownMenuWrapper = (props) => /* @__PURE__ */ reactExports.createElement("div", {
      className: props.className,
      onClick: (e2) => e2.stopPropagation(),
      onKeyDown
    }, props.children);
    const FilterDropdownMenuWrapper$1 = FilterDropdownMenuWrapper;
    function hasSubMenu(filters) {
      return filters.some((_ref) => {
        let {
          children
        } = _ref;
        return children;
      });
    }
    function searchValueMatched(searchValue, text2) {
      if (typeof text2 === "string" || typeof text2 === "number") {
        return text2 === null || text2 === void 0 ? void 0 : text2.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
      }
      return false;
    }
    function renderFilterItems(_ref2) {
      let {
        filters,
        prefixCls,
        filteredKeys,
        filterMultiple,
        searchValue,
        filterSearch
      } = _ref2;
      return filters.map((filter2, index2) => {
        const key = String(filter2.value);
        if (filter2.children) {
          return {
            key: key || index2,
            label: filter2.text,
            popupClassName: `${prefixCls}-dropdown-submenu`,
            children: renderFilterItems({
              filters: filter2.children,
              prefixCls,
              filteredKeys,
              filterMultiple,
              searchValue,
              filterSearch
            })
          };
        }
        const Component = filterMultiple ? Checkbox$1 : Radio$1;
        const item = {
          key: filter2.value !== void 0 ? key : index2,
          label: /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Component, {
            checked: filteredKeys.includes(key)
          }), /* @__PURE__ */ reactExports.createElement("span", null, filter2.text))
        };
        if (searchValue.trim()) {
          if (typeof filterSearch === "function") {
            return filterSearch(searchValue, filter2) ? item : null;
          }
          return searchValueMatched(searchValue, filter2.text) ? item : null;
        }
        return item;
      });
    }
    function FilterDropdown(props) {
      var _a, _b;
      const {
        tablePrefixCls,
        prefixCls,
        column: column2,
        dropdownPrefixCls,
        columnKey,
        filterMultiple,
        filterMode = "menu",
        filterSearch = false,
        filterState,
        triggerFilter,
        locale: locale2,
        children,
        getPopupContainer
      } = props;
      const {
        filterDropdownOpen,
        onFilterDropdownOpenChange,
        filterResetToDefaultFilteredValue,
        defaultFilteredValue,
        // Deprecated
        filterDropdownVisible,
        onFilterDropdownVisibleChange
      } = column2;
      const [visible, setVisible] = reactExports.useState(false);
      const filtered = !!(filterState && (((_a = filterState.filteredKeys) === null || _a === void 0 ? void 0 : _a.length) || filterState.forceFiltered));
      const triggerVisible = (newVisible) => {
        setVisible(newVisible);
        onFilterDropdownOpenChange === null || onFilterDropdownOpenChange === void 0 ? void 0 : onFilterDropdownOpenChange(newVisible);
        onFilterDropdownVisibleChange === null || onFilterDropdownVisibleChange === void 0 ? void 0 : onFilterDropdownVisibleChange(newVisible);
      };
      const mergedVisible = (_b = filterDropdownOpen !== null && filterDropdownOpen !== void 0 ? filterDropdownOpen : filterDropdownVisible) !== null && _b !== void 0 ? _b : visible;
      const propFilteredKeys = filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys;
      const [getFilteredKeysSync, setFilteredKeysSync] = useSyncState(propFilteredKeys || []);
      const onSelectKeys = (_ref4) => {
        let {
          selectedKeys
        } = _ref4;
        setFilteredKeysSync(selectedKeys);
      };
      const onCheck = (keys2, _ref5) => {
        let {
          node: node2,
          checked
        } = _ref5;
        if (!filterMultiple) {
          onSelectKeys({
            selectedKeys: checked && node2.key ? [node2.key] : []
          });
        } else {
          onSelectKeys({
            selectedKeys: keys2
          });
        }
      };
      reactExports.useEffect(() => {
        if (!visible) {
          return;
        }
        onSelectKeys({
          selectedKeys: propFilteredKeys || []
        });
      }, [propFilteredKeys]);
      const [openKeys, setOpenKeys] = reactExports.useState([]);
      const onOpenChange = (keys2) => {
        setOpenKeys(keys2);
      };
      const [searchValue, setSearchValue] = reactExports.useState("");
      const onSearch = (e2) => {
        const {
          value
        } = e2.target;
        setSearchValue(value);
      };
      reactExports.useEffect(() => {
        if (!visible) {
          setSearchValue("");
        }
      }, [visible]);
      const internalTriggerFilter = (keys2) => {
        const mergedKeys = keys2 && keys2.length ? keys2 : null;
        if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) {
          return null;
        }
        if (isEqual$1(mergedKeys, filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys, true)) {
          return null;
        }
        triggerFilter({
          column: column2,
          key: columnKey,
          filteredKeys: mergedKeys
        });
      };
      const onConfirm = () => {
        triggerVisible(false);
        internalTriggerFilter(getFilteredKeysSync());
      };
      const onReset = function() {
        let {
          confirm: confirm2,
          closeDropdown
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          confirm: false,
          closeDropdown: false
        };
        if (confirm2) {
          internalTriggerFilter([]);
        }
        if (closeDropdown) {
          triggerVisible(false);
        }
        setSearchValue("");
        if (filterResetToDefaultFilteredValue) {
          setFilteredKeysSync((defaultFilteredValue || []).map((key) => String(key)));
        } else {
          setFilteredKeysSync([]);
        }
      };
      const doFilter = function() {
        let {
          closeDropdown
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          closeDropdown: true
        };
        if (closeDropdown) {
          triggerVisible(false);
        }
        internalTriggerFilter(getFilteredKeysSync());
      };
      const onVisibleChange = (newVisible) => {
        if (newVisible && propFilteredKeys !== void 0) {
          setFilteredKeysSync(propFilteredKeys || []);
        }
        triggerVisible(newVisible);
        if (!newVisible && !column2.filterDropdown) {
          onConfirm();
        }
      };
      const dropdownMenuClass = classNames({
        [`${dropdownPrefixCls}-menu-without-submenu`]: !hasSubMenu(column2.filters || [])
      });
      const onCheckAll = (e2) => {
        if (e2.target.checked) {
          const allFilterKeys = flattenKeys(column2 === null || column2 === void 0 ? void 0 : column2.filters).map((key) => String(key));
          setFilteredKeysSync(allFilterKeys);
        } else {
          setFilteredKeysSync([]);
        }
      };
      const getTreeData2 = (_ref6) => {
        let {
          filters
        } = _ref6;
        return (filters || []).map((filter2, index2) => {
          const key = String(filter2.value);
          const item = {
            title: filter2.text,
            key: filter2.value !== void 0 ? key : index2
          };
          if (filter2.children) {
            item.children = getTreeData2({
              filters: filter2.children
            });
          }
          return item;
        });
      };
      const getFilterData2 = (node2) => {
        var _a2;
        return Object.assign(Object.assign({}, node2), {
          text: node2.title,
          value: node2.key,
          children: ((_a2 = node2.children) === null || _a2 === void 0 ? void 0 : _a2.map((item) => getFilterData2(item))) || []
        });
      };
      let dropdownContent;
      if (typeof column2.filterDropdown === "function") {
        dropdownContent = column2.filterDropdown({
          prefixCls: `${dropdownPrefixCls}-custom`,
          setSelectedKeys: (selectedKeys) => onSelectKeys({
            selectedKeys
          }),
          selectedKeys: getFilteredKeysSync(),
          confirm: doFilter,
          clearFilters: onReset,
          filters: column2.filters,
          visible: mergedVisible,
          close: () => {
            triggerVisible(false);
          }
        });
      } else if (column2.filterDropdown) {
        dropdownContent = column2.filterDropdown;
      } else {
        const selectedKeys = getFilteredKeysSync() || [];
        const getFilterComponent = () => {
          if ((column2.filters || []).length === 0) {
            return /* @__PURE__ */ reactExports.createElement(Empty$1, {
              image: Empty$1.PRESENTED_IMAGE_SIMPLE,
              description: locale2.filterEmptyText,
              imageStyle: {
                height: 24
              },
              style: {
                margin: 0,
                padding: "16px 0"
              }
            });
          }
          if (filterMode === "tree") {
            return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(FilterSearch, {
              filterSearch,
              value: searchValue,
              onChange: onSearch,
              tablePrefixCls,
              locale: locale2
            }), /* @__PURE__ */ reactExports.createElement("div", {
              className: `${tablePrefixCls}-filter-dropdown-tree`
            }, filterMultiple ? /* @__PURE__ */ reactExports.createElement(Checkbox$1, {
              checked: selectedKeys.length === flattenKeys(column2.filters).length,
              indeterminate: selectedKeys.length > 0 && selectedKeys.length < flattenKeys(column2.filters).length,
              className: `${tablePrefixCls}-filter-dropdown-checkall`,
              onChange: onCheckAll
            }, locale2.filterCheckall) : null, /* @__PURE__ */ reactExports.createElement(Tree$1, {
              checkable: true,
              selectable: false,
              blockNode: true,
              multiple: filterMultiple,
              checkStrictly: !filterMultiple,
              className: `${dropdownPrefixCls}-menu`,
              onCheck,
              checkedKeys: selectedKeys,
              selectedKeys,
              showIcon: false,
              treeData: getTreeData2({
                filters: column2.filters
              }),
              autoExpandParent: true,
              defaultExpandAll: true,
              filterTreeNode: searchValue.trim() ? (node2) => {
                if (typeof filterSearch === "function") {
                  return filterSearch(searchValue, getFilterData2(node2));
                }
                return searchValueMatched(searchValue, node2.title);
              } : void 0
            })));
          }
          return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(FilterSearch, {
            filterSearch,
            value: searchValue,
            onChange: onSearch,
            tablePrefixCls,
            locale: locale2
          }), /* @__PURE__ */ reactExports.createElement(Menu$1, {
            selectable: true,
            multiple: filterMultiple,
            prefixCls: `${dropdownPrefixCls}-menu`,
            className: dropdownMenuClass,
            onSelect: onSelectKeys,
            onDeselect: onSelectKeys,
            selectedKeys,
            getPopupContainer,
            openKeys,
            onOpenChange,
            items: renderFilterItems({
              filters: column2.filters || [],
              filterSearch,
              prefixCls,
              filteredKeys: getFilteredKeysSync(),
              filterMultiple,
              searchValue
            })
          }));
        };
        const getResetDisabled = () => {
          if (filterResetToDefaultFilteredValue) {
            return isEqual$1((defaultFilteredValue || []).map((key) => String(key)), selectedKeys, true);
          }
          return selectedKeys.length === 0;
        };
        dropdownContent = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, getFilterComponent(), /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-dropdown-btns`
        }, /* @__PURE__ */ reactExports.createElement(Button$2, {
          type: "link",
          size: "small",
          disabled: getResetDisabled(),
          onClick: () => onReset()
        }, locale2.filterReset), /* @__PURE__ */ reactExports.createElement(Button$2, {
          type: "primary",
          size: "small",
          onClick: onConfirm
        }, locale2.filterConfirm)));
      }
      if (column2.filterDropdown) {
        dropdownContent = /* @__PURE__ */ reactExports.createElement(OverrideProvider, {
          selectable: void 0
        }, dropdownContent);
      }
      const menu = () => /* @__PURE__ */ reactExports.createElement(FilterDropdownMenuWrapper$1, {
        className: `${prefixCls}-dropdown`
      }, dropdownContent);
      let filterIcon;
      if (typeof column2.filterIcon === "function") {
        filterIcon = column2.filterIcon(filtered);
      } else if (column2.filterIcon) {
        filterIcon = column2.filterIcon;
      } else {
        filterIcon = /* @__PURE__ */ reactExports.createElement(FilterFilled$1, null);
      }
      const {
        direction
      } = reactExports.useContext(ConfigContext);
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-column`
      }, /* @__PURE__ */ reactExports.createElement("span", {
        className: `${tablePrefixCls}-column-title`
      }, children), /* @__PURE__ */ reactExports.createElement(Dropdown$1, {
        dropdownRender: menu,
        trigger: ["click"],
        open: mergedVisible,
        onOpenChange: onVisibleChange,
        getPopupContainer,
        placement: direction === "rtl" ? "bottomLeft" : "bottomRight"
      }, /* @__PURE__ */ reactExports.createElement("span", {
        role: "button",
        tabIndex: -1,
        className: classNames(`${prefixCls}-trigger`, {
          active: filtered
        }),
        onClick: (e2) => {
          e2.stopPropagation();
        }
      }, filterIcon)));
    }
    function collectFilterStates(columns, init, pos) {
      let filterStates = [];
      (columns || []).forEach((column2, index2) => {
        var _a;
        const columnPos = getColumnPos(index2, pos);
        if (column2.filters || "filterDropdown" in column2 || "onFilter" in column2) {
          if ("filteredValue" in column2) {
            let filteredValues = column2.filteredValue;
            if (!("filterDropdown" in column2)) {
              filteredValues = (_a = filteredValues === null || filteredValues === void 0 ? void 0 : filteredValues.map(String)) !== null && _a !== void 0 ? _a : filteredValues;
            }
            filterStates.push({
              column: column2,
              key: getColumnKey(column2, columnPos),
              filteredKeys: filteredValues,
              forceFiltered: column2.filtered
            });
          } else {
            filterStates.push({
              column: column2,
              key: getColumnKey(column2, columnPos),
              filteredKeys: init && column2.defaultFilteredValue ? column2.defaultFilteredValue : void 0,
              forceFiltered: column2.filtered
            });
          }
        }
        if ("children" in column2) {
          filterStates = [].concat(_toConsumableArray(filterStates), _toConsumableArray(collectFilterStates(column2.children, init, columnPos)));
        }
      });
      return filterStates;
    }
    function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, locale2, triggerFilter, getPopupContainer, pos) {
      return columns.map((column2, index2) => {
        const columnPos = getColumnPos(index2, pos);
        const {
          filterMultiple = true,
          filterMode,
          filterSearch
        } = column2;
        let newColumn = column2;
        if (newColumn.filters || newColumn.filterDropdown) {
          const columnKey = getColumnKey(newColumn, columnPos);
          const filterState = filterStates.find((_ref) => {
            let {
              key
            } = _ref;
            return columnKey === key;
          });
          newColumn = Object.assign(Object.assign({}, newColumn), {
            title: (renderProps) => /* @__PURE__ */ reactExports.createElement(FilterDropdown, {
              tablePrefixCls: prefixCls,
              prefixCls: `${prefixCls}-filter`,
              dropdownPrefixCls,
              column: newColumn,
              columnKey,
              filterState,
              filterMultiple,
              filterMode,
              filterSearch,
              triggerFilter,
              locale: locale2,
              getPopupContainer
            }, renderColumnTitle(column2.title, renderProps))
          });
        }
        if ("children" in newColumn) {
          newColumn = Object.assign(Object.assign({}, newColumn), {
            children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, locale2, triggerFilter, getPopupContainer, columnPos)
          });
        }
        return newColumn;
      });
    }
    function flattenKeys(filters) {
      let keys2 = [];
      (filters || []).forEach((_ref2) => {
        let {
          value,
          children
        } = _ref2;
        keys2.push(value);
        if (children) {
          keys2 = [].concat(_toConsumableArray(keys2), _toConsumableArray(flattenKeys(children)));
        }
      });
      return keys2;
    }
    function generateFilterInfo(filterStates) {
      const currentFilters = {};
      filterStates.forEach((_ref3) => {
        let {
          key,
          filteredKeys,
          column: column2
        } = _ref3;
        const {
          filters,
          filterDropdown
        } = column2;
        if (filterDropdown) {
          currentFilters[key] = filteredKeys || null;
        } else if (Array.isArray(filteredKeys)) {
          const keys2 = flattenKeys(filters);
          currentFilters[key] = keys2.filter((originKey) => filteredKeys.includes(String(originKey)));
        } else {
          currentFilters[key] = null;
        }
      });
      return currentFilters;
    }
    function getFilterData(data2, filterStates) {
      return filterStates.reduce((currentData, filterState) => {
        const {
          column: {
            onFilter,
            filters
          },
          filteredKeys
        } = filterState;
        if (onFilter && filteredKeys && filteredKeys.length) {
          return currentData.filter((record) => filteredKeys.some((key) => {
            const keys2 = flattenKeys(filters);
            const keyIndex = keys2.findIndex((k2) => String(k2) === String(key));
            const realKey = keyIndex !== -1 ? keys2[keyIndex] : key;
            return onFilter(realKey, record);
          }));
        }
        return currentData;
      }, data2);
    }
    const getMergedColumns = (rawMergedColumns) => rawMergedColumns.flatMap((column2) => {
      if ("children" in column2) {
        return [column2].concat(_toConsumableArray(getMergedColumns(column2.children || [])));
      }
      return [column2];
    });
    function useFilter(_ref4) {
      let {
        prefixCls,
        dropdownPrefixCls,
        mergedColumns: rawMergedColumns,
        onFilterChange,
        getPopupContainer,
        locale: tableLocale
      } = _ref4;
      const mergedColumns = getMergedColumns(rawMergedColumns || []);
      const [filterStates, setFilterStates] = reactExports.useState(() => collectFilterStates(mergedColumns, true));
      const mergedFilterStates = reactExports.useMemo(() => {
        const collectedStates = collectFilterStates(mergedColumns, false);
        if (collectedStates.length === 0) {
          return collectedStates;
        }
        let filteredKeysIsAllNotControlled = true;
        collectedStates.forEach((_ref5) => {
          let {
            filteredKeys
          } = _ref5;
          if (filteredKeys !== void 0) {
            filteredKeysIsAllNotControlled = false;
          }
        });
        if (filteredKeysIsAllNotControlled) {
          const keyList = (mergedColumns || []).map((column2, index2) => getColumnKey(column2, getColumnPos(index2)));
          return filterStates.filter((_ref6) => {
            let {
              key
            } = _ref6;
            return keyList.includes(key);
          }).map((item) => {
            const col = mergedColumns[keyList.findIndex((key) => key === item.key)];
            return Object.assign(Object.assign({}, item), {
              column: Object.assign(Object.assign({}, item.column), col),
              forceFiltered: col.filtered
            });
          });
        }
        return collectedStates;
      }, [mergedColumns, filterStates]);
      const filters = reactExports.useMemo(() => generateFilterInfo(mergedFilterStates), [mergedFilterStates]);
      const triggerFilter = (filterState) => {
        const newFilterStates = mergedFilterStates.filter((_ref7) => {
          let {
            key
          } = _ref7;
          return key !== filterState.key;
        });
        newFilterStates.push(filterState);
        setFilterStates(newFilterStates);
        onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
      };
      const transformColumns = (innerColumns) => injectFilter(prefixCls, dropdownPrefixCls, innerColumns, mergedFilterStates, tableLocale, triggerFilter, getPopupContainer);
      return [transformColumns, mergedFilterStates, filters];
    }
    function useLazyKVMap(data2, childrenColumnName, getRowKey) {
      const mapCacheRef = reactExports.useRef({});
      function getRecordByKey(key) {
        if (!mapCacheRef.current || mapCacheRef.current.data !== data2 || mapCacheRef.current.childrenColumnName !== childrenColumnName || mapCacheRef.current.getRowKey !== getRowKey) {
          let dig2 = function(records) {
            records.forEach((record, index2) => {
              const rowKey = getRowKey(record, index2);
              kvMap.set(rowKey, record);
              if (record && typeof record === "object" && childrenColumnName in record) {
                dig2(record[childrenColumnName] || []);
              }
            });
          };
          var dig = dig2;
          const kvMap = /* @__PURE__ */ new Map();
          dig2(data2);
          mapCacheRef.current = {
            data: data2,
            childrenColumnName,
            kvMap,
            getRowKey
          };
        }
        return mapCacheRef.current.kvMap.get(key);
      }
      return [getRecordByKey];
    }
    var __rest$a = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const DEFAULT_PAGE_SIZE = 10;
    function getPaginationParam(mergedPagination, pagination) {
      const param = {
        current: mergedPagination.current,
        pageSize: mergedPagination.pageSize
      };
      const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
      Object.keys(paginationObj).forEach((pageProp) => {
        const value = mergedPagination[pageProp];
        if (typeof value !== "function") {
          param[pageProp] = value;
        }
      });
      return param;
    }
    function usePagination(total, onChange, pagination) {
      const _a = pagination && typeof pagination === "object" ? pagination : {}, {
        total: paginationTotal = 0
      } = _a, paginationObj = __rest$a(_a, ["total"]);
      const [innerPagination, setInnerPagination] = reactExports.useState(() => ({
        current: "defaultCurrent" in paginationObj ? paginationObj.defaultCurrent : 1,
        pageSize: "defaultPageSize" in paginationObj ? paginationObj.defaultPageSize : DEFAULT_PAGE_SIZE
      }));
      const mergedPagination = extendsObject(innerPagination, paginationObj, {
        total: paginationTotal > 0 ? paginationTotal : total
      });
      const maxPage = Math.ceil((paginationTotal || total) / mergedPagination.pageSize);
      if (mergedPagination.current > maxPage) {
        mergedPagination.current = maxPage || 1;
      }
      const refreshPagination = (current, pageSize) => {
        setInnerPagination({
          current: current !== null && current !== void 0 ? current : 1,
          pageSize: pageSize || mergedPagination.pageSize
        });
      };
      const onInternalChange = (current, pageSize) => {
        var _a2;
        if (pagination) {
          (_a2 = pagination.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(pagination, current, pageSize);
        }
        refreshPagination(current, pageSize);
        onChange(current, pageSize || (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.pageSize));
      };
      if (pagination === false) {
        return [{}, () => {
        }];
      }
      return [Object.assign(Object.assign({}, mergedPagination), {
        onChange: onInternalChange
      }), refreshPagination];
    }
    const SELECTION_COLUMN = {};
    const SELECTION_ALL = "SELECT_ALL";
    const SELECTION_INVERT = "SELECT_INVERT";
    const SELECTION_NONE = "SELECT_NONE";
    const EMPTY_LIST$1 = [];
    function flattenData(childrenColumnName, data2) {
      let list2 = [];
      (data2 || []).forEach((record) => {
        list2.push(record);
        if (record && typeof record === "object" && childrenColumnName in record) {
          list2 = [].concat(_toConsumableArray(list2), _toConsumableArray(flattenData(childrenColumnName, record[childrenColumnName])));
        }
      });
      return list2;
    }
    function useSelection(config, rowSelection) {
      const {
        preserveSelectedRowKeys,
        selectedRowKeys,
        defaultSelectedRowKeys,
        getCheckboxProps,
        onChange: onSelectionChange,
        onSelect,
        onSelectAll,
        onSelectInvert,
        onSelectNone,
        onSelectMultiple,
        columnWidth: selectionColWidth,
        type: selectionType,
        selections,
        fixed,
        renderCell: customizeRenderCell,
        hideSelectAll,
        checkStrictly = true
      } = rowSelection || {};
      const {
        prefixCls,
        data: data2,
        pageData,
        getRecordByKey,
        getRowKey,
        expandType,
        childrenColumnName,
        locale: tableLocale,
        getPopupContainer
      } = config;
      const [mergedSelectedKeys, setMergedSelectedKeys] = useMergedState(selectedRowKeys || defaultSelectedRowKeys || EMPTY_LIST$1, {
        value: selectedRowKeys
      });
      const preserveRecordsRef = reactExports.useRef(/* @__PURE__ */ new Map());
      const updatePreserveRecordsCache = reactExports.useCallback((keys2) => {
        if (preserveSelectedRowKeys) {
          const newCache = /* @__PURE__ */ new Map();
          keys2.forEach((key) => {
            let record = getRecordByKey(key);
            if (!record && preserveRecordsRef.current.has(key)) {
              record = preserveRecordsRef.current.get(key);
            }
            newCache.set(key, record);
          });
          preserveRecordsRef.current = newCache;
        }
      }, [getRecordByKey, preserveSelectedRowKeys]);
      reactExports.useEffect(() => {
        updatePreserveRecordsCache(mergedSelectedKeys);
      }, [mergedSelectedKeys]);
      const {
        keyEntities
      } = reactExports.useMemo(() => checkStrictly ? {
        keyEntities: null
      } : convertDataToEntities(data2, {
        externalGetKey: getRowKey,
        childrenPropName: childrenColumnName
      }), [data2, getRowKey, checkStrictly, childrenColumnName]);
      const flattedData = reactExports.useMemo(() => flattenData(childrenColumnName, pageData), [pageData, childrenColumnName]);
      const checkboxPropsMap = reactExports.useMemo(() => {
        const map = /* @__PURE__ */ new Map();
        flattedData.forEach((record, index2) => {
          const key = getRowKey(record, index2);
          const checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
          map.set(key, checkboxProps);
        });
        return map;
      }, [flattedData, getRowKey, getCheckboxProps]);
      const isCheckboxDisabled = reactExports.useCallback((r2) => {
        var _a;
        return !!((_a = checkboxPropsMap.get(getRowKey(r2))) === null || _a === void 0 ? void 0 : _a.disabled);
      }, [checkboxPropsMap, getRowKey]);
      const [derivedSelectedKeys, derivedHalfSelectedKeys] = reactExports.useMemo(() => {
        if (checkStrictly) {
          return [mergedSelectedKeys || [], []];
        }
        const {
          checkedKeys,
          halfCheckedKeys
        } = conductCheck(mergedSelectedKeys, true, keyEntities, isCheckboxDisabled);
        return [checkedKeys || [], halfCheckedKeys];
      }, [mergedSelectedKeys, checkStrictly, keyEntities, isCheckboxDisabled]);
      const derivedSelectedKeySet = reactExports.useMemo(() => {
        const keys2 = selectionType === "radio" ? derivedSelectedKeys.slice(0, 1) : derivedSelectedKeys;
        return new Set(keys2);
      }, [derivedSelectedKeys, selectionType]);
      const derivedHalfSelectedKeySet = reactExports.useMemo(() => selectionType === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys), [derivedHalfSelectedKeys, selectionType]);
      const [lastSelectedKey, setLastSelectedKey] = reactExports.useState(null);
      reactExports.useEffect(() => {
        if (!rowSelection) {
          setMergedSelectedKeys(EMPTY_LIST$1);
        }
      }, [!!rowSelection]);
      const setSelectedKeys = reactExports.useCallback((keys2, method2) => {
        let availableKeys;
        let records;
        updatePreserveRecordsCache(keys2);
        if (preserveSelectedRowKeys) {
          availableKeys = keys2;
          records = keys2.map((key) => preserveRecordsRef.current.get(key));
        } else {
          availableKeys = [];
          records = [];
          keys2.forEach((key) => {
            const record = getRecordByKey(key);
            if (record !== void 0) {
              availableKeys.push(key);
              records.push(record);
            }
          });
        }
        setMergedSelectedKeys(availableKeys);
        onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(availableKeys, records, {
          type: method2
        });
      }, [setMergedSelectedKeys, getRecordByKey, onSelectionChange, preserveSelectedRowKeys]);
      const triggerSingleSelection = reactExports.useCallback((key, selected, keys2, event) => {
        if (onSelect) {
          const rows = keys2.map((k2) => getRecordByKey(k2));
          onSelect(getRecordByKey(key), selected, rows, event);
        }
        setSelectedKeys(keys2, "single");
      }, [onSelect, getRecordByKey, setSelectedKeys]);
      const mergedSelections = reactExports.useMemo(() => {
        if (!selections || hideSelectAll) {
          return null;
        }
        const selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
        return selectionList.map((selection) => {
          if (selection === SELECTION_ALL) {
            return {
              key: "all",
              text: tableLocale.selectionAll,
              onSelect() {
                setSelectedKeys(data2.map((record, index2) => getRowKey(record, index2)).filter((key) => {
                  const checkProps = checkboxPropsMap.get(key);
                  return !(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled) || derivedSelectedKeySet.has(key);
                }), "all");
              }
            };
          }
          if (selection === SELECTION_INVERT) {
            return {
              key: "invert",
              text: tableLocale.selectInvert,
              onSelect() {
                const keySet = new Set(derivedSelectedKeySet);
                pageData.forEach((record, index2) => {
                  const key = getRowKey(record, index2);
                  const checkProps = checkboxPropsMap.get(key);
                  if (!(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled)) {
                    if (keySet.has(key)) {
                      keySet.delete(key);
                    } else {
                      keySet.add(key);
                    }
                  }
                });
                const keys2 = Array.from(keySet);
                if (onSelectInvert) {
                  onSelectInvert(keys2);
                }
                setSelectedKeys(keys2, "invert");
              }
            };
          }
          if (selection === SELECTION_NONE) {
            return {
              key: "none",
              text: tableLocale.selectNone,
              onSelect() {
                onSelectNone === null || onSelectNone === void 0 ? void 0 : onSelectNone();
                setSelectedKeys(Array.from(derivedSelectedKeySet).filter((key) => {
                  const checkProps = checkboxPropsMap.get(key);
                  return checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled;
                }), "none");
              }
            };
          }
          return selection;
        }).map((selection) => Object.assign(Object.assign({}, selection), {
          onSelect: function() {
            var _a2;
            var _a;
            for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
              rest[_key] = arguments[_key];
            }
            (_a = selection.onSelect) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [selection].concat(rest));
            setLastSelectedKey(null);
          }
        }));
      }, [selections, derivedSelectedKeySet, pageData, getRowKey, onSelectInvert, setSelectedKeys]);
      const transformColumns = reactExports.useCallback((columns) => {
        var _a;
        if (!rowSelection) {
          return columns.filter((col) => col !== SELECTION_COLUMN);
        }
        let cloneColumns = _toConsumableArray(columns);
        const keySet = new Set(derivedSelectedKeySet);
        const recordKeys = flattedData.map(getRowKey).filter((key) => !checkboxPropsMap.get(key).disabled);
        const checkedCurrentAll = recordKeys.every((key) => keySet.has(key));
        const checkedCurrentSome = recordKeys.some((key) => keySet.has(key));
        const onSelectAllChange = () => {
          const changeKeys = [];
          if (checkedCurrentAll) {
            recordKeys.forEach((key) => {
              keySet.delete(key);
              changeKeys.push(key);
            });
          } else {
            recordKeys.forEach((key) => {
              if (!keySet.has(key)) {
                keySet.add(key);
                changeKeys.push(key);
              }
            });
          }
          const keys2 = Array.from(keySet);
          onSelectAll === null || onSelectAll === void 0 ? void 0 : onSelectAll(!checkedCurrentAll, keys2.map((k2) => getRecordByKey(k2)), changeKeys.map((k2) => getRecordByKey(k2)));
          setSelectedKeys(keys2, "all");
          setLastSelectedKey(null);
        };
        let title;
        if (selectionType !== "radio") {
          let customizeSelections;
          if (mergedSelections) {
            const menu = {
              getPopupContainer,
              items: mergedSelections.map((selection, index2) => {
                const {
                  key,
                  text: text2,
                  onSelect: onSelectionClick
                } = selection;
                return {
                  key: key || index2,
                  onClick: () => {
                    onSelectionClick === null || onSelectionClick === void 0 ? void 0 : onSelectionClick(recordKeys);
                  },
                  label: text2
                };
              })
            };
            customizeSelections = /* @__PURE__ */ reactExports.createElement("div", {
              className: `${prefixCls}-selection-extra`
            }, /* @__PURE__ */ reactExports.createElement(Dropdown$1, {
              menu,
              getPopupContainer
            }, /* @__PURE__ */ reactExports.createElement("span", null, /* @__PURE__ */ reactExports.createElement(DownOutlined$3, null))));
          }
          const allDisabledData = flattedData.map((record, index2) => {
            const key = getRowKey(record, index2);
            const checkboxProps = checkboxPropsMap.get(key) || {};
            return Object.assign({
              checked: keySet.has(key)
            }, checkboxProps);
          }).filter((_ref) => {
            let {
              disabled
            } = _ref;
            return disabled;
          });
          const allDisabled = !!allDisabledData.length && allDisabledData.length === flattedData.length;
          const allDisabledAndChecked = allDisabled && allDisabledData.every((_ref2) => {
            let {
              checked
            } = _ref2;
            return checked;
          });
          const allDisabledSomeChecked = allDisabled && allDisabledData.some((_ref3) => {
            let {
              checked
            } = _ref3;
            return checked;
          });
          title = !hideSelectAll && /* @__PURE__ */ reactExports.createElement("div", {
            className: `${prefixCls}-selection`
          }, /* @__PURE__ */ reactExports.createElement(Checkbox$1, {
            checked: !allDisabled ? !!flattedData.length && checkedCurrentAll : allDisabledAndChecked,
            indeterminate: !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
            onChange: onSelectAllChange,
            disabled: flattedData.length === 0 || allDisabled,
            "aria-label": customizeSelections ? "Custom selection" : "Select all",
            skipGroup: true
          }), customizeSelections);
        }
        let renderCell;
        if (selectionType === "radio") {
          renderCell = (_, record, index2) => {
            const key = getRowKey(record, index2);
            const checked = keySet.has(key);
            return {
              node: /* @__PURE__ */ reactExports.createElement(Radio$1, Object.assign({}, checkboxPropsMap.get(key), {
                checked,
                onClick: (e2) => e2.stopPropagation(),
                onChange: (event) => {
                  if (!keySet.has(key)) {
                    triggerSingleSelection(key, true, [key], event.nativeEvent);
                  }
                }
              })),
              checked
            };
          };
        } else {
          renderCell = (_, record, index2) => {
            var _a2;
            const key = getRowKey(record, index2);
            const checked = keySet.has(key);
            const indeterminate = derivedHalfSelectedKeySet.has(key);
            const checkboxProps = checkboxPropsMap.get(key);
            let mergedIndeterminate;
            if (expandType === "nest") {
              mergedIndeterminate = indeterminate;
            } else {
              mergedIndeterminate = (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.indeterminate) !== null && _a2 !== void 0 ? _a2 : indeterminate;
            }
            return {
              node: /* @__PURE__ */ reactExports.createElement(Checkbox$1, Object.assign({}, checkboxProps, {
                indeterminate: mergedIndeterminate,
                checked,
                skipGroup: true,
                onClick: (e2) => e2.stopPropagation(),
                onChange: (_ref4) => {
                  let {
                    nativeEvent
                  } = _ref4;
                  const {
                    shiftKey
                  } = nativeEvent;
                  let startIndex = -1;
                  let endIndex = -1;
                  if (shiftKey && checkStrictly) {
                    const pointKeys = /* @__PURE__ */ new Set([lastSelectedKey, key]);
                    recordKeys.some((recordKey, recordIndex) => {
                      if (pointKeys.has(recordKey)) {
                        if (startIndex === -1) {
                          startIndex = recordIndex;
                        } else {
                          endIndex = recordIndex;
                          return true;
                        }
                      }
                      return false;
                    });
                  }
                  if (endIndex !== -1 && startIndex !== endIndex && checkStrictly) {
                    const rangeKeys = recordKeys.slice(startIndex, endIndex + 1);
                    const changedKeys = [];
                    if (checked) {
                      rangeKeys.forEach((recordKey) => {
                        if (keySet.has(recordKey)) {
                          changedKeys.push(recordKey);
                          keySet.delete(recordKey);
                        }
                      });
                    } else {
                      rangeKeys.forEach((recordKey) => {
                        if (!keySet.has(recordKey)) {
                          changedKeys.push(recordKey);
                          keySet.add(recordKey);
                        }
                      });
                    }
                    const keys2 = Array.from(keySet);
                    onSelectMultiple === null || onSelectMultiple === void 0 ? void 0 : onSelectMultiple(!checked, keys2.map((recordKey) => getRecordByKey(recordKey)), changedKeys.map((recordKey) => getRecordByKey(recordKey)));
                    setSelectedKeys(keys2, "multiple");
                  } else {
                    const originCheckedKeys = derivedSelectedKeys;
                    if (checkStrictly) {
                      const checkedKeys = checked ? arrDel(originCheckedKeys, key) : arrAdd(originCheckedKeys, key);
                      triggerSingleSelection(key, !checked, checkedKeys, nativeEvent);
                    } else {
                      const result = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key]), true, keyEntities, isCheckboxDisabled);
                      const {
                        checkedKeys,
                        halfCheckedKeys
                      } = result;
                      let nextCheckedKeys = checkedKeys;
                      if (checked) {
                        const tempKeySet = new Set(checkedKeys);
                        tempKeySet.delete(key);
                        nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                          checked: false,
                          halfCheckedKeys
                        }, keyEntities, isCheckboxDisabled).checkedKeys;
                      }
                      triggerSingleSelection(key, !checked, nextCheckedKeys, nativeEvent);
                    }
                  }
                  if (checked) {
                    setLastSelectedKey(null);
                  } else {
                    setLastSelectedKey(key);
                  }
                }
              })),
              checked
            };
          };
        }
        const renderSelectionCell = (_, record, index2) => {
          const {
            node: node2,
            checked
          } = renderCell(_, record, index2);
          if (customizeRenderCell) {
            return customizeRenderCell(checked, record, index2, node2);
          }
          return node2;
        };
        if (!cloneColumns.includes(SELECTION_COLUMN)) {
          if (cloneColumns.findIndex((col) => {
            var _a2;
            return ((_a2 = col[INTERNAL_COL_DEFINE]) === null || _a2 === void 0 ? void 0 : _a2.columnType) === "EXPAND_COLUMN";
          }) === 0) {
            const [expandColumn, ...restColumns] = cloneColumns;
            cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
          } else {
            cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
          }
        }
        const selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
        cloneColumns = cloneColumns.filter((column2, index2) => column2 !== SELECTION_COLUMN || index2 === selectionColumnIndex);
        const prevCol = cloneColumns[selectionColumnIndex - 1];
        const nextCol = cloneColumns[selectionColumnIndex + 1];
        let mergedFixed = fixed;
        if (mergedFixed === void 0) {
          if ((nextCol === null || nextCol === void 0 ? void 0 : nextCol.fixed) !== void 0) {
            mergedFixed = nextCol.fixed;
          } else if ((prevCol === null || prevCol === void 0 ? void 0 : prevCol.fixed) !== void 0) {
            mergedFixed = prevCol.fixed;
          }
        }
        if (mergedFixed && prevCol && ((_a = prevCol[INTERNAL_COL_DEFINE]) === null || _a === void 0 ? void 0 : _a.columnType) === "EXPAND_COLUMN" && prevCol.fixed === void 0) {
          prevCol.fixed = mergedFixed;
        }
        const selectionColumn = {
          fixed: mergedFixed,
          width: selectionColWidth,
          className: `${prefixCls}-selection-column`,
          title: rowSelection.columnTitle || title,
          render: renderSelectionCell,
          [INTERNAL_COL_DEFINE]: {
            className: `${prefixCls}-selection-col`
          }
        };
        return cloneColumns.map((col) => col === SELECTION_COLUMN ? selectionColumn : col);
      }, [getRowKey, flattedData, rowSelection, derivedSelectedKeys, derivedSelectedKeySet, derivedHalfSelectedKeySet, selectionColWidth, mergedSelections, expandType, lastSelectedKey, checkboxPropsMap, onSelectMultiple, triggerSingleSelection, isCheckboxDisabled]);
      return [transformColumns, derivedSelectedKeySet];
    }
    const ASCEND = "ascend";
    const DESCEND = "descend";
    function getMultiplePriority(column2) {
      if (typeof column2.sorter === "object" && typeof column2.sorter.multiple === "number") {
        return column2.sorter.multiple;
      }
      return false;
    }
    function getSortFunction(sorter) {
      if (typeof sorter === "function") {
        return sorter;
      }
      if (sorter && typeof sorter === "object" && sorter.compare) {
        return sorter.compare;
      }
      return false;
    }
    function nextSortDirection(sortDirections, current) {
      if (!current) {
        return sortDirections[0];
      }
      return sortDirections[sortDirections.indexOf(current) + 1];
    }
    function collectSortStates(columns, init, pos) {
      let sortStates = [];
      function pushState(column2, columnPos) {
        sortStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          multiplePriority: getMultiplePriority(column2),
          sortOrder: column2.sortOrder
        });
      }
      (columns || []).forEach((column2, index2) => {
        const columnPos = getColumnPos(index2, pos);
        if (column2.children) {
          if ("sortOrder" in column2) {
            pushState(column2, columnPos);
          }
          sortStates = [].concat(_toConsumableArray(sortStates), _toConsumableArray(collectSortStates(column2.children, init, columnPos)));
        } else if (column2.sorter) {
          if ("sortOrder" in column2) {
            pushState(column2, columnPos);
          } else if (init && column2.defaultSortOrder) {
            sortStates.push({
              column: column2,
              key: getColumnKey(column2, columnPos),
              multiplePriority: getMultiplePriority(column2),
              sortOrder: column2.defaultSortOrder
            });
          }
        }
      });
      return sortStates;
    }
    function injectSorter(prefixCls, columns, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos) {
      return (columns || []).map((column2, index2) => {
        const columnPos = getColumnPos(index2, pos);
        let newColumn = column2;
        if (newColumn.sorter) {
          const sortDirections = newColumn.sortDirections || defaultSortDirections;
          const showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
          const columnKey = getColumnKey(newColumn, columnPos);
          const sorterState = sorterStates.find((_ref) => {
            let {
              key
            } = _ref;
            return key === columnKey;
          });
          const sorterOrder = sorterState ? sorterState.sortOrder : null;
          const nextSortOrder = nextSortDirection(sortDirections, sorterOrder);
          const upNode = sortDirections.includes(ASCEND) && /* @__PURE__ */ reactExports.createElement(CaretUpOutlined$1, {
            className: classNames(`${prefixCls}-column-sorter-up`, {
              active: sorterOrder === ASCEND
            })
          });
          const downNode = sortDirections.includes(DESCEND) && /* @__PURE__ */ reactExports.createElement(CaretDownOutlined$1, {
            className: classNames(`${prefixCls}-column-sorter-down`, {
              active: sorterOrder === DESCEND
            })
          });
          const {
            cancelSort,
            triggerAsc,
            triggerDesc
          } = tableLocale || {};
          let sortTip = cancelSort;
          if (nextSortOrder === DESCEND) {
            sortTip = triggerDesc;
          } else if (nextSortOrder === ASCEND) {
            sortTip = triggerAsc;
          }
          const tooltipProps = typeof showSorterTooltip === "object" ? showSorterTooltip : {
            title: sortTip
          };
          newColumn = Object.assign(Object.assign({}, newColumn), {
            className: classNames(newColumn.className, {
              [`${prefixCls}-column-sort`]: sorterOrder
            }),
            title: (renderProps) => {
              const renderSortTitle = /* @__PURE__ */ reactExports.createElement("div", {
                className: `${prefixCls}-column-sorters`
              }, /* @__PURE__ */ reactExports.createElement("span", {
                className: `${prefixCls}-column-title`
              }, renderColumnTitle(column2.title, renderProps)), /* @__PURE__ */ reactExports.createElement("span", {
                className: classNames(`${prefixCls}-column-sorter`, {
                  [`${prefixCls}-column-sorter-full`]: !!(upNode && downNode)
                })
              }, /* @__PURE__ */ reactExports.createElement("span", {
                className: `${prefixCls}-column-sorter-inner`,
                "aria-hidden": "true"
              }, upNode, downNode)));
              return showSorterTooltip ? /* @__PURE__ */ reactExports.createElement(pn, Object.assign({}, tooltipProps), renderSortTitle) : renderSortTitle;
            },
            onHeaderCell: (col) => {
              const cell = column2.onHeaderCell && column2.onHeaderCell(col) || {};
              const originOnClick = cell.onClick;
              const originOKeyDown = cell.onKeyDown;
              cell.onClick = (event) => {
                triggerSorter({
                  column: column2,
                  key: columnKey,
                  sortOrder: nextSortOrder,
                  multiplePriority: getMultiplePriority(column2)
                });
                originOnClick === null || originOnClick === void 0 ? void 0 : originOnClick(event);
              };
              cell.onKeyDown = (event) => {
                if (event.keyCode === KeyCode.ENTER) {
                  triggerSorter({
                    column: column2,
                    key: columnKey,
                    sortOrder: nextSortOrder,
                    multiplePriority: getMultiplePriority(column2)
                  });
                  originOKeyDown === null || originOKeyDown === void 0 ? void 0 : originOKeyDown(event);
                }
              };
              const renderTitle2 = safeColumnTitle(column2.title, {});
              const displayTitle = renderTitle2 === null || renderTitle2 === void 0 ? void 0 : renderTitle2.toString();
              if (sorterOrder) {
                cell["aria-sort"] = sorterOrder === "ascend" ? "ascending" : "descending";
              } else {
                cell["aria-label"] = displayTitle || "";
              }
              cell.className = classNames(cell.className, `${prefixCls}-column-has-sorters`);
              cell.tabIndex = 0;
              if (column2.ellipsis) {
                cell.title = (renderTitle2 !== null && renderTitle2 !== void 0 ? renderTitle2 : "").toString();
              }
              return cell;
            }
          });
        }
        if ("children" in newColumn) {
          newColumn = Object.assign(Object.assign({}, newColumn), {
            children: injectSorter(prefixCls, newColumn.children, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos)
          });
        }
        return newColumn;
      });
    }
    function stateToInfo(sorterStates) {
      const {
        column: column2,
        sortOrder
      } = sorterStates;
      return {
        column: column2,
        order: sortOrder,
        field: column2.dataIndex,
        columnKey: column2.key
      };
    }
    function generateSorterInfo(sorterStates) {
      const list2 = sorterStates.filter((_ref2) => {
        let {
          sortOrder
        } = _ref2;
        return sortOrder;
      }).map(stateToInfo);
      if (list2.length === 0 && sorterStates.length) {
        return Object.assign(Object.assign({}, stateToInfo(sorterStates[sorterStates.length - 1])), {
          column: void 0
        });
      }
      if (list2.length <= 1) {
        return list2[0] || {};
      }
      return list2;
    }
    function getSortData(data2, sortStates, childrenColumnName) {
      const innerSorterStates = sortStates.slice().sort((a, b2) => b2.multiplePriority - a.multiplePriority);
      const cloneData = data2.slice();
      const runningSorters = innerSorterStates.filter((_ref3) => {
        let {
          column: {
            sorter
          },
          sortOrder
        } = _ref3;
        return getSortFunction(sorter) && sortOrder;
      });
      if (!runningSorters.length) {
        return cloneData;
      }
      return cloneData.sort((record1, record2) => {
        for (let i2 = 0; i2 < runningSorters.length; i2 += 1) {
          const sorterState = runningSorters[i2];
          const {
            column: {
              sorter
            },
            sortOrder
          } = sorterState;
          const compareFn = getSortFunction(sorter);
          if (compareFn && sortOrder) {
            const compareResult = compareFn(record1, record2, sortOrder);
            if (compareResult !== 0) {
              return sortOrder === ASCEND ? compareResult : -compareResult;
            }
          }
        }
        return 0;
      }).map((record) => {
        const subRecords = record[childrenColumnName];
        if (subRecords) {
          return Object.assign(Object.assign({}, record), {
            [childrenColumnName]: getSortData(subRecords, sortStates, childrenColumnName)
          });
        }
        return record;
      });
    }
    function useFilterSorter(_ref4) {
      let {
        prefixCls,
        mergedColumns,
        onSorterChange,
        sortDirections,
        tableLocale,
        showSorterTooltip
      } = _ref4;
      const [sortStates, setSortStates] = reactExports.useState(collectSortStates(mergedColumns, true));
      const mergedSorterStates = reactExports.useMemo(() => {
        let validate = true;
        const collectedStates = collectSortStates(mergedColumns, false);
        if (!collectedStates.length) {
          return sortStates;
        }
        const validateStates = [];
        function patchStates(state) {
          if (validate) {
            validateStates.push(state);
          } else {
            validateStates.push(Object.assign(Object.assign({}, state), {
              sortOrder: null
            }));
          }
        }
        let multipleMode = null;
        collectedStates.forEach((state) => {
          if (multipleMode === null) {
            patchStates(state);
            if (state.sortOrder) {
              if (state.multiplePriority === false) {
                validate = false;
              } else {
                multipleMode = true;
              }
            }
          } else if (multipleMode && state.multiplePriority !== false) {
            patchStates(state);
          } else {
            validate = false;
            patchStates(state);
          }
        });
        return validateStates;
      }, [mergedColumns, sortStates]);
      const columnTitleSorterProps = reactExports.useMemo(() => {
        const sortColumns = mergedSorterStates.map((_ref5) => {
          let {
            column: column2,
            sortOrder
          } = _ref5;
          return {
            column: column2,
            order: sortOrder
          };
        });
        return {
          sortColumns,
          // Legacy
          sortColumn: sortColumns[0] && sortColumns[0].column,
          sortOrder: sortColumns[0] && sortColumns[0].order
        };
      }, [mergedSorterStates]);
      function triggerSorter(sortState) {
        let newSorterStates;
        if (sortState.multiplePriority === false || !mergedSorterStates.length || mergedSorterStates[0].multiplePriority === false) {
          newSorterStates = [sortState];
        } else {
          newSorterStates = [].concat(_toConsumableArray(mergedSorterStates.filter((_ref6) => {
            let {
              key
            } = _ref6;
            return key !== sortState.key;
          })), [sortState]);
        }
        setSortStates(newSorterStates);
        onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
      }
      const transformColumns = (innerColumns) => injectSorter(prefixCls, innerColumns, mergedSorterStates, triggerSorter, sortDirections, tableLocale, showSorterTooltip);
      const getSorters = () => generateSorterInfo(mergedSorterStates);
      return [transformColumns, mergedSorterStates, columnTitleSorterProps, getSorters];
    }
    function fillTitle(columns, columnTitleProps) {
      return columns.map((column2) => {
        const cloneColumn = Object.assign({}, column2);
        cloneColumn.title = renderColumnTitle(column2.title, columnTitleProps);
        if ("children" in cloneColumn) {
          cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
        }
        return cloneColumn;
      });
    }
    function useTitleColumns(columnTitleProps) {
      const filledColumns = reactExports.useCallback((columns) => fillTitle(columns, columnTitleProps), [columnTitleProps]);
      return [filledColumns];
    }
    const RcTable = genTable((prev2, next2) => {
      const {
        _renderTimes: prevRenderTimes
      } = prev2;
      const {
        _renderTimes: nextRenderTimes
      } = next2;
      return prevRenderTimes !== nextRenderTimes;
    });
    const genBorderedStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const tableBorder = `${token2.lineWidth}px ${token2.lineType} ${token2.tableBorderColor}`;
      const getSizeBorderStyle = (size, paddingVertical, paddingHorizontal) => ({
        [`&${componentCls}-${size}`]: {
          [`> ${componentCls}-container`]: {
            [`> ${componentCls}-content, > ${componentCls}-body`]: {
              [`
            > table > tbody > tr > th,
            > table > tbody > tr > td
          `]: {
                [`> ${componentCls}-expanded-row-fixed`]: {
                  margin: `-${paddingVertical}px -${paddingHorizontal + token2.lineWidth}px`
                }
              }
            }
          }
        }
      });
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}${componentCls}-bordered`]: Object.assign(Object.assign(Object.assign({
            // ============================ Title =============================
            [`> ${componentCls}-title`]: {
              border: tableBorder,
              borderBottom: 0
            },
            // ============================ Content ============================
            [`> ${componentCls}-container`]: {
              borderInlineStart: tableBorder,
              [`
            > ${componentCls}-content,
            > ${componentCls}-header,
            > ${componentCls}-body,
            > ${componentCls}-summary
          `]: {
                "> table": {
                  // ============================= Cell =============================
                  [`
                > thead > tr > th,
                > tbody > tr > th,
                > tbody > tr > td,
                > tfoot > tr > th,
                > tfoot > tr > td
              `]: {
                    borderInlineEnd: tableBorder
                  },
                  // ============================ Header ============================
                  "> thead": {
                    "> tr:not(:last-child) > th": {
                      borderBottom: tableBorder
                    },
                    "> tr > th::before": {
                      backgroundColor: "transparent !important"
                    }
                  },
                  // Fixed right should provides additional border
                  [`
                > thead > tr,
                > tbody > tr,
                > tfoot > tr
              `]: {
                    [`> ${componentCls}-cell-fix-right-first::after`]: {
                      borderInlineEnd: tableBorder
                    }
                  },
                  // ========================== Expandable ==========================
                  [`
                > tbody > tr > th,
                > tbody > tr > td
              `]: {
                    [`> ${componentCls}-expanded-row-fixed`]: {
                      margin: `-${token2.tablePaddingVertical}px -${token2.tablePaddingHorizontal + token2.lineWidth}px`,
                      "&::after": {
                        position: "absolute",
                        top: 0,
                        insetInlineEnd: token2.lineWidth,
                        bottom: 0,
                        borderInlineEnd: tableBorder,
                        content: '""'
                      }
                    }
                  }
                }
              },
              [`
            > ${componentCls}-content,
            > ${componentCls}-header
          `]: {
                "> table": {
                  borderTop: tableBorder
                }
              }
            },
            // ============================ Scroll ============================
            [`&${componentCls}-scroll-horizontal`]: {
              [`> ${componentCls}-container > ${componentCls}-body`]: {
                "> table > tbody": {
                  [`
                > tr${componentCls}-expanded-row,
                > tr${componentCls}-placeholder
              `]: {
                    [`> th, > td`]: {
                      borderInlineEnd: 0
                    }
                  }
                }
              }
            }
          }, getSizeBorderStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle)), getSizeBorderStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall)), {
            // ============================ Footer ============================
            [`> ${componentCls}-footer`]: {
              border: tableBorder,
              borderTop: 0
            }
          }),
          // ============================ Nested ============================
          [`${componentCls}-cell`]: {
            [`${componentCls}-container:first-child`]: {
              // :first-child to avoid the case when bordered and title is set
              borderTop: 0
            },
            // https://github.com/ant-design/ant-design/issues/35577
            "&-scrollbar:not([rowspan])": {
              boxShadow: `0 ${token2.lineWidth}px 0 ${token2.lineWidth}px ${token2.tableHeaderBg}`
            }
          }
        }
      };
    };
    const genBorderedStyle$1 = genBorderedStyle;
    const genEllipsisStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-cell-ellipsis`]: Object.assign(Object.assign({}, textEllipsis), {
            wordBreak: "keep-all",
            // Fixed first or last should special process
            [`
          &${componentCls}-cell-fix-left-last,
          &${componentCls}-cell-fix-right-first
        `]: {
              overflow: "visible",
              [`${componentCls}-cell-content`]: {
                display: "block",
                overflow: "hidden",
                textOverflow: "ellipsis"
              }
            },
            [`${componentCls}-column-title`]: {
              overflow: "hidden",
              textOverflow: "ellipsis",
              wordBreak: "keep-all"
            }
          })
        }
      };
    };
    const genEllipsisStyle$1 = genEllipsisStyle;
    const genEmptyStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-tbody > tr${componentCls}-placeholder`]: {
            textAlign: "center",
            color: token2.colorTextDisabled,
            [`
          &:hover > th,
          &:hover > td,
        `]: {
              background: token2.colorBgContainer
            }
          }
        }
      };
    };
    const genEmptyStyle$1 = genEmptyStyle;
    const genExpandStyle = (token2) => {
      const {
        componentCls,
        antCls,
        controlInteractiveSize: checkboxSize,
        motionDurationSlow,
        lineWidth,
        paddingXS,
        lineType,
        tableBorderColor,
        tableExpandIconBg,
        tableExpandColumnWidth,
        borderRadius,
        fontSize,
        fontSizeSM,
        lineHeight,
        tablePaddingVertical,
        tablePaddingHorizontal,
        tableExpandedRowBg,
        paddingXXS
      } = token2;
      const halfInnerSize = checkboxSize / 2 - lineWidth;
      const expandIconSize = halfInnerSize * 2 + lineWidth * 3;
      const tableBorder = `${lineWidth}px ${lineType} ${tableBorderColor}`;
      const expandIconLineOffset = paddingXXS - lineWidth;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-expand-icon-col`]: {
            width: tableExpandColumnWidth
          },
          [`${componentCls}-row-expand-icon-cell`]: {
            textAlign: "center",
            [`${componentCls}-row-expand-icon`]: {
              display: "inline-flex",
              float: "none",
              verticalAlign: "sub"
            }
          },
          [`${componentCls}-row-indent`]: {
            height: 1,
            float: "left"
          },
          [`${componentCls}-row-expand-icon`]: Object.assign(Object.assign({}, operationUnit$1(token2)), {
            position: "relative",
            float: "left",
            boxSizing: "border-box",
            width: expandIconSize,
            height: expandIconSize,
            padding: 0,
            color: "inherit",
            lineHeight: `${expandIconSize}px`,
            background: tableExpandIconBg,
            border: tableBorder,
            borderRadius,
            transform: `scale(${checkboxSize / expandIconSize})`,
            transition: `all ${motionDurationSlow}`,
            userSelect: "none",
            [`&:focus, &:hover, &:active`]: {
              borderColor: "currentcolor"
            },
            [`&::before, &::after`]: {
              position: "absolute",
              background: "currentcolor",
              transition: `transform ${motionDurationSlow} ease-out`,
              content: '""'
            },
            "&::before": {
              top: halfInnerSize,
              insetInlineEnd: expandIconLineOffset,
              insetInlineStart: expandIconLineOffset,
              height: lineWidth
            },
            "&::after": {
              top: expandIconLineOffset,
              bottom: expandIconLineOffset,
              insetInlineStart: halfInnerSize,
              width: lineWidth,
              transform: "rotate(90deg)"
            },
            // Motion effect
            "&-collapsed::before": {
              transform: "rotate(-180deg)"
            },
            "&-collapsed::after": {
              transform: "rotate(0deg)"
            },
            "&-spaced": {
              "&::before, &::after": {
                display: "none",
                content: "none"
              },
              background: "transparent",
              border: 0,
              visibility: "hidden"
            }
          }),
          [`${componentCls}-row-indent + ${componentCls}-row-expand-icon`]: {
            marginTop: (fontSize * lineHeight - lineWidth * 3) / 2 - Math.ceil((fontSizeSM * 1.4 - lineWidth * 3) / 2),
            marginInlineEnd: paddingXS
          },
          [`tr${componentCls}-expanded-row`]: {
            "&, &:hover": {
              [`> th, > td`]: {
                background: tableExpandedRowBg
              }
            },
            // https://github.com/ant-design/ant-design/issues/25573
            [`${antCls}-descriptions-view`]: {
              display: "flex",
              table: {
                flex: "auto",
                width: "auto"
              }
            }
          },
          // With fixed
          [`${componentCls}-expanded-row-fixed`]: {
            position: "relative",
            margin: `-${tablePaddingVertical}px -${tablePaddingHorizontal}px`,
            padding: `${tablePaddingVertical}px ${tablePaddingHorizontal}px`
          }
        }
      };
    };
    const genExpandStyle$1 = genExpandStyle;
    const genFilterStyle = (token2) => {
      const {
        componentCls,
        antCls,
        iconCls,
        tableFilterDropdownWidth,
        tableFilterDropdownSearchWidth,
        paddingXXS,
        paddingXS,
        colorText,
        lineWidth,
        lineType,
        tableBorderColor,
        tableHeaderIconColor,
        fontSizeSM,
        tablePaddingHorizontal,
        borderRadius,
        motionDurationSlow,
        colorTextDescription,
        colorPrimary,
        tableHeaderFilterActiveBg,
        colorTextDisabled,
        tableFilterDropdownBg,
        tableFilterDropdownHeight,
        controlItemBgHover,
        controlItemBgActive,
        boxShadowSecondary
      } = token2;
      const dropdownPrefixCls = `${antCls}-dropdown`;
      const tableFilterDropdownPrefixCls = `${componentCls}-filter-dropdown`;
      const treePrefixCls = `${antCls}-tree`;
      const tableBorder = `${lineWidth}px ${lineType} ${tableBorderColor}`;
      return [
        {
          [`${componentCls}-wrapper`]: {
            [`${componentCls}-filter-column`]: {
              display: "flex",
              justifyContent: "space-between"
            },
            [`${componentCls}-filter-trigger`]: {
              position: "relative",
              display: "flex",
              alignItems: "center",
              marginBlock: -paddingXXS,
              marginInline: `${paddingXXS}px ${-tablePaddingHorizontal / 2}px`,
              padding: `0 ${paddingXXS}px`,
              color: tableHeaderIconColor,
              fontSize: fontSizeSM,
              borderRadius,
              cursor: "pointer",
              transition: `all ${motionDurationSlow}`,
              "&:hover": {
                color: colorTextDescription,
                background: tableHeaderFilterActiveBg
              },
              "&.active": {
                color: colorPrimary
              }
            }
          }
        },
        {
          // Dropdown
          [`${antCls}-dropdown`]: {
            [tableFilterDropdownPrefixCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
              minWidth: tableFilterDropdownWidth,
              backgroundColor: tableFilterDropdownBg,
              borderRadius,
              boxShadow: boxShadowSecondary,
              // Reset menu
              [`${dropdownPrefixCls}-menu`]: {
                // https://github.com/ant-design/ant-design/issues/4916
                // https://github.com/ant-design/ant-design/issues/19542
                maxHeight: tableFilterDropdownHeight,
                overflowX: "hidden",
                border: 0,
                boxShadow: "none",
                "&:empty::after": {
                  display: "block",
                  padding: `${paddingXS}px 0`,
                  color: colorTextDisabled,
                  fontSize: fontSizeSM,
                  textAlign: "center",
                  content: '"Not Found"'
                }
              },
              [`${tableFilterDropdownPrefixCls}-tree`]: {
                paddingBlock: `${paddingXS}px 0`,
                paddingInline: paddingXS,
                [treePrefixCls]: {
                  padding: 0
                },
                [`${treePrefixCls}-treenode ${treePrefixCls}-node-content-wrapper:hover`]: {
                  backgroundColor: controlItemBgHover
                },
                [`${treePrefixCls}-treenode-checkbox-checked ${treePrefixCls}-node-content-wrapper`]: {
                  "&, &:hover": {
                    backgroundColor: controlItemBgActive
                  }
                }
              },
              [`${tableFilterDropdownPrefixCls}-search`]: {
                padding: paddingXS,
                borderBottom: tableBorder,
                "&-input": {
                  input: {
                    minWidth: tableFilterDropdownSearchWidth
                  },
                  [iconCls]: {
                    color: colorTextDisabled
                  }
                }
              },
              [`${tableFilterDropdownPrefixCls}-checkall`]: {
                width: "100%",
                marginBottom: paddingXXS,
                marginInlineStart: paddingXXS
              },
              // Operation
              [`${tableFilterDropdownPrefixCls}-btns`]: {
                display: "flex",
                justifyContent: "space-between",
                padding: `${paddingXS - lineWidth}px ${paddingXS}px`,
                overflow: "hidden",
                borderTop: tableBorder
              }
            })
          }
        },
        // Dropdown Menu & SubMenu
        {
          // submenu of table filter dropdown
          [`${antCls}-dropdown ${tableFilterDropdownPrefixCls}, ${tableFilterDropdownPrefixCls}-submenu`]: {
            // Checkbox
            [`${antCls}-checkbox-wrapper + span`]: {
              paddingInlineStart: paddingXS,
              color: colorText
            },
            [`> ul`]: {
              maxHeight: "calc(100vh - 130px)",
              overflowX: "hidden",
              overflowY: "auto"
            }
          }
        }
      ];
    };
    const genFilterStyle$1 = genFilterStyle;
    const genFixedStyle = (token2) => {
      const {
        componentCls,
        lineWidth,
        colorSplit,
        motionDurationSlow,
        zIndexTableFixed,
        tableBg,
        zIndexTableSticky
      } = token2;
      const shadowColor = colorSplit;
      return {
        [`${componentCls}-wrapper`]: {
          [`
        ${componentCls}-cell-fix-left,
        ${componentCls}-cell-fix-right
      `]: {
            position: "sticky !important",
            zIndex: zIndexTableFixed,
            background: tableBg
          },
          [`
        ${componentCls}-cell-fix-left-first::after,
        ${componentCls}-cell-fix-left-last::after
      `]: {
            position: "absolute",
            top: 0,
            right: {
              _skip_check_: true,
              value: 0
            },
            bottom: -lineWidth,
            width: 30,
            transform: "translateX(100%)",
            transition: `box-shadow ${motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          },
          [`${componentCls}-cell-fix-left-all::after`]: {
            display: "none"
          },
          [`
        ${componentCls}-cell-fix-right-first::after,
        ${componentCls}-cell-fix-right-last::after
      `]: {
            position: "absolute",
            top: 0,
            bottom: -lineWidth,
            left: {
              _skip_check_: true,
              value: 0
            },
            width: 30,
            transform: "translateX(-100%)",
            transition: `box-shadow ${motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          },
          [`${componentCls}-container`]: {
            "&::before, &::after": {
              position: "absolute",
              top: 0,
              bottom: 0,
              zIndex: zIndexTableSticky + 1,
              width: 30,
              transition: `box-shadow ${motionDurationSlow}`,
              content: '""',
              pointerEvents: "none"
            },
            "&::before": {
              insetInlineStart: 0
            },
            "&::after": {
              insetInlineEnd: 0
            }
          },
          [`${componentCls}-ping-left`]: {
            [`&:not(${componentCls}-has-fix-left) ${componentCls}-container`]: {
              position: "relative",
              "&::before": {
                boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
              }
            },
            [`
          ${componentCls}-cell-fix-left-first::after,
          ${componentCls}-cell-fix-left-last::after
        `]: {
              boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
            },
            [`${componentCls}-cell-fix-left-last::before`]: {
              backgroundColor: "transparent !important"
            }
          },
          [`${componentCls}-ping-right`]: {
            [`&:not(${componentCls}-has-fix-right) ${componentCls}-container`]: {
              position: "relative",
              "&::after": {
                boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
              }
            },
            [`
          ${componentCls}-cell-fix-right-first::after,
          ${componentCls}-cell-fix-right-last::after
        `]: {
              boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
            }
          }
        }
      };
    };
    const genFixedStyle$1 = genFixedStyle;
    const genPaginationStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          // ========================== Pagination ==========================
          [`${componentCls}-pagination${antCls}-pagination`]: {
            margin: `${token2.margin}px 0`
          },
          [`${componentCls}-pagination`]: {
            display: "flex",
            flexWrap: "wrap",
            rowGap: token2.paddingXS,
            "> *": {
              flex: "none"
            },
            "&-left": {
              justifyContent: "flex-start"
            },
            "&-center": {
              justifyContent: "center"
            },
            "&-right": {
              justifyContent: "flex-end"
            }
          }
        }
      };
    };
    const genPaginationStyle$1 = genPaginationStyle;
    const genRadiusStyle = (token2) => {
      const {
        componentCls,
        tableRadius
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          [componentCls]: {
            // https://github.com/ant-design/ant-design/issues/39115#issuecomment-1362314574
            [`${componentCls}-title, ${componentCls}-header`]: {
              borderRadius: `${tableRadius}px ${tableRadius}px 0 0`
            },
            [`${componentCls}-title + ${componentCls}-container`]: {
              borderStartStartRadius: 0,
              borderStartEndRadius: 0,
              table: {
                borderRadius: 0,
                "> thead > tr:first-child": {
                  "th:first-child": {
                    borderRadius: 0
                  },
                  "th:last-child": {
                    borderRadius: 0
                  }
                }
              }
            },
            "&-container": {
              borderStartStartRadius: tableRadius,
              borderStartEndRadius: tableRadius,
              "table > thead > tr:first-child": {
                "> *:first-child": {
                  borderStartStartRadius: tableRadius
                },
                "> *:last-child": {
                  borderStartEndRadius: tableRadius
                }
              }
            },
            "&-footer": {
              borderRadius: `0 0 ${tableRadius}px ${tableRadius}px`
            }
          }
        }
      };
    };
    const genRadiusStyle$1 = genRadiusStyle;
    const genStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-wrapper-rtl`]: {
          direction: "rtl",
          table: {
            direction: "rtl"
          },
          [`${componentCls}-pagination-left`]: {
            justifyContent: "flex-end"
          },
          [`${componentCls}-pagination-right`]: {
            justifyContent: "flex-start"
          },
          [`${componentCls}-row-expand-icon`]: {
            "&::after": {
              transform: "rotate(-90deg)"
            },
            "&-collapsed::before": {
              transform: "rotate(180deg)"
            },
            "&-collapsed::after": {
              transform: "rotate(0deg)"
            }
          },
          [`${componentCls}-container`]: {
            "&::before": {
              insetInlineStart: "unset",
              insetInlineEnd: 0
            },
            "&::after": {
              insetInlineStart: 0,
              insetInlineEnd: "unset"
            }
          }
        }
      };
    };
    const genRtlStyle$2 = genStyle;
    const genSelectionStyle = (token2) => {
      const {
        componentCls,
        antCls,
        iconCls,
        fontSizeIcon,
        paddingXS,
        tableHeaderIconColor,
        tableHeaderIconColorHover
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          // ========================== Selections ==========================
          [`${componentCls}-selection-col`]: {
            width: token2.tableSelectionColumnWidth
          },
          [`${componentCls}-bordered ${componentCls}-selection-col`]: {
            width: token2.tableSelectionColumnWidth + paddingXS * 2
          },
          [`
        table tr th${componentCls}-selection-column,
        table tr td${componentCls}-selection-column
      `]: {
            paddingInlineEnd: token2.paddingXS,
            paddingInlineStart: token2.paddingXS,
            textAlign: "center",
            [`${antCls}-radio-wrapper`]: {
              marginInlineEnd: 0
            }
          },
          [`table tr th${componentCls}-selection-column${componentCls}-cell-fix-left`]: {
            zIndex: token2.zIndexTableFixed + 1
          },
          [`table tr th${componentCls}-selection-column::after`]: {
            backgroundColor: "transparent !important"
          },
          [`${componentCls}-selection`]: {
            position: "relative",
            display: "inline-flex",
            flexDirection: "column"
          },
          [`${componentCls}-selection-extra`]: {
            position: "absolute",
            top: 0,
            zIndex: 1,
            cursor: "pointer",
            transition: `all ${token2.motionDurationSlow}`,
            marginInlineStart: "100%",
            paddingInlineStart: `${token2.tablePaddingHorizontal / 4}px`,
            [iconCls]: {
              color: tableHeaderIconColor,
              fontSize: fontSizeIcon,
              verticalAlign: "baseline",
              "&:hover": {
                color: tableHeaderIconColorHover
              }
            }
          }
        }
      };
    };
    const genSelectionStyle$1 = genSelectionStyle;
    const genSizeStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const getSizeStyle = (size, paddingVertical, paddingHorizontal, fontSize) => ({
        [`${componentCls}${componentCls}-${size}`]: {
          fontSize,
          [`
        ${componentCls}-title,
        ${componentCls}-footer,
        ${componentCls}-thead > tr > th,
        ${componentCls}-tbody > tr > th,
        ${componentCls}-tbody > tr > td,
        tfoot > tr > th,
        tfoot > tr > td
      `]: {
            padding: `${paddingVertical}px ${paddingHorizontal}px`
          },
          [`${componentCls}-filter-trigger`]: {
            marginInlineEnd: `-${paddingHorizontal / 2}px`
          },
          [`${componentCls}-expanded-row-fixed`]: {
            margin: `-${paddingVertical}px -${paddingHorizontal}px`
          },
          [`${componentCls}-tbody`]: {
            // ========================= Nest Table ===========================
            [`${componentCls}-wrapper:only-child ${componentCls}`]: {
              marginBlock: `-${paddingVertical}px`,
              marginInline: `${token2.tableExpandColumnWidth - paddingHorizontal}px -${paddingHorizontal}px`
            }
          },
          // https://github.com/ant-design/ant-design/issues/35167
          [`${componentCls}-selection-column`]: {
            paddingInlineStart: `${paddingHorizontal / 4}px`
          }
        }
      });
      return {
        [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, getSizeStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle, token2.tableFontSizeMiddle)), getSizeStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall, token2.tableFontSizeSmall))
      };
    };
    const genSizeStyle$1 = genSizeStyle;
    const genSorterStyle = (token2) => {
      const {
        componentCls,
        marginXXS,
        fontSizeIcon,
        tableHeaderIconColor,
        tableHeaderIconColorHover
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-thead th${componentCls}-column-has-sorters`]: {
            outline: "none",
            cursor: "pointer",
            transition: `all ${token2.motionDurationSlow}`,
            "&:hover": {
              background: token2.tableHeaderSortHoverBg,
              "&::before": {
                backgroundColor: "transparent !important"
              }
            },
            "&:focus-visible": {
              color: token2.colorPrimary
            },
            // https://github.com/ant-design/ant-design/issues/30969
            [`
          &${componentCls}-cell-fix-left:hover,
          &${componentCls}-cell-fix-right:hover
        `]: {
              background: token2.tableFixedHeaderSortActiveBg
            }
          },
          [`${componentCls}-thead th${componentCls}-column-sort`]: {
            background: token2.tableHeaderSortBg,
            "&::before": {
              backgroundColor: "transparent !important"
            }
          },
          [`td${componentCls}-column-sort`]: {
            background: token2.tableBodySortBg
          },
          [`${componentCls}-column-title`]: {
            position: "relative",
            zIndex: 1,
            flex: 1
          },
          [`${componentCls}-column-sorters`]: {
            display: "flex",
            flex: "auto",
            alignItems: "center",
            justifyContent: "space-between",
            "&::after": {
              position: "absolute",
              inset: 0,
              width: "100%",
              height: "100%",
              content: '""'
            }
          },
          [`${componentCls}-column-sorter`]: {
            marginInlineStart: marginXXS,
            color: tableHeaderIconColor,
            fontSize: 0,
            transition: `color ${token2.motionDurationSlow}`,
            "&-inner": {
              display: "inline-flex",
              flexDirection: "column",
              alignItems: "center"
            },
            "&-up, &-down": {
              fontSize: fontSizeIcon,
              "&.active": {
                color: token2.colorPrimary
              }
            },
            [`${componentCls}-column-sorter-up + ${componentCls}-column-sorter-down`]: {
              marginTop: "-0.3em"
            }
          },
          [`${componentCls}-column-sorters:hover ${componentCls}-column-sorter`]: {
            color: tableHeaderIconColorHover
          }
        }
      };
    };
    const genSorterStyle$1 = genSorterStyle;
    const genStickyStyle = (token2) => {
      const {
        componentCls,
        opacityLoading,
        tableScrollThumbBg,
        tableScrollThumbBgHover,
        tableScrollThumbSize,
        tableScrollBg,
        zIndexTableSticky
      } = token2;
      const tableBorder = `${token2.lineWidth}px ${token2.lineType} ${token2.tableBorderColor}`;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-sticky`]: {
            "&-holder": {
              position: "sticky",
              zIndex: zIndexTableSticky,
              background: token2.colorBgContainer
            },
            "&-scroll": {
              position: "sticky",
              bottom: 0,
              height: `${tableScrollThumbSize}px !important`,
              zIndex: zIndexTableSticky,
              display: "flex",
              alignItems: "center",
              background: tableScrollBg,
              borderTop: tableBorder,
              opacity: opacityLoading,
              "&:hover": {
                transformOrigin: "center bottom"
              },
              // fake scrollbar style of sticky
              "&-bar": {
                height: tableScrollThumbSize,
                backgroundColor: tableScrollThumbBg,
                borderRadius: 100,
                transition: `all ${token2.motionDurationSlow}, transform none`,
                position: "absolute",
                bottom: 0,
                "&:hover, &-active": {
                  backgroundColor: tableScrollThumbBgHover
                }
              }
            }
          }
        }
      };
    };
    const genStickyStyle$1 = genStickyStyle;
    const genSummaryStyle = (token2) => {
      const {
        componentCls,
        lineWidth,
        tableBorderColor
      } = token2;
      const tableBorder = `${lineWidth}px ${token2.lineType} ${tableBorderColor}`;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-summary`]: {
            position: "relative",
            zIndex: token2.zIndexTableFixed,
            background: token2.tableBg,
            "> tr": {
              "> th, > td": {
                borderBottom: tableBorder
              }
            }
          },
          [`div${componentCls}-summary`]: {
            boxShadow: `0 -${lineWidth}px 0 ${tableBorderColor}`
          }
        }
      };
    };
    const genSummaryStyle$1 = genSummaryStyle;
    const genTableStyle = (token2) => {
      const {
        componentCls,
        fontWeightStrong,
        tablePaddingVertical,
        tablePaddingHorizontal,
        lineWidth,
        lineType,
        tableBorderColor,
        tableFontSize,
        tableBg,
        tableRadius,
        tableHeaderTextColor,
        motionDurationMid,
        tableHeaderBg,
        tableHeaderCellSplitColor,
        tableRowHoverBg,
        tableSelectedRowBg,
        tableSelectedRowHoverBg,
        tableFooterTextColor,
        tableFooterBg,
        paddingContentVerticalLG
      } = token2;
      const tableBorder = `${lineWidth}px ${lineType} ${tableBorderColor}`;
      return {
        [`${componentCls}-wrapper`]: Object.assign(Object.assign({
          clear: "both",
          maxWidth: "100%"
        }, clearFix()), {
          [componentCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
            fontSize: tableFontSize,
            background: tableBg,
            borderRadius: `${tableRadius}px ${tableRadius}px 0 0`
          }),
          // https://github.com/ant-design/ant-design/issues/17611
          table: {
            width: "100%",
            textAlign: "start",
            borderRadius: `${tableRadius}px ${tableRadius}px 0 0`,
            borderCollapse: "separate",
            borderSpacing: 0
          },
          // ============================= Cell =============================
          [`
          ${componentCls}-thead > tr > th,
          ${componentCls}-tbody > tr > th,
          ${componentCls}-tbody > tr > td,
          tfoot > tr > th,
          tfoot > tr > td
        `]: {
            position: "relative",
            padding: `${paddingContentVerticalLG}px ${tablePaddingHorizontal}px`,
            overflowWrap: "break-word"
          },
          // ============================ Title =============================
          [`${componentCls}-title`]: {
            padding: `${tablePaddingVertical}px ${tablePaddingHorizontal}px`
          },
          // ============================ Header ============================
          [`${componentCls}-thead`]: {
            [`
          > tr > th,
          > tr > td
        `]: {
              position: "relative",
              color: tableHeaderTextColor,
              fontWeight: fontWeightStrong,
              textAlign: "start",
              background: tableHeaderBg,
              borderBottom: tableBorder,
              transition: `background ${motionDurationMid} ease`,
              "&[colspan]:not([colspan='1'])": {
                textAlign: "center"
              },
              [`&:not(:last-child):not(${componentCls}-selection-column):not(${componentCls}-row-expand-icon-cell):not([colspan])::before`]: {
                position: "absolute",
                top: "50%",
                insetInlineEnd: 0,
                width: 1,
                height: "1.6em",
                backgroundColor: tableHeaderCellSplitColor,
                transform: "translateY(-50%)",
                transition: `background-color ${motionDurationMid}`,
                content: '""'
              }
            },
            "> tr:not(:last-child) > th[colspan]": {
              borderBottom: 0
            }
          },
          // ============================ Body ============================
          [`${componentCls}-tbody`]: {
            "> tr": {
              [`> th, > td`]: {
                transition: `background ${motionDurationMid}, border-color ${motionDurationMid}`,
                borderBottom: tableBorder,
                // ========================= Nest Table ===========================
                [`
              > ${componentCls}-wrapper:only-child,
              > ${componentCls}-expanded-row-fixed > ${componentCls}-wrapper:only-child
            `]: {
                  [componentCls]: {
                    marginBlock: `-${tablePaddingVertical}px`,
                    marginInline: `${token2.tableExpandColumnWidth - tablePaddingHorizontal}px -${tablePaddingHorizontal}px`,
                    [`${componentCls}-tbody > tr:last-child > td`]: {
                      borderBottom: 0,
                      "&:first-child, &:last-child": {
                        borderRadius: 0
                      }
                    }
                  }
                }
              },
              "> th": {
                position: "relative",
                color: tableHeaderTextColor,
                fontWeight: fontWeightStrong,
                textAlign: "start",
                background: tableHeaderBg,
                borderBottom: tableBorder,
                transition: `background ${motionDurationMid} ease`
              },
              [`
            &${componentCls}-row:hover > th,
            &${componentCls}-row:hover > td,
            > th${componentCls}-cell-row-hover
            > td${componentCls}-cell-row-hover
          `]: {
                background: tableRowHoverBg
              },
              [`&${componentCls}-row-selected`]: {
                [`> th, > td`]: {
                  background: tableSelectedRowBg
                },
                [`&:hover > th, &:hover > td`]: {
                  background: tableSelectedRowHoverBg
                }
              }
            }
          },
          // ============================ Footer ============================
          [`${componentCls}-footer`]: {
            padding: `${tablePaddingVertical}px ${tablePaddingHorizontal}px`,
            color: tableFooterTextColor,
            background: tableFooterBg
          }
        })
      };
    };
    const useStyle$5 = genComponentStyleHook("Table", (token2) => {
      const {
        controlItemBgActive,
        controlItemBgActiveHover,
        colorTextPlaceholder,
        colorTextHeading,
        colorSplit,
        colorBorderSecondary,
        fontSize,
        padding,
        paddingXS,
        paddingSM,
        controlHeight,
        colorFillAlter,
        colorIcon,
        colorIconHover,
        opacityLoading,
        colorBgContainer,
        borderRadiusLG,
        colorFillContent,
        colorFillSecondary,
        controlInteractiveSize: checkboxSize
      } = token2;
      const baseColorAction = new TinyColor(colorIcon);
      const baseColorActionHover = new TinyColor(colorIconHover);
      const tableSelectedRowBg = controlItemBgActive;
      const zIndexTableFixed = 2;
      const colorFillSecondarySolid = new TinyColor(colorFillSecondary).onBackground(colorBgContainer).toHexShortString();
      const colorFillContentSolid = new TinyColor(colorFillContent).onBackground(colorBgContainer).toHexShortString();
      const colorFillAlterSolid = new TinyColor(colorFillAlter).onBackground(colorBgContainer).toHexShortString();
      const tableToken = merge$4(token2, {
        tableFontSize: fontSize,
        tableBg: colorBgContainer,
        tableRadius: borderRadiusLG,
        tablePaddingVertical: padding,
        tablePaddingHorizontal: padding,
        tablePaddingVerticalMiddle: paddingSM,
        tablePaddingHorizontalMiddle: paddingXS,
        tablePaddingVerticalSmall: paddingXS,
        tablePaddingHorizontalSmall: paddingXS,
        tableBorderColor: colorBorderSecondary,
        tableHeaderTextColor: colorTextHeading,
        tableHeaderBg: colorFillAlterSolid,
        tableFooterTextColor: colorTextHeading,
        tableFooterBg: colorFillAlterSolid,
        tableHeaderCellSplitColor: colorBorderSecondary,
        tableHeaderSortBg: colorFillSecondarySolid,
        tableHeaderSortHoverBg: colorFillContentSolid,
        tableHeaderIconColor: baseColorAction.clone().setAlpha(baseColorAction.getAlpha() * opacityLoading).toRgbString(),
        tableHeaderIconColorHover: baseColorActionHover.clone().setAlpha(baseColorActionHover.getAlpha() * opacityLoading).toRgbString(),
        tableBodySortBg: colorFillAlterSolid,
        tableFixedHeaderSortActiveBg: colorFillSecondarySolid,
        tableHeaderFilterActiveBg: colorFillContent,
        tableFilterDropdownBg: colorBgContainer,
        tableRowHoverBg: colorFillAlterSolid,
        tableSelectedRowBg,
        tableSelectedRowHoverBg: controlItemBgActiveHover,
        zIndexTableFixed,
        zIndexTableSticky: zIndexTableFixed + 1,
        tableFontSizeMiddle: fontSize,
        tableFontSizeSmall: fontSize,
        tableSelectionColumnWidth: controlHeight,
        tableExpandIconBg: colorBgContainer,
        tableExpandColumnWidth: checkboxSize + 2 * token2.padding,
        tableExpandedRowBg: colorFillAlter,
        // Dropdown
        tableFilterDropdownWidth: 120,
        tableFilterDropdownHeight: 264,
        tableFilterDropdownSearchWidth: 140,
        // Virtual Scroll Bar
        tableScrollThumbSize: 8,
        tableScrollThumbBg: colorTextPlaceholder,
        tableScrollThumbBgHover: colorTextHeading,
        tableScrollBg: colorSplit
      });
      return [genTableStyle(tableToken), genPaginationStyle$1(tableToken), genSummaryStyle$1(tableToken), genSorterStyle$1(tableToken), genFilterStyle$1(tableToken), genBorderedStyle$1(tableToken), genRadiusStyle$1(tableToken), genExpandStyle$1(tableToken), genSummaryStyle$1(tableToken), genEmptyStyle$1(tableToken), genSelectionStyle$1(tableToken), genFixedStyle$1(tableToken), genStickyStyle$1(tableToken), genEllipsisStyle$1(tableToken), genSizeStyle$1(tableToken), genRtlStyle$2(tableToken)];
    });
    const EMPTY_LIST = [];
    function InternalTable(props, ref) {
      const {
        getPopupContainer: getContextPopupContainer
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        style: style2,
        size: customizeSize,
        bordered,
        dropdownPrefixCls: customizeDropdownPrefixCls,
        dataSource,
        pagination,
        rowSelection,
        rowKey = "key",
        rowClassName,
        columns,
        children,
        childrenColumnName: legacyChildrenColumnName,
        onChange,
        getPopupContainer,
        loading,
        expandIcon,
        expandable,
        expandedRowRender,
        expandIconColumnIndex,
        indentSize,
        scroll,
        sortDirections,
        locale: locale2,
        showSorterTooltip = true
      } = props;
      const baseColumns = reactExports.useMemo(() => columns || convertChildrenToColumns(children), [columns, children]);
      const needResponsive = reactExports.useMemo(() => baseColumns.some((col) => col.responsive), [baseColumns]);
      const screens = useBreakpoint$3(needResponsive);
      const mergedColumns = reactExports.useMemo(() => {
        const matched = new Set(Object.keys(screens).filter((m2) => screens[m2]));
        return baseColumns.filter((c2) => !c2.responsive || c2.responsive.some((r2) => matched.has(r2)));
      }, [baseColumns, screens]);
      const tableProps = omit(props, ["className", "style", "columns"]);
      const size = reactExports.useContext(SizeContext$2);
      const {
        locale: contextLocale = defaultLocale,
        direction,
        renderEmpty,
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const mergedSize = customizeSize || size;
      const tableLocale = Object.assign(Object.assign({}, contextLocale.Table), locale2);
      const rawData = dataSource || EMPTY_LIST;
      const prefixCls = getPrefixCls("table", customizePrefixCls);
      const dropdownPrefixCls = getPrefixCls("dropdown", customizeDropdownPrefixCls);
      const mergedExpandable = Object.assign({
        childrenColumnName: legacyChildrenColumnName,
        expandIconColumnIndex
      }, expandable);
      const {
        childrenColumnName = "children"
      } = mergedExpandable;
      const expandType = reactExports.useMemo(() => {
        if (rawData.some((item) => item === null || item === void 0 ? void 0 : item[childrenColumnName])) {
          return "nest";
        }
        if (expandedRowRender || expandable && expandable.expandedRowRender) {
          return "row";
        }
        return null;
      }, [rawData]);
      const internalRefs = {
        body: reactExports.useRef()
      };
      const getRowKey = reactExports.useMemo(() => {
        if (typeof rowKey === "function") {
          return rowKey;
        }
        return (record) => record === null || record === void 0 ? void 0 : record[rowKey];
      }, [rowKey]);
      const [getRecordByKey] = useLazyKVMap(rawData, childrenColumnName, getRowKey);
      const changeEventInfo = {};
      const triggerOnChange = function(info2, action) {
        let reset2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        const changeInfo = Object.assign(Object.assign({}, changeEventInfo), info2);
        if (reset2) {
          changeEventInfo.resetPagination();
          if (changeInfo.pagination.current) {
            changeInfo.pagination.current = 1;
          }
          if (pagination && pagination.onChange) {
            pagination.onChange(1, changeInfo.pagination.pageSize);
          }
        }
        if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body.current) {
          scrollTo$1(0, {
            getContainer: () => internalRefs.body.current
          });
        }
        onChange === null || onChange === void 0 ? void 0 : onChange(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
          currentDataSource: getFilterData(getSortData(rawData, changeInfo.sorterStates, childrenColumnName), changeInfo.filterStates),
          action
        });
      };
      const onSorterChange = (sorter, sorterStates) => {
        triggerOnChange({
          sorter,
          sorterStates
        }, "sort", false);
      };
      const [transformSorterColumns, sortStates, sorterTitleProps, getSorters] = useFilterSorter({
        prefixCls,
        mergedColumns,
        onSorterChange,
        sortDirections: sortDirections || ["ascend", "descend"],
        tableLocale,
        showSorterTooltip
      });
      const sortedData = reactExports.useMemo(() => getSortData(rawData, sortStates, childrenColumnName), [rawData, sortStates]);
      changeEventInfo.sorter = getSorters();
      changeEventInfo.sorterStates = sortStates;
      const onFilterChange = (filters2, filterStates2) => {
        triggerOnChange({
          filters: filters2,
          filterStates: filterStates2
        }, "filter", true);
      };
      const [transformFilterColumns, filterStates, filters] = useFilter({
        prefixCls,
        locale: tableLocale,
        dropdownPrefixCls,
        mergedColumns,
        onFilterChange,
        getPopupContainer: getPopupContainer || getContextPopupContainer
      });
      const mergedData = getFilterData(sortedData, filterStates);
      changeEventInfo.filters = filters;
      changeEventInfo.filterStates = filterStates;
      const columnTitleProps = reactExports.useMemo(() => {
        const mergedFilters = {};
        Object.keys(filters).forEach((filterKey) => {
          if (filters[filterKey] !== null) {
            mergedFilters[filterKey] = filters[filterKey];
          }
        });
        return Object.assign(Object.assign({}, sorterTitleProps), {
          filters: mergedFilters
        });
      }, [sorterTitleProps, filters]);
      const [transformTitleColumns] = useTitleColumns(columnTitleProps);
      const onPaginationChange = (current, pageSize) => {
        triggerOnChange({
          pagination: Object.assign(Object.assign({}, changeEventInfo.pagination), {
            current,
            pageSize
          })
        }, "paginate");
      };
      const [mergedPagination, resetPagination] = usePagination(mergedData.length, onPaginationChange, pagination);
      changeEventInfo.pagination = pagination === false ? {} : getPaginationParam(mergedPagination, pagination);
      changeEventInfo.resetPagination = resetPagination;
      const pageData = reactExports.useMemo(() => {
        if (pagination === false || !mergedPagination.pageSize) {
          return mergedData;
        }
        const {
          current = 1,
          total,
          pageSize = DEFAULT_PAGE_SIZE
        } = mergedPagination;
        if (mergedData.length < total) {
          if (mergedData.length > pageSize) {
            return mergedData.slice((current - 1) * pageSize, current * pageSize);
          }
          return mergedData;
        }
        return mergedData.slice((current - 1) * pageSize, current * pageSize);
      }, [!!pagination, mergedData, mergedPagination && mergedPagination.current, mergedPagination && mergedPagination.pageSize, mergedPagination && mergedPagination.total]);
      const [transformSelectionColumns, selectedKeySet] = useSelection({
        prefixCls,
        data: mergedData,
        pageData,
        getRowKey,
        getRecordByKey,
        expandType,
        childrenColumnName,
        locale: tableLocale,
        getPopupContainer: getPopupContainer || getContextPopupContainer
      }, rowSelection);
      const internalRowClassName = (record, index2, indent) => {
        let mergedRowClassName;
        if (typeof rowClassName === "function") {
          mergedRowClassName = classNames(rowClassName(record, index2, indent));
        } else {
          mergedRowClassName = classNames(rowClassName);
        }
        return classNames({
          [`${prefixCls}-row-selected`]: selectedKeySet.has(getRowKey(record, index2))
        }, mergedRowClassName);
      };
      mergedExpandable.__PARENT_RENDER_ICON__ = mergedExpandable.expandIcon;
      mergedExpandable.expandIcon = mergedExpandable.expandIcon || expandIcon || renderExpandIcon(tableLocale);
      if (expandType === "nest" && mergedExpandable.expandIconColumnIndex === void 0) {
        mergedExpandable.expandIconColumnIndex = rowSelection ? 1 : 0;
      } else if (mergedExpandable.expandIconColumnIndex > 0 && rowSelection) {
        mergedExpandable.expandIconColumnIndex -= 1;
      }
      if (typeof mergedExpandable.indentSize !== "number") {
        mergedExpandable.indentSize = typeof indentSize === "number" ? indentSize : 15;
      }
      const transformColumns = reactExports.useCallback((innerColumns) => transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(innerColumns)))), [transformSorterColumns, transformFilterColumns, transformSelectionColumns]);
      let topPaginationNode;
      let bottomPaginationNode;
      if (pagination !== false && (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.total)) {
        let paginationSize;
        if (mergedPagination.size) {
          paginationSize = mergedPagination.size;
        } else {
          paginationSize = mergedSize === "small" || mergedSize === "middle" ? "small" : void 0;
        }
        const renderPagination = (position3) => /* @__PURE__ */ reactExports.createElement(Pagination$1, Object.assign({}, mergedPagination, {
          className: classNames(`${prefixCls}-pagination ${prefixCls}-pagination-${position3}`, mergedPagination.className),
          size: paginationSize
        }));
        const defaultPosition = direction === "rtl" ? "left" : "right";
        const {
          position: position2
        } = mergedPagination;
        if (position2 !== null && Array.isArray(position2)) {
          const topPos = position2.find((p2) => p2.includes("top"));
          const bottomPos = position2.find((p2) => p2.includes("bottom"));
          const isDisable = position2.every((p2) => `${p2}` === "none");
          if (!topPos && !bottomPos && !isDisable) {
            bottomPaginationNode = renderPagination(defaultPosition);
          }
          if (topPos) {
            topPaginationNode = renderPagination(topPos.toLowerCase().replace("top", ""));
          }
          if (bottomPos) {
            bottomPaginationNode = renderPagination(bottomPos.toLowerCase().replace("bottom", ""));
          }
        } else {
          bottomPaginationNode = renderPagination(defaultPosition);
        }
      }
      let spinProps;
      if (typeof loading === "boolean") {
        spinProps = {
          spinning: loading
        };
      } else if (typeof loading === "object") {
        spinProps = Object.assign({
          spinning: true
        }, loading);
      }
      const [wrapSSR, hashId] = useStyle$5(prefixCls);
      const wrapperClassNames = classNames(`${prefixCls}-wrapper`, {
        [`${prefixCls}-wrapper-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      const emptyText = locale2 && locale2.emptyText || (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Table")) || /* @__PURE__ */ reactExports.createElement(DefaultRenderEmpty$1, {
        componentName: "Table"
      });
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", {
        ref,
        className: wrapperClassNames,
        style: style2
      }, /* @__PURE__ */ reactExports.createElement(la, Object.assign({
        spinning: false
      }, spinProps), topPaginationNode, /* @__PURE__ */ reactExports.createElement(RcTable, Object.assign({}, tableProps, {
        columns: mergedColumns,
        direction,
        expandable: mergedExpandable,
        prefixCls,
        className: classNames({
          [`${prefixCls}-middle`]: mergedSize === "middle",
          [`${prefixCls}-small`]: mergedSize === "small",
          [`${prefixCls}-bordered`]: bordered,
          [`${prefixCls}-empty`]: rawData.length === 0
        }),
        data: pageData,
        rowKey: getRowKey,
        rowClassName: internalRowClassName,
        emptyText,
        // Internal
        internalHooks: INTERNAL_HOOKS,
        internalRefs,
        transformColumns
      })), bottomPaginationNode)));
    }
    const InternalTable$1 = /* @__PURE__ */ reactExports.forwardRef(InternalTable);
    function Table(props, ref) {
      const renderTimesRef = reactExports.useRef(0);
      renderTimesRef.current += 1;
      return /* @__PURE__ */ reactExports.createElement(InternalTable$1, Object.assign({}, props, {
        ref,
        _renderTimes: renderTimesRef.current
      }));
    }
    const ForwardTable = /* @__PURE__ */ reactExports.forwardRef(Table);
    ForwardTable.SELECTION_COLUMN = SELECTION_COLUMN;
    ForwardTable.EXPAND_COLUMN = EXPAND_COLUMN;
    ForwardTable.SELECTION_ALL = SELECTION_ALL;
    ForwardTable.SELECTION_INVERT = SELECTION_INVERT;
    ForwardTable.SELECTION_NONE = SELECTION_NONE;
    ForwardTable.Column = Column;
    ForwardTable.ColumnGroup = ColumnGroup;
    ForwardTable.Summary = FooterComponents;
    const Table$1 = ForwardTable;
    function capitalize(str) {
      if (typeof str !== "string") {
        return str;
      }
      const ret = str.charAt(0).toUpperCase() + str.slice(1);
      return ret;
    }
    const genTagStatusStyle = (token2, status, cssVariableType) => {
      const capitalizedCssVariableType = capitalize(cssVariableType);
      return {
        [`${token2.componentCls}-${status}`]: {
          color: token2[`color${cssVariableType}`],
          background: token2[`color${capitalizedCssVariableType}Bg`],
          borderColor: token2[`color${capitalizedCssVariableType}Border`]
        }
      };
    };
    const genPresetStyle = (token2) => genPresetColor(token2, (colorKey, _ref) => {
      let {
        textColor,
        lightBorderColor,
        lightColor,
        darkColor
      } = _ref;
      return {
        [`${token2.componentCls}-${colorKey}`]: {
          color: textColor,
          background: lightColor,
          borderColor: lightBorderColor,
          // Inverse color
          "&-inverse": {
            color: token2.colorTextLightSolid,
            background: darkColor,
            borderColor: darkColor
          }
        }
      };
    });
    const genBaseStyle$1 = (token2) => {
      const {
        paddingXXS,
        lineWidth,
        tagPaddingHorizontal,
        componentCls
      } = token2;
      const paddingInline = tagPaddingHorizontal - lineWidth;
      const iconMarginInline = paddingXXS - lineWidth;
      return {
        // Result
        [componentCls]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
          display: "inline-block",
          height: "auto",
          marginInlineEnd: token2.marginXS,
          paddingInline,
          fontSize: token2.tagFontSize,
          lineHeight: `${token2.tagLineHeight}px`,
          whiteSpace: "nowrap",
          background: token2.tagDefaultBg,
          border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusSM,
          opacity: 1,
          transition: `all ${token2.motionDurationMid}`,
          textAlign: "start",
          // RTL
          [`&${componentCls}-rtl`]: {
            direction: "rtl"
          },
          "&, a, a:hover": {
            color: token2.tagDefaultColor
          },
          [`${componentCls}-close-icon`]: {
            marginInlineStart: iconMarginInline,
            color: token2.colorTextDescription,
            fontSize: token2.tagIconSize,
            cursor: "pointer",
            transition: `all ${token2.motionDurationMid}`,
            "&:hover": {
              color: token2.colorTextHeading
            }
          },
          [`&${componentCls}-has-color`]: {
            borderColor: "transparent",
            [`&, a, a:hover, ${token2.iconCls}-close, ${token2.iconCls}-close:hover`]: {
              color: token2.colorTextLightSolid
            }
          },
          [`&-checkable`]: {
            backgroundColor: "transparent",
            borderColor: "transparent",
            cursor: "pointer",
            [`&:not(${componentCls}-checkable-checked):hover`]: {
              color: token2.colorPrimary,
              backgroundColor: token2.colorFillSecondary
            },
            "&:active, &-checked": {
              color: token2.colorTextLightSolid
            },
            "&-checked": {
              backgroundColor: token2.colorPrimary,
              "&:hover": {
                backgroundColor: token2.colorPrimaryHover
              }
            },
            "&:active": {
              backgroundColor: token2.colorPrimaryActive
            }
          },
          [`&-hidden`]: {
            display: "none"
          },
          // To ensure that a space will be placed between character and `Icon`.
          [`> ${token2.iconCls} + span, > span + ${token2.iconCls}`]: {
            marginInlineStart: paddingInline
          }
        })
      };
    };
    const useStyle$4 = genComponentStyleHook("Tag", (token2) => {
      const {
        fontSize,
        lineHeight,
        lineWidth,
        fontSizeIcon
      } = token2;
      const tagHeight = Math.round(fontSize * lineHeight);
      const tagFontSize = token2.fontSizeSM;
      const tagLineHeight = tagHeight - lineWidth * 2;
      const tagDefaultBg = token2.colorFillAlter;
      const tagDefaultColor = token2.colorText;
      const tagToken = merge$4(token2, {
        tagFontSize,
        tagLineHeight,
        tagDefaultBg,
        tagDefaultColor,
        tagIconSize: fontSizeIcon - 2 * lineWidth,
        tagPaddingHorizontal: 8
        // Fixed padding.
      });
      return [genBaseStyle$1(tagToken), genPresetStyle(tagToken), genTagStatusStyle(tagToken, "success", "Success"), genTagStatusStyle(tagToken, "processing", "Info"), genTagStatusStyle(tagToken, "error", "Error"), genTagStatusStyle(tagToken, "warning", "Warning")];
    });
    var __rest$9 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const CheckableTag = (_a) => {
      var {
        prefixCls: customizePrefixCls,
        className,
        checked,
        onChange,
        onClick
      } = _a, restProps = __rest$9(_a, ["prefixCls", "className", "checked", "onChange", "onClick"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const handleClick = (e2) => {
        onChange === null || onChange === void 0 ? void 0 : onChange(!checked);
        onClick === null || onClick === void 0 ? void 0 : onClick(e2);
      };
      const prefixCls = getPrefixCls("tag", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$4(prefixCls);
      const cls = classNames(prefixCls, {
        [`${prefixCls}-checkable`]: true,
        [`${prefixCls}-checkable-checked`]: checked
      }, className, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("span", Object.assign({}, restProps, {
        className: cls,
        onClick: handleClick
      })));
    };
    const CheckableTag$1 = CheckableTag;
    var __rest$8 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const InternalTag = (_a, ref) => {
      var {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        style: style2,
        children,
        icon,
        color: color2,
        onClose,
        closeIcon,
        closable = false
      } = _a, props = __rest$8(_a, ["prefixCls", "className", "rootClassName", "style", "children", "icon", "color", "onClose", "closeIcon", "closable"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const [visible, setVisible] = reactExports.useState(true);
      reactExports.useEffect(() => {
        if ("visible" in props) {
          setVisible(props.visible);
        }
      }, [props.visible]);
      const isInternalColor = isPresetColor(color2) || isPresetStatusColor(color2);
      const tagStyle = Object.assign({
        backgroundColor: color2 && !isInternalColor ? color2 : void 0
      }, style2);
      const prefixCls = getPrefixCls("tag", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$4(prefixCls);
      const tagClassName = classNames(prefixCls, {
        [`${prefixCls}-${color2}`]: isInternalColor,
        [`${prefixCls}-has-color`]: color2 && !isInternalColor,
        [`${prefixCls}-hidden`]: !visible,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      const handleCloseClick = (e2) => {
        e2.stopPropagation();
        onClose === null || onClose === void 0 ? void 0 : onClose(e2);
        if (e2.defaultPrevented) {
          return;
        }
        setVisible(false);
      };
      const renderCloseIcon2 = () => {
        if (closable) {
          return closeIcon ? /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-close-icon`,
            onClick: handleCloseClick
          }, closeIcon) : /* @__PURE__ */ reactExports.createElement(CloseOutlined$1, {
            className: `${prefixCls}-close-icon`,
            onClick: handleCloseClick
          });
        }
        return null;
      };
      const isNeedWave = typeof props.onClick === "function" || children && children.type === "a";
      const iconNode = icon || null;
      const kids = iconNode ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, iconNode, /* @__PURE__ */ reactExports.createElement("span", null, children)) : children;
      const tagNode = /* @__PURE__ */ reactExports.createElement("span", Object.assign({}, props, {
        ref,
        className: tagClassName,
        style: tagStyle
      }), kids, renderCloseIcon2());
      return wrapSSR(isNeedWave ? /* @__PURE__ */ reactExports.createElement(Wave$1, null, tagNode) : tagNode);
    };
    const Tag = /* @__PURE__ */ reactExports.forwardRef(InternalTag);
    Tag.CheckableTag = CheckableTag$1;
    const Ca = Tag;
    var __rest$7 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const {
      TimePicker: InternalTimePicker,
      RangePicker: InternalRangePicker
    } = DatePicker$1;
    const RangePicker = /* @__PURE__ */ reactExports.forwardRef((props, ref) => /* @__PURE__ */ reactExports.createElement(InternalRangePicker, Object.assign({}, props, {
      picker: "time",
      mode: void 0,
      ref
    })));
    const TimePicker = /* @__PURE__ */ reactExports.forwardRef((_a, ref) => {
      var {
        addon,
        renderExtraFooter
      } = _a, restProps = __rest$7(_a, ["addon", "renderExtraFooter"]);
      const internalRenderExtraFooter = reactExports.useMemo(() => {
        if (renderExtraFooter) {
          return renderExtraFooter;
        }
        if (addon) {
          return addon;
        }
        return void 0;
      }, [addon, renderExtraFooter]);
      return /* @__PURE__ */ reactExports.createElement(InternalTimePicker, Object.assign({}, restProps, {
        mode: void 0,
        ref,
        renderExtraFooter: internalRenderExtraFooter
      }));
    });
    const PurePanel = genPurePanel(TimePicker, "picker");
    TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel;
    TimePicker.RangePicker = RangePicker;
    TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel;
    const TimePicker$1 = TimePicker;
    var __rest$6 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const inlineStyle = {
      border: 0,
      background: "transparent",
      padding: 0,
      lineHeight: "inherit",
      display: "inline-block"
    };
    const TransButton = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const onKeyDown2 = (event) => {
        const {
          keyCode
        } = event;
        if (keyCode === KeyCode.ENTER) {
          event.preventDefault();
        }
      };
      const onKeyUp = (event) => {
        const {
          keyCode
        } = event;
        const {
          onClick
        } = props;
        if (keyCode === KeyCode.ENTER && onClick) {
          onClick();
        }
      };
      const {
        style: style2,
        noStyle,
        disabled
      } = props, restProps = __rest$6(props, ["style", "noStyle", "disabled"]);
      let mergedStyle = {};
      if (!noStyle) {
        mergedStyle = Object.assign({}, inlineStyle);
      }
      if (disabled) {
        mergedStyle.pointerEvents = "none";
      }
      mergedStyle = Object.assign(Object.assign({}, mergedStyle), style2);
      return /* @__PURE__ */ reactExports.createElement("div", Object.assign({
        role: "button",
        tabIndex: 0,
        ref
      }, restProps, {
        onKeyDown: onKeyDown2,
        onKeyUp,
        style: mergedStyle
      }));
    });
    const TransButton$1 = TransButton;
    var toggleSelection = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i2 = 0; i2 < selection.rangeCount; i2++) {
        ranges.push(selection.getRangeAt(i2));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range2) {
            selection.addRange(range2);
          });
        }
        active && active.focus();
      };
    };
    var deselectCurrent = toggleSelection;
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message2) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message2.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text2, options) {
      var debug, message2, reselectPrevious, range2, selection, mark2, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range2 = document.createRange();
        selection = document.getSelection();
        mark2 = document.createElement("span");
        mark2.textContent = text2;
        mark2.ariaHidden = "true";
        mark2.style.all = "unset";
        mark2.style.position = "fixed";
        mark2.style.top = 0;
        mark2.style.clip = "rect(0, 0, 0, 0)";
        mark2.style.whiteSpace = "pre";
        mark2.style.webkitUserSelect = "text";
        mark2.style.MozUserSelect = "text";
        mark2.style.msUserSelect = "text";
        mark2.style.userSelect = "text";
        mark2.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text2);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options.format, text2);
            }
          }
          if (options.onCopy) {
            e2.preventDefault();
            options.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark2);
        range2.selectNodeContents(mark2);
        selection.addRange(range2);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text2);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message2 = format("message" in options ? options.message : defaultMessage);
          window.prompt(message2, text2);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range2);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark2) {
          document.body.removeChild(mark2);
        }
        reselectPrevious();
      }
      return success;
    }
    var copyToClipboard = copy;
    const getTitleStyle = (fontSize, lineHeight, color2, token2) => {
      const {
        sizeMarginHeadingVerticalEnd,
        fontWeightStrong
      } = token2;
      return {
        marginBottom: sizeMarginHeadingVerticalEnd,
        color: color2,
        fontWeight: fontWeightStrong,
        fontSize,
        lineHeight
      };
    };
    const getTitleStyles = (token2) => {
      const headings = [1, 2, 3, 4, 5];
      const styles = {};
      headings.forEach((headingLevel) => {
        styles[`
      h${headingLevel}&,
      div&-h${headingLevel},
      div&-h${headingLevel} > textarea,
      h${headingLevel}
    `] = getTitleStyle(token2[`fontSizeHeading${headingLevel}`], token2[`lineHeightHeading${headingLevel}`], token2.colorTextHeading, token2);
      });
      return styles;
    };
    const getLinkStyles = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        "a&, a": Object.assign(Object.assign({}, operationUnit$1(token2)), {
          textDecoration: token2.linkDecoration,
          "&:active, &:hover": {
            textDecoration: token2.linkHoverDecoration
          },
          [`&[disabled], &${componentCls}-disabled`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed",
            "&:active, &:hover": {
              color: token2.colorTextDisabled
            },
            "&:active": {
              pointerEvents: "none"
            }
          }
        })
      };
    };
    const getResetStyles = (token2) => ({
      code: {
        margin: "0 0.2em",
        paddingInline: "0.4em",
        paddingBlock: "0.2em 0.1em",
        fontSize: "85%",
        fontFamily: token2.fontFamilyCode,
        background: "rgba(150, 150, 150, 0.1)",
        border: "1px solid rgba(100, 100, 100, 0.2)",
        borderRadius: 3
      },
      kbd: {
        margin: "0 0.2em",
        paddingInline: "0.4em",
        paddingBlock: "0.15em 0.1em",
        fontSize: "90%",
        fontFamily: token2.fontFamilyCode,
        background: "rgba(150, 150, 150, 0.06)",
        border: "1px solid rgba(100, 100, 100, 0.2)",
        borderBottomWidth: 2,
        borderRadius: 3
      },
      mark: {
        padding: 0,
        // FIXME hardcode in v4
        backgroundColor: gold[2]
      },
      "u, ins": {
        textDecoration: "underline",
        textDecorationSkipInk: "auto"
      },
      "s, del": {
        textDecoration: "line-through"
      },
      strong: {
        fontWeight: 600
      },
      // list
      "ul, ol": {
        marginInline: 0,
        marginBlock: "0 1em",
        padding: 0,
        li: {
          marginInline: "20px 0",
          marginBlock: 0,
          paddingInline: "4px 0",
          paddingBlock: 0
        }
      },
      ul: {
        listStyleType: "circle",
        ul: {
          listStyleType: "disc"
        }
      },
      ol: {
        listStyleType: "decimal"
      },
      // pre & block
      "pre, blockquote": {
        margin: "1em 0"
      },
      pre: {
        padding: "0.4em 0.6em",
        whiteSpace: "pre-wrap",
        wordWrap: "break-word",
        background: "rgba(150, 150, 150, 0.1)",
        border: "1px solid rgba(100, 100, 100, 0.2)",
        borderRadius: 3,
        fontFamily: token2.fontFamilyCode,
        // Compatible for marked
        code: {
          display: "inline",
          margin: 0,
          padding: 0,
          fontSize: "inherit",
          fontFamily: "inherit",
          background: "transparent",
          border: 0
        }
      },
      blockquote: {
        paddingInline: "0.6em 0",
        paddingBlock: 0,
        borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
        opacity: 0.85
      }
    });
    const getEditableStyles = (token2) => {
      const {
        componentCls
      } = token2;
      const inputToken = initInputToken(token2);
      const inputShift = inputToken.inputPaddingVertical + 1;
      return {
        "&-edit-content": {
          position: "relative",
          "div&": {
            insetInlineStart: -token2.paddingSM,
            marginTop: -inputShift,
            marginBottom: `calc(1em - ${inputShift}px)`
          },
          [`${componentCls}-edit-content-confirm`]: {
            position: "absolute",
            insetInlineEnd: token2.marginXS + 2,
            insetBlockEnd: token2.marginXS,
            color: token2.colorTextDescription,
            // default style
            fontWeight: "normal",
            fontSize: token2.fontSize,
            fontStyle: "normal",
            pointerEvents: "none"
          },
          textarea: {
            margin: "0!important",
            // Fix Editable Textarea flash in Firefox
            MozTransition: "none",
            height: "1em"
          }
        }
      };
    };
    const getCopyableStyles = (token2) => ({
      "&-copy-success": {
        [`
    &,
    &:hover,
    &:focus`]: {
          color: token2.colorSuccess
        }
      }
    });
    const getEllipsisStyles = () => ({
      [`
  a&-ellipsis,
  span&-ellipsis
  `]: {
        display: "inline-block",
        maxWidth: "100%"
      },
      "&-single-line": {
        whiteSpace: "nowrap"
      },
      "&-ellipsis-single-line": {
        overflow: "hidden",
        textOverflow: "ellipsis",
        // https://blog.csdn.net/iefreer/article/details/50421025
        "a&, span&": {
          verticalAlign: "bottom"
        }
      },
      "&-ellipsis-multiple-line": {
        display: "-webkit-box",
        overflow: "hidden",
        WebkitLineClamp: 3,
        WebkitBoxOrient: "vertical"
      }
    });
    const genTypographyStyle = (token2) => {
      const {
        componentCls,
        sizeMarginHeadingVerticalStart
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
          color: token2.colorText,
          wordBreak: "break-word",
          lineHeight: token2.lineHeight,
          [`&${componentCls}-secondary`]: {
            color: token2.colorTextDescription
          },
          [`&${componentCls}-success`]: {
            color: token2.colorSuccess
          },
          [`&${componentCls}-warning`]: {
            color: token2.colorWarning
          },
          [`&${componentCls}-danger`]: {
            color: token2.colorError,
            "a&:active, a&:focus": {
              color: token2.colorErrorActive
            },
            "a&:hover": {
              color: token2.colorErrorHover
            }
          },
          [`&${componentCls}-disabled`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed",
            userSelect: "none"
          },
          [`
        div&,
        p
      `]: {
            marginBottom: "1em"
          }
        }, getTitleStyles(token2)), {
          [`
      & + h1${componentCls},
      & + h2${componentCls},
      & + h3${componentCls},
      & + h4${componentCls},
      & + h5${componentCls}
      `]: {
            marginTop: sizeMarginHeadingVerticalStart
          },
          [`
      div,
      ul,
      li,
      p,
      h1,
      h2,
      h3,
      h4,
      h5`]: {
            [`
        + h1,
        + h2,
        + h3,
        + h4,
        + h5
        `]: {
              marginTop: sizeMarginHeadingVerticalStart
            }
          }
        }), getResetStyles(token2)), getLinkStyles(token2)), {
          // Operation
          [`
        ${componentCls}-expand,
        ${componentCls}-edit,
        ${componentCls}-copy
      `]: Object.assign(Object.assign({}, operationUnit$1(token2)), {
            marginInlineStart: token2.marginXXS
          })
        }), getEditableStyles(token2)), getCopyableStyles(token2)), getEllipsisStyles()), {
          "&-rtl": {
            direction: "rtl"
          }
        })
      };
    };
    const useStyle$3 = genComponentStyleHook("Typography", (token2) => [genTypographyStyle(token2)], {
      sizeMarginHeadingVerticalStart: "1.2em",
      sizeMarginHeadingVerticalEnd: "0.5em"
    });
    const Editable = (_ref) => {
      let {
        prefixCls,
        "aria-label": ariaLabel,
        className,
        style: style2,
        direction,
        maxLength,
        autoSize = true,
        value,
        onSave,
        onCancel,
        onEnd,
        component,
        enterIcon = /* @__PURE__ */ reactExports.createElement(EnterOutlined$1, null)
      } = _ref;
      const ref = reactExports.useRef(null);
      const inComposition = reactExports.useRef(false);
      const lastKeyCode = reactExports.useRef();
      const [current, setCurrent] = reactExports.useState(value);
      reactExports.useEffect(() => {
        setCurrent(value);
      }, [value]);
      reactExports.useEffect(() => {
        if (ref.current && ref.current.resizableTextArea) {
          const {
            textArea
          } = ref.current.resizableTextArea;
          textArea.focus();
          const {
            length: length2
          } = textArea.value;
          textArea.setSelectionRange(length2, length2);
        }
      }, []);
      const onChange = (_ref2) => {
        let {
          target
        } = _ref2;
        setCurrent(target.value.replace(/[\n\r]/g, ""));
      };
      const onCompositionStart = () => {
        inComposition.current = true;
      };
      const onCompositionEnd = () => {
        inComposition.current = false;
      };
      const onKeyDown2 = (_ref3) => {
        let {
          keyCode
        } = _ref3;
        if (inComposition.current)
          return;
        lastKeyCode.current = keyCode;
      };
      const confirmChange = () => {
        onSave(current.trim());
      };
      const onKeyUp = (_ref4) => {
        let {
          keyCode,
          ctrlKey,
          altKey,
          metaKey,
          shiftKey
        } = _ref4;
        if (lastKeyCode.current === keyCode && !inComposition.current && !ctrlKey && !altKey && !metaKey && !shiftKey) {
          if (keyCode === KeyCode.ENTER) {
            confirmChange();
            onEnd === null || onEnd === void 0 ? void 0 : onEnd();
          } else if (keyCode === KeyCode.ESC) {
            onCancel();
          }
        }
      };
      const onBlur = () => {
        confirmChange();
      };
      const textClassName = component ? `${prefixCls}-${component}` : "";
      const [wrapSSR, hashId] = useStyle$3(prefixCls);
      const textAreaClassName = classNames(prefixCls, `${prefixCls}-edit-content`, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, textClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", {
        className: textAreaClassName,
        style: style2
      }, /* @__PURE__ */ reactExports.createElement(TextArea$1, {
        ref,
        maxLength,
        value: current,
        onChange,
        onKeyDown: onKeyDown2,
        onKeyUp,
        onCompositionStart,
        onCompositionEnd,
        onBlur,
        "aria-label": ariaLabel,
        rows: 1,
        autoSize
      }), enterIcon !== null ? cloneElement(enterIcon, {
        className: `${prefixCls}-edit-content-confirm`
      }) : null));
    };
    const Editable$1 = Editable;
    function useMergedConfig(propConfig, templateConfig) {
      return reactExports.useMemo(() => {
        const support = !!propConfig;
        return [support, Object.assign(Object.assign({}, templateConfig), support && typeof propConfig === "object" ? propConfig : null)];
      }, [propConfig]);
    }
    const useUpdatedEffect = (callback, conditions) => {
      const mountRef = reactExports.useRef(false);
      reactExports.useEffect(() => {
        if (mountRef.current) {
          callback();
        } else {
          mountRef.current = true;
        }
      }, conditions);
    };
    const useUpdatedEffect$1 = useUpdatedEffect;
    var __rest$5 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Typography$2 = /* @__PURE__ */ reactExports.forwardRef((_a, ref) => {
      var {
        prefixCls: customizePrefixCls,
        component: Component = "article",
        className,
        rootClassName,
        setContentRef,
        children,
        direction: typographyDirection
      } = _a, restProps = __rest$5(_a, ["prefixCls", "component", "className", "rootClassName", "setContentRef", "children", "direction"]);
      const {
        getPrefixCls,
        direction: contextDirection
      } = reactExports.useContext(ConfigContext);
      const direction = typographyDirection !== null && typographyDirection !== void 0 ? typographyDirection : contextDirection;
      let mergedRef = ref;
      if (setContentRef) {
        mergedRef = composeRef(ref, setContentRef);
      }
      const prefixCls = getPrefixCls("typography", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$3(prefixCls);
      const componentClassName = classNames(prefixCls, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      return wrapSSR(
        // @ts-expect-error: Expression produces a union type that is too complex to represent.
        /* @__PURE__ */ reactExports.createElement(Component, Object.assign({
          className: componentClassName,
          ref: mergedRef
        }, restProps), children)
      );
    });
    const OriginTypography = Typography$2;
    function cuttable(node2) {
      const type2 = typeof node2;
      return type2 === "string" || type2 === "number";
    }
    function getNodesLen(nodeList) {
      let totalLen = 0;
      nodeList.forEach((node2) => {
        if (cuttable(node2)) {
          totalLen += String(node2).length;
        } else {
          totalLen += 1;
        }
      });
      return totalLen;
    }
    function sliceNodes(nodeList, len) {
      let currLen = 0;
      const currentNodeList = [];
      for (let i2 = 0; i2 < nodeList.length; i2 += 1) {
        if (currLen === len) {
          return currentNodeList;
        }
        const node2 = nodeList[i2];
        const canCut = cuttable(node2);
        const nodeLen = canCut ? String(node2).length : 1;
        const nextLen = currLen + nodeLen;
        if (nextLen > len) {
          const restLen = len - currLen;
          currentNodeList.push(String(node2).slice(0, restLen));
          return currentNodeList;
        }
        currentNodeList.push(node2);
        currLen = nextLen;
      }
      return nodeList;
    }
    const NONE$1 = 0;
    const PREPARE = 1;
    const WALKING = 2;
    const DONE_WITH_ELLIPSIS = 3;
    const DONE_WITHOUT_ELLIPSIS = 4;
    const Ellipsis = (_ref) => {
      let {
        enabledMeasure,
        children,
        text: text2,
        width,
        fontSize,
        rows,
        onEllipsis
      } = _ref;
      const [[startLen, midLen, endLen], setCutLength] = reactExports.useState([0, 0, 0]);
      const [walkingState, setWalkingState] = reactExports.useState(NONE$1);
      const [singleRowHeight, setSingleRowHeight] = reactExports.useState(0);
      const singleRowRef = reactExports.useRef(null);
      const midRowRef = reactExports.useRef(null);
      const nodeList = reactExports.useMemo(() => toArray$8(text2), [text2]);
      const totalLen = reactExports.useMemo(() => getNodesLen(nodeList), [nodeList]);
      const mergedChildren = reactExports.useMemo(() => {
        if (!enabledMeasure || walkingState !== DONE_WITH_ELLIPSIS) {
          return children(nodeList, false);
        }
        return children(sliceNodes(nodeList, midLen), midLen < totalLen);
      }, [enabledMeasure, walkingState, children, nodeList, midLen, totalLen]);
      useLayoutEffect$1(() => {
        if (enabledMeasure && width && fontSize && totalLen) {
          setWalkingState(PREPARE);
          setCutLength([0, Math.ceil(totalLen / 2), totalLen]);
        }
      }, [enabledMeasure, width, fontSize, text2, totalLen, rows]);
      useLayoutEffect$1(() => {
        var _a;
        if (walkingState === PREPARE) {
          setSingleRowHeight(((_a = singleRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0);
        }
      }, [walkingState]);
      useLayoutEffect$1(() => {
        var _a, _b;
        if (singleRowHeight) {
          if (walkingState === PREPARE) {
            const midHeight = ((_a = midRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
            const maxHeight = rows * singleRowHeight;
            if (midHeight <= maxHeight) {
              setWalkingState(DONE_WITHOUT_ELLIPSIS);
              onEllipsis(false);
            } else {
              setWalkingState(WALKING);
            }
          } else if (walkingState === WALKING) {
            if (startLen !== endLen) {
              const midHeight = ((_b = midRowRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;
              const maxHeight = rows * singleRowHeight;
              let nextStartLen = startLen;
              let nextEndLen = endLen;
              if (startLen === endLen - 1) {
                nextEndLen = startLen;
              } else if (midHeight <= maxHeight) {
                nextStartLen = midLen;
              } else {
                nextEndLen = midLen;
              }
              const nextMidLen = Math.ceil((nextStartLen + nextEndLen) / 2);
              setCutLength([nextStartLen, nextMidLen, nextEndLen]);
            } else {
              setWalkingState(DONE_WITH_ELLIPSIS);
              onEllipsis(true);
            }
          }
        }
      }, [walkingState, startLen, endLen, rows, singleRowHeight]);
      const measureStyle = {
        width,
        whiteSpace: "normal",
        margin: 0,
        padding: 0
      };
      const renderMeasure = (content2, ref, style2) => /* @__PURE__ */ reactExports.createElement("span", {
        "aria-hidden": true,
        ref,
        style: Object.assign({
          position: "fixed",
          display: "block",
          left: 0,
          top: 0,
          zIndex: -9999,
          visibility: "hidden",
          pointerEvents: "none",
          fontSize: Math.floor(fontSize / 2) * 2
        }, style2)
      }, content2);
      const renderMeasureSlice = (len, ref) => {
        const sliceNodeList = sliceNodes(nodeList, len);
        return renderMeasure(children(sliceNodeList, true), ref, measureStyle);
      };
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, mergedChildren, enabledMeasure && walkingState !== DONE_WITH_ELLIPSIS && walkingState !== DONE_WITHOUT_ELLIPSIS && /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, renderMeasure("lg", singleRowRef, {
        wordBreak: "keep-all",
        whiteSpace: "nowrap"
      }), walkingState === PREPARE ? renderMeasure(children(nodeList, false), midRowRef, measureStyle) : renderMeasureSlice(midLen, midRowRef)));
    };
    const Ellipsis$1 = Ellipsis;
    const EllipsisTooltip = (_ref) => {
      let {
        enabledEllipsis,
        isEllipsis,
        children,
        tooltipProps
      } = _ref;
      if (!(tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.title) || !enabledEllipsis) {
        return children;
      }
      return /* @__PURE__ */ reactExports.createElement(pn, Object.assign({
        open: isEllipsis ? void 0 : false
      }, tooltipProps), children);
    };
    const EllipsisTooltip$1 = EllipsisTooltip;
    var __rest$4 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function wrapperDecorations(_ref, content2) {
      let {
        mark: mark2,
        code: code2,
        underline,
        delete: del,
        strong: strong2,
        keyboard,
        italic
      } = _ref;
      let currentContent = content2;
      function wrap2(tag, needed) {
        if (!needed) {
          return;
        }
        currentContent = /* @__PURE__ */ reactExports.createElement(tag, {}, currentContent);
      }
      wrap2("strong", strong2);
      wrap2("u", underline);
      wrap2("del", del);
      wrap2("code", code2);
      wrap2("mark", mark2);
      wrap2("kbd", keyboard);
      wrap2("i", italic);
      return currentContent;
    }
    function getNode(dom, defaultNode, needDom) {
      if (dom === true || dom === void 0) {
        return defaultNode;
      }
      return dom || needDom && defaultNode;
    }
    function toList(val) {
      if (val === false) {
        return [false, false];
      }
      return Array.isArray(val) ? val : [val];
    }
    const ELLIPSIS_STR = "...";
    const Base = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a, _b, _c;
      const {
        prefixCls: customizePrefixCls,
        className,
        style: style2,
        type: type2,
        disabled,
        children,
        ellipsis,
        editable,
        copyable,
        component,
        title
      } = props, restProps = __rest$4(props, ["prefixCls", "className", "style", "type", "disabled", "children", "ellipsis", "editable", "copyable", "component", "title"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const [textLocale] = useLocale$1("Text");
      const typographyRef = reactExports.useRef(null);
      const editIconRef = reactExports.useRef(null);
      const prefixCls = getPrefixCls("typography", customizePrefixCls);
      const textProps = omit(restProps, ["mark", "code", "delete", "underline", "strong", "keyboard", "italic"]);
      const [enableEdit, editConfig] = useMergedConfig(editable);
      const [editing, setEditing] = useMergedState(false, {
        value: editConfig.editing
      });
      const {
        triggerType = ["icon"]
      } = editConfig;
      const triggerEdit = (edit) => {
        var _a2;
        if (edit) {
          (_a2 = editConfig.onStart) === null || _a2 === void 0 ? void 0 : _a2.call(editConfig);
        }
        setEditing(edit);
      };
      useUpdatedEffect$1(() => {
        var _a2;
        if (!editing) {
          (_a2 = editIconRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
        }
      }, [editing]);
      const onEditClick = (e2) => {
        e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
        triggerEdit(true);
      };
      const onEditChange = (value) => {
        var _a2;
        (_a2 = editConfig.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(editConfig, value);
        triggerEdit(false);
      };
      const onEditCancel = () => {
        var _a2;
        (_a2 = editConfig.onCancel) === null || _a2 === void 0 ? void 0 : _a2.call(editConfig);
        triggerEdit(false);
      };
      const [enableCopy, copyConfig] = useMergedConfig(copyable);
      const [copied, setCopied] = reactExports.useState(false);
      const copyIdRef = reactExports.useRef();
      const copyOptions = {};
      if (copyConfig.format) {
        copyOptions.format = copyConfig.format;
      }
      const cleanCopyId = () => {
        window.clearTimeout(copyIdRef.current);
      };
      const onCopyClick = (e2) => {
        var _a2;
        e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
        e2 === null || e2 === void 0 ? void 0 : e2.stopPropagation();
        copyToClipboard(copyConfig.text || String(children) || "", copyOptions);
        setCopied(true);
        cleanCopyId();
        copyIdRef.current = window.setTimeout(() => {
          setCopied(false);
        }, 3e3);
        (_a2 = copyConfig.onCopy) === null || _a2 === void 0 ? void 0 : _a2.call(copyConfig, e2);
      };
      reactExports.useEffect(() => cleanCopyId, []);
      const [isLineClampSupport, setIsLineClampSupport] = reactExports.useState(false);
      const [isTextOverflowSupport, setIsTextOverflowSupport] = reactExports.useState(false);
      const [expanded, setExpanded] = reactExports.useState(false);
      const [isJsEllipsis, setIsJsEllipsis] = reactExports.useState(false);
      const [isNativeEllipsis, setIsNativeEllipsis] = reactExports.useState(false);
      const [isNativeVisible, setIsNativeVisible] = reactExports.useState(true);
      const [enableEllipsis, ellipsisConfig] = useMergedConfig(ellipsis, {
        expandable: false
      });
      const mergedEnableEllipsis = enableEllipsis && !expanded;
      const {
        rows = 1
      } = ellipsisConfig;
      const needMeasureEllipsis = reactExports.useMemo(() => (
        // Disable ellipsis
        !mergedEnableEllipsis || // Provide suffix
        ellipsisConfig.suffix !== void 0 || ellipsisConfig.onEllipsis || // Can't use css ellipsis since we need to provide the place for button
        ellipsisConfig.expandable || enableEdit || enableCopy
      ), [mergedEnableEllipsis, ellipsisConfig, enableEdit, enableCopy]);
      useLayoutEffect$1(() => {
        if (enableEllipsis && !needMeasureEllipsis) {
          setIsLineClampSupport(isStyleSupport("webkitLineClamp"));
          setIsTextOverflowSupport(isStyleSupport("textOverflow"));
        }
      }, [needMeasureEllipsis, enableEllipsis]);
      const cssEllipsis = reactExports.useMemo(() => {
        if (needMeasureEllipsis) {
          return false;
        }
        if (rows === 1) {
          return isTextOverflowSupport;
        }
        return isLineClampSupport;
      }, [needMeasureEllipsis, isTextOverflowSupport, isLineClampSupport]);
      const isMergedEllipsis = mergedEnableEllipsis && (cssEllipsis ? isNativeEllipsis : isJsEllipsis);
      const cssTextOverflow = mergedEnableEllipsis && rows === 1 && cssEllipsis;
      const cssLineClamp = mergedEnableEllipsis && rows > 1 && cssEllipsis;
      const onExpandClick = (e2) => {
        var _a2;
        setExpanded(true);
        (_a2 = ellipsisConfig.onExpand) === null || _a2 === void 0 ? void 0 : _a2.call(ellipsisConfig, e2);
      };
      const [ellipsisWidth, setEllipsisWidth] = reactExports.useState(0);
      const [ellipsisFontSize, setEllipsisFontSize] = reactExports.useState(0);
      const onResize2 = (_ref2, element) => {
        let {
          offsetWidth
        } = _ref2;
        var _a2;
        setEllipsisWidth(offsetWidth);
        setEllipsisFontSize(parseInt((_a2 = window.getComputedStyle) === null || _a2 === void 0 ? void 0 : _a2.call(window, element).fontSize, 10) || 0);
      };
      const onJsEllipsis = (jsEllipsis) => {
        var _a2;
        setIsJsEllipsis(jsEllipsis);
        if (isJsEllipsis !== jsEllipsis) {
          (_a2 = ellipsisConfig.onEllipsis) === null || _a2 === void 0 ? void 0 : _a2.call(ellipsisConfig, jsEllipsis);
        }
      };
      reactExports.useEffect(() => {
        const textEle = typographyRef.current;
        if (enableEllipsis && cssEllipsis && textEle) {
          const currentEllipsis = cssLineClamp ? textEle.offsetHeight < textEle.scrollHeight : textEle.offsetWidth < textEle.scrollWidth;
          if (isNativeEllipsis !== currentEllipsis) {
            setIsNativeEllipsis(currentEllipsis);
          }
        }
      }, [enableEllipsis, cssEllipsis, children, cssLineClamp, isNativeVisible]);
      reactExports.useEffect(() => {
        const textEle = typographyRef.current;
        if (typeof IntersectionObserver === "undefined" || !textEle || !cssEllipsis || !mergedEnableEllipsis) {
          return;
        }
        const observer = new IntersectionObserver(() => {
          setIsNativeVisible(!!textEle.offsetParent);
        });
        observer.observe(textEle);
        return () => {
          observer.disconnect();
        };
      }, [cssEllipsis, mergedEnableEllipsis]);
      let tooltipProps = {};
      if (ellipsisConfig.tooltip === true) {
        tooltipProps = {
          title: (_a = editConfig.text) !== null && _a !== void 0 ? _a : children
        };
      } else if (/* @__PURE__ */ reactExports.isValidElement(ellipsisConfig.tooltip)) {
        tooltipProps = {
          title: ellipsisConfig.tooltip
        };
      } else if (typeof ellipsisConfig.tooltip === "object") {
        tooltipProps = Object.assign({
          title: (_b = editConfig.text) !== null && _b !== void 0 ? _b : children
        }, ellipsisConfig.tooltip);
      } else {
        tooltipProps = {
          title: ellipsisConfig.tooltip
        };
      }
      const topAriaLabel = reactExports.useMemo(() => {
        const isValid = (val) => ["string", "number"].includes(typeof val);
        if (!enableEllipsis || cssEllipsis) {
          return void 0;
        }
        if (isValid(editConfig.text)) {
          return editConfig.text;
        }
        if (isValid(children)) {
          return children;
        }
        if (isValid(title)) {
          return title;
        }
        if (isValid(tooltipProps.title)) {
          return tooltipProps.title;
        }
        return void 0;
      }, [enableEllipsis, cssEllipsis, title, tooltipProps.title, isMergedEllipsis]);
      if (editing) {
        return /* @__PURE__ */ reactExports.createElement(Editable$1, {
          value: (_c = editConfig.text) !== null && _c !== void 0 ? _c : typeof children === "string" ? children : "",
          onSave: onEditChange,
          onCancel: onEditCancel,
          onEnd: editConfig.onEnd,
          prefixCls,
          className,
          style: style2,
          direction,
          component,
          maxLength: editConfig.maxLength,
          autoSize: editConfig.autoSize,
          enterIcon: editConfig.enterIcon
        });
      }
      const renderExpand = () => {
        const {
          expandable,
          symbol
        } = ellipsisConfig;
        if (!expandable)
          return null;
        let expandContent;
        if (symbol) {
          expandContent = symbol;
        } else {
          expandContent = textLocale === null || textLocale === void 0 ? void 0 : textLocale.expand;
        }
        return /* @__PURE__ */ reactExports.createElement("a", {
          key: "expand",
          className: `${prefixCls}-expand`,
          onClick: onExpandClick,
          "aria-label": textLocale === null || textLocale === void 0 ? void 0 : textLocale.expand
        }, expandContent);
      };
      const renderEdit = () => {
        if (!enableEdit)
          return;
        const {
          icon,
          tooltip
        } = editConfig;
        const editTitle = toArray$8(tooltip)[0] || (textLocale === null || textLocale === void 0 ? void 0 : textLocale.edit);
        const ariaLabel = typeof editTitle === "string" ? editTitle : "";
        return triggerType.includes("icon") ? /* @__PURE__ */ reactExports.createElement(pn, {
          key: "edit",
          title: tooltip === false ? "" : editTitle
        }, /* @__PURE__ */ reactExports.createElement(TransButton$1, {
          ref: editIconRef,
          className: `${prefixCls}-edit`,
          onClick: onEditClick,
          "aria-label": ariaLabel
        }, icon || /* @__PURE__ */ reactExports.createElement(EditOutlined$2, {
          role: "button"
        }))) : null;
      };
      const renderCopy = () => {
        if (!enableCopy)
          return;
        const {
          tooltips,
          icon
        } = copyConfig;
        const tooltipNodes = toList(tooltips);
        const iconNodes = toList(icon);
        const copyTitle = copied ? getNode(tooltipNodes[1], textLocale === null || textLocale === void 0 ? void 0 : textLocale.copied) : getNode(tooltipNodes[0], textLocale === null || textLocale === void 0 ? void 0 : textLocale.copy);
        const systemStr = copied ? textLocale === null || textLocale === void 0 ? void 0 : textLocale.copied : textLocale === null || textLocale === void 0 ? void 0 : textLocale.copy;
        const ariaLabel = typeof copyTitle === "string" ? copyTitle : systemStr;
        return /* @__PURE__ */ reactExports.createElement(pn, {
          key: "copy",
          title: copyTitle
        }, /* @__PURE__ */ reactExports.createElement(TransButton$1, {
          className: classNames(`${prefixCls}-copy`, copied && `${prefixCls}-copy-success`),
          onClick: onCopyClick,
          "aria-label": ariaLabel
        }, copied ? getNode(iconNodes[1], /* @__PURE__ */ reactExports.createElement(CheckOutlined$2, null), true) : getNode(iconNodes[0], /* @__PURE__ */ reactExports.createElement(CopyOutlined$1, null), true)));
      };
      const renderOperations = (renderExpanded) => [renderExpanded && renderExpand(), renderEdit(), renderCopy()];
      const renderEllipsis = (needEllipsis) => [needEllipsis && /* @__PURE__ */ reactExports.createElement("span", {
        "aria-hidden": true,
        key: "ellipsis"
      }, ELLIPSIS_STR), ellipsisConfig.suffix, renderOperations(needEllipsis)];
      return /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onResize2,
        disabled: !mergedEnableEllipsis || cssEllipsis
      }, (resizeRef) => /* @__PURE__ */ reactExports.createElement(EllipsisTooltip$1, {
        tooltipProps,
        enabledEllipsis: mergedEnableEllipsis,
        isEllipsis: isMergedEllipsis
      }, /* @__PURE__ */ reactExports.createElement(OriginTypography, Object.assign({
        className: classNames({
          [`${prefixCls}-${type2}`]: type2,
          [`${prefixCls}-disabled`]: disabled,
          [`${prefixCls}-ellipsis`]: enableEllipsis,
          [`${prefixCls}-single-line`]: mergedEnableEllipsis && rows === 1,
          [`${prefixCls}-ellipsis-single-line`]: cssTextOverflow,
          [`${prefixCls}-ellipsis-multiple-line`]: cssLineClamp
        }, className),
        prefixCls: customizePrefixCls,
        style: Object.assign(Object.assign({}, style2), {
          WebkitLineClamp: cssLineClamp ? rows : void 0
        }),
        component,
        ref: composeRef(resizeRef, typographyRef, ref),
        direction,
        onClick: triggerType.includes("text") ? onEditClick : void 0,
        "aria-label": topAriaLabel === null || topAriaLabel === void 0 ? void 0 : topAriaLabel.toString(),
        title
      }, textProps), /* @__PURE__ */ reactExports.createElement(Ellipsis$1, {
        enabledMeasure: mergedEnableEllipsis && !cssEllipsis,
        text: children,
        rows,
        width: ellipsisWidth,
        fontSize: ellipsisFontSize,
        onEllipsis: onJsEllipsis
      }, (node2, needEllipsis) => {
        let renderNode = node2;
        if (node2.length && needEllipsis && topAriaLabel) {
          renderNode = /* @__PURE__ */ reactExports.createElement("span", {
            key: "show-content",
            "aria-hidden": true
          }, renderNode);
        }
        const wrappedContext = wrapperDecorations(props, /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, renderNode, renderEllipsis(needEllipsis)));
        return wrappedContext;
      }))));
    });
    const Base$1 = Base;
    var __rest$3 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Link$1 = /* @__PURE__ */ reactExports.forwardRef((_a, ref) => {
      var {
        ellipsis,
        rel
      } = _a, restProps = __rest$3(_a, ["ellipsis", "rel"]);
      const mergedProps = Object.assign(Object.assign({}, restProps), {
        rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel
      });
      delete mergedProps.navigate;
      return /* @__PURE__ */ reactExports.createElement(Base$1, Object.assign({}, mergedProps, {
        ref,
        ellipsis: !!ellipsis,
        component: "a"
      }));
    });
    const Link$2 = Link$1;
    const Paragraph = /* @__PURE__ */ reactExports.forwardRef((props, ref) => /* @__PURE__ */ reactExports.createElement(Base$1, Object.assign({
      ref
    }, props, {
      component: "div"
    })));
    const Paragraph$1 = Paragraph;
    var __rest$2 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Text$c = (_a, ref) => {
      var {
        ellipsis
      } = _a, restProps = __rest$2(_a, ["ellipsis"]);
      const mergedEllipsis = reactExports.useMemo(() => {
        if (ellipsis && typeof ellipsis === "object") {
          return omit(ellipsis, ["expandable", "rows"]);
        }
        return ellipsis;
      }, [ellipsis]);
      return /* @__PURE__ */ reactExports.createElement(Base$1, Object.assign({
        ref
      }, restProps, {
        ellipsis: mergedEllipsis,
        component: "span"
      }));
    };
    const Text$d = /* @__PURE__ */ reactExports.forwardRef(Text$c);
    var __rest$1 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const TITLE_ELE_LIST = [1, 2, 3, 4, 5];
    const Title$b = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        level = 1
      } = props, restProps = __rest$1(props, ["level"]);
      let component;
      if (TITLE_ELE_LIST.includes(level)) {
        component = `h${level}`;
      } else {
        component = "h1";
      }
      return /* @__PURE__ */ reactExports.createElement(Base$1, Object.assign({
        ref
      }, restProps, {
        component
      }));
    });
    const Title$c = Title$b;
    const Typography = OriginTypography;
    Typography.Text = Text$d;
    Typography.Link = Link$2;
    Typography.Title = Title$c;
    Typography.Paragraph = Paragraph$1;
    const Typography$1 = Typography;
    function getError(option, xhr2) {
      var msg = "cannot ".concat(option.method, " ").concat(option.action, " ").concat(xhr2.status, "'");
      var err = new Error(msg);
      err.status = xhr2.status;
      err.method = option.method;
      err.url = option.action;
      return err;
    }
    function getBody(xhr2) {
      var text2 = xhr2.responseText || xhr2.response;
      if (!text2) {
        return text2;
      }
      try {
        return JSON.parse(text2);
      } catch (e2) {
        return text2;
      }
    }
    function upload(option) {
      var xhr2 = new XMLHttpRequest();
      if (option.onProgress && xhr2.upload) {
        xhr2.upload.onprogress = function progress(e2) {
          if (e2.total > 0) {
            e2.percent = e2.loaded / e2.total * 100;
          }
          option.onProgress(e2);
        };
      }
      var formData = new FormData();
      if (option.data) {
        Object.keys(option.data).forEach(function(key) {
          var value = option.data[key];
          if (Array.isArray(value)) {
            value.forEach(function(item) {
              formData.append("".concat(key, "[]"), item);
            });
            return;
          }
          formData.append(key, value);
        });
      }
      if (option.file instanceof Blob) {
        formData.append(option.filename, option.file, option.file.name);
      } else {
        formData.append(option.filename, option.file);
      }
      xhr2.onerror = function error(e2) {
        option.onError(e2);
      };
      xhr2.onload = function onload() {
        if (xhr2.status < 200 || xhr2.status >= 300) {
          return option.onError(getError(option, xhr2), getBody(xhr2));
        }
        return option.onSuccess(getBody(xhr2), xhr2);
      };
      xhr2.open(option.method, option.action, true);
      if (option.withCredentials && "withCredentials" in xhr2) {
        xhr2.withCredentials = true;
      }
      var headers = option.headers || {};
      if (headers["X-Requested-With"] !== null) {
        xhr2.setRequestHeader("X-Requested-With", "XMLHttpRequest");
      }
      Object.keys(headers).forEach(function(h2) {
        if (headers[h2] !== null) {
          xhr2.setRequestHeader(h2, headers[h2]);
        }
      });
      xhr2.send(formData);
      return {
        abort: function abort() {
          xhr2.abort();
        }
      };
    }
    var now = +new Date();
    var index$2 = 0;
    function uid() {
      return "rc-upload-".concat(now, "-").concat(++index$2);
    }
    const attrAccept = function(file, acceptedFiles) {
      if (file && acceptedFiles) {
        var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
        var fileName = file.name || "";
        var mimeType = file.type || "";
        var baseMimeType = mimeType.replace(/\/.*$/, "");
        return acceptedFilesArray.some(function(type2) {
          var validType = type2.trim();
          if (/^\*(\/\*)?$/.test(type2)) {
            return true;
          }
          if (validType.charAt(0) === ".") {
            var lowerFileName = fileName.toLowerCase();
            var lowerType = validType.toLowerCase();
            var affixList = [lowerType];
            if (lowerType === ".jpg" || lowerType === ".jpeg") {
              affixList = [".jpg", ".jpeg"];
            }
            return affixList.some(function(affix) {
              return lowerFileName.endsWith(affix);
            });
          }
          if (/\/\*$/.test(validType)) {
            return baseMimeType === validType.replace(/\/.*$/, "");
          }
          if (mimeType === validType) {
            return true;
          }
          if (/^\w+$/.test(validType)) {
            warningOnce$1(false, "Upload takes an invalidate 'accept' type '".concat(validType, "'.Skip for check."));
            return true;
          }
          return false;
        });
      }
      return true;
    };
    function loopFiles(item, callback) {
      var dirReader = item.createReader();
      var fileList = [];
      function sequence() {
        dirReader.readEntries(function(entries) {
          var entryList = Array.prototype.slice.apply(entries);
          fileList = fileList.concat(entryList);
          var isFinished = !entryList.length;
          if (isFinished) {
            callback(fileList);
          } else {
            sequence();
          }
        });
      }
      sequence();
    }
    var traverseFileTree = function traverseFileTree2(files, callback, isAccepted) {
      var _traverseFileTree = function _traverseFileTree2(item, path2) {
        item.path = path2 || "";
        if (item.isFile) {
          item.file(function(file) {
            if (isAccepted(file)) {
              if (item.fullPath && !file.webkitRelativePath) {
                Object.defineProperties(file, {
                  webkitRelativePath: {
                    writable: true
                  }
                });
                file.webkitRelativePath = item.fullPath.replace(/^\//, "");
                Object.defineProperties(file, {
                  webkitRelativePath: {
                    writable: false
                  }
                });
              }
              callback([file]);
            }
          });
        } else if (item.isDirectory) {
          loopFiles(item, function(entries) {
            entries.forEach(function(entryItem) {
              _traverseFileTree2(entryItem, "".concat(path2).concat(item.name, "/"));
            });
          });
        }
      };
      files.forEach(function(file) {
        _traverseFileTree(file.webkitGetAsEntry());
      });
    };
    var _excluded$4 = ["component", "prefixCls", "className", "disabled", "id", "style", "multiple", "accept", "capture", "children", "directory", "openFileDialogOnClick", "onMouseEnter", "onMouseLeave"];
    var AjaxUploader = /* @__PURE__ */ function(_Component) {
      _inherits(AjaxUploader2, _Component);
      var _super = _createSuper(AjaxUploader2);
      function AjaxUploader2() {
        var _this;
        _classCallCheck(this, AjaxUploader2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.state = {
          uid: uid()
        };
        _this.reqs = {};
        _this.fileInput = void 0;
        _this._isMounted = void 0;
        _this.onChange = function(e2) {
          var _this$props = _this.props, accept = _this$props.accept, directory = _this$props.directory;
          var files = e2.target.files;
          var acceptedFiles = _toConsumableArray(files).filter(function(file) {
            return !directory || attrAccept(file, accept);
          });
          _this.uploadFiles(acceptedFiles);
          _this.reset();
        };
        _this.onClick = function(e2) {
          var el2 = _this.fileInput;
          if (!el2) {
            return;
          }
          var _this$props2 = _this.props, children = _this$props2.children, onClick = _this$props2.onClick;
          if (children && children.type === "button") {
            var parent = el2.parentNode;
            parent.focus();
            parent.querySelector("button").blur();
          }
          el2.click();
          if (onClick) {
            onClick(e2);
          }
        };
        _this.onKeyDown = function(e2) {
          if (e2.key === "Enter") {
            _this.onClick(e2);
          }
        };
        _this.onFileDrop = function(e2) {
          var multiple = _this.props.multiple;
          e2.preventDefault();
          if (e2.type === "dragover") {
            return;
          }
          if (_this.props.directory) {
            traverseFileTree(Array.prototype.slice.call(e2.dataTransfer.items), _this.uploadFiles, function(_file) {
              return attrAccept(_file, _this.props.accept);
            });
          } else {
            var files = _toConsumableArray(e2.dataTransfer.files).filter(function(file) {
              return attrAccept(file, _this.props.accept);
            });
            if (multiple === false) {
              files = files.slice(0, 1);
            }
            _this.uploadFiles(files);
          }
        };
        _this.uploadFiles = function(files) {
          var originFiles = _toConsumableArray(files);
          var postFiles = originFiles.map(function(file) {
            file.uid = uid();
            return _this.processFile(file, originFiles);
          });
          Promise.all(postFiles).then(function(fileList) {
            var onBatchStart = _this.props.onBatchStart;
            onBatchStart === null || onBatchStart === void 0 ? void 0 : onBatchStart(fileList.map(function(_ref) {
              var origin = _ref.origin, parsedFile = _ref.parsedFile;
              return {
                file: origin,
                parsedFile
              };
            }));
            fileList.filter(function(file) {
              return file.parsedFile !== null;
            }).forEach(function(file) {
              _this.post(file);
            });
          });
        };
        _this.processFile = /* @__PURE__ */ function() {
          var _ref2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(file, fileList) {
            var beforeUpload, transformedFile, action, mergedAction, data2, mergedData, parsedData, parsedFile, mergedParsedFile;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    beforeUpload = _this.props.beforeUpload;
                    transformedFile = file;
                    if (!beforeUpload) {
                      _context.next = 14;
                      break;
                    }
                    _context.prev = 3;
                    _context.next = 6;
                    return beforeUpload(file, fileList);
                  case 6:
                    transformedFile = _context.sent;
                    _context.next = 12;
                    break;
                  case 9:
                    _context.prev = 9;
                    _context.t0 = _context["catch"](3);
                    transformedFile = false;
                  case 12:
                    if (!(transformedFile === false)) {
                      _context.next = 14;
                      break;
                    }
                    return _context.abrupt("return", {
                      origin: file,
                      parsedFile: null,
                      action: null,
                      data: null
                    });
                  case 14:
                    action = _this.props.action;
                    if (!(typeof action === "function")) {
                      _context.next = 21;
                      break;
                    }
                    _context.next = 18;
                    return action(file);
                  case 18:
                    mergedAction = _context.sent;
                    _context.next = 22;
                    break;
                  case 21:
                    mergedAction = action;
                  case 22:
                    data2 = _this.props.data;
                    if (!(typeof data2 === "function")) {
                      _context.next = 29;
                      break;
                    }
                    _context.next = 26;
                    return data2(file);
                  case 26:
                    mergedData = _context.sent;
                    _context.next = 30;
                    break;
                  case 29:
                    mergedData = data2;
                  case 30:
                    parsedData = // string type is from legacy `transformFile`.
                    // Not sure if this will work since no related test case works with it
                    (_typeof$4(transformedFile) === "object" || typeof transformedFile === "string") && transformedFile ? transformedFile : file;
                    if (parsedData instanceof File) {
                      parsedFile = parsedData;
                    } else {
                      parsedFile = new File([parsedData], file.name, {
                        type: file.type
                      });
                    }
                    mergedParsedFile = parsedFile;
                    mergedParsedFile.uid = file.uid;
                    return _context.abrupt("return", {
                      origin: file,
                      data: mergedData,
                      parsedFile: mergedParsedFile,
                      action: mergedAction
                    });
                  case 35:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[3, 9]]);
          }));
          return function(_x, _x2) {
            return _ref2.apply(this, arguments);
          };
        }();
        _this.saveFileInput = function(node2) {
          _this.fileInput = node2;
        };
        return _this;
      }
      _createClass(AjaxUploader2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this._isMounted = true;
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this._isMounted = false;
          this.abort();
        }
      }, {
        key: "post",
        value: function post(_ref3) {
          var _this2 = this;
          var data2 = _ref3.data, origin = _ref3.origin, action = _ref3.action, parsedFile = _ref3.parsedFile;
          if (!this._isMounted) {
            return;
          }
          var _this$props3 = this.props, onStart = _this$props3.onStart, customRequest = _this$props3.customRequest, name = _this$props3.name, headers = _this$props3.headers, withCredentials = _this$props3.withCredentials, method2 = _this$props3.method;
          var uid2 = origin.uid;
          var request = customRequest || upload;
          var requestOption = {
            action,
            filename: name,
            data: data2,
            file: parsedFile,
            headers,
            withCredentials,
            method: method2 || "post",
            onProgress: function onProgress(e2) {
              var onProgress2 = _this2.props.onProgress;
              onProgress2 === null || onProgress2 === void 0 ? void 0 : onProgress2(e2, parsedFile);
            },
            onSuccess: function onSuccess(ret, xhr2) {
              var onSuccess2 = _this2.props.onSuccess;
              onSuccess2 === null || onSuccess2 === void 0 ? void 0 : onSuccess2(ret, parsedFile, xhr2);
              delete _this2.reqs[uid2];
            },
            onError: function onError(err, ret) {
              var onError2 = _this2.props.onError;
              onError2 === null || onError2 === void 0 ? void 0 : onError2(err, ret, parsedFile);
              delete _this2.reqs[uid2];
            }
          };
          onStart(origin);
          this.reqs[uid2] = request(requestOption);
        }
      }, {
        key: "reset",
        value: function reset2() {
          this.setState({
            uid: uid()
          });
        }
      }, {
        key: "abort",
        value: function abort(file) {
          var reqs = this.reqs;
          if (file) {
            var uid2 = file.uid ? file.uid : file;
            if (reqs[uid2] && reqs[uid2].abort) {
              reqs[uid2].abort();
            }
            delete reqs[uid2];
          } else {
            Object.keys(reqs).forEach(function(uid3) {
              if (reqs[uid3] && reqs[uid3].abort) {
                reqs[uid3].abort();
              }
              delete reqs[uid3];
            });
          }
        }
      }, {
        key: "render",
        value: function render2() {
          var _classNames;
          var _this$props4 = this.props, Tag2 = _this$props4.component, prefixCls = _this$props4.prefixCls, className = _this$props4.className, disabled = _this$props4.disabled, id2 = _this$props4.id, style2 = _this$props4.style, multiple = _this$props4.multiple, accept = _this$props4.accept, capture = _this$props4.capture, children = _this$props4.children, directory = _this$props4.directory, openFileDialogOnClick = _this$props4.openFileDialogOnClick, onMouseEnter = _this$props4.onMouseEnter, onMouseLeave = _this$props4.onMouseLeave, otherProps = _objectWithoutProperties$1(_this$props4, _excluded$4);
          var cls = classNames((_classNames = {}, _defineProperty$7(_classNames, prefixCls, true), _defineProperty$7(_classNames, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$7(_classNames, className, className), _classNames));
          var dirProps = directory ? {
            directory: "directory",
            webkitdirectory: "webkitdirectory"
          } : {};
          var events = disabled ? {} : {
            onClick: openFileDialogOnClick ? this.onClick : function() {
            },
            onKeyDown: openFileDialogOnClick ? this.onKeyDown : function() {
            },
            onMouseEnter,
            onMouseLeave,
            onDrop: this.onFileDrop,
            onDragOver: this.onFileDrop,
            tabIndex: "0"
          };
          return /* @__PURE__ */ React$3.createElement(Tag2, _extends$2({}, events, {
            className: cls,
            role: "button",
            style: style2
          }), /* @__PURE__ */ React$3.createElement("input", _extends$2({}, pickAttrs(otherProps, {
            aria: true,
            data: true
          }), {
            id: id2,
            type: "file",
            ref: this.saveFileInput,
            onClick: function onClick(e2) {
              return e2.stopPropagation();
            },
            key: this.state.uid,
            style: {
              display: "none"
            },
            accept
          }, dirProps, {
            multiple,
            onChange: this.onChange
          }, capture != null ? {
            capture
          } : {})), children);
        }
      }]);
      return AjaxUploader2;
    }(reactExports.Component);
    function empty() {
    }
    var Upload$3 = /* @__PURE__ */ function(_Component) {
      _inherits(Upload2, _Component);
      var _super = _createSuper(Upload2);
      function Upload2() {
        var _this;
        _classCallCheck(this, Upload2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.uploader = void 0;
        _this.saveUploader = function(node2) {
          _this.uploader = node2;
        };
        return _this;
      }
      _createClass(Upload2, [{
        key: "abort",
        value: function abort(file) {
          this.uploader.abort(file);
        }
      }, {
        key: "render",
        value: function render2() {
          return /* @__PURE__ */ React$3.createElement(AjaxUploader, _extends$2({}, this.props, {
            ref: this.saveUploader
          }));
        }
      }]);
      return Upload2;
    }(reactExports.Component);
    Upload$3.defaultProps = {
      component: "span",
      prefixCls: "rc-upload",
      data: {},
      headers: {},
      name: "file",
      multipart: false,
      onStart: empty,
      onError: empty,
      onSuccess: empty,
      multiple: false,
      beforeUpload: null,
      customRequest: null,
      withCredentials: false,
      openFileDialogOnClick: true
    };
    function file2Obj(file) {
      return Object.assign(Object.assign({}, file), {
        lastModified: file.lastModified,
        lastModifiedDate: file.lastModifiedDate,
        name: file.name,
        size: file.size,
        type: file.type,
        uid: file.uid,
        percent: 0,
        originFileObj: file
      });
    }
    function updateFileList(file, fileList) {
      const nextFileList = _toConsumableArray(fileList);
      const fileIndex = nextFileList.findIndex((_ref) => {
        let {
          uid: uid2
        } = _ref;
        return uid2 === file.uid;
      });
      if (fileIndex === -1) {
        nextFileList.push(file);
      } else {
        nextFileList[fileIndex] = file;
      }
      return nextFileList;
    }
    function getFileItem(file, fileList) {
      const matchKey = file.uid !== void 0 ? "uid" : "name";
      return fileList.filter((item) => item[matchKey] === file[matchKey])[0];
    }
    function removeFileItem(file, fileList) {
      const matchKey = file.uid !== void 0 ? "uid" : "name";
      const removed = fileList.filter((item) => item[matchKey] !== file[matchKey]);
      if (removed.length === fileList.length) {
        return null;
      }
      return removed;
    }
    const extname$1 = function() {
      let url = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      const temp = url.split("/");
      const filename = temp[temp.length - 1];
      const filenameWithoutSuffix = filename.split(/#|\?/)[0];
      return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
    };
    const isImageFileType = (type2) => type2.indexOf("image/") === 0;
    const isImageUrl = (file) => {
      if (file.type && !file.thumbUrl) {
        return isImageFileType(file.type);
      }
      const url = file.thumbUrl || file.url || "";
      const extension2 = extname$1(url);
      if (/^data:image\//.test(url) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico|heic|heif)$/i.test(extension2)) {
        return true;
      }
      if (/^data:/.test(url)) {
        return false;
      }
      if (extension2) {
        return false;
      }
      return true;
    };
    const MEASURE_SIZE = 200;
    function previewImage(file) {
      return new Promise((resolve) => {
        if (!file.type || !isImageFileType(file.type)) {
          resolve("");
          return;
        }
        const canvas = document.createElement("canvas");
        canvas.width = MEASURE_SIZE;
        canvas.height = MEASURE_SIZE;
        canvas.style.cssText = `position: fixed; left: 0; top: 0; width: ${MEASURE_SIZE}px; height: ${MEASURE_SIZE}px; z-index: 9999; display: none;`;
        document.body.appendChild(canvas);
        const ctx = canvas.getContext("2d");
        const img = new Image();
        img.onload = () => {
          const {
            width,
            height
          } = img;
          let drawWidth = MEASURE_SIZE;
          let drawHeight = MEASURE_SIZE;
          let offsetX = 0;
          let offsetY = 0;
          if (width > height) {
            drawHeight = height * (MEASURE_SIZE / width);
            offsetY = -(drawHeight - drawWidth) / 2;
          } else {
            drawWidth = width * (MEASURE_SIZE / height);
            offsetX = -(drawWidth - drawHeight) / 2;
          }
          ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
          const dataURL = canvas.toDataURL();
          document.body.removeChild(canvas);
          resolve(dataURL);
        };
        img.crossOrigin = "anonymous";
        if (file.type.startsWith("image/svg+xml")) {
          const reader = new FileReader();
          reader.addEventListener("load", () => {
            if (reader.result)
              img.src = reader.result;
          });
          reader.readAsDataURL(file);
        } else {
          img.src = window.URL.createObjectURL(file);
        }
      });
    }
    const ListItem = /* @__PURE__ */ reactExports.forwardRef((_ref, ref) => {
      let {
        prefixCls,
        className,
        style: style2,
        locale: locale2,
        listType,
        file,
        items,
        progress: progressProps,
        iconRender,
        actionIconRender,
        itemRender,
        isImgUrl,
        showPreviewIcon,
        showRemoveIcon,
        showDownloadIcon,
        previewIcon: customPreviewIcon,
        removeIcon: customRemoveIcon,
        downloadIcon: customDownloadIcon,
        onPreview,
        onDownload,
        onClose
      } = _ref;
      var _a, _b;
      const {
        status
      } = file;
      const [mergedStatus, setMergedStatus] = reactExports.useState(status);
      reactExports.useEffect(() => {
        if (status !== "removed") {
          setMergedStatus(status);
        }
      }, [status]);
      const [showProgress, setShowProgress] = reactExports.useState(false);
      const progressRafRef = reactExports.useRef(null);
      reactExports.useEffect(() => {
        progressRafRef.current = setTimeout(() => {
          setShowProgress(true);
        }, 300);
        return () => {
          if (progressRafRef.current) {
            clearTimeout(progressRafRef.current);
          }
        };
      }, []);
      const iconNode = iconRender(file);
      let icon = /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-icon`
      }, iconNode);
      if (listType === "picture" || listType === "picture-card" || listType === "picture-circle") {
        if (mergedStatus === "uploading" || !file.thumbUrl && !file.url) {
          const uploadingClassName = classNames({
            [`${prefixCls}-list-item-thumbnail`]: true,
            [`${prefixCls}-list-item-file`]: mergedStatus !== "uploading"
          });
          icon = /* @__PURE__ */ reactExports.createElement("div", {
            className: uploadingClassName
          }, iconNode);
        } else {
          const thumbnail = (isImgUrl === null || isImgUrl === void 0 ? void 0 : isImgUrl(file)) ? /* @__PURE__ */ reactExports.createElement("img", {
            src: file.thumbUrl || file.url,
            alt: file.name,
            className: `${prefixCls}-list-item-image`,
            crossOrigin: file.crossOrigin
          }) : iconNode;
          const aClassName = classNames({
            [`${prefixCls}-list-item-thumbnail`]: true,
            [`${prefixCls}-list-item-file`]: isImgUrl && !isImgUrl(file)
          });
          icon = /* @__PURE__ */ reactExports.createElement("a", {
            className: aClassName,
            onClick: (e2) => onPreview(file, e2),
            href: file.url || file.thumbUrl,
            target: "_blank",
            rel: "noopener noreferrer"
          }, thumbnail);
        }
      }
      const listItemClassName = classNames(`${prefixCls}-list-item`, `${prefixCls}-list-item-${mergedStatus}`);
      const linkProps = typeof file.linkProps === "string" ? JSON.parse(file.linkProps) : file.linkProps;
      const removeIcon = showRemoveIcon ? actionIconRender((typeof customRemoveIcon === "function" ? customRemoveIcon(file) : customRemoveIcon) || /* @__PURE__ */ reactExports.createElement(DeleteOutlined$2, null), () => onClose(file), prefixCls, locale2.removeFile) : null;
      const downloadIcon = showDownloadIcon && mergedStatus === "done" ? actionIconRender((typeof customDownloadIcon === "function" ? customDownloadIcon(file) : customDownloadIcon) || /* @__PURE__ */ reactExports.createElement(DownloadOutlined$1, null), () => onDownload(file), prefixCls, locale2.downloadFile) : null;
      const downloadOrDelete = listType !== "picture-card" && listType !== "picture-circle" && /* @__PURE__ */ reactExports.createElement("span", {
        key: "download-delete",
        className: classNames(`${prefixCls}-list-item-actions`, {
          picture: listType === "picture"
        })
      }, downloadIcon, removeIcon);
      const listItemNameClass = classNames(`${prefixCls}-list-item-name`);
      const fileName = file.url ? [/* @__PURE__ */ reactExports.createElement("a", Object.assign({
        key: "view",
        target: "_blank",
        rel: "noopener noreferrer",
        className: listItemNameClass,
        title: file.name
      }, linkProps, {
        href: file.url,
        onClick: (e2) => onPreview(file, e2)
      }), file.name), downloadOrDelete] : [/* @__PURE__ */ reactExports.createElement("span", {
        key: "view",
        className: listItemNameClass,
        onClick: (e2) => onPreview(file, e2),
        title: file.name
      }, file.name), downloadOrDelete];
      const previewStyle = {
        pointerEvents: "none",
        opacity: 0.5
      };
      const previewIcon = showPreviewIcon ? /* @__PURE__ */ reactExports.createElement("a", {
        href: file.url || file.thumbUrl,
        target: "_blank",
        rel: "noopener noreferrer",
        style: file.url || file.thumbUrl ? void 0 : previewStyle,
        onClick: (e2) => onPreview(file, e2),
        title: locale2.previewFile
      }, typeof customPreviewIcon === "function" ? customPreviewIcon(file) : customPreviewIcon || /* @__PURE__ */ reactExports.createElement(EyeOutlined$1, null)) : null;
      const pictureCardActions = (listType === "picture-card" || listType === "picture-circle") && mergedStatus !== "uploading" && /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-list-item-actions`
      }, previewIcon, mergedStatus === "done" && downloadIcon, removeIcon);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const rootPrefixCls = getPrefixCls();
      const dom = /* @__PURE__ */ reactExports.createElement("div", {
        className: listItemClassName
      }, icon, fileName, pictureCardActions, showProgress && /* @__PURE__ */ reactExports.createElement(CSSMotion, {
        motionName: `${rootPrefixCls}-fade`,
        visible: mergedStatus === "uploading",
        motionDeadline: 2e3
      }, (_ref2) => {
        let {
          className: motionClassName
        } = _ref2;
        const loadingProgress = "percent" in file ? /* @__PURE__ */ reactExports.createElement(Progress$1, Object.assign({}, progressProps, {
          type: "line",
          percent: file.percent
        })) : null;
        return /* @__PURE__ */ reactExports.createElement("div", {
          className: classNames(`${prefixCls}-list-item-progress`, motionClassName)
        }, loadingProgress);
      }));
      const message2 = file.response && typeof file.response === "string" ? file.response : ((_a = file.error) === null || _a === void 0 ? void 0 : _a.statusText) || ((_b = file.error) === null || _b === void 0 ? void 0 : _b.message) || locale2.uploadError;
      const item = mergedStatus === "error" ? /* @__PURE__ */ reactExports.createElement(pn, {
        title: message2,
        getPopupContainer: (node2) => node2.parentNode
      }, dom) : dom;
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(`${prefixCls}-list-item-container`, className),
        style: style2,
        ref
      }, itemRender ? itemRender(item, file, items, {
        download: onDownload.bind(null, file),
        preview: onPreview.bind(null, file),
        remove: onClose.bind(null, file)
      }) : item);
    });
    const ListItem$1 = ListItem;
    const InternalUploadList = (props, ref) => {
      const {
        listType = "text",
        previewFile = previewImage,
        onPreview,
        onDownload,
        onRemove,
        locale: locale2,
        iconRender,
        isImageUrl: isImgUrl = isImageUrl,
        prefixCls: customizePrefixCls,
        items = [],
        showPreviewIcon = true,
        showRemoveIcon = true,
        showDownloadIcon = false,
        removeIcon,
        previewIcon,
        downloadIcon,
        progress = {
          strokeWidth: 2,
          showInfo: false
        },
        appendAction,
        appendActionVisible = true,
        itemRender
      } = props;
      const forceUpdate = useForceUpdate();
      const [motionAppear, setMotionAppear] = reactExports.useState(false);
      reactExports.useEffect(() => {
        if (listType !== "picture" && listType !== "picture-card" && listType !== "picture-circle") {
          return;
        }
        (items || []).forEach((file) => {
          if (typeof document === "undefined" || typeof window === "undefined" || !window.FileReader || !window.File || !(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== void 0) {
            return;
          }
          file.thumbUrl = "";
          if (previewFile) {
            previewFile(file.originFileObj).then((previewDataUrl) => {
              file.thumbUrl = previewDataUrl || "";
              forceUpdate();
            });
          }
        });
      }, [listType, items, previewFile]);
      reactExports.useEffect(() => {
        setMotionAppear(true);
      }, []);
      const onInternalPreview = (file, e2) => {
        if (!onPreview) {
          return;
        }
        e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
        return onPreview(file);
      };
      const onInternalDownload = (file) => {
        if (typeof onDownload === "function") {
          onDownload(file);
        } else if (file.url) {
          window.open(file.url);
        }
      };
      const onInternalClose = (file) => {
        onRemove === null || onRemove === void 0 ? void 0 : onRemove(file);
      };
      const internalIconRender = (file) => {
        if (iconRender) {
          return iconRender(file, listType);
        }
        const isLoading = file.status === "uploading";
        const fileIcon = isImgUrl && isImgUrl(file) ? /* @__PURE__ */ reactExports.createElement(PictureTwoTone$1, null) : /* @__PURE__ */ reactExports.createElement(FileTwoTone$1, null);
        let icon = isLoading ? /* @__PURE__ */ reactExports.createElement(LoadingOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(PaperClipOutlined$1, null);
        if (listType === "picture") {
          icon = isLoading ? /* @__PURE__ */ reactExports.createElement(LoadingOutlined$1, null) : fileIcon;
        } else if (listType === "picture-card" || listType === "picture-circle") {
          icon = isLoading ? locale2.uploading : fileIcon;
        }
        return icon;
      };
      const actionIconRender = (customIcon, callback, prefixCls2, title) => {
        const btnProps = {
          type: "text",
          size: "small",
          title,
          onClick: (e2) => {
            callback();
            if (isValidElement(customIcon) && customIcon.props.onClick) {
              customIcon.props.onClick(e2);
            }
          },
          className: `${prefixCls2}-list-item-action`
        };
        if (isValidElement(customIcon)) {
          const btnIcon = cloneElement(customIcon, Object.assign(Object.assign({}, customIcon.props), {
            onClick: () => {
            }
          }));
          return /* @__PURE__ */ reactExports.createElement(Button$2, Object.assign({}, btnProps, {
            icon: btnIcon
          }));
        }
        return /* @__PURE__ */ reactExports.createElement(Button$2, Object.assign({}, btnProps), /* @__PURE__ */ reactExports.createElement("span", null, customIcon));
      };
      reactExports.useImperativeHandle(ref, () => ({
        handlePreview: onInternalPreview,
        handleDownload: onInternalDownload
      }));
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("upload", customizePrefixCls);
      const rootPrefixCls = getPrefixCls();
      const listClassNames = classNames({
        [`${prefixCls}-list`]: true,
        [`${prefixCls}-list-${listType}`]: true
      });
      const motionKeyList = _toConsumableArray(items.map((file) => ({
        key: file.uid,
        file
      })));
      const animationDirection = listType === "picture-card" || listType === "picture-circle" ? "animate-inline" : "animate";
      let motionConfig = {
        motionDeadline: 2e3,
        motionName: `${prefixCls}-${animationDirection}`,
        keys: motionKeyList,
        motionAppear
      };
      const listItemMotion = reactExports.useMemo(() => {
        const motion2 = Object.assign({}, initCollapseMotion$1(rootPrefixCls));
        delete motion2.onAppearEnd;
        delete motion2.onEnterEnd;
        delete motion2.onLeaveEnd;
        return motion2;
      }, [rootPrefixCls]);
      if (listType !== "picture-card" && listType !== "picture-circle") {
        motionConfig = Object.assign(Object.assign({}, listItemMotion), motionConfig);
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: listClassNames
      }, /* @__PURE__ */ reactExports.createElement(CSSMotionList, Object.assign({}, motionConfig, {
        component: false
      }), (_ref) => {
        let {
          key,
          file,
          className: motionClassName,
          style: motionStyle
        } = _ref;
        return /* @__PURE__ */ reactExports.createElement(ListItem$1, {
          key,
          locale: locale2,
          prefixCls,
          className: motionClassName,
          style: motionStyle,
          file,
          items,
          progress,
          listType,
          isImgUrl,
          showPreviewIcon,
          showRemoveIcon,
          showDownloadIcon,
          removeIcon,
          previewIcon,
          downloadIcon,
          iconRender: internalIconRender,
          actionIconRender,
          itemRender,
          onPreview: onInternalPreview,
          onDownload: onInternalDownload,
          onClose: onInternalClose
        });
      }), appendAction && /* @__PURE__ */ reactExports.createElement(CSSMotion, Object.assign({}, motionConfig, {
        visible: appendActionVisible,
        forceRender: true
      }), (_ref2) => {
        let {
          className: motionClassName,
          style: motionStyle
        } = _ref2;
        return cloneElement(appendAction, (oriProps) => ({
          className: classNames(oriProps.className, motionClassName),
          style: Object.assign(Object.assign(Object.assign({}, motionStyle), {
            // prevent the element has hover css pseudo-class that may cause animation to end prematurely.
            pointerEvents: motionClassName ? "none" : void 0
          }), oriProps.style)
        }));
      }));
    };
    const UploadList = /* @__PURE__ */ reactExports.forwardRef(InternalUploadList);
    const UploadList$1 = UploadList;
    const genDraggerStyle = (token2) => {
      const {
        componentCls,
        iconCls
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-drag`]: {
            position: "relative",
            width: "100%",
            height: "100%",
            textAlign: "center",
            background: token2.colorFillAlter,
            border: `${token2.lineWidth}px dashed ${token2.colorBorder}`,
            borderRadius: token2.borderRadiusLG,
            cursor: "pointer",
            transition: `border-color ${token2.motionDurationSlow}`,
            [componentCls]: {
              padding: `${token2.padding}px 0`
            },
            [`${componentCls}-btn`]: {
              display: "table",
              width: "100%",
              height: "100%",
              outline: "none"
            },
            [`${componentCls}-drag-container`]: {
              display: "table-cell",
              verticalAlign: "middle"
            },
            [`&:not(${componentCls}-disabled):hover`]: {
              borderColor: token2.colorPrimaryHover
            },
            [`p${componentCls}-drag-icon`]: {
              marginBottom: token2.margin,
              [iconCls]: {
                color: token2.colorPrimary,
                fontSize: token2.uploadThumbnailSize
              }
            },
            [`p${componentCls}-text`]: {
              margin: `0 0 ${token2.marginXXS}px`,
              color: token2.colorTextHeading,
              fontSize: token2.fontSizeLG
            },
            [`p${componentCls}-hint`]: {
              color: token2.colorTextDescription,
              fontSize: token2.fontSize
            },
            // ===================== Disabled =====================
            [`&${componentCls}-disabled`]: {
              cursor: "not-allowed",
              [`p${componentCls}-drag-icon ${iconCls},
            p${componentCls}-text,
            p${componentCls}-hint
          `]: {
                color: token2.colorTextDisabled
              }
            }
          }
        }
      };
    };
    const genDraggerStyle$1 = genDraggerStyle;
    const genListStyle = (token2) => {
      const {
        componentCls,
        antCls,
        iconCls,
        fontSize,
        lineHeight
      } = token2;
      const itemCls = `${componentCls}-list-item`;
      const actionsCls = `${itemCls}-actions`;
      const actionCls = `${itemCls}-action`;
      const listItemHeightSM = Math.round(fontSize * lineHeight);
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-list`]: Object.assign(Object.assign({}, clearFix()), {
            lineHeight: token2.lineHeight,
            [itemCls]: {
              position: "relative",
              height: token2.lineHeight * fontSize,
              marginTop: token2.marginXS,
              fontSize,
              display: "flex",
              alignItems: "center",
              transition: `background-color ${token2.motionDurationSlow}`,
              "&:hover": {
                backgroundColor: token2.controlItemBgHover
              },
              [`${itemCls}-name`]: Object.assign(Object.assign({}, textEllipsis), {
                padding: `0 ${token2.paddingXS}px`,
                lineHeight,
                flex: "auto",
                transition: `all ${token2.motionDurationSlow}`
              }),
              [actionsCls]: {
                [actionCls]: {
                  opacity: 0
                },
                [`${actionCls}${antCls}-btn-sm`]: {
                  height: listItemHeightSM,
                  border: 0,
                  lineHeight: 1,
                  // FIXME: should not override small button
                  "> span": {
                    transform: "scale(1)"
                  }
                },
                [`
              ${actionCls}:focus,
              &.picture ${actionCls}
            `]: {
                  opacity: 1
                },
                [iconCls]: {
                  color: token2.colorTextDescription,
                  transition: `all ${token2.motionDurationSlow}`
                },
                [`&:hover ${iconCls}`]: {
                  color: token2.colorText
                }
              },
              [`${componentCls}-icon ${iconCls}`]: {
                color: token2.colorTextDescription,
                fontSize
              },
              [`${itemCls}-progress`]: {
                position: "absolute",
                bottom: -token2.uploadProgressOffset,
                width: "100%",
                paddingInlineStart: fontSize + token2.paddingXS,
                fontSize,
                lineHeight: 0,
                pointerEvents: "none",
                "> div": {
                  margin: 0
                }
              }
            },
            [`${itemCls}:hover ${actionCls}`]: {
              opacity: 1,
              color: token2.colorText
            },
            [`${itemCls}-error`]: {
              color: token2.colorError,
              [`${itemCls}-name, ${componentCls}-icon ${iconCls}`]: {
                color: token2.colorError
              },
              [actionsCls]: {
                [`${iconCls}, ${iconCls}:hover`]: {
                  color: token2.colorError
                },
                [actionCls]: {
                  opacity: 1
                }
              }
            },
            [`${componentCls}-list-item-container`]: {
              transition: `opacity ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
              // For smooth removing animation
              "&::before": {
                display: "table",
                width: 0,
                height: 0,
                content: '""'
              }
            }
          })
        }
      };
    };
    const genListStyle$1 = genListStyle;
    const uploadAnimateInlineIn = new Keyframe("uploadAnimateInlineIn", {
      from: {
        width: 0,
        height: 0,
        margin: 0,
        padding: 0,
        opacity: 0
      }
    });
    const uploadAnimateInlineOut = new Keyframe("uploadAnimateInlineOut", {
      to: {
        width: 0,
        height: 0,
        margin: 0,
        padding: 0,
        opacity: 0
      }
    });
    const genMotionStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const inlineCls = `${componentCls}-animate-inline`;
      return [{
        [`${componentCls}-wrapper`]: {
          [`${inlineCls}-appear, ${inlineCls}-enter, ${inlineCls}-leave`]: {
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: token2.motionEaseInOutCirc,
            animationFillMode: "forwards"
          },
          [`${inlineCls}-appear, ${inlineCls}-enter`]: {
            animationName: uploadAnimateInlineIn
          },
          [`${inlineCls}-leave`]: {
            animationName: uploadAnimateInlineOut
          }
        }
      }, uploadAnimateInlineIn, uploadAnimateInlineOut];
    };
    const genMotionStyle$1 = genMotionStyle;
    const genPictureStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        uploadThumbnailSize,
        uploadProgressOffset
      } = token2;
      const listCls = `${componentCls}-list`;
      const itemCls = `${listCls}-item`;
      return {
        [`${componentCls}-wrapper`]: {
          // ${listCls} 增加优先级
          [`
        ${listCls}${listCls}-picture,
        ${listCls}${listCls}-picture-card,
        ${listCls}${listCls}-picture-circle
      `]: {
            [itemCls]: {
              position: "relative",
              height: uploadThumbnailSize + token2.lineWidth * 2 + token2.paddingXS * 2,
              padding: token2.paddingXS,
              border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
              borderRadius: token2.borderRadiusLG,
              "&:hover": {
                background: "transparent"
              },
              [`${itemCls}-thumbnail`]: Object.assign(Object.assign({}, textEllipsis), {
                width: uploadThumbnailSize,
                height: uploadThumbnailSize,
                lineHeight: `${uploadThumbnailSize + token2.paddingSM}px`,
                textAlign: "center",
                flex: "none",
                [iconCls]: {
                  fontSize: token2.fontSizeHeading2,
                  color: token2.colorPrimary
                },
                img: {
                  display: "block",
                  width: "100%",
                  height: "100%",
                  overflow: "hidden"
                }
              }),
              [`${itemCls}-progress`]: {
                bottom: uploadProgressOffset,
                width: `calc(100% - ${token2.paddingSM * 2}px)`,
                marginTop: 0,
                paddingInlineStart: uploadThumbnailSize + token2.paddingXS
              }
            },
            [`${itemCls}-error`]: {
              borderColor: token2.colorError,
              // Adjust the color of the error icon : https://github.com/ant-design/ant-design/pull/24160
              [`${itemCls}-thumbnail ${iconCls}`]: {
                [`svg path[fill='#e6f7ff']`]: {
                  fill: token2.colorErrorBg
                },
                [`svg path[fill='#1890ff']`]: {
                  fill: token2.colorError
                }
              }
            },
            [`${itemCls}-uploading`]: {
              borderStyle: "dashed",
              [`${itemCls}-name`]: {
                marginBottom: uploadProgressOffset
              }
            }
          },
          [`${listCls}${listCls}-picture-circle ${itemCls}`]: {
            [`&, &::before, ${itemCls}-thumbnail`]: {
              borderRadius: "50%"
            }
          }
        }
      };
    };
    const genPictureCardStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        fontSizeLG,
        colorTextLightSolid
      } = token2;
      const listCls = `${componentCls}-list`;
      const itemCls = `${listCls}-item`;
      const uploadPictureCardSize = token2.uploadPicCardSize;
      return {
        [`
      ${componentCls}-wrapper${componentCls}-picture-card-wrapper,
      ${componentCls}-wrapper${componentCls}-picture-circle-wrapper
    `]: Object.assign(Object.assign({}, clearFix()), {
          display: "inline-block",
          width: "100%",
          [`${componentCls}${componentCls}-select`]: {
            width: uploadPictureCardSize,
            height: uploadPictureCardSize,
            marginInlineEnd: token2.marginXS,
            marginBottom: token2.marginXS,
            textAlign: "center",
            verticalAlign: "top",
            backgroundColor: token2.colorFillAlter,
            border: `${token2.lineWidth}px dashed ${token2.colorBorder}`,
            borderRadius: token2.borderRadiusLG,
            cursor: "pointer",
            transition: `border-color ${token2.motionDurationSlow}`,
            [`> ${componentCls}`]: {
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              height: "100%",
              textAlign: "center"
            },
            [`&:not(${componentCls}-disabled):hover`]: {
              borderColor: token2.colorPrimary
            }
          },
          // list
          [`${listCls}${listCls}-picture-card, ${listCls}${listCls}-picture-circle`]: {
            [`${listCls}-item-container`]: {
              display: "inline-block",
              width: uploadPictureCardSize,
              height: uploadPictureCardSize,
              marginBlock: `0 ${token2.marginXS}px`,
              marginInline: `0 ${token2.marginXS}px`,
              verticalAlign: "top"
            },
            "&::after": {
              display: "none"
            },
            [itemCls]: {
              height: "100%",
              margin: 0,
              "&::before": {
                position: "absolute",
                zIndex: 1,
                width: `calc(100% - ${token2.paddingXS * 2}px)`,
                height: `calc(100% - ${token2.paddingXS * 2}px)`,
                backgroundColor: token2.colorBgMask,
                opacity: 0,
                transition: `all ${token2.motionDurationSlow}`,
                content: '" "'
              }
            },
            [`${itemCls}:hover`]: {
              [`&::before, ${itemCls}-actions`]: {
                opacity: 1
              }
            },
            [`${itemCls}-actions`]: {
              position: "absolute",
              insetInlineStart: 0,
              zIndex: 10,
              width: "100%",
              whiteSpace: "nowrap",
              textAlign: "center",
              opacity: 0,
              transition: `all ${token2.motionDurationSlow}`,
              [`${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
                zIndex: 10,
                width: fontSizeLG,
                margin: `0 ${token2.marginXXS}px`,
                fontSize: fontSizeLG,
                cursor: "pointer",
                transition: `all ${token2.motionDurationSlow}`,
                svg: {
                  verticalAlign: "baseline"
                }
              }
            },
            [`${itemCls}-actions, ${itemCls}-actions:hover`]: {
              [`${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
                color: new TinyColor(colorTextLightSolid).setAlpha(0.65).toRgbString(),
                "&:hover": {
                  color: colorTextLightSolid
                }
              }
            },
            [`${itemCls}-thumbnail, ${itemCls}-thumbnail img`]: {
              position: "static",
              display: "block",
              width: "100%",
              height: "100%",
              objectFit: "contain"
            },
            [`${itemCls}-name`]: {
              display: "none",
              textAlign: "center"
            },
            [`${itemCls}-file + ${itemCls}-name`]: {
              position: "absolute",
              bottom: token2.margin,
              display: "block",
              width: `calc(100% - ${token2.paddingXS * 2}px)`
            },
            [`${itemCls}-uploading`]: {
              [`&${itemCls}`]: {
                backgroundColor: token2.colorFillAlter
              },
              [`&::before, ${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
                display: "none"
              }
            },
            [`${itemCls}-progress`]: {
              bottom: token2.marginXL,
              width: `calc(100% - ${token2.paddingXS * 2}px)`,
              paddingInlineStart: 0
            }
          }
        }),
        [`${componentCls}-wrapper${componentCls}-picture-circle-wrapper`]: {
          [`${componentCls}${componentCls}-select`]: {
            borderRadius: "50%"
          }
        }
      };
    };
    const genRtlStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-rtl`]: {
          direction: "rtl"
        }
      };
    };
    const genRtlStyle$1 = genRtlStyle;
    const genBaseStyle = (token2) => {
      const {
        componentCls,
        colorTextDisabled
      } = token2;
      return {
        [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, resetComponent$1(token2)), {
          [componentCls]: {
            outline: 0,
            "input[type='file']": {
              cursor: "pointer"
            }
          },
          [`${componentCls}-select`]: {
            display: "inline-block"
          },
          [`${componentCls}-disabled`]: {
            color: colorTextDisabled,
            cursor: "not-allowed"
          }
        })
      };
    };
    const useStyle$2 = genComponentStyleHook("Upload", (token2) => {
      const {
        fontSizeHeading3,
        fontSize,
        lineHeight,
        lineWidth,
        controlHeightLG
      } = token2;
      const listItemHeightSM = Math.round(fontSize * lineHeight);
      const uploadToken = merge$4(token2, {
        uploadThumbnailSize: fontSizeHeading3 * 2,
        uploadProgressOffset: listItemHeightSM / 2 + lineWidth,
        uploadPicCardSize: controlHeightLG * 2.55
      });
      return [genBaseStyle(uploadToken), genDraggerStyle$1(uploadToken), genPictureStyle(uploadToken), genPictureCardStyle(uploadToken), genListStyle$1(uploadToken), genMotionStyle$1(uploadToken), genRtlStyle$1(uploadToken), genCollapseMotion$1(uploadToken)];
    });
    var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator2) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator2.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator2["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
      });
    };
    const LIST_IGNORE = `__LIST_IGNORE_${Date.now()}__`;
    const InternalUpload = (props, ref) => {
      const {
        fileList,
        defaultFileList,
        onRemove,
        showUploadList = true,
        listType = "text",
        onPreview,
        onDownload,
        onChange,
        onDrop,
        previewFile,
        disabled: customDisabled,
        locale: propLocale,
        iconRender,
        isImageUrl: isImageUrl2,
        progress,
        prefixCls: customizePrefixCls,
        className,
        type: type2 = "select",
        children,
        style: style2,
        itemRender,
        maxCount,
        data: data2 = {},
        multiple = false,
        action = "",
        accept = "",
        supportServerRender = true
      } = props;
      const disabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const [mergedFileList, setMergedFileList] = useMergedState(defaultFileList || [], {
        value: fileList,
        postState: (list2) => list2 !== null && list2 !== void 0 ? list2 : []
      });
      const [dragState, setDragState] = reactExports.useState("drop");
      const upload2 = reactExports.useRef(null);
      reactExports.useMemo(() => {
        const timestamp = Date.now();
        (fileList || []).forEach((file, index2) => {
          if (!file.uid && !Object.isFrozen(file)) {
            file.uid = `__AUTO__${timestamp}_${index2}__`;
          }
        });
      }, [fileList]);
      const onInternalChange = (file, changedFileList, event) => {
        let cloneList = _toConsumableArray(changedFileList);
        if (maxCount === 1) {
          cloneList = cloneList.slice(-1);
        } else if (maxCount) {
          cloneList = cloneList.slice(0, maxCount);
        }
        reactDomExports.flushSync(() => {
          setMergedFileList(cloneList);
        });
        const changeInfo = {
          file,
          fileList: cloneList
        };
        if (event) {
          changeInfo.event = event;
        }
        onChange === null || onChange === void 0 ? void 0 : onChange(changeInfo);
      };
      const mergedBeforeUpload = (file, fileListArgs) => __awaiter(void 0, void 0, void 0, function* () {
        const {
          beforeUpload,
          transformFile
        } = props;
        let parsedFile = file;
        if (beforeUpload) {
          const result = yield beforeUpload(file, fileListArgs);
          if (result === false) {
            return false;
          }
          delete file[LIST_IGNORE];
          if (result === LIST_IGNORE) {
            Object.defineProperty(file, LIST_IGNORE, {
              value: true,
              configurable: true
            });
            return false;
          }
          if (typeof result === "object" && result) {
            parsedFile = result;
          }
        }
        if (transformFile) {
          parsedFile = yield transformFile(parsedFile);
        }
        return parsedFile;
      });
      const onBatchStart = (batchFileInfoList) => {
        const filteredFileInfoList = batchFileInfoList.filter((info2) => !info2.file[LIST_IGNORE]);
        if (!filteredFileInfoList.length) {
          return;
        }
        const objectFileList = filteredFileInfoList.map((info2) => file2Obj(info2.file));
        let newFileList = _toConsumableArray(mergedFileList);
        objectFileList.forEach((fileObj) => {
          newFileList = updateFileList(fileObj, newFileList);
        });
        objectFileList.forEach((fileObj, index2) => {
          let triggerFileObj = fileObj;
          if (!filteredFileInfoList[index2].parsedFile) {
            const {
              originFileObj
            } = fileObj;
            let clone;
            try {
              clone = new File([originFileObj], originFileObj.name, {
                type: originFileObj.type
              });
            } catch (e2) {
              clone = new Blob([originFileObj], {
                type: originFileObj.type
              });
              clone.name = originFileObj.name;
              clone.lastModifiedDate = new Date();
              clone.lastModified = new Date().getTime();
            }
            clone.uid = fileObj.uid;
            triggerFileObj = clone;
          } else {
            fileObj.status = "uploading";
          }
          onInternalChange(triggerFileObj, newFileList);
        });
      };
      const onSuccess = (response, file, xhr2) => {
        try {
          if (typeof response === "string") {
            response = JSON.parse(response);
          }
        } catch (e2) {
        }
        if (!getFileItem(file, mergedFileList)) {
          return;
        }
        const targetItem = file2Obj(file);
        targetItem.status = "done";
        targetItem.percent = 100;
        targetItem.response = response;
        targetItem.xhr = xhr2;
        const nextFileList = updateFileList(targetItem, mergedFileList);
        onInternalChange(targetItem, nextFileList);
      };
      const onProgress = (e2, file) => {
        if (!getFileItem(file, mergedFileList)) {
          return;
        }
        const targetItem = file2Obj(file);
        targetItem.status = "uploading";
        targetItem.percent = e2.percent;
        const nextFileList = updateFileList(targetItem, mergedFileList);
        onInternalChange(targetItem, nextFileList, e2);
      };
      const onError = (error, response, file) => {
        if (!getFileItem(file, mergedFileList)) {
          return;
        }
        const targetItem = file2Obj(file);
        targetItem.error = error;
        targetItem.response = response;
        targetItem.status = "error";
        const nextFileList = updateFileList(targetItem, mergedFileList);
        onInternalChange(targetItem, nextFileList);
      };
      const handleRemove = (file) => {
        let currentFile;
        Promise.resolve(typeof onRemove === "function" ? onRemove(file) : onRemove).then((ret) => {
          var _a;
          if (ret === false) {
            return;
          }
          const removedFileList = removeFileItem(file, mergedFileList);
          if (removedFileList) {
            currentFile = Object.assign(Object.assign({}, file), {
              status: "removed"
            });
            mergedFileList === null || mergedFileList === void 0 ? void 0 : mergedFileList.forEach((item) => {
              const matchKey = currentFile.uid !== void 0 ? "uid" : "name";
              if (item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item)) {
                item.status = "removed";
              }
            });
            (_a = upload2.current) === null || _a === void 0 ? void 0 : _a.abort(currentFile);
            onInternalChange(currentFile, removedFileList);
          }
        });
      };
      const onFileDrop = (e2) => {
        setDragState(e2.type);
        if (e2.type === "drop") {
          onDrop === null || onDrop === void 0 ? void 0 : onDrop(e2);
        }
      };
      reactExports.useImperativeHandle(ref, () => ({
        onBatchStart,
        onSuccess,
        onProgress,
        onError,
        fileList: mergedFileList,
        upload: upload2.current
      }));
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("upload", customizePrefixCls);
      const rcUploadProps = Object.assign(Object.assign({
        onBatchStart,
        onError,
        onProgress,
        onSuccess
      }, props), {
        data: data2,
        multiple,
        action,
        accept,
        supportServerRender,
        prefixCls,
        disabled: mergedDisabled,
        beforeUpload: mergedBeforeUpload,
        onChange: void 0
      });
      delete rcUploadProps.className;
      delete rcUploadProps.style;
      if (!children || mergedDisabled) {
        delete rcUploadProps.id;
      }
      const [wrapSSR, hashId] = useStyle$2(prefixCls);
      const [contextLocale] = useLocale$1("Upload", defaultLocale.Upload);
      const {
        showRemoveIcon,
        showPreviewIcon,
        showDownloadIcon,
        removeIcon,
        previewIcon,
        downloadIcon
      } = typeof showUploadList === "boolean" ? {} : showUploadList;
      const renderUploadList = (button, buttonVisible) => {
        if (!showUploadList) {
          return button;
        }
        return /* @__PURE__ */ reactExports.createElement(UploadList$1, {
          prefixCls,
          listType,
          items: mergedFileList,
          previewFile,
          onPreview,
          onDownload,
          onRemove: handleRemove,
          showRemoveIcon: !mergedDisabled && showRemoveIcon,
          showPreviewIcon,
          showDownloadIcon,
          removeIcon,
          previewIcon,
          downloadIcon,
          iconRender,
          locale: Object.assign(Object.assign({}, contextLocale), propLocale),
          isImageUrl: isImageUrl2,
          progress,
          appendAction: button,
          appendActionVisible: buttonVisible,
          itemRender
        });
      };
      const rtlCls = {
        [`${prefixCls}-rtl`]: direction === "rtl"
      };
      if (type2 === "drag") {
        const dragCls = classNames(prefixCls, {
          [`${prefixCls}-drag`]: true,
          [`${prefixCls}-drag-uploading`]: mergedFileList.some((file) => file.status === "uploading"),
          [`${prefixCls}-drag-hover`]: dragState === "dragover",
          [`${prefixCls}-disabled`]: mergedDisabled,
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, hashId);
        return wrapSSR(/* @__PURE__ */ reactExports.createElement("span", {
          className: classNames(`${prefixCls}-wrapper`, rtlCls, className, hashId)
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: dragCls,
          onDrop: onFileDrop,
          onDragOver: onFileDrop,
          onDragLeave: onFileDrop,
          style: style2
        }, /* @__PURE__ */ reactExports.createElement(Upload$3, Object.assign({}, rcUploadProps, {
          ref: upload2,
          className: `${prefixCls}-btn`
        }), /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-drag-container`
        }, children))), renderUploadList()));
      }
      const uploadButtonCls = classNames(prefixCls, `${prefixCls}-select`, {
        [`${prefixCls}-disabled`]: mergedDisabled
      });
      const renderUploadButton = (uploadButtonStyle) => /* @__PURE__ */ reactExports.createElement("div", {
        className: uploadButtonCls,
        style: uploadButtonStyle
      }, /* @__PURE__ */ reactExports.createElement(Upload$3, Object.assign({}, rcUploadProps, {
        ref: upload2
      })));
      const uploadButton = renderUploadButton(children ? void 0 : {
        display: "none"
      });
      if (listType === "picture-card" || listType === "picture-circle") {
        return wrapSSR(/* @__PURE__ */ reactExports.createElement("span", {
          className: classNames(`${prefixCls}-wrapper`, {
            [`${prefixCls}-picture-card-wrapper`]: listType === "picture-card",
            [`${prefixCls}-picture-circle-wrapper`]: listType === "picture-circle"
          }, rtlCls, className, hashId)
        }, renderUploadList(uploadButton, !!children)));
      }
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("span", {
        className: classNames(`${prefixCls}-wrapper`, rtlCls, className, hashId)
      }, uploadButton, renderUploadList()));
    };
    const Upload$2 = /* @__PURE__ */ reactExports.forwardRef(InternalUpload);
    const InternalUpload$1 = Upload$2;
    var __rest = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Dragger = /* @__PURE__ */ reactExports.forwardRef((_a, ref) => {
      var {
        style: style2,
        height
      } = _a, restProps = __rest(_a, ["style", "height"]);
      return /* @__PURE__ */ reactExports.createElement(InternalUpload$1, Object.assign({
        ref
      }, restProps, {
        type: "drag",
        style: Object.assign(Object.assign({}, style2), {
          height
        })
      }));
    });
    const Dragger$1 = Dragger;
    const Upload = InternalUpload$1;
    Upload.Dragger = Dragger$1;
    Upload.LIST_IGNORE = LIST_IGNORE;
    const Upload$1 = Upload;
    var __assign = function() {
      __assign = Object.assign || function __assign2(t2) {
        for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s = arguments[i2];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t2[p2] = s[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var useModal = function(config) {
      var modalConfig = config || {};
      var _a = modalConfig.defaultVisible, defaultVisible = _a === void 0 ? false : _a;
      var _b = reactExports.useState(defaultVisible), visible = _b[0], setVisible = _b[1];
      var show = reactExports.useCallback(function() {
        return setVisible(true);
      }, [visible]);
      var close = reactExports.useCallback(function() {
        return setVisible(false);
      }, [visible]);
      var modalProps = {
        visible,
        onCancel: close
      };
      return {
        visible,
        show,
        close,
        modalProps
      };
    };
    var useForm = function(config) {
      var _a = reactExports.useState(false), defaultFormValuesLoading = _a[0], setDefaultFormValuesLoading = _a[1];
      var _b = reactExports.useState({}), initialValues = _b[0], setInitialValues = _b[1];
      var defaultFormValues = config.defaultFormValues, form = config.form, submit = config.submit;
      var _c = reactExports.useState({}), formValues = _c[0], setFormValues = _c[1];
      var _d = reactExports.useState(false), formLoading = _d[0], setFormLoading = _d[1];
      var _e2 = reactExports.useState(), formResult = _e2[0], setFormResult = _e2[1];
      var version2 = 3;
      if (Form$1["useForm"]) {
        version2 = 4;
      }
      var formInstance = form;
      if (!form) {
        if (version2 === 4) {
          formInstance = Form$1["useForm"]()[0];
        } else {
          throw new Error('"form" need in antd@3');
        }
      }
      var onFinish = function(formValue) {
        setFormValues(formValue);
        setFormLoading(true);
        return new Promise(function(resolve, reject) {
          if (version2 === 4) {
            formInstance.validateFields().then(function() {
              resolve(Promise.resolve(submit(formValue)).then(function(data2) {
                setFormLoading(false);
                setFormResult(data2);
                return data2;
              }).catch(function(err) {
                setFormLoading(false);
                throw err;
              }));
            }).catch(function(validateErr) {
              setFormLoading(false);
              reject(validateErr);
            });
          } else {
            formInstance.validateFields(function(validateErr) {
              if (validateErr) {
                setFormLoading(false);
                reject(validateErr);
              } else {
                resolve(Promise.resolve(submit(formValue)).then(function(data2) {
                  setFormLoading(false);
                  setFormResult(data2);
                  return data2;
                }).catch(function(err) {
                  setFormLoading(false);
                  throw err;
                }));
              }
            });
          }
        });
      };
      reactExports.useEffect(function() {
        var isUnMounted = false;
        if (!defaultFormValues) {
          return;
        }
        var value;
        if (typeof defaultFormValues === "function") {
          setDefaultFormValuesLoading(true);
          value = defaultFormValues();
        } else {
          value = defaultFormValues;
        }
        Promise.resolve(value).then(function(data2) {
          if (!isUnMounted) {
            var obj_1 = __assign({}, data2);
            Object.keys(data2).forEach(function(name) {
              obj_1[name] = formInstance.isFieldTouched(name) ? formInstance.getFieldValue(name) : data2[name];
            });
            setDefaultFormValuesLoading(false);
            setInitialValues(data2);
            formInstance.setFieldsValue(obj_1);
          }
        }).catch(function() {
          if (!isUnMounted) {
            setDefaultFormValuesLoading(false);
          }
        });
        return function() {
          isUnMounted = true;
        };
      }, []);
      var formProps = version2 === 4 ? {
        form: formInstance,
        onFinish,
        initialValues
      } : {
        onSubmit: function(e2) {
          e2.preventDefault();
          onFinish(formInstance.getFieldsValue(version2 === 4 ? true : void 0));
        }
      };
      return {
        form: formInstance,
        formProps,
        defaultFormValuesLoading,
        formValues,
        initialValues,
        formResult,
        formLoading,
        submit: function(values) {
          formInstance.setFieldsValue(values);
          return onFinish(formInstance.getFieldsValue(version2 === 4 ? true : void 0));
        }
      };
    };
    var useModalForm = function(config) {
      var modalFormConfig = config || {};
      var _a = modalFormConfig.defaultVisible, defaultVisible = _a === void 0 ? false : _a, _b = modalFormConfig.autoSubmitClose, autoSubmitClose = _b === void 0 ? true : _b, _c = modalFormConfig.autoResetForm, autoResetForm = _c === void 0 ? true : _c, submit = modalFormConfig.submit, form = modalFormConfig.form, defaultFormValues = modalFormConfig.defaultFormValues;
      var _d = useModal({
        defaultVisible
      }), visible = _d.visible, show = _d.show, close = _d.close, modalProps = _d.modalProps;
      var _e2 = useForm({
        form,
        submit,
        defaultFormValues
      }), formInstance = _e2.form, formProps = _e2.formProps, formLoading = _e2.formLoading, defaultFormValuesLoading = _e2.defaultFormValuesLoading, formValues = _e2.formValues, initialValues = _e2.initialValues, formResult = _e2.formResult, formSubmit = _e2.submit;
      var modalFormProps = __assign(__assign({}, modalProps), { onOk: function() {
        formSubmit().then(function() {
          if (autoSubmitClose) {
            close();
          }
          if (autoResetForm) {
            formInstance.resetFields();
          }
        });
      } });
      return {
        form: formInstance,
        visible,
        show,
        close,
        modalProps: modalFormProps,
        formProps,
        formLoading,
        defaultFormValuesLoading,
        formValues,
        initialValues,
        formResult,
        submit: formSubmit
      };
    };
    var IconContext$1 = /* @__PURE__ */ reactExports.createContext({});
    const Context$1 = IconContext$1;
    var hueStep = 2;
    var saturationStep = 0.16;
    var saturationStep2 = 0.05;
    var brightnessStep1 = 0.05;
    var brightnessStep2 = 0.15;
    var lightColorCount = 5;
    var darkColorCount = 4;
    var darkColorMap = [{
      index: 7,
      opacity: 0.15
    }, {
      index: 6,
      opacity: 0.25
    }, {
      index: 5,
      opacity: 0.3
    }, {
      index: 5,
      opacity: 0.45
    }, {
      index: 5,
      opacity: 0.65
    }, {
      index: 5,
      opacity: 0.85
    }, {
      index: 4,
      opacity: 0.9
    }, {
      index: 3,
      opacity: 0.95
    }, {
      index: 2,
      opacity: 0.97
    }, {
      index: 1,
      opacity: 0.98
    }];
    function toHsv(_ref) {
      var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
      var hsv = rgbToHsv(r2, g2, b2);
      return {
        h: hsv.h * 360,
        s: hsv.s,
        v: hsv.v
      };
    }
    function toHex(_ref2) {
      var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
      return "#".concat(rgbToHex(r2, g2, b2, false));
    }
    function mix(rgb1, rgb2, amount) {
      var p2 = amount / 100;
      var rgb = {
        r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p2 + rgb1.b
      };
      return rgb;
    }
    function getHue(hsv, i2, light) {
      var hue;
      if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
        hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
      } else {
        hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
      }
      if (hue < 0) {
        hue += 360;
      } else if (hue >= 360) {
        hue -= 360;
      }
      return hue;
    }
    function getSaturation(hsv, i2, light) {
      if (hsv.h === 0 && hsv.s === 0) {
        return hsv.s;
      }
      var saturation;
      if (light) {
        saturation = hsv.s - saturationStep * i2;
      } else if (i2 === darkColorCount) {
        saturation = hsv.s + saturationStep;
      } else {
        saturation = hsv.s + saturationStep2 * i2;
      }
      if (saturation > 1) {
        saturation = 1;
      }
      if (light && i2 === lightColorCount && saturation > 0.1) {
        saturation = 0.1;
      }
      if (saturation < 0.06) {
        saturation = 0.06;
      }
      return Number(saturation.toFixed(2));
    }
    function getValue(hsv, i2, light) {
      var value;
      if (light) {
        value = hsv.v + brightnessStep1 * i2;
      } else {
        value = hsv.v - brightnessStep2 * i2;
      }
      if (value > 1) {
        value = 1;
      }
      return Number(value.toFixed(2));
    }
    function generate$1(color2) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var patterns = [];
      var pColor = inputToRGB(color2);
      for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
        var hsv = toHsv(pColor);
        var colorString = toHex(inputToRGB({
          h: getHue(hsv, i2, true),
          s: getSaturation(hsv, i2, true),
          v: getValue(hsv, i2, true)
        }));
        patterns.push(colorString);
      }
      patterns.push(toHex(pColor));
      for (var _i = 1; _i <= darkColorCount; _i += 1) {
        var _hsv = toHsv(pColor);
        var _colorString = toHex(inputToRGB({
          h: getHue(_hsv, _i),
          s: getSaturation(_hsv, _i),
          v: getValue(_hsv, _i)
        }));
        patterns.push(_colorString);
      }
      if (opts.theme === "dark") {
        return darkColorMap.map(function(_ref3) {
          var index2 = _ref3.index, opacity = _ref3.opacity;
          var darkColorString = toHex(mix(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
          return darkColorString;
        });
      }
      return patterns;
    }
    var presetPrimaryColors = {
      red: "#F5222D",
      volcano: "#FA541C",
      orange: "#FA8C16",
      gold: "#FAAD14",
      yellow: "#FADB14",
      lime: "#A0D911",
      green: "#52C41A",
      cyan: "#13C2C2",
      blue: "#1890FF",
      geekblue: "#2F54EB",
      purple: "#722ED1",
      magenta: "#EB2F96",
      grey: "#666666"
    };
    var presetPalettes = {};
    var presetDarkPalettes = {};
    Object.keys(presetPrimaryColors).forEach(function(key) {
      presetPalettes[key] = generate$1(presetPrimaryColors[key]);
      presetPalettes[key].primary = presetPalettes[key][5];
      presetDarkPalettes[key] = generate$1(presetPrimaryColors[key], {
        theme: "dark",
        backgroundColor: "#141414"
      });
      presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
    });
    function warning$2(valid, message2) {
      warningOnce$1(valid, "[@ant-design/icons] ".concat(message2));
    }
    function isIconDefinition(target) {
      return _typeof$4(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof$4(target.icon) === "object" || typeof target.icon === "function");
    }
    function normalizeAttrs() {
      var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return Object.keys(attrs).reduce(function(acc, key) {
        var val = attrs[key];
        switch (key) {
          case "class":
            acc.className = val;
            delete acc.class;
            break;
          default:
            acc[key] = val;
        }
        return acc;
      }, {});
    }
    function generate(node2, key, rootProps) {
      if (!rootProps) {
        return /* @__PURE__ */ React$3.createElement(node2.tag, _objectSpread2$3({
          key
        }, normalizeAttrs(node2.attrs)), (node2.children || []).map(function(child, index2) {
          return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
        }));
      }
      return /* @__PURE__ */ React$3.createElement(node2.tag, _objectSpread2$3(_objectSpread2$3({
        key
      }, normalizeAttrs(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
        return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
      }));
    }
    function getSecondaryColor(primaryColor) {
      return generate$1(primaryColor)[0];
    }
    function normalizeTwoToneColors(twoToneColor) {
      if (!twoToneColor) {
        return [];
      }
      return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
    }
    var svgBaseProps = {
      width: "1em",
      height: "1em",
      fill: "currentColor",
      "aria-hidden": "true",
      focusable: "false"
    };
    var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
    var useInsertStyles = function useInsertStyles2() {
      var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles;
      var _useContext = reactExports.useContext(Context$1), csp = _useContext.csp;
      reactExports.useEffect(function() {
        updateCSS$1(styleStr, "@ant-design-icons", {
          prepend: true,
          csp
        });
      }, []);
    };
    var _excluded$3 = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
    var twoToneColorPalette = {
      primaryColor: "#333",
      secondaryColor: "#E6E6E6",
      calculated: false
    };
    function setTwoToneColors(_ref) {
      var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
      twoToneColorPalette.primaryColor = primaryColor;
      twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
      twoToneColorPalette.calculated = !!secondaryColor;
    }
    function getTwoToneColors() {
      return _objectSpread2$3({}, twoToneColorPalette);
    }
    var IconBase$1 = function IconBase2(props) {
      var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties$1(props, _excluded$3);
      var colors = twoToneColorPalette;
      if (primaryColor) {
        colors = {
          primaryColor,
          secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
        };
      }
      useInsertStyles();
      warning$2(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
      if (!isIconDefinition(icon)) {
        return null;
      }
      var target = icon;
      if (target && typeof target.icon === "function") {
        target = _objectSpread2$3(_objectSpread2$3({}, target), {}, {
          icon: target.icon(colors.primaryColor, colors.secondaryColor)
        });
      }
      return generate(target.icon, "svg-".concat(target.name), _objectSpread2$3({
        className,
        onClick,
        style: style2,
        "data-icon": target.name,
        width: "1em",
        height: "1em",
        fill: "currentColor",
        "aria-hidden": "true"
      }, restProps));
    };
    IconBase$1.displayName = "IconReact";
    IconBase$1.getTwoToneColors = getTwoToneColors;
    IconBase$1.setTwoToneColors = setTwoToneColors;
    const ReactIcon = IconBase$1;
    function setTwoToneColor(twoToneColor) {
      var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
      return ReactIcon.setTwoToneColors({
        primaryColor,
        secondaryColor
      });
    }
    function getTwoToneColor() {
      var colors = ReactIcon.getTwoToneColors();
      if (!colors.calculated) {
        return colors.primaryColor;
      }
      return [colors.primaryColor, colors.secondaryColor];
    }
    var _excluded$2 = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
    setTwoToneColor("#1890ff");
    var Icon$4 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _classNames;
      var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties$1(props, _excluded$2);
      var _React$useContext = reactExports.useContext(Context$1), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
      var classString = classNames(rootClassName, prefixCls, (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty$7(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _classNames), className);
      var iconTabIndex = tabIndex;
      if (iconTabIndex === void 0 && onClick) {
        iconTabIndex = -1;
      }
      var svgStyle = rotate ? {
        msTransform: "rotate(".concat(rotate, "deg)"),
        transform: "rotate(".concat(rotate, "deg)")
      } : void 0;
      var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
      return /* @__PURE__ */ reactExports.createElement("span", _objectSpread2$3(_objectSpread2$3({
        role: "img",
        "aria-label": icon.name
      }, restProps), {}, {
        ref,
        tabIndex: iconTabIndex,
        onClick,
        className: classString
      }), /* @__PURE__ */ reactExports.createElement(ReactIcon, {
        icon,
        primaryColor,
        secondaryColor,
        style: svgStyle
      }));
    });
    Icon$4.displayName = "AntdIcon";
    Icon$4.getTwoToneColor = getTwoToneColor;
    Icon$4.setTwoToneColor = setTwoToneColor;
    const AntdIcon$1 = Icon$4;
    var ArrowLeftOutlined$5 = function ArrowLeftOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: ArrowLeftOutlinedSvg
      }));
    };
    ArrowLeftOutlined$5.displayName = "ArrowLeftOutlined";
    const Hi = /* @__PURE__ */ reactExports.forwardRef(ArrowLeftOutlined$5);
    var BarsOutlined = function BarsOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: BarsOutlinedSvg
      }));
    };
    BarsOutlined.displayName = "BarsOutlined";
    const ss = /* @__PURE__ */ reactExports.forwardRef(BarsOutlined);
    var CheckOutlined = function CheckOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: CheckOutlinedSvg
      }));
    };
    CheckOutlined.displayName = "CheckOutlined";
    const Ua = /* @__PURE__ */ reactExports.forwardRef(CheckOutlined);
    var CloseCircleOutlined = function CloseCircleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: CloseCircleOutlinedSvg
      }));
    };
    CloseCircleOutlined.displayName = "CloseCircleOutlined";
    const CloseCircleOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CloseCircleOutlined);
    var CrownOutlined = function CrownOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: CrownOutlinedSvg
      }));
    };
    CrownOutlined.displayName = "CrownOutlined";
    const CrownOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CrownOutlined);
    var DashboardOutlined = function DashboardOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: DashboardOutlinedSvg
      }));
    };
    DashboardOutlined.displayName = "DashboardOutlined";
    const Xo = /* @__PURE__ */ reactExports.forwardRef(DashboardOutlined);
    var DeleteOutlined = function DeleteOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: DeleteOutlinedSvg
      }));
    };
    DeleteOutlined.displayName = "DeleteOutlined";
    const Vt = /* @__PURE__ */ reactExports.forwardRef(DeleteOutlined);
    var DownOutlined = function DownOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: DownOutlinedSvg
      }));
    };
    DownOutlined.displayName = "DownOutlined";
    const DownOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(DownOutlined);
    var EditOutlined = function EditOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: EditOutlinedSvg
      }));
    };
    EditOutlined.displayName = "EditOutlined";
    const vt = /* @__PURE__ */ reactExports.forwardRef(EditOutlined);
    var FacebookOutlined = function FacebookOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: FacebookOutlinedSvg
      }));
    };
    FacebookOutlined.displayName = "FacebookOutlined";
    const FacebookOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(FacebookOutlined);
    var FilterOutlined = function FilterOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: FilterOutlinedSvg
      }));
    };
    FilterOutlined.displayName = "FilterOutlined";
    const on = /* @__PURE__ */ reactExports.forwardRef(FilterOutlined);
    var FolderOutlined = function FolderOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: FolderOutlinedSvg
      }));
    };
    FolderOutlined.displayName = "FolderOutlined";
    const Mn = /* @__PURE__ */ reactExports.forwardRef(FolderOutlined);
    var GoogleOutlined = function GoogleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: GoogleOutlinedSvg
      }));
    };
    GoogleOutlined.displayName = "GoogleOutlined";
    const GoogleOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(GoogleOutlined);
    var HomeOutlined = function HomeOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: HomeOutlinedSvg
      }));
    };
    HomeOutlined.displayName = "HomeOutlined";
    const Ii = /* @__PURE__ */ reactExports.forwardRef(HomeOutlined);
    var InfoCircleOutlined = function InfoCircleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: InfoCircleOutlinedSvg
      }));
    };
    InfoCircleOutlined.displayName = "InfoCircleOutlined";
    const dn = /* @__PURE__ */ reactExports.forwardRef(InfoCircleOutlined);
    var KeyOutlined = function KeyOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: KeyOutlinedSvg
      }));
    };
    KeyOutlined.displayName = "KeyOutlined";
    const KeyOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(KeyOutlined);
    var LockOutlined = function LockOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: LockOutlinedSvg
      }));
    };
    LockOutlined.displayName = "LockOutlined";
    const LockOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(LockOutlined);
    var LogoutOutlined = function LogoutOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: LogoutOutlinedSvg
      }));
    };
    LogoutOutlined.displayName = "LogoutOutlined";
    const Jo = /* @__PURE__ */ reactExports.forwardRef(LogoutOutlined);
    var MailOutlined = function MailOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: MailOutlinedSvg
      }));
    };
    MailOutlined.displayName = "MailOutlined";
    const MailOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(MailOutlined);
    var MoreOutlined = function MoreOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: MoreOutlinedSvg
      }));
    };
    MoreOutlined.displayName = "MoreOutlined";
    const MoreOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(MoreOutlined);
    var PhoneOutlined = function PhoneOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: PhoneOutlinedSvg
      }));
    };
    PhoneOutlined.displayName = "PhoneOutlined";
    const PhoneOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(PhoneOutlined);
    var PlusCircleOutlined = function PlusCircleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: PlusCircleOutlinedSvg
      }));
    };
    PlusCircleOutlined.displayName = "PlusCircleOutlined";
    const PlusCircleOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(PlusCircleOutlined);
    var PlusSquareOutlined = function PlusSquareOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: PlusSquareOutlinedSvg
      }));
    };
    PlusSquareOutlined.displayName = "PlusSquareOutlined";
    const Cs = /* @__PURE__ */ reactExports.forwardRef(PlusSquareOutlined);
    var ReadOutlined = function ReadOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: ReadOutlinedSvg
      }));
    };
    ReadOutlined.displayName = "ReadOutlined";
    const Vn = /* @__PURE__ */ reactExports.forwardRef(ReadOutlined);
    var RedoOutlined = function RedoOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: RedoOutlinedSvg
      }));
    };
    RedoOutlined.displayName = "RedoOutlined";
    const Gt = /* @__PURE__ */ reactExports.forwardRef(RedoOutlined);
    var SaveOutlined = function SaveOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: SaveOutlinedSvg
      }));
    };
    SaveOutlined.displayName = "SaveOutlined";
    const bs = /* @__PURE__ */ reactExports.forwardRef(SaveOutlined);
    var SelectOutlined = function SelectOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: SelectOutlinedSvg
      }));
    };
    SelectOutlined.displayName = "SelectOutlined";
    const SelectOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(SelectOutlined);
    var TeamOutlined = function TeamOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: TeamOutlinedSvg
      }));
    };
    TeamOutlined.displayName = "TeamOutlined";
    const Hn = /* @__PURE__ */ reactExports.forwardRef(TeamOutlined);
    var UndoOutlined = function UndoOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: UndoOutlinedSvg
      }));
    };
    UndoOutlined.displayName = "UndoOutlined";
    const qo = /* @__PURE__ */ reactExports.forwardRef(UndoOutlined);
    var UnorderedListOutlined = function UnorderedListOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon$1, _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        ref,
        icon: UnorderedListOutlinedSvg
      }));
    };
    UnorderedListOutlined.displayName = "UnorderedListOutlined";
    const yr = /* @__PURE__ */ reactExports.forwardRef(UnorderedListOutlined);
    var _excluded$1 = ["className", "component", "viewBox", "spin", "rotate", "tabIndex", "onClick", "children"];
    var Icon$2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var className = props.className, Component = props.component, viewBox = props.viewBox, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, children = props.children, restProps = _objectWithoutProperties$1(props, _excluded$1);
      warning$2(Boolean(Component || children), "Should have `component` prop or `children`.");
      useInsertStyles();
      var _React$useContext = reactExports.useContext(Context$1), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
      var classString = classNames(rootClassName, prefixCls, className);
      var svgClassString = classNames(_defineProperty$7({}, "".concat(prefixCls, "-spin"), !!spin));
      var svgStyle = rotate ? {
        msTransform: "rotate(".concat(rotate, "deg)"),
        transform: "rotate(".concat(rotate, "deg)")
      } : void 0;
      var innerSvgProps = _objectSpread2$3(_objectSpread2$3({}, svgBaseProps), {}, {
        className: svgClassString,
        style: svgStyle,
        viewBox
      });
      if (!viewBox) {
        delete innerSvgProps.viewBox;
      }
      var renderInnerNode = function renderInnerNode2() {
        if (Component) {
          return /* @__PURE__ */ reactExports.createElement(Component, _objectSpread2$3({}, innerSvgProps), children);
        }
        if (children) {
          warning$2(Boolean(viewBox) || reactExports.Children.count(children) === 1 && /* @__PURE__ */ reactExports.isValidElement(children) && reactExports.Children.only(children).type === "use", "Make sure that you provide correct `viewBox` prop (default `0 0 1024 1024`) to the icon.");
          return /* @__PURE__ */ reactExports.createElement("svg", _objectSpread2$3(_objectSpread2$3({}, innerSvgProps), {}, {
            viewBox
          }), children);
        }
        return null;
      };
      var iconTabIndex = tabIndex;
      if (iconTabIndex === void 0 && onClick) {
        iconTabIndex = -1;
      }
      return /* @__PURE__ */ reactExports.createElement("span", _objectSpread2$3(_objectSpread2$3({
        role: "img"
      }, restProps), {}, {
        ref,
        tabIndex: iconTabIndex,
        onClick,
        className: classString
      }), renderInnerNode());
    });
    Icon$2.displayName = "AntdIcon";
    const Icon$3 = Icon$2;
    var localizedFormatExports = {};
    var localizedFormat = {
      get exports() {
        return localizedFormatExports;
      },
      set exports(v2) {
        localizedFormatExports = v2;
      }
    };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
        return function(t2, o2, n2) {
          var r2 = o2.prototype, i2 = r2.format;
          n2.en.formats = e2, r2.format = function(t3) {
            void 0 === t3 && (t3 = "YYYY-MM-DDTHH:mm:ssZ");
            var o3 = this.$locale().formats, n3 = function(t4, o4) {
              return t4.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t5, n4, r3) {
                var i3 = r3 && r3.toUpperCase();
                return n4 || o4[r3] || e2[r3] || o4[i3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t6, o5) {
                  return t6 || o5.slice(1);
                });
              });
            }(t3, void 0 === o3 ? {} : o3);
            return i2.call(this, n3);
          };
        };
      });
    })(localizedFormat);
    const Ha = localizedFormatExports;
    var vfileExports = {};
    var vfile$1 = {
      get exports() {
        return vfileExports;
      },
      set exports(v2) {
        vfileExports = v2;
      }
    };
    var own$7 = {}.hasOwnProperty;
    var unistUtilStringifyPosition = stringify$1;
    function stringify$1(value) {
      if (!value || typeof value !== "object") {
        return "";
      }
      if (own$7.call(value, "position") || own$7.call(value, "type")) {
        return position$3(value.position);
      }
      if (own$7.call(value, "start") || own$7.call(value, "end")) {
        return position$3(value);
      }
      if (own$7.call(value, "line") || own$7.call(value, "column")) {
        return point(value);
      }
      return "";
    }
    function point(point2) {
      if (!point2 || typeof point2 !== "object") {
        point2 = {};
      }
      return index$1(point2.line) + ":" + index$1(point2.column);
    }
    function position$3(pos) {
      if (!pos || typeof pos !== "object") {
        pos = {};
      }
      return point(pos.start) + "-" + point(pos.end);
    }
    function index$1(value) {
      return value && typeof value === "number" ? value : 1;
    }
    var stringify = unistUtilStringifyPosition;
    var vfileMessage = VMessage$1;
    function VMessagePrototype() {
    }
    VMessagePrototype.prototype = Error.prototype;
    VMessage$1.prototype = new VMessagePrototype();
    var proto$2 = VMessage$1.prototype;
    proto$2.file = "";
    proto$2.name = "";
    proto$2.reason = "";
    proto$2.message = "";
    proto$2.stack = "";
    proto$2.fatal = null;
    proto$2.column = null;
    proto$2.line = null;
    function VMessage$1(reason, position2, origin) {
      var parts;
      var range2;
      var location2;
      if (typeof position2 === "string") {
        origin = position2;
        position2 = null;
      }
      parts = parseOrigin(origin);
      range2 = stringify(position2) || "1:1";
      location2 = {
        start: { line: null, column: null },
        end: { line: null, column: null }
      };
      if (position2 && position2.position) {
        position2 = position2.position;
      }
      if (position2) {
        if (position2.start) {
          location2 = position2;
          position2 = position2.start;
        } else {
          location2.start = position2;
        }
      }
      if (reason.stack) {
        this.stack = reason.stack;
        reason = reason.message;
      }
      this.message = reason;
      this.name = range2;
      this.reason = reason;
      this.line = position2 ? position2.line : null;
      this.column = position2 ? position2.column : null;
      this.location = location2;
      this.source = parts[0];
      this.ruleId = parts[1];
    }
    function parseOrigin(origin) {
      var result = [null, null];
      var index2;
      if (typeof origin === "string") {
        index2 = origin.indexOf(":");
        if (index2 === -1) {
          result[1] = origin;
        } else {
          result[0] = origin.slice(0, index2);
          result[1] = origin.slice(index2 + 1);
        }
      }
      return result;
    }
    var minpath_browser = {};
    minpath_browser.basename = basename;
    minpath_browser.dirname = dirname;
    minpath_browser.extname = extname;
    minpath_browser.join = join;
    minpath_browser.sep = "/";
    function basename(path2, ext) {
      var start2 = 0;
      var end2 = -1;
      var index2;
      var firstNonSlashEnd;
      var seenNonSlash;
      var extIndex;
      if (ext !== void 0 && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
      }
      assertPath$1(path2);
      index2 = path2.length;
      if (ext === void 0 || !ext.length || ext.length > path2.length) {
        while (index2--) {
          if (path2.charCodeAt(index2) === 47) {
            if (seenNonSlash) {
              start2 = index2 + 1;
              break;
            }
          } else if (end2 < 0) {
            seenNonSlash = true;
            end2 = index2 + 1;
          }
        }
        return end2 < 0 ? "" : path2.slice(start2, end2);
      }
      if (ext === path2) {
        return "";
      }
      firstNonSlashEnd = -1;
      extIndex = ext.length - 1;
      while (index2--) {
        if (path2.charCodeAt(index2) === 47) {
          if (seenNonSlash) {
            start2 = index2 + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd < 0) {
            seenNonSlash = true;
            firstNonSlashEnd = index2 + 1;
          }
          if (extIndex > -1) {
            if (path2.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
              if (extIndex < 0) {
                end2 = index2;
              }
            } else {
              extIndex = -1;
              end2 = firstNonSlashEnd;
            }
          }
        }
      }
      if (start2 === end2) {
        end2 = firstNonSlashEnd;
      } else if (end2 < 0) {
        end2 = path2.length;
      }
      return path2.slice(start2, end2);
    }
    function dirname(path2) {
      var end2;
      var unmatchedSlash;
      var index2;
      assertPath$1(path2);
      if (!path2.length) {
        return ".";
      }
      end2 = -1;
      index2 = path2.length;
      while (--index2) {
        if (path2.charCodeAt(index2) === 47) {
          if (unmatchedSlash) {
            end2 = index2;
            break;
          }
        } else if (!unmatchedSlash) {
          unmatchedSlash = true;
        }
      }
      return end2 < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end2 === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end2);
    }
    function extname(path2) {
      var startDot = -1;
      var startPart = 0;
      var end2 = -1;
      var preDotState = 0;
      var unmatchedSlash;
      var code2;
      var index2;
      assertPath$1(path2);
      index2 = path2.length;
      while (index2--) {
        code2 = path2.charCodeAt(index2);
        if (code2 === 47) {
          if (unmatchedSlash) {
            startPart = index2 + 1;
            break;
          }
          continue;
        }
        if (end2 < 0) {
          unmatchedSlash = true;
          end2 = index2 + 1;
        }
        if (code2 === 46) {
          if (startDot < 0) {
            startDot = index2;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot > -1) {
          preDotState = -1;
        }
      }
      if (startDot < 0 || end2 < 0 || // We saw a non-dot character immediately before the dot.
      preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
      preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end2);
    }
    function join() {
      var index2 = -1;
      var joined;
      while (++index2 < arguments.length) {
        assertPath$1(arguments[index2]);
        if (arguments[index2]) {
          joined = joined === void 0 ? arguments[index2] : joined + "/" + arguments[index2];
        }
      }
      return joined === void 0 ? "." : normalize$6(joined);
    }
    function normalize$6(path2) {
      var absolute;
      var value;
      assertPath$1(path2);
      absolute = path2.charCodeAt(0) === 47;
      value = normalizeString(path2, !absolute);
      if (!value.length && !absolute) {
        value = ".";
      }
      if (value.length && path2.charCodeAt(path2.length - 1) === 47) {
        value += "/";
      }
      return absolute ? "/" + value : value;
    }
    function normalizeString(path2, allowAboveRoot) {
      var result = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var index2 = -1;
      var code2;
      var lastSlashIndex;
      while (++index2 <= path2.length) {
        if (index2 < path2.length) {
          code2 = path2.charCodeAt(index2);
        } else if (code2 === 47) {
          break;
        } else {
          code2 = 47;
        }
        if (code2 === 47) {
          if (lastSlash === index2 - 1 || dots === 1)
            ;
          else if (lastSlash !== index2 - 1 && dots === 2) {
            if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
              if (result.length > 2) {
                lastSlashIndex = result.lastIndexOf("/");
                if (lastSlashIndex !== result.length - 1) {
                  if (lastSlashIndex < 0) {
                    result = "";
                    lastSegmentLength = 0;
                  } else {
                    result = result.slice(0, lastSlashIndex);
                    lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
                  }
                  lastSlash = index2;
                  dots = 0;
                  continue;
                }
              } else if (result.length) {
                result = "";
                lastSegmentLength = 0;
                lastSlash = index2;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              result = result.length ? result + "/.." : "..";
              lastSegmentLength = 2;
            }
          } else {
            if (result.length) {
              result += "/" + path2.slice(lastSlash + 1, index2);
            } else {
              result = path2.slice(lastSlash + 1, index2);
            }
            lastSegmentLength = index2 - lastSlash - 1;
          }
          lastSlash = index2;
          dots = 0;
        } else if (code2 === 46 && dots > -1) {
          dots++;
        } else {
          dots = -1;
        }
      }
      return result;
    }
    function assertPath$1(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError(
          "Path must be a string. Received " + JSON.stringify(path2)
        );
      }
    }
    var minproc_browser = {};
    minproc_browser.cwd = cwd;
    function cwd() {
      return "/";
    }
    /*!
     * Determine if an object is a Buffer
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    var isBuffer$1 = function isBuffer2(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
    var p$2 = minpath_browser;
    var proc = minproc_browser;
    var buffer$1 = isBuffer$1;
    var core = VFile$1;
    var own$6 = {}.hasOwnProperty;
    var order = ["history", "path", "basename", "stem", "extname", "dirname"];
    VFile$1.prototype.toString = toString$3;
    Object.defineProperty(VFile$1.prototype, "path", { get: getPath, set: setPath });
    Object.defineProperty(VFile$1.prototype, "dirname", {
      get: getDirname,
      set: setDirname
    });
    Object.defineProperty(VFile$1.prototype, "basename", {
      get: getBasename,
      set: setBasename
    });
    Object.defineProperty(VFile$1.prototype, "extname", {
      get: getExtname,
      set: setExtname
    });
    Object.defineProperty(VFile$1.prototype, "stem", { get: getStem, set: setStem });
    function VFile$1(options) {
      var prop;
      var index2;
      if (!options) {
        options = {};
      } else if (typeof options === "string" || buffer$1(options)) {
        options = { contents: options };
      } else if ("message" in options && "messages" in options) {
        return options;
      }
      if (!(this instanceof VFile$1)) {
        return new VFile$1(options);
      }
      this.data = {};
      this.messages = [];
      this.history = [];
      this.cwd = proc.cwd();
      index2 = -1;
      while (++index2 < order.length) {
        prop = order[index2];
        if (own$6.call(options, prop)) {
          this[prop] = options[prop];
        }
      }
      for (prop in options) {
        if (order.indexOf(prop) < 0) {
          this[prop] = options[prop];
        }
      }
    }
    function getPath() {
      return this.history[this.history.length - 1];
    }
    function setPath(path2) {
      assertNonEmpty(path2, "path");
      if (this.path !== path2) {
        this.history.push(path2);
      }
    }
    function getDirname() {
      return typeof this.path === "string" ? p$2.dirname(this.path) : void 0;
    }
    function setDirname(dirname2) {
      assertPath(this.path, "dirname");
      this.path = p$2.join(dirname2 || "", this.basename);
    }
    function getBasename() {
      return typeof this.path === "string" ? p$2.basename(this.path) : void 0;
    }
    function setBasename(basename2) {
      assertNonEmpty(basename2, "basename");
      assertPart(basename2, "basename");
      this.path = p$2.join(this.dirname || "", basename2);
    }
    function getExtname() {
      return typeof this.path === "string" ? p$2.extname(this.path) : void 0;
    }
    function setExtname(extname2) {
      assertPart(extname2, "extname");
      assertPath(this.path, "extname");
      if (extname2) {
        if (extname2.charCodeAt(0) !== 46) {
          throw new Error("`extname` must start with `.`");
        }
        if (extname2.indexOf(".", 1) > -1) {
          throw new Error("`extname` cannot contain multiple dots");
        }
      }
      this.path = p$2.join(this.dirname, this.stem + (extname2 || ""));
    }
    function getStem() {
      return typeof this.path === "string" ? p$2.basename(this.path, this.extname) : void 0;
    }
    function setStem(stem) {
      assertNonEmpty(stem, "stem");
      assertPart(stem, "stem");
      this.path = p$2.join(this.dirname || "", stem + (this.extname || ""));
    }
    function toString$3(encoding) {
      return (this.contents || "").toString(encoding);
    }
    function assertPart(part, name) {
      if (part && part.indexOf(p$2.sep) > -1) {
        throw new Error(
          "`" + name + "` cannot be a path: did not expect `" + p$2.sep + "`"
        );
      }
    }
    function assertNonEmpty(part, name) {
      if (!part) {
        throw new Error("`" + name + "` cannot be empty");
      }
    }
    function assertPath(path2, name) {
      if (!path2) {
        throw new Error("Setting `" + name + "` requires `path` to be set too");
      }
    }
    var VMessage = vfileMessage;
    var VFile = core;
    var lib$3 = VFile;
    VFile.prototype.message = message;
    VFile.prototype.info = info$1;
    VFile.prototype.fail = fail;
    function message(reason, position2, origin) {
      var message2 = new VMessage(reason, position2, origin);
      if (this.path) {
        message2.name = this.path + ":" + message2.name;
        message2.file = this.path;
      }
      message2.fatal = false;
      this.messages.push(message2);
      return message2;
    }
    function fail() {
      var message2 = this.message.apply(this, arguments);
      message2.fatal = true;
      throw message2;
    }
    function info$1() {
      var message2 = this.message.apply(this, arguments);
      message2.fatal = null;
      return message2;
    }
    (function(module2) {
      module2.exports = lib$3;
    })(vfile$1);
    var bail_1 = bail$1;
    function bail$1(err) {
      if (err) {
        throw err;
      }
    }
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty$1 = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray$2 = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject$2 = function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty$1 && options.name === "__proto__") {
        defineProperty$1(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    var extend$3 = function extend2() {
      var options, name, src2, copy2, copyIsArray, clone;
      var target = arguments[0];
      var i2 = 1;
      var length2 = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i2 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i2 < length2; ++i2) {
        options = arguments[i2];
        if (options != null) {
          for (name in options) {
            src2 = getProperty(target, name);
            copy2 = getProperty(options, name);
            if (target !== copy2) {
              if (deep && copy2 && (isPlainObject$2(copy2) || (copyIsArray = isArray$2(copy2)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src2 && isArray$2(src2) ? src2 : [];
                } else {
                  clone = src2 && isPlainObject$2(src2) ? src2 : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone, copy2) });
              } else if (typeof copy2 !== "undefined") {
                setProperty(target, { name, newValue: copy2 });
              }
            }
          }
        }
      }
      return target;
    };
    var isPlainObj = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype2 = Object.getPrototypeOf(value);
      return prototype2 === null || prototype2 === Object.prototype;
    };
    var slice$2 = [].slice;
    var wrap_1$1 = wrap$7;
    function wrap$7(fn, callback) {
      var invoked;
      return wrapped;
      function wrapped() {
        var params = slice$2.call(arguments, 0);
        var callback2 = fn.length > params.length;
        var result;
        if (callback2) {
          params.push(done);
        }
        try {
          result = fn.apply(null, params);
        } catch (error) {
          if (callback2 && invoked) {
            throw error;
          }
          return done(error);
        }
        if (!callback2) {
          if (result && typeof result.then === "function") {
            result.then(then, done);
          } else if (result instanceof Error) {
            done(result);
          } else {
            then(result);
          }
        }
      }
      function done() {
        if (!invoked) {
          invoked = true;
          callback.apply(null, arguments);
        }
      }
      function then(value) {
        done(null, value);
      }
    }
    var wrap$6 = wrap_1$1;
    var trough_1 = trough$1;
    trough$1.wrap = wrap$6;
    var slice$1 = [].slice;
    function trough$1() {
      var fns = [];
      var middleware2 = {};
      middleware2.run = run;
      middleware2.use = use2;
      return middleware2;
      function run() {
        var index2 = -1;
        var input = slice$1.call(arguments, 0, -1);
        var done = arguments[arguments.length - 1];
        if (typeof done !== "function") {
          throw new Error("Expected function as last argument, not " + done);
        }
        next2.apply(null, [null].concat(input));
        function next2(err) {
          var fn = fns[++index2];
          var params = slice$1.call(arguments, 0);
          var values = params.slice(1);
          var length2 = input.length;
          var pos = -1;
          if (err) {
            done(err);
            return;
          }
          while (++pos < length2) {
            if (values[pos] === null || values[pos] === void 0) {
              values[pos] = input[pos];
            }
          }
          input = values;
          if (fn) {
            wrap$6(fn, next2).apply(null, input);
          } else {
            done.apply(null, [null].concat(input));
          }
        }
      }
      function use2(fn) {
        if (typeof fn !== "function") {
          throw new Error("Expected `fn` to be a function, not " + fn);
        }
        fns.push(fn);
        return middleware2;
      }
    }
    var bail = bail_1;
    var buffer = isBuffer$1;
    var extend$2 = extend$3;
    var plain = isPlainObj;
    var trough = trough_1;
    var vfile = vfileExports;
    unified().freeze();
    var slice = [].slice;
    var own$5 = {}.hasOwnProperty;
    var pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);
    function pipelineParse(p2, ctx) {
      ctx.tree = p2.parse(ctx.file);
    }
    function pipelineRun(p2, ctx, next2) {
      p2.run(ctx.tree, ctx.file, done);
      function done(error, tree, file) {
        if (error) {
          next2(error);
        } else {
          ctx.tree = tree;
          ctx.file = file;
          next2();
        }
      }
    }
    function pipelineStringify(p2, ctx) {
      var result = p2.stringify(ctx.tree, ctx.file);
      if (result === void 0 || result === null)
        ;
      else if (typeof result === "string" || buffer(result)) {
        if ("value" in ctx.file) {
          ctx.file.value = result;
        }
        ctx.file.contents = result;
      } else {
        ctx.file.result = result;
      }
    }
    function unified() {
      var attachers = [];
      var transformers = trough();
      var namespace = {};
      var freezeIndex = -1;
      var frozen;
      processor.data = data2;
      processor.freeze = freeze;
      processor.attachers = attachers;
      processor.use = use2;
      processor.parse = parse2;
      processor.stringify = stringify2;
      processor.run = run;
      processor.runSync = runSync;
      processor.process = process2;
      processor.processSync = processSync;
      return processor;
      function processor() {
        var destination = unified();
        var index2 = -1;
        while (++index2 < attachers.length) {
          destination.use.apply(null, attachers[index2]);
        }
        destination.data(extend$2(true, {}, namespace));
        return destination;
      }
      function freeze() {
        var values;
        var transformer;
        if (frozen) {
          return processor;
        }
        while (++freezeIndex < attachers.length) {
          values = attachers[freezeIndex];
          if (values[1] === false) {
            continue;
          }
          if (values[1] === true) {
            values[1] = void 0;
          }
          transformer = values[0].apply(processor, values.slice(1));
          if (typeof transformer === "function") {
            transformers.use(transformer);
          }
        }
        frozen = true;
        freezeIndex = Infinity;
        return processor;
      }
      function data2(key, value) {
        if (typeof key === "string") {
          if (arguments.length === 2) {
            assertUnfrozen("data", frozen);
            namespace[key] = value;
            return processor;
          }
          return own$5.call(namespace, key) && namespace[key] || null;
        }
        if (key) {
          assertUnfrozen("data", frozen);
          namespace = key;
          return processor;
        }
        return namespace;
      }
      function use2(value) {
        var settings;
        assertUnfrozen("use", frozen);
        if (value === null || value === void 0)
          ;
        else if (typeof value === "function") {
          addPlugin.apply(null, arguments);
        } else if (typeof value === "object") {
          if ("length" in value) {
            addList(value);
          } else {
            addPreset(value);
          }
        } else {
          throw new Error("Expected usable value, not `" + value + "`");
        }
        if (settings) {
          namespace.settings = extend$2(namespace.settings || {}, settings);
        }
        return processor;
        function addPreset(result) {
          addList(result.plugins);
          if (result.settings) {
            settings = extend$2(settings || {}, result.settings);
          }
        }
        function add2(value2) {
          if (typeof value2 === "function") {
            addPlugin(value2);
          } else if (typeof value2 === "object") {
            if ("length" in value2) {
              addPlugin.apply(null, value2);
            } else {
              addPreset(value2);
            }
          } else {
            throw new Error("Expected usable value, not `" + value2 + "`");
          }
        }
        function addList(plugins) {
          var index2 = -1;
          if (plugins === null || plugins === void 0)
            ;
          else if (typeof plugins === "object" && "length" in plugins) {
            while (++index2 < plugins.length) {
              add2(plugins[index2]);
            }
          } else {
            throw new Error("Expected a list of plugins, not `" + plugins + "`");
          }
        }
        function addPlugin(plugin, value2) {
          var entry = find(plugin);
          if (entry) {
            if (plain(entry[1]) && plain(value2)) {
              value2 = extend$2(true, entry[1], value2);
            }
            entry[1] = value2;
          } else {
            attachers.push(slice.call(arguments));
          }
        }
      }
      function find(plugin) {
        var index2 = -1;
        while (++index2 < attachers.length) {
          if (attachers[index2][0] === plugin) {
            return attachers[index2];
          }
        }
      }
      function parse2(doc) {
        var file = vfile(doc);
        var Parser;
        freeze();
        Parser = processor.Parser;
        assertParser("parse", Parser);
        if (newable(Parser, "parse")) {
          return new Parser(String(file), file).parse();
        }
        return Parser(String(file), file);
      }
      function run(node2, file, cb2) {
        assertNode(node2);
        freeze();
        if (!cb2 && typeof file === "function") {
          cb2 = file;
          file = null;
        }
        if (!cb2) {
          return new Promise(executor);
        }
        executor(null, cb2);
        function executor(resolve, reject) {
          transformers.run(node2, vfile(file), done);
          function done(error, tree, file2) {
            tree = tree || node2;
            if (error) {
              reject(error);
            } else if (resolve) {
              resolve(tree);
            } else {
              cb2(null, tree, file2);
            }
          }
        }
      }
      function runSync(node2, file) {
        var result;
        var complete;
        run(node2, file, done);
        assertDone("runSync", "run", complete);
        return result;
        function done(error, tree) {
          complete = true;
          result = tree;
          bail(error);
        }
      }
      function stringify2(node2, doc) {
        var file = vfile(doc);
        var Compiler;
        freeze();
        Compiler = processor.Compiler;
        assertCompiler("stringify", Compiler);
        assertNode(node2);
        if (newable(Compiler, "compile")) {
          return new Compiler(node2, file).compile();
        }
        return Compiler(node2, file);
      }
      function process2(doc, cb2) {
        freeze();
        assertParser("process", processor.Parser);
        assertCompiler("process", processor.Compiler);
        if (!cb2) {
          return new Promise(executor);
        }
        executor(null, cb2);
        function executor(resolve, reject) {
          var file = vfile(doc);
          pipeline.run(processor, { file }, done);
          function done(error) {
            if (error) {
              reject(error);
            } else if (resolve) {
              resolve(file);
            } else {
              cb2(null, file);
            }
          }
        }
      }
      function processSync(doc) {
        var file;
        var complete;
        freeze();
        assertParser("processSync", processor.Parser);
        assertCompiler("processSync", processor.Compiler);
        file = vfile(doc);
        process2(file, done);
        assertDone("processSync", "process", complete);
        return file;
        function done(error) {
          complete = true;
          bail(error);
        }
      }
    }
    function newable(value, name) {
      return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
      // Classes’ prototype methods are not enumerable, so we check if some value
      // exists in the prototype.
      (keys(value.prototype) || name in value.prototype);
    }
    function keys(value) {
      var key;
      for (key in value) {
        return true;
      }
      return false;
    }
    function assertParser(name, Parser) {
      if (typeof Parser !== "function") {
        throw new Error("Cannot `" + name + "` without `Parser`");
      }
    }
    function assertCompiler(name, Compiler) {
      if (typeof Compiler !== "function") {
        throw new Error("Cannot `" + name + "` without `Compiler`");
      }
    }
    function assertUnfrozen(name, frozen) {
      if (frozen) {
        throw new Error(
          "Cannot invoke `" + name + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`."
        );
      }
    }
    function assertNode(node2) {
      if (!node2 || typeof node2.type !== "string") {
        throw new Error("Expected node, got `" + node2 + "`");
      }
    }
    function assertDone(name, asyncName, complete) {
      if (!complete) {
        throw new Error(
          "`" + name + "` finished async. Use `" + asyncName + "` instead"
        );
      }
    }
    var mdastUtilFromMarkdownExports = {};
    var mdastUtilFromMarkdown = {
      get exports() {
        return mdastUtilFromMarkdownExports;
      },
      set exports(v2) {
        mdastUtilFromMarkdownExports = v2;
      }
    };
    var mdastUtilToString = toString$2;
    function toString$2(node2) {
      return node2 && (node2.value || node2.alt || node2.title || "children" in node2 && all$d(node2.children) || "length" in node2 && all$d(node2)) || "";
    }
    function all$d(values) {
      var result = [];
      var index2 = -1;
      while (++index2 < values.length) {
        result[index2] = toString$2(values[index2]);
      }
      return result.join("");
    }
    var assign$5 = Object.assign;
    var assign_1 = assign$5;
    var own$4 = {}.hasOwnProperty;
    var hasOwnProperty$5 = own$4;
    function normalizeIdentifier$3(value) {
      return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
    }
    var normalizeIdentifier_1 = normalizeIdentifier$3;
    var fromCharCode$4 = String.fromCharCode;
    var fromCharCode_1 = fromCharCode$4;
    var fromCharCode$3 = fromCharCode_1;
    function safeFromInt$1(value, base) {
      var code2 = parseInt(value, base);
      if (
        // C0 except for HT, LF, FF, CR, space
        code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of the basic block and C1 controls.
        code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
        code2 > 55295 && code2 < 57344 || // Noncharacters.
        code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || // Out of range
        code2 > 1114111
      ) {
        return "�";
      }
      return fromCharCode$3(code2);
    }
    var safeFromInt_1 = safeFromInt$1;
    var content$3 = {};
    function markdownLineEnding$k(code2) {
      return code2 < -2;
    }
    var markdownLineEnding_1 = markdownLineEnding$k;
    function markdownSpace$9(code2) {
      return code2 === -2 || code2 === -1 || code2 === 32;
    }
    var markdownSpace_1 = markdownSpace$9;
    var markdownSpace$8 = markdownSpace_1;
    function spaceFactory$1(effects, ok2, type2, max) {
      var limit = max ? max - 1 : Infinity;
      var size = 0;
      return start2;
      function start2(code2) {
        if (markdownSpace$8(code2)) {
          effects.enter(type2);
          return prefix(code2);
        }
        return ok2(code2);
      }
      function prefix(code2) {
        if (markdownSpace$8(code2) && size++ < limit) {
          effects.consume(code2);
          return prefix;
        }
        effects.exit(type2);
        return ok2(code2);
      }
    }
    var factorySpace$h = spaceFactory$1;
    Object.defineProperty(content$3, "__esModule", { value: true });
    var markdownLineEnding$j = markdownLineEnding_1;
    var factorySpace$g = factorySpace$h;
    var tokenize$2 = initializeContent;
    function initializeContent(effects) {
      var contentStart = effects.attempt(
        this.parser.constructs.contentInitial,
        afterContentStartConstruct,
        paragraphInitial
      );
      var previous2;
      return contentStart;
      function afterContentStartConstruct(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace$g(effects, contentStart, "linePrefix");
      }
      function paragraphInitial(code2) {
        effects.enter("paragraph");
        return lineStart(code2);
      }
      function lineStart(code2) {
        var token2 = effects.enter("chunkText", {
          contentType: "text",
          previous: previous2
        });
        if (previous2) {
          previous2.next = token2;
        }
        previous2 = token2;
        return data2(code2);
      }
      function data2(code2) {
        if (code2 === null) {
          effects.exit("chunkText");
          effects.exit("paragraph");
          effects.consume(code2);
          return;
        }
        if (markdownLineEnding$j(code2)) {
          effects.consume(code2);
          effects.exit("chunkText");
          return lineStart;
        }
        effects.consume(code2);
        return data2;
      }
    }
    content$3.tokenize = tokenize$2;
    var document$3 = {};
    var markdownLineEnding$i = markdownLineEnding_1;
    var factorySpace$f = factorySpace$h;
    var partialBlankLine$4 = {
      tokenize: tokenizePartialBlankLine,
      partial: true
    };
    function tokenizePartialBlankLine(effects, ok2, nok) {
      return factorySpace$f(effects, afterWhitespace, "linePrefix");
      function afterWhitespace(code2) {
        return code2 === null || markdownLineEnding$i(code2) ? ok2(code2) : nok(code2);
      }
    }
    var partialBlankLine_1 = partialBlankLine$4;
    Object.defineProperty(document$3, "__esModule", { value: true });
    var markdownLineEnding$h = markdownLineEnding_1;
    var factorySpace$e = factorySpace$h;
    var partialBlankLine$3 = partialBlankLine_1;
    var tokenize$1 = initializeDocument;
    var containerConstruct = {
      tokenize: tokenizeContainer
    };
    var lazyFlowConstruct = {
      tokenize: tokenizeLazyFlow
    };
    function initializeDocument(effects) {
      var self2 = this;
      var stack = [];
      var continued = 0;
      var inspectConstruct = {
        tokenize: tokenizeInspect,
        partial: true
      };
      var inspectResult;
      var childFlow;
      var childToken;
      return start2;
      function start2(code2) {
        if (continued < stack.length) {
          self2.containerState = stack[continued][1];
          return effects.attempt(
            stack[continued][0].continuation,
            documentContinue,
            documentContinued
          )(code2);
        }
        return documentContinued(code2);
      }
      function documentContinue(code2) {
        continued++;
        return start2(code2);
      }
      function documentContinued(code2) {
        if (inspectResult && inspectResult.flowContinue) {
          return flowStart(code2);
        }
        self2.interrupt = childFlow && childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
        self2.containerState = {};
        return effects.attempt(
          containerConstruct,
          containerContinue,
          flowStart
        )(code2);
      }
      function containerContinue(code2) {
        stack.push([self2.currentConstruct, self2.containerState]);
        self2.containerState = void 0;
        return documentContinued(code2);
      }
      function flowStart(code2) {
        if (code2 === null) {
          exitContainers(0, true);
          effects.consume(code2);
          return;
        }
        childFlow = childFlow || self2.parser.flow(self2.now());
        effects.enter("chunkFlow", {
          contentType: "flow",
          previous: childToken,
          _tokenizer: childFlow
        });
        return flowContinue(code2);
      }
      function flowContinue(code2) {
        if (code2 === null) {
          continueFlow(effects.exit("chunkFlow"));
          return flowStart(code2);
        }
        if (markdownLineEnding$h(code2)) {
          effects.consume(code2);
          continueFlow(effects.exit("chunkFlow"));
          return effects.check(inspectConstruct, documentAfterPeek);
        }
        effects.consume(code2);
        return flowContinue;
      }
      function documentAfterPeek(code2) {
        exitContainers(
          inspectResult.continued,
          inspectResult && inspectResult.flowEnd
        );
        continued = 0;
        return start2(code2);
      }
      function continueFlow(token2) {
        if (childToken)
          childToken.next = token2;
        childToken = token2;
        childFlow.lazy = inspectResult && inspectResult.lazy;
        childFlow.defineSkip(token2.start);
        childFlow.write(self2.sliceStream(token2));
      }
      function exitContainers(size, end2) {
        var index2 = stack.length;
        if (childFlow && end2) {
          childFlow.write([null]);
          childToken = childFlow = void 0;
        }
        while (index2-- > size) {
          self2.containerState = stack[index2][1];
          stack[index2][0].exit.call(self2, effects);
        }
        stack.length = size;
      }
      function tokenizeInspect(effects2, ok2) {
        var subcontinued = 0;
        inspectResult = {};
        return inspectStart;
        function inspectStart(code2) {
          if (subcontinued < stack.length) {
            self2.containerState = stack[subcontinued][1];
            return effects2.attempt(
              stack[subcontinued][0].continuation,
              inspectContinue,
              inspectLess
            )(code2);
          }
          if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
            inspectResult.flowContinue = true;
            return inspectDone(code2);
          }
          self2.interrupt = childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
          self2.containerState = {};
          return effects2.attempt(
            containerConstruct,
            inspectFlowEnd,
            inspectDone
          )(code2);
        }
        function inspectContinue(code2) {
          subcontinued++;
          return self2.containerState._closeFlow ? inspectFlowEnd(code2) : inspectStart(code2);
        }
        function inspectLess(code2) {
          if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {
            self2.containerState = {};
            return effects2.attempt(
              containerConstruct,
              inspectFlowEnd,
              // Maybe flow, or a blank line?
              effects2.attempt(
                lazyFlowConstruct,
                inspectFlowEnd,
                effects2.check(partialBlankLine$3, inspectFlowEnd, inspectLazy)
              )
            )(code2);
          }
          return inspectFlowEnd(code2);
        }
        function inspectLazy(code2) {
          subcontinued = stack.length;
          inspectResult.lazy = true;
          inspectResult.flowContinue = true;
          return inspectDone(code2);
        }
        function inspectFlowEnd(code2) {
          inspectResult.flowEnd = true;
          return inspectDone(code2);
        }
        function inspectDone(code2) {
          inspectResult.continued = subcontinued;
          self2.interrupt = self2.containerState = void 0;
          return ok2(code2);
        }
      }
    }
    function tokenizeContainer(effects, ok2, nok) {
      return factorySpace$e(
        effects,
        effects.attempt(this.parser.constructs.document, ok2, nok),
        "linePrefix",
        this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
      );
    }
    function tokenizeLazyFlow(effects, ok2, nok) {
      return factorySpace$e(
        effects,
        effects.lazy(this.parser.constructs.flow, ok2, nok),
        "linePrefix",
        this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
      );
    }
    document$3.tokenize = tokenize$1;
    var flow$2 = {};
    function sizeChunks$2(chunks) {
      var index2 = -1;
      var size = 0;
      while (++index2 < chunks.length) {
        size += typeof chunks[index2] === "string" ? chunks[index2].length : 1;
      }
      return size;
    }
    var sizeChunks_1 = sizeChunks$2;
    var sizeChunks$1 = sizeChunks_1;
    function prefixSize$5(events, type2) {
      var tail = events[events.length - 1];
      if (!tail || tail[1].type !== type2)
        return 0;
      return sizeChunks$1(tail[2].sliceStream(tail[1]));
    }
    var prefixSize_1 = prefixSize$5;
    var splice$2 = [].splice;
    var splice_1 = splice$2;
    var splice$1 = splice_1;
    function chunkedSplice$9(list2, start2, remove, items) {
      var end2 = list2.length;
      var chunkStart = 0;
      var parameters;
      if (start2 < 0) {
        start2 = -start2 > end2 ? 0 : end2 + start2;
      } else {
        start2 = start2 > end2 ? end2 : start2;
      }
      remove = remove > 0 ? remove : 0;
      if (items.length < 1e4) {
        parameters = Array.from(items);
        parameters.unshift(start2, remove);
        splice$1.apply(list2, parameters);
      } else {
        if (remove)
          splice$1.apply(list2, [start2, remove]);
        while (chunkStart < items.length) {
          parameters = items.slice(chunkStart, chunkStart + 1e4);
          parameters.unshift(start2, 0);
          splice$1.apply(list2, parameters);
          chunkStart += 1e4;
          start2 += 1e4;
        }
      }
    }
    var chunkedSplice_1 = chunkedSplice$9;
    var assign$4 = assign_1;
    function shallow$7(object2) {
      return assign$4({}, object2);
    }
    var shallow_1 = shallow$7;
    var assign$3 = assign_1;
    var chunkedSplice$8 = chunkedSplice_1;
    var shallow$6 = shallow_1;
    function subtokenize$2(events) {
      var jumps = {};
      var index2 = -1;
      var event;
      var lineIndex;
      var otherIndex;
      var otherEvent;
      var parameters;
      var subevents;
      var more;
      while (++index2 < events.length) {
        while (index2 in jumps) {
          index2 = jumps[index2];
        }
        event = events[index2];
        if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
          subevents = event[1]._tokenizer.events;
          otherIndex = 0;
          if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
            otherIndex += 2;
          }
          if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
            while (++otherIndex < subevents.length) {
              if (subevents[otherIndex][1].type === "content") {
                break;
              }
              if (subevents[otherIndex][1].type === "chunkText") {
                subevents[otherIndex][1].isInFirstContentOfListItem = true;
                otherIndex++;
              }
            }
          }
        }
        if (event[0] === "enter") {
          if (event[1].contentType) {
            assign$3(jumps, subcontent(events, index2));
            index2 = jumps[index2];
            more = true;
          }
        } else if (event[1]._container || event[1]._movePreviousLineEndings) {
          otherIndex = index2;
          lineIndex = void 0;
          while (otherIndex--) {
            otherEvent = events[otherIndex];
            if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
              if (otherEvent[0] === "enter") {
                if (lineIndex) {
                  events[lineIndex][1].type = "lineEndingBlank";
                }
                otherEvent[1].type = "lineEnding";
                lineIndex = otherIndex;
              }
            } else {
              break;
            }
          }
          if (lineIndex) {
            event[1].end = shallow$6(events[lineIndex][1].start);
            parameters = events.slice(lineIndex, index2);
            parameters.unshift(event);
            chunkedSplice$8(events, lineIndex, index2 - lineIndex + 1, parameters);
          }
        }
      }
      return !more;
    }
    function subcontent(events, eventIndex) {
      var token2 = events[eventIndex][1];
      var context = events[eventIndex][2];
      var startPosition = eventIndex - 1;
      var startPositions = [];
      var tokenizer = token2._tokenizer || context.parser[token2.contentType](token2.start);
      var childEvents = tokenizer.events;
      var jumps = [];
      var gaps = {};
      var stream;
      var previous2;
      var index2;
      var entered;
      var end2;
      var adjust;
      while (token2) {
        while (events[++startPosition][1] !== token2) {
        }
        startPositions.push(startPosition);
        if (!token2._tokenizer) {
          stream = context.sliceStream(token2);
          if (!token2.next) {
            stream.push(null);
          }
          if (previous2) {
            tokenizer.defineSkip(token2.start);
          }
          if (token2.isInFirstContentOfListItem) {
            tokenizer._gfmTasklistFirstContentOfListItem = true;
          }
          tokenizer.write(stream);
          if (token2.isInFirstContentOfListItem) {
            tokenizer._gfmTasklistFirstContentOfListItem = void 0;
          }
        }
        previous2 = token2;
        token2 = token2.next;
      }
      token2 = previous2;
      index2 = childEvents.length;
      while (index2--) {
        if (childEvents[index2][0] === "enter") {
          entered = true;
        } else if (
          // Find a void token that includes a break.
          entered && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
        ) {
          add2(childEvents.slice(index2 + 1, end2));
          token2._tokenizer = token2.next = void 0;
          token2 = token2.previous;
          end2 = index2 + 1;
        }
      }
      tokenizer.events = token2._tokenizer = token2.next = void 0;
      add2(childEvents.slice(0, end2));
      index2 = -1;
      adjust = 0;
      while (++index2 < jumps.length) {
        gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
        adjust += jumps[index2][1] - jumps[index2][0] - 1;
      }
      return gaps;
      function add2(slice2) {
        var start2 = startPositions.pop();
        jumps.unshift([start2, start2 + slice2.length - 1]);
        chunkedSplice$8(events, start2, 2, slice2);
      }
    }
    var subtokenize_1 = subtokenize$2;
    var markdownLineEnding$g = markdownLineEnding_1;
    var prefixSize$4 = prefixSize_1;
    var subtokenize$1 = subtokenize_1;
    var factorySpace$d = factorySpace$h;
    var content$2 = {
      tokenize: tokenizeContent,
      resolve: resolveContent,
      interruptible: true,
      lazy: true
    };
    var continuationConstruct = {
      tokenize: tokenizeContinuation,
      partial: true
    };
    function resolveContent(events) {
      subtokenize$1(events);
      return events;
    }
    function tokenizeContent(effects, ok2) {
      var previous2;
      return start2;
      function start2(code2) {
        effects.enter("content");
        previous2 = effects.enter("chunkContent", {
          contentType: "content"
        });
        return data2(code2);
      }
      function data2(code2) {
        if (code2 === null) {
          return contentEnd(code2);
        }
        if (markdownLineEnding$g(code2)) {
          return effects.check(
            continuationConstruct,
            contentContinue,
            contentEnd
          )(code2);
        }
        effects.consume(code2);
        return data2;
      }
      function contentEnd(code2) {
        effects.exit("chunkContent");
        effects.exit("content");
        return ok2(code2);
      }
      function contentContinue(code2) {
        effects.consume(code2);
        effects.exit("chunkContent");
        previous2 = previous2.next = effects.enter("chunkContent", {
          contentType: "content",
          previous: previous2
        });
        return data2;
      }
    }
    function tokenizeContinuation(effects, ok2, nok) {
      var self2 = this;
      return startLookahead;
      function startLookahead(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace$d(effects, prefixed, "linePrefix");
      }
      function prefixed(code2) {
        if (code2 === null || markdownLineEnding$g(code2)) {
          return nok(code2);
        }
        if (self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 || prefixSize$4(self2.events, "linePrefix") < 4) {
          return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
        }
        return ok2(code2);
      }
    }
    var content_1 = content$2;
    Object.defineProperty(flow$2, "__esModule", { value: true });
    var content$1 = content_1;
    var factorySpace$c = factorySpace$h;
    var partialBlankLine$2 = partialBlankLine_1;
    var tokenize = initializeFlow;
    function initializeFlow(effects) {
      var self2 = this;
      var initial = effects.attempt(
        // Try to parse a blank line.
        partialBlankLine$2,
        atBlankEnding,
        // Try to parse initial flow (essentially, only code).
        effects.attempt(
          this.parser.constructs.flowInitial,
          afterConstruct,
          factorySpace$c(
            effects,
            effects.attempt(
              this.parser.constructs.flow,
              afterConstruct,
              effects.attempt(content$1, afterConstruct)
            ),
            "linePrefix"
          )
        )
      );
      return initial;
      function atBlankEnding(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("lineEndingBlank");
        effects.consume(code2);
        effects.exit("lineEndingBlank");
        self2.currentConstruct = void 0;
        return initial;
      }
      function afterConstruct(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        self2.currentConstruct = void 0;
        return initial;
      }
    }
    flow$2.tokenize = tokenize;
    var text$5 = {};
    Object.defineProperty(text$5, "__esModule", { value: true });
    var assign$2 = assign_1;
    var shallow$5 = shallow_1;
    var text$4 = initializeFactory("text");
    var string$1 = initializeFactory("string");
    var resolver = {
      resolveAll: createResolver()
    };
    function initializeFactory(field) {
      return {
        tokenize: initializeText,
        resolveAll: createResolver(
          field === "text" ? resolveAllLineSuffixes : void 0
        )
      };
      function initializeText(effects) {
        var self2 = this;
        var constructs2 = this.parser.constructs[field];
        var text2 = effects.attempt(constructs2, start2, notText);
        return start2;
        function start2(code2) {
          return atBreak(code2) ? text2(code2) : notText(code2);
        }
        function notText(code2) {
          if (code2 === null) {
            effects.consume(code2);
            return;
          }
          effects.enter("data");
          effects.consume(code2);
          return data2;
        }
        function data2(code2) {
          if (atBreak(code2)) {
            effects.exit("data");
            return text2(code2);
          }
          effects.consume(code2);
          return data2;
        }
        function atBreak(code2) {
          var list2 = constructs2[code2];
          var index2 = -1;
          if (code2 === null) {
            return true;
          }
          if (list2) {
            while (++index2 < list2.length) {
              if (!list2[index2].previous || list2[index2].previous.call(self2, self2.previous)) {
                return true;
              }
            }
          }
        }
      }
    }
    function createResolver(extraResolver) {
      return resolveAllText;
      function resolveAllText(events, context) {
        var index2 = -1;
        var enter;
        while (++index2 <= events.length) {
          if (enter === void 0) {
            if (events[index2] && events[index2][1].type === "data") {
              enter = index2;
              index2++;
            }
          } else if (!events[index2] || events[index2][1].type !== "data") {
            if (index2 !== enter + 2) {
              events[enter][1].end = events[index2 - 1][1].end;
              events.splice(enter + 2, index2 - enter - 2);
              index2 = enter + 2;
            }
            enter = void 0;
          }
        }
        return extraResolver ? extraResolver(events, context) : events;
      }
    }
    function resolveAllLineSuffixes(events, context) {
      var eventIndex = -1;
      var chunks;
      var data2;
      var chunk;
      var index2;
      var bufferIndex;
      var size;
      var tabs;
      var token2;
      while (++eventIndex <= events.length) {
        if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
          data2 = events[eventIndex - 1][1];
          chunks = context.sliceStream(data2);
          index2 = chunks.length;
          bufferIndex = -1;
          size = 0;
          tabs = void 0;
          while (index2--) {
            chunk = chunks[index2];
            if (typeof chunk === "string") {
              bufferIndex = chunk.length;
              while (chunk.charCodeAt(bufferIndex - 1) === 32) {
                size++;
                bufferIndex--;
              }
              if (bufferIndex)
                break;
              bufferIndex = -1;
            } else if (chunk === -2) {
              tabs = true;
              size++;
            } else if (chunk === -1)
              ;
            else {
              index2++;
              break;
            }
          }
          if (size) {
            token2 = {
              type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
              start: {
                line: data2.end.line,
                column: data2.end.column - size,
                offset: data2.end.offset - size,
                _index: data2.start._index + index2,
                _bufferIndex: index2 ? bufferIndex : data2.start._bufferIndex + bufferIndex
              },
              end: shallow$5(data2.end)
            };
            data2.end = shallow$5(token2.start);
            if (data2.start.offset === data2.end.offset) {
              assign$2(data2, token2);
            } else {
              events.splice(
                eventIndex,
                0,
                ["enter", token2, context],
                ["exit", token2, context]
              );
              eventIndex += 2;
            }
          }
          eventIndex++;
        }
      }
      return events;
    }
    text$5.resolver = resolver;
    text$5.string = string$1;
    text$5.text = text$4;
    function miniflat$3(value) {
      return value === null || value === void 0 ? [] : "length" in value ? value : [value];
    }
    var miniflat_1 = miniflat$3;
    var hasOwnProperty$4 = hasOwnProperty$5;
    var chunkedSplice$7 = chunkedSplice_1;
    var miniflat$2 = miniflat_1;
    function combineExtensions$1(extensions) {
      var all2 = {};
      var index2 = -1;
      while (++index2 < extensions.length) {
        extension$2(all2, extensions[index2]);
      }
      return all2;
    }
    function extension$2(all2, extension2) {
      var hook;
      var left;
      var right;
      var code2;
      for (hook in extension2) {
        left = hasOwnProperty$4.call(all2, hook) ? all2[hook] : all2[hook] = {};
        right = extension2[hook];
        for (code2 in right) {
          left[code2] = constructs$2(
            miniflat$2(right[code2]),
            hasOwnProperty$4.call(left, code2) ? left[code2] : []
          );
        }
      }
    }
    function constructs$2(list2, existing) {
      var index2 = -1;
      var before = [];
      while (++index2 < list2.length) {
        (list2[index2].add === "after" ? existing : before).push(list2[index2]);
      }
      chunkedSplice$7(existing, 0, 0, before);
      return existing;
    }
    var combineExtensions_1 = combineExtensions$1;
    var chunkedSplice$6 = chunkedSplice_1;
    function chunkedPush$3(list2, items) {
      if (list2.length) {
        chunkedSplice$6(list2, list2.length, 0, items);
        return list2;
      }
      return items;
    }
    var chunkedPush_1 = chunkedPush$3;
    function resolveAll$4(constructs2, events, context) {
      var called = [];
      var index2 = -1;
      var resolve;
      while (++index2 < constructs2.length) {
        resolve = constructs2[index2].resolveAll;
        if (resolve && called.indexOf(resolve) < 0) {
          events = resolve(events, context);
          called.push(resolve);
        }
      }
      return events;
    }
    var resolveAll_1 = resolveAll$4;
    var fromCharCode$2 = fromCharCode_1;
    function serializeChunks$1(chunks) {
      var index2 = -1;
      var result = [];
      var chunk;
      var value;
      var atTab;
      while (++index2 < chunks.length) {
        chunk = chunks[index2];
        if (typeof chunk === "string") {
          value = chunk;
        } else if (chunk === -5) {
          value = "\r";
        } else if (chunk === -4) {
          value = "\n";
        } else if (chunk === -3) {
          value = "\r\n";
        } else if (chunk === -2) {
          value = "	";
        } else if (chunk === -1) {
          if (atTab)
            continue;
          value = " ";
        } else {
          value = fromCharCode$2(chunk);
        }
        atTab = chunk === -2;
        result.push(value);
      }
      return result.join("");
    }
    var serializeChunks_1 = serializeChunks$1;
    function sliceChunks$1(chunks, token2) {
      var startIndex = token2.start._index;
      var startBufferIndex = token2.start._bufferIndex;
      var endIndex = token2.end._index;
      var endBufferIndex = token2.end._bufferIndex;
      var view;
      if (startIndex === endIndex) {
        view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
      } else {
        view = chunks.slice(startIndex, endIndex);
        if (startBufferIndex > -1) {
          view[0] = view[0].slice(startBufferIndex);
        }
        if (endBufferIndex > 0) {
          view.push(chunks[endIndex].slice(0, endBufferIndex));
        }
      }
      return view;
    }
    var sliceChunks_1 = sliceChunks$1;
    var assign$1 = assign_1;
    var markdownLineEnding$f = markdownLineEnding_1;
    var chunkedPush$2 = chunkedPush_1;
    var chunkedSplice$5 = chunkedSplice_1;
    var miniflat$1 = miniflat_1;
    var resolveAll$3 = resolveAll_1;
    var serializeChunks = serializeChunks_1;
    var shallow$4 = shallow_1;
    var sliceChunks = sliceChunks_1;
    function createTokenizer$1(parser2, initialize, from2) {
      var point2 = from2 ? shallow$4(from2) : {
        line: 1,
        column: 1,
        offset: 0
      };
      var columnStart = {};
      var resolveAllConstructs = [];
      var chunks = [];
      var stack = [];
      var effects = {
        consume,
        enter,
        exit: exit2,
        attempt: constructFactory(onsuccessfulconstruct),
        check: constructFactory(onsuccessfulcheck),
        interrupt: constructFactory(onsuccessfulcheck, {
          interrupt: true
        }),
        lazy: constructFactory(onsuccessfulcheck, {
          lazy: true
        })
      };
      var context = {
        previous: null,
        events: [],
        parser: parser2,
        sliceStream,
        sliceSerialize,
        now: now2,
        defineSkip: skip,
        write
      };
      var state = initialize.tokenize.call(context, effects);
      if (initialize.resolveAll) {
        resolveAllConstructs.push(initialize);
      }
      point2._index = 0;
      point2._bufferIndex = -1;
      return context;
      function write(slice2) {
        chunks = chunkedPush$2(chunks, slice2);
        main();
        if (chunks[chunks.length - 1] !== null) {
          return [];
        }
        addResult(initialize, 0);
        context.events = resolveAll$3(resolveAllConstructs, context.events, context);
        return context.events;
      }
      function sliceSerialize(token2) {
        return serializeChunks(sliceStream(token2));
      }
      function sliceStream(token2) {
        return sliceChunks(chunks, token2);
      }
      function now2() {
        return shallow$4(point2);
      }
      function skip(value) {
        columnStart[value.line] = value.column;
        accountForPotentialSkip();
      }
      function main() {
        var chunkIndex;
        var chunk;
        while (point2._index < chunks.length) {
          chunk = chunks[point2._index];
          if (typeof chunk === "string") {
            chunkIndex = point2._index;
            if (point2._bufferIndex < 0) {
              point2._bufferIndex = 0;
            }
            while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
              go(chunk.charCodeAt(point2._bufferIndex));
            }
          } else {
            go(chunk);
          }
        }
      }
      function go(code2) {
        state = state(code2);
      }
      function consume(code2) {
        if (markdownLineEnding$f(code2)) {
          point2.line++;
          point2.column = 1;
          point2.offset += code2 === -3 ? 2 : 1;
          accountForPotentialSkip();
        } else if (code2 !== -1) {
          point2.column++;
          point2.offset++;
        }
        if (point2._bufferIndex < 0) {
          point2._index++;
        } else {
          point2._bufferIndex++;
          if (point2._bufferIndex === chunks[point2._index].length) {
            point2._bufferIndex = -1;
            point2._index++;
          }
        }
        context.previous = code2;
      }
      function enter(type2, fields) {
        var token2 = fields || {};
        token2.type = type2;
        token2.start = now2();
        context.events.push(["enter", token2, context]);
        stack.push(token2);
        return token2;
      }
      function exit2(type2) {
        var token2 = stack.pop();
        token2.end = now2();
        context.events.push(["exit", token2, context]);
        return token2;
      }
      function onsuccessfulconstruct(construct, info2) {
        addResult(construct, info2.from);
      }
      function onsuccessfulcheck(construct, info2) {
        info2.restore();
      }
      function constructFactory(onreturn, fields) {
        return hook;
        function hook(constructs2, returnState, bogusState) {
          var listOfConstructs;
          var constructIndex;
          var currentConstruct;
          var info2;
          return constructs2.tokenize || "length" in constructs2 ? handleListOfConstructs(miniflat$1(constructs2)) : handleMapOfConstructs;
          function handleMapOfConstructs(code2) {
            if (code2 in constructs2 || null in constructs2) {
              return handleListOfConstructs(
                constructs2.null ? (
                  /* c8 ignore next */
                  miniflat$1(constructs2[code2]).concat(miniflat$1(constructs2.null))
                ) : constructs2[code2]
              )(code2);
            }
            return bogusState(code2);
          }
          function handleListOfConstructs(list2) {
            listOfConstructs = list2;
            constructIndex = 0;
            return handleConstruct(list2[constructIndex]);
          }
          function handleConstruct(construct) {
            return start2;
            function start2(code2) {
              info2 = store();
              currentConstruct = construct;
              if (!construct.partial) {
                context.currentConstruct = construct;
              }
              if (construct.name && context.parser.constructs.disable.null.indexOf(construct.name) > -1) {
                return nok();
              }
              return construct.tokenize.call(
                fields ? assign$1({}, context, fields) : context,
                effects,
                ok2,
                nok
              )(code2);
            }
          }
          function ok2(code2) {
            onreturn(currentConstruct, info2);
            return returnState;
          }
          function nok(code2) {
            info2.restore();
            if (++constructIndex < listOfConstructs.length) {
              return handleConstruct(listOfConstructs[constructIndex]);
            }
            return bogusState;
          }
        }
      }
      function addResult(construct, from3) {
        if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {
          resolveAllConstructs.push(construct);
        }
        if (construct.resolve) {
          chunkedSplice$5(
            context.events,
            from3,
            context.events.length - from3,
            construct.resolve(context.events.slice(from3), context)
          );
        }
        if (construct.resolveTo) {
          context.events = construct.resolveTo(context.events, context);
        }
      }
      function store() {
        var startPoint = now2();
        var startPrevious = context.previous;
        var startCurrentConstruct = context.currentConstruct;
        var startEventsIndex = context.events.length;
        var startStack = Array.from(stack);
        return {
          restore,
          from: startEventsIndex
        };
        function restore() {
          point2 = startPoint;
          context.previous = startPrevious;
          context.currentConstruct = startCurrentConstruct;
          context.events.length = startEventsIndex;
          stack = startStack;
          accountForPotentialSkip();
        }
      }
      function accountForPotentialSkip() {
        if (point2.line in columnStart && point2.column < 2) {
          point2.column = columnStart[point2.line];
          point2.offset += columnStart[point2.line] - 1;
        }
      }
    }
    var createTokenizer_1 = createTokenizer$1;
    var constructs$1 = {};
    function markdownLineEndingOrSpace$9(code2) {
      return code2 < 0 || code2 === 32;
    }
    var markdownLineEndingOrSpace_1 = markdownLineEndingOrSpace$9;
    var unicodePunctuation$4 = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
    var unicodePunctuationRegex$1 = unicodePunctuation$4;
    var fromCharCode$1 = fromCharCode_1;
    function regexCheck$8(regex) {
      return check;
      function check(code2) {
        return regex.test(fromCharCode$1(code2));
      }
    }
    var regexCheck_1 = regexCheck$8;
    var unicodePunctuationRegex = unicodePunctuationRegex$1;
    var regexCheck$7 = regexCheck_1;
    var unicodePunctuation$3 = regexCheck$7(unicodePunctuationRegex);
    var unicodePunctuation_1 = unicodePunctuation$3;
    var regexCheck$6 = regexCheck_1;
    var unicodeWhitespace$3 = regexCheck$6(/\s/);
    var unicodeWhitespace_1 = unicodeWhitespace$3;
    var markdownLineEndingOrSpace$8 = markdownLineEndingOrSpace_1;
    var unicodePunctuation$2 = unicodePunctuation_1;
    var unicodeWhitespace$2 = unicodeWhitespace_1;
    function classifyCharacter$2(code2) {
      if (code2 === null || markdownLineEndingOrSpace$8(code2) || unicodeWhitespace$2(code2)) {
        return 1;
      }
      if (unicodePunctuation$2(code2)) {
        return 2;
      }
    }
    var classifyCharacter_1 = classifyCharacter$2;
    function movePoint$1(point2, offset2) {
      point2.column += offset2;
      point2.offset += offset2;
      point2._bufferIndex += offset2;
      return point2;
    }
    var movePoint_1 = movePoint$1;
    var chunkedPush$1 = chunkedPush_1;
    var chunkedSplice$4 = chunkedSplice_1;
    var classifyCharacter$1 = classifyCharacter_1;
    var movePoint = movePoint_1;
    var resolveAll$2 = resolveAll_1;
    var shallow$3 = shallow_1;
    var attention$1 = {
      name: "attention",
      tokenize: tokenizeAttention,
      resolveAll: resolveAllAttention
    };
    function resolveAllAttention(events, context) {
      var index2 = -1;
      var open2;
      var group;
      var text2;
      var openingSequence;
      var closingSequence;
      var use2;
      var nextEvents;
      var offset2;
      while (++index2 < events.length) {
        if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
          open2 = index2;
          while (open2--) {
            if (events[open2][0] === "exit" && events[open2][1].type === "attentionSequence" && events[open2][1]._open && // If the markers are the same:
            context.sliceSerialize(events[open2][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
              if ((events[open2][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open2][1].end.offset - events[open2][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
                continue;
              }
              use2 = events[open2][1].end.offset - events[open2][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
              openingSequence = {
                type: use2 > 1 ? "strongSequence" : "emphasisSequence",
                start: movePoint(shallow$3(events[open2][1].end), -use2),
                end: shallow$3(events[open2][1].end)
              };
              closingSequence = {
                type: use2 > 1 ? "strongSequence" : "emphasisSequence",
                start: shallow$3(events[index2][1].start),
                end: movePoint(shallow$3(events[index2][1].start), use2)
              };
              text2 = {
                type: use2 > 1 ? "strongText" : "emphasisText",
                start: shallow$3(events[open2][1].end),
                end: shallow$3(events[index2][1].start)
              };
              group = {
                type: use2 > 1 ? "strong" : "emphasis",
                start: shallow$3(openingSequence.start),
                end: shallow$3(closingSequence.end)
              };
              events[open2][1].end = shallow$3(openingSequence.start);
              events[index2][1].start = shallow$3(closingSequence.end);
              nextEvents = [];
              if (events[open2][1].end.offset - events[open2][1].start.offset) {
                nextEvents = chunkedPush$1(nextEvents, [
                  ["enter", events[open2][1], context],
                  ["exit", events[open2][1], context]
                ]);
              }
              nextEvents = chunkedPush$1(nextEvents, [
                ["enter", group, context],
                ["enter", openingSequence, context],
                ["exit", openingSequence, context],
                ["enter", text2, context]
              ]);
              nextEvents = chunkedPush$1(
                nextEvents,
                resolveAll$2(
                  context.parser.constructs.insideSpan.null,
                  events.slice(open2 + 1, index2),
                  context
                )
              );
              nextEvents = chunkedPush$1(nextEvents, [
                ["exit", text2, context],
                ["enter", closingSequence, context],
                ["exit", closingSequence, context],
                ["exit", group, context]
              ]);
              if (events[index2][1].end.offset - events[index2][1].start.offset) {
                offset2 = 2;
                nextEvents = chunkedPush$1(nextEvents, [
                  ["enter", events[index2][1], context],
                  ["exit", events[index2][1], context]
                ]);
              } else {
                offset2 = 0;
              }
              chunkedSplice$4(events, open2 - 1, index2 - open2 + 3, nextEvents);
              index2 = open2 + nextEvents.length - offset2 - 2;
              break;
            }
          }
        }
      }
      index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][1].type === "attentionSequence") {
          events[index2][1].type = "data";
        }
      }
      return events;
    }
    function tokenizeAttention(effects, ok2) {
      var before = classifyCharacter$1(this.previous);
      var marker;
      return start2;
      function start2(code2) {
        effects.enter("attentionSequence");
        marker = code2;
        return sequence(code2);
      }
      function sequence(code2) {
        var token2;
        var after;
        var open2;
        var close;
        if (code2 === marker) {
          effects.consume(code2);
          return sequence;
        }
        token2 = effects.exit("attentionSequence");
        after = classifyCharacter$1(code2);
        open2 = !after || after === 2 && before;
        close = !before || before === 2 && after;
        token2._open = marker === 42 ? open2 : open2 && (before || !close);
        token2._close = marker === 42 ? close : close && (after || !open2);
        return ok2(code2);
      }
    }
    var attention_1 = attention$1;
    var regexCheck$5 = regexCheck_1;
    var asciiAlpha$4 = regexCheck$5(/[A-Za-z]/);
    var asciiAlpha_1 = asciiAlpha$4;
    var regexCheck$4 = regexCheck_1;
    var asciiAlphanumeric$5 = regexCheck$4(/[\dA-Za-z]/);
    var asciiAlphanumeric_1 = asciiAlphanumeric$5;
    var regexCheck$3 = regexCheck_1;
    var asciiAtext$1 = regexCheck$3(/[#-'*+\--9=?A-Z^-~]/);
    var asciiAtext_1 = asciiAtext$1;
    function asciiControl$3(code2) {
      return (
        // Special whitespace codes (which have negative values), C0 and Control
        // character DEL
        code2 < 32 || code2 === 127
      );
    }
    var asciiControl_1 = asciiControl$3;
    var asciiAlpha$3 = asciiAlpha_1;
    var asciiAlphanumeric$4 = asciiAlphanumeric_1;
    var asciiAtext = asciiAtext_1;
    var asciiControl$2 = asciiControl_1;
    var autolink$2 = {
      name: "autolink",
      tokenize: tokenizeAutolink
    };
    function tokenizeAutolink(effects, ok2, nok) {
      var size = 1;
      return start2;
      function start2(code2) {
        effects.enter("autolink");
        effects.enter("autolinkMarker");
        effects.consume(code2);
        effects.exit("autolinkMarker");
        effects.enter("autolinkProtocol");
        return open2;
      }
      function open2(code2) {
        if (asciiAlpha$3(code2)) {
          effects.consume(code2);
          return schemeOrEmailAtext;
        }
        return asciiAtext(code2) ? emailAtext(code2) : nok(code2);
      }
      function schemeOrEmailAtext(code2) {
        return code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric$4(code2) ? schemeInsideOrEmailAtext(code2) : emailAtext(code2);
      }
      function schemeInsideOrEmailAtext(code2) {
        if (code2 === 58) {
          effects.consume(code2);
          return urlInside;
        }
        if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric$4(code2)) && size++ < 32) {
          effects.consume(code2);
          return schemeInsideOrEmailAtext;
        }
        return emailAtext(code2);
      }
      function urlInside(code2) {
        if (code2 === 62) {
          effects.exit("autolinkProtocol");
          return end2(code2);
        }
        if (code2 === 32 || code2 === 60 || asciiControl$2(code2)) {
          return nok(code2);
        }
        effects.consume(code2);
        return urlInside;
      }
      function emailAtext(code2) {
        if (code2 === 64) {
          effects.consume(code2);
          size = 0;
          return emailAtSignOrDot;
        }
        if (asciiAtext(code2)) {
          effects.consume(code2);
          return emailAtext;
        }
        return nok(code2);
      }
      function emailAtSignOrDot(code2) {
        return asciiAlphanumeric$4(code2) ? emailLabel(code2) : nok(code2);
      }
      function emailLabel(code2) {
        if (code2 === 46) {
          effects.consume(code2);
          size = 0;
          return emailAtSignOrDot;
        }
        if (code2 === 62) {
          effects.exit("autolinkProtocol").type = "autolinkEmail";
          return end2(code2);
        }
        return emailValue(code2);
      }
      function emailValue(code2) {
        if ((code2 === 45 || asciiAlphanumeric$4(code2)) && size++ < 63) {
          effects.consume(code2);
          return code2 === 45 ? emailValue : emailLabel;
        }
        return nok(code2);
      }
      function end2(code2) {
        effects.enter("autolinkMarker");
        effects.consume(code2);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok2;
      }
    }
    var autolink_1 = autolink$2;
    var markdownSpace$7 = markdownSpace_1;
    var factorySpace$b = factorySpace$h;
    var blockQuote$1 = {
      name: "blockQuote",
      tokenize: tokenizeBlockQuoteStart,
      continuation: {
        tokenize: tokenizeBlockQuoteContinuation
      },
      exit: exit$1
    };
    function tokenizeBlockQuoteStart(effects, ok2, nok) {
      var self2 = this;
      return start2;
      function start2(code2) {
        if (code2 === 62) {
          if (!self2.containerState.open) {
            effects.enter("blockQuote", {
              _container: true
            });
            self2.containerState.open = true;
          }
          effects.enter("blockQuotePrefix");
          effects.enter("blockQuoteMarker");
          effects.consume(code2);
          effects.exit("blockQuoteMarker");
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        if (markdownSpace$7(code2)) {
          effects.enter("blockQuotePrefixWhitespace");
          effects.consume(code2);
          effects.exit("blockQuotePrefixWhitespace");
          effects.exit("blockQuotePrefix");
          return ok2;
        }
        effects.exit("blockQuotePrefix");
        return ok2(code2);
      }
    }
    function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
      return factorySpace$b(
        effects,
        effects.attempt(blockQuote$1, ok2, nok),
        "linePrefix",
        this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
      );
    }
    function exit$1(effects) {
      effects.exit("blockQuote");
    }
    var blockQuote_1 = blockQuote$1;
    var regexCheck$2 = regexCheck_1;
    var asciiPunctuation$1 = regexCheck$2(/[!-/:-@[-`{-~]/);
    var asciiPunctuation_1 = asciiPunctuation$1;
    var asciiPunctuation = asciiPunctuation_1;
    var characterEscape$1 = {
      name: "characterEscape",
      tokenize: tokenizeCharacterEscape
    };
    function tokenizeCharacterEscape(effects, ok2, nok) {
      return start2;
      function start2(code2) {
        effects.enter("characterEscape");
        effects.enter("escapeMarker");
        effects.consume(code2);
        effects.exit("escapeMarker");
        return open2;
      }
      function open2(code2) {
        if (asciiPunctuation(code2)) {
          effects.enter("characterEscapeValue");
          effects.consume(code2);
          effects.exit("characterEscapeValue");
          effects.exit("characterEscape");
          return ok2;
        }
        return nok(code2);
      }
    }
    var characterEscape_1 = characterEscape$1;
    var el;
    var semicolon = 59;
    var decodeEntity_browser = decodeEntity$1;
    function decodeEntity$1(characters2) {
      var entity = "&" + characters2 + ";";
      var char2;
      el = el || document.createElement("i");
      el.innerHTML = entity;
      char2 = el.textContent;
      if (char2.charCodeAt(char2.length - 1) === semicolon && characters2 !== "semi") {
        return false;
      }
      return char2 === entity ? false : char2;
    }
    var regexCheck$1 = regexCheck_1;
    var asciiDigit$2 = regexCheck$1(/\d/);
    var asciiDigit_1 = asciiDigit$2;
    var regexCheck = regexCheck_1;
    var asciiHexDigit$1 = regexCheck(/[\dA-Fa-f]/);
    var asciiHexDigit_1 = asciiHexDigit$1;
    var decodeEntity = decodeEntity_browser;
    var asciiAlphanumeric$3 = asciiAlphanumeric_1;
    var asciiDigit$1 = asciiDigit_1;
    var asciiHexDigit = asciiHexDigit_1;
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2 : { default: e2 };
    }
    var decodeEntity__default = /* @__PURE__ */ _interopDefaultLegacy(decodeEntity);
    var characterReference$1 = {
      name: "characterReference",
      tokenize: tokenizeCharacterReference
    };
    function tokenizeCharacterReference(effects, ok2, nok) {
      var self2 = this;
      var size = 0;
      var max;
      var test;
      return start2;
      function start2(code2) {
        effects.enter("characterReference");
        effects.enter("characterReferenceMarker");
        effects.consume(code2);
        effects.exit("characterReferenceMarker");
        return open2;
      }
      function open2(code2) {
        if (code2 === 35) {
          effects.enter("characterReferenceMarkerNumeric");
          effects.consume(code2);
          effects.exit("characterReferenceMarkerNumeric");
          return numeric;
        }
        effects.enter("characterReferenceValue");
        max = 31;
        test = asciiAlphanumeric$3;
        return value(code2);
      }
      function numeric(code2) {
        if (code2 === 88 || code2 === 120) {
          effects.enter("characterReferenceMarkerHexadecimal");
          effects.consume(code2);
          effects.exit("characterReferenceMarkerHexadecimal");
          effects.enter("characterReferenceValue");
          max = 6;
          test = asciiHexDigit;
          return value;
        }
        effects.enter("characterReferenceValue");
        max = 7;
        test = asciiDigit$1;
        return value(code2);
      }
      function value(code2) {
        var token2;
        if (code2 === 59 && size) {
          token2 = effects.exit("characterReferenceValue");
          if (test === asciiAlphanumeric$3 && !decodeEntity__default["default"](self2.sliceSerialize(token2))) {
            return nok(code2);
          }
          effects.enter("characterReferenceMarker");
          effects.consume(code2);
          effects.exit("characterReferenceMarker");
          effects.exit("characterReference");
          return ok2;
        }
        if (test(code2) && size++ < max) {
          effects.consume(code2);
          return value;
        }
        return nok(code2);
      }
    }
    var characterReference_1 = characterReference$1;
    var markdownLineEnding$e = markdownLineEnding_1;
    var markdownLineEndingOrSpace$7 = markdownLineEndingOrSpace_1;
    var prefixSize$3 = prefixSize_1;
    var factorySpace$a = factorySpace$h;
    var codeFenced$1 = {
      name: "codeFenced",
      tokenize: tokenizeCodeFenced,
      concrete: true
    };
    function tokenizeCodeFenced(effects, ok2, nok) {
      var self2 = this;
      var closingFenceConstruct = {
        tokenize: tokenizeClosingFence,
        partial: true
      };
      var initialPrefix = prefixSize$3(this.events, "linePrefix");
      var sizeOpen = 0;
      var marker;
      return start2;
      function start2(code2) {
        effects.enter("codeFenced");
        effects.enter("codeFencedFence");
        effects.enter("codeFencedFenceSequence");
        marker = code2;
        return sequenceOpen(code2);
      }
      function sequenceOpen(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          sizeOpen++;
          return sequenceOpen;
        }
        effects.exit("codeFencedFenceSequence");
        return sizeOpen < 3 ? nok(code2) : factorySpace$a(effects, infoOpen, "whitespace")(code2);
      }
      function infoOpen(code2) {
        if (code2 === null || markdownLineEnding$e(code2)) {
          return openAfter(code2);
        }
        effects.enter("codeFencedFenceInfo");
        effects.enter("chunkString", {
          contentType: "string"
        });
        return info2(code2);
      }
      function info2(code2) {
        if (code2 === null || markdownLineEndingOrSpace$7(code2)) {
          effects.exit("chunkString");
          effects.exit("codeFencedFenceInfo");
          return factorySpace$a(effects, infoAfter, "whitespace")(code2);
        }
        if (code2 === 96 && code2 === marker)
          return nok(code2);
        effects.consume(code2);
        return info2;
      }
      function infoAfter(code2) {
        if (code2 === null || markdownLineEnding$e(code2)) {
          return openAfter(code2);
        }
        effects.enter("codeFencedFenceMeta");
        effects.enter("chunkString", {
          contentType: "string"
        });
        return meta(code2);
      }
      function meta(code2) {
        if (code2 === null || markdownLineEnding$e(code2)) {
          effects.exit("chunkString");
          effects.exit("codeFencedFenceMeta");
          return openAfter(code2);
        }
        if (code2 === 96 && code2 === marker)
          return nok(code2);
        effects.consume(code2);
        return meta;
      }
      function openAfter(code2) {
        effects.exit("codeFencedFence");
        return self2.interrupt ? ok2(code2) : content2(code2);
      }
      function content2(code2) {
        if (code2 === null) {
          return after(code2);
        }
        if (markdownLineEnding$e(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return effects.attempt(
            closingFenceConstruct,
            after,
            initialPrefix ? factorySpace$a(effects, content2, "linePrefix", initialPrefix + 1) : content2
          );
        }
        effects.enter("codeFlowValue");
        return contentContinue(code2);
      }
      function contentContinue(code2) {
        if (code2 === null || markdownLineEnding$e(code2)) {
          effects.exit("codeFlowValue");
          return content2(code2);
        }
        effects.consume(code2);
        return contentContinue;
      }
      function after(code2) {
        effects.exit("codeFenced");
        return ok2(code2);
      }
      function tokenizeClosingFence(effects2, ok3, nok2) {
        var size = 0;
        return factorySpace$a(
          effects2,
          closingSequenceStart,
          "linePrefix",
          this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
        );
        function closingSequenceStart(code2) {
          effects2.enter("codeFencedFence");
          effects2.enter("codeFencedFenceSequence");
          return closingSequence(code2);
        }
        function closingSequence(code2) {
          if (code2 === marker) {
            effects2.consume(code2);
            size++;
            return closingSequence;
          }
          if (size < sizeOpen)
            return nok2(code2);
          effects2.exit("codeFencedFenceSequence");
          return factorySpace$a(effects2, closingSequenceEnd, "whitespace")(code2);
        }
        function closingSequenceEnd(code2) {
          if (code2 === null || markdownLineEnding$e(code2)) {
            effects2.exit("codeFencedFence");
            return ok3(code2);
          }
          return nok2(code2);
        }
      }
    }
    var codeFenced_1 = codeFenced$1;
    var markdownLineEnding$d = markdownLineEnding_1;
    var chunkedSplice$3 = chunkedSplice_1;
    var prefixSize$2 = prefixSize_1;
    var factorySpace$9 = factorySpace$h;
    var codeIndented$1 = {
      name: "codeIndented",
      tokenize: tokenizeCodeIndented,
      resolve: resolveCodeIndented
    };
    var indentedContentConstruct = {
      tokenize: tokenizeIndentedContent,
      partial: true
    };
    function resolveCodeIndented(events, context) {
      var code2 = {
        type: "codeIndented",
        start: events[0][1].start,
        end: events[events.length - 1][1].end
      };
      chunkedSplice$3(events, 0, 0, [["enter", code2, context]]);
      chunkedSplice$3(events, events.length, 0, [["exit", code2, context]]);
      return events;
    }
    function tokenizeCodeIndented(effects, ok2, nok) {
      return effects.attempt(indentedContentConstruct, afterPrefix, nok);
      function afterPrefix(code2) {
        if (code2 === null) {
          return ok2(code2);
        }
        if (markdownLineEnding$d(code2)) {
          return effects.attempt(indentedContentConstruct, afterPrefix, ok2)(code2);
        }
        effects.enter("codeFlowValue");
        return content2(code2);
      }
      function content2(code2) {
        if (code2 === null || markdownLineEnding$d(code2)) {
          effects.exit("codeFlowValue");
          return afterPrefix(code2);
        }
        effects.consume(code2);
        return content2;
      }
    }
    function tokenizeIndentedContent(effects, ok2, nok) {
      var self2 = this;
      return factorySpace$9(effects, afterPrefix, "linePrefix", 4 + 1);
      function afterPrefix(code2) {
        if (markdownLineEnding$d(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return factorySpace$9(effects, afterPrefix, "linePrefix", 4 + 1);
        }
        return prefixSize$2(self2.events, "linePrefix") < 4 ? nok(code2) : ok2(code2);
      }
    }
    var codeIndented_1 = codeIndented$1;
    var markdownLineEnding$c = markdownLineEnding_1;
    var codeText$1 = {
      name: "codeText",
      tokenize: tokenizeCodeText,
      resolve: resolveCodeText,
      previous: previous$2
    };
    function resolveCodeText(events) {
      var tailExitIndex = events.length - 4;
      var headEnterIndex = 3;
      var index2;
      var enter;
      if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
        index2 = headEnterIndex;
        while (++index2 < tailExitIndex) {
          if (events[index2][1].type === "codeTextData") {
            events[tailExitIndex][1].type = events[headEnterIndex][1].type = "codeTextPadding";
            headEnterIndex += 2;
            tailExitIndex -= 2;
            break;
          }
        }
      }
      index2 = headEnterIndex - 1;
      tailExitIndex++;
      while (++index2 <= tailExitIndex) {
        if (enter === void 0) {
          if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
            enter = index2;
          }
        } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
          events[enter][1].type = "codeTextData";
          if (index2 !== enter + 2) {
            events[enter][1].end = events[index2 - 1][1].end;
            events.splice(enter + 2, index2 - enter - 2);
            tailExitIndex -= index2 - enter - 2;
            index2 = enter + 2;
          }
          enter = void 0;
        }
      }
      return events;
    }
    function previous$2(code2) {
      return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
    }
    function tokenizeCodeText(effects, ok2, nok) {
      var sizeOpen = 0;
      var size;
      var token2;
      return start2;
      function start2(code2) {
        effects.enter("codeText");
        effects.enter("codeTextSequence");
        return openingSequence(code2);
      }
      function openingSequence(code2) {
        if (code2 === 96) {
          effects.consume(code2);
          sizeOpen++;
          return openingSequence;
        }
        effects.exit("codeTextSequence");
        return gap(code2);
      }
      function gap(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 96) {
          token2 = effects.enter("codeTextSequence");
          size = 0;
          return closingSequence(code2);
        }
        if (code2 === 32) {
          effects.enter("space");
          effects.consume(code2);
          effects.exit("space");
          return gap;
        }
        if (markdownLineEnding$c(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return gap;
        }
        effects.enter("codeTextData");
        return data2(code2);
      }
      function data2(code2) {
        if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding$c(code2)) {
          effects.exit("codeTextData");
          return gap(code2);
        }
        effects.consume(code2);
        return data2;
      }
      function closingSequence(code2) {
        if (code2 === 96) {
          effects.consume(code2);
          size++;
          return closingSequence;
        }
        if (size === sizeOpen) {
          effects.exit("codeTextSequence");
          effects.exit("codeText");
          return ok2(code2);
        }
        token2.type = "codeTextData";
        return data2(code2);
      }
    }
    var codeText_1 = codeText$1;
    var asciiControl$1 = asciiControl_1;
    var markdownLineEndingOrSpace$6 = markdownLineEndingOrSpace_1;
    var markdownLineEnding$b = markdownLineEnding_1;
    function destinationFactory(effects, ok2, nok, type2, literalType, literalMarkerType, rawType, stringType, max) {
      var limit = max || Infinity;
      var balance = 0;
      return start2;
      function start2(code2) {
        if (code2 === 60) {
          effects.enter(type2);
          effects.enter(literalType);
          effects.enter(literalMarkerType);
          effects.consume(code2);
          effects.exit(literalMarkerType);
          return destinationEnclosedBefore;
        }
        if (asciiControl$1(code2) || code2 === 41) {
          return nok(code2);
        }
        effects.enter(type2);
        effects.enter(rawType);
        effects.enter(stringType);
        effects.enter("chunkString", {
          contentType: "string"
        });
        return destinationRaw(code2);
      }
      function destinationEnclosedBefore(code2) {
        if (code2 === 62) {
          effects.enter(literalMarkerType);
          effects.consume(code2);
          effects.exit(literalMarkerType);
          effects.exit(literalType);
          effects.exit(type2);
          return ok2;
        }
        effects.enter(stringType);
        effects.enter("chunkString", {
          contentType: "string"
        });
        return destinationEnclosed(code2);
      }
      function destinationEnclosed(code2) {
        if (code2 === 62) {
          effects.exit("chunkString");
          effects.exit(stringType);
          return destinationEnclosedBefore(code2);
        }
        if (code2 === null || code2 === 60 || markdownLineEnding$b(code2)) {
          return nok(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? destinationEnclosedEscape : destinationEnclosed;
      }
      function destinationEnclosedEscape(code2) {
        if (code2 === 60 || code2 === 62 || code2 === 92) {
          effects.consume(code2);
          return destinationEnclosed;
        }
        return destinationEnclosed(code2);
      }
      function destinationRaw(code2) {
        if (code2 === 40) {
          if (++balance > limit)
            return nok(code2);
          effects.consume(code2);
          return destinationRaw;
        }
        if (code2 === 41) {
          if (!balance--) {
            effects.exit("chunkString");
            effects.exit(stringType);
            effects.exit(rawType);
            effects.exit(type2);
            return ok2(code2);
          }
          effects.consume(code2);
          return destinationRaw;
        }
        if (code2 === null || markdownLineEndingOrSpace$6(code2)) {
          if (balance)
            return nok(code2);
          effects.exit("chunkString");
          effects.exit(stringType);
          effects.exit(rawType);
          effects.exit(type2);
          return ok2(code2);
        }
        if (asciiControl$1(code2))
          return nok(code2);
        effects.consume(code2);
        return code2 === 92 ? destinationRawEscape : destinationRaw;
      }
      function destinationRawEscape(code2) {
        if (code2 === 40 || code2 === 41 || code2 === 92) {
          effects.consume(code2);
          return destinationRaw;
        }
        return destinationRaw(code2);
      }
    }
    var factoryDestination$2 = destinationFactory;
    var markdownLineEnding$a = markdownLineEnding_1;
    var markdownSpace$6 = markdownSpace_1;
    function labelFactory(effects, ok2, nok, type2, markerType, stringType) {
      var self2 = this;
      var size = 0;
      var data2;
      return start2;
      function start2(code2) {
        effects.enter(type2);
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        effects.enter(stringType);
        return atBreak;
      }
      function atBreak(code2) {
        if (code2 === null || code2 === 91 || code2 === 93 && !data2 || /* c8 ignore next */
        code2 === 94 && /* c8 ignore next */
        !size && /* c8 ignore next */
        "_hiddenFootnoteSupport" in self2.parser.constructs || size > 999) {
          return nok(code2);
        }
        if (code2 === 93) {
          effects.exit(stringType);
          effects.enter(markerType);
          effects.consume(code2);
          effects.exit(markerType);
          effects.exit(type2);
          return ok2;
        }
        if (markdownLineEnding$a(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return atBreak;
        }
        effects.enter("chunkString", {
          contentType: "string"
        });
        return label(code2);
      }
      function label(code2) {
        if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding$a(code2) || size++ > 999) {
          effects.exit("chunkString");
          return atBreak(code2);
        }
        effects.consume(code2);
        data2 = data2 || !markdownSpace$6(code2);
        return code2 === 92 ? labelEscape : label;
      }
      function labelEscape(code2) {
        if (code2 === 91 || code2 === 92 || code2 === 93) {
          effects.consume(code2);
          size++;
          return label;
        }
        return label(code2);
      }
    }
    var factoryLabel$2 = labelFactory;
    var markdownLineEnding$9 = markdownLineEnding_1;
    var markdownSpace$5 = markdownSpace_1;
    var factorySpace$8 = factorySpace$h;
    function whitespaceFactory(effects, ok2) {
      var seen;
      return start2;
      function start2(code2) {
        if (markdownLineEnding$9(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          seen = true;
          return start2;
        }
        if (markdownSpace$5(code2)) {
          return factorySpace$8(
            effects,
            start2,
            seen ? "linePrefix" : "lineSuffix"
          )(code2);
        }
        return ok2(code2);
      }
    }
    var factoryWhitespace$2 = whitespaceFactory;
    var markdownLineEnding$8 = markdownLineEnding_1;
    var factorySpace$7 = factorySpace$h;
    function titleFactory(effects, ok2, nok, type2, markerType, stringType) {
      var marker;
      return start2;
      function start2(code2) {
        effects.enter(type2);
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        marker = code2 === 40 ? 41 : code2;
        return atFirstTitleBreak;
      }
      function atFirstTitleBreak(code2) {
        if (code2 === marker) {
          effects.enter(markerType);
          effects.consume(code2);
          effects.exit(markerType);
          effects.exit(type2);
          return ok2;
        }
        effects.enter(stringType);
        return atTitleBreak(code2);
      }
      function atTitleBreak(code2) {
        if (code2 === marker) {
          effects.exit(stringType);
          return atFirstTitleBreak(marker);
        }
        if (code2 === null) {
          return nok(code2);
        }
        if (markdownLineEnding$8(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return factorySpace$7(effects, atTitleBreak, "linePrefix");
        }
        effects.enter("chunkString", {
          contentType: "string"
        });
        return title(code2);
      }
      function title(code2) {
        if (code2 === marker || code2 === null || markdownLineEnding$8(code2)) {
          effects.exit("chunkString");
          return atTitleBreak(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? titleEscape : title;
      }
      function titleEscape(code2) {
        if (code2 === marker || code2 === 92) {
          effects.consume(code2);
          return title;
        }
        return title(code2);
      }
    }
    var factoryTitle$2 = titleFactory;
    var markdownLineEnding$7 = markdownLineEnding_1;
    var markdownLineEndingOrSpace$5 = markdownLineEndingOrSpace_1;
    var normalizeIdentifier$2 = normalizeIdentifier_1;
    var factoryDestination$1 = factoryDestination$2;
    var factoryLabel$1 = factoryLabel$2;
    var factorySpace$6 = factorySpace$h;
    var factoryWhitespace$1 = factoryWhitespace$2;
    var factoryTitle$1 = factoryTitle$2;
    var definition$1 = {
      name: "definition",
      tokenize: tokenizeDefinition
    };
    var titleConstruct = {
      tokenize: tokenizeTitle,
      partial: true
    };
    function tokenizeDefinition(effects, ok2, nok) {
      var self2 = this;
      var identifier2;
      return start2;
      function start2(code2) {
        effects.enter("definition");
        return factoryLabel$1.call(
          self2,
          effects,
          labelAfter,
          nok,
          "definitionLabel",
          "definitionLabelMarker",
          "definitionLabelString"
        )(code2);
      }
      function labelAfter(code2) {
        identifier2 = normalizeIdentifier$2(
          self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
        );
        if (code2 === 58) {
          effects.enter("definitionMarker");
          effects.consume(code2);
          effects.exit("definitionMarker");
          return factoryWhitespace$1(
            effects,
            factoryDestination$1(
              effects,
              effects.attempt(
                titleConstruct,
                factorySpace$6(effects, after, "whitespace"),
                factorySpace$6(effects, after, "whitespace")
              ),
              nok,
              "definitionDestination",
              "definitionDestinationLiteral",
              "definitionDestinationLiteralMarker",
              "definitionDestinationRaw",
              "definitionDestinationString"
            )
          );
        }
        return nok(code2);
      }
      function after(code2) {
        if (code2 === null || markdownLineEnding$7(code2)) {
          effects.exit("definition");
          if (self2.parser.defined.indexOf(identifier2) < 0) {
            self2.parser.defined.push(identifier2);
          }
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    function tokenizeTitle(effects, ok2, nok) {
      return start2;
      function start2(code2) {
        return markdownLineEndingOrSpace$5(code2) ? factoryWhitespace$1(effects, before)(code2) : nok(code2);
      }
      function before(code2) {
        if (code2 === 34 || code2 === 39 || code2 === 40) {
          return factoryTitle$1(
            effects,
            factorySpace$6(effects, after, "whitespace"),
            nok,
            "definitionTitle",
            "definitionTitleMarker",
            "definitionTitleString"
          )(code2);
        }
        return nok(code2);
      }
      function after(code2) {
        return code2 === null || markdownLineEnding$7(code2) ? ok2(code2) : nok(code2);
      }
    }
    var definition_1 = definition$1;
    var markdownLineEnding$6 = markdownLineEnding_1;
    var hardBreakEscape$1 = {
      name: "hardBreakEscape",
      tokenize: tokenizeHardBreakEscape
    };
    function tokenizeHardBreakEscape(effects, ok2, nok) {
      return start2;
      function start2(code2) {
        effects.enter("hardBreakEscape");
        effects.enter("escapeMarker");
        effects.consume(code2);
        return open2;
      }
      function open2(code2) {
        if (markdownLineEnding$6(code2)) {
          effects.exit("escapeMarker");
          effects.exit("hardBreakEscape");
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    var hardBreakEscape_1 = hardBreakEscape$1;
    var markdownLineEnding$5 = markdownLineEnding_1;
    var markdownLineEndingOrSpace$4 = markdownLineEndingOrSpace_1;
    var markdownSpace$4 = markdownSpace_1;
    var chunkedSplice$2 = chunkedSplice_1;
    var factorySpace$5 = factorySpace$h;
    var headingAtx$1 = {
      name: "headingAtx",
      tokenize: tokenizeHeadingAtx,
      resolve: resolveHeadingAtx
    };
    function resolveHeadingAtx(events, context) {
      var contentEnd = events.length - 2;
      var contentStart = 3;
      var content2;
      var text2;
      if (events[contentStart][1].type === "whitespace") {
        contentStart += 2;
      }
      if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
        contentEnd -= 2;
      }
      if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
        contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
      }
      if (contentEnd > contentStart) {
        content2 = {
          type: "atxHeadingText",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end
        };
        text2 = {
          type: "chunkText",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end,
          contentType: "text"
        };
        chunkedSplice$2(events, contentStart, contentEnd - contentStart + 1, [
          ["enter", content2, context],
          ["enter", text2, context],
          ["exit", text2, context],
          ["exit", content2, context]
        ]);
      }
      return events;
    }
    function tokenizeHeadingAtx(effects, ok2, nok) {
      var self2 = this;
      var size = 0;
      return start2;
      function start2(code2) {
        effects.enter("atxHeading");
        effects.enter("atxHeadingSequence");
        return fenceOpenInside(code2);
      }
      function fenceOpenInside(code2) {
        if (code2 === 35 && size++ < 6) {
          effects.consume(code2);
          return fenceOpenInside;
        }
        if (code2 === null || markdownLineEndingOrSpace$4(code2)) {
          effects.exit("atxHeadingSequence");
          return self2.interrupt ? ok2(code2) : headingBreak(code2);
        }
        return nok(code2);
      }
      function headingBreak(code2) {
        if (code2 === 35) {
          effects.enter("atxHeadingSequence");
          return sequence(code2);
        }
        if (code2 === null || markdownLineEnding$5(code2)) {
          effects.exit("atxHeading");
          return ok2(code2);
        }
        if (markdownSpace$4(code2)) {
          return factorySpace$5(effects, headingBreak, "whitespace")(code2);
        }
        effects.enter("atxHeadingText");
        return data2(code2);
      }
      function sequence(code2) {
        if (code2 === 35) {
          effects.consume(code2);
          return sequence;
        }
        effects.exit("atxHeadingSequence");
        return headingBreak(code2);
      }
      function data2(code2) {
        if (code2 === null || code2 === 35 || markdownLineEndingOrSpace$4(code2)) {
          effects.exit("atxHeadingText");
          return headingBreak(code2);
        }
        effects.consume(code2);
        return data2;
      }
    }
    var headingAtx_1 = headingAtx$1;
    var basics = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
    var htmlBlockNames$1 = basics;
    var raws = ["pre", "script", "style", "textarea"];
    var htmlRawNames$1 = raws;
    var asciiAlpha$2 = asciiAlpha_1;
    var asciiAlphanumeric$2 = asciiAlphanumeric_1;
    var markdownLineEnding$4 = markdownLineEnding_1;
    var markdownLineEndingOrSpace$3 = markdownLineEndingOrSpace_1;
    var markdownSpace$3 = markdownSpace_1;
    var fromCharCode = fromCharCode_1;
    var htmlBlockNames = htmlBlockNames$1;
    var htmlRawNames = htmlRawNames$1;
    var partialBlankLine$1 = partialBlankLine_1;
    var htmlFlow$1 = {
      name: "htmlFlow",
      tokenize: tokenizeHtmlFlow,
      resolveTo: resolveToHtmlFlow,
      concrete: true
    };
    var nextBlankConstruct = {
      tokenize: tokenizeNextBlank,
      partial: true
    };
    function resolveToHtmlFlow(events) {
      var index2 = events.length;
      while (index2--) {
        if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
          break;
        }
      }
      if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
        events[index2][1].start = events[index2 - 2][1].start;
        events[index2 + 1][1].start = events[index2 - 2][1].start;
        events.splice(index2 - 2, 2);
      }
      return events;
    }
    function tokenizeHtmlFlow(effects, ok2, nok) {
      var self2 = this;
      var kind;
      var startTag;
      var buffer2;
      var index2;
      var marker;
      return start2;
      function start2(code2) {
        effects.enter("htmlFlow");
        effects.enter("htmlFlowData");
        effects.consume(code2);
        return open2;
      }
      function open2(code2) {
        if (code2 === 33) {
          effects.consume(code2);
          return declarationStart;
        }
        if (code2 === 47) {
          effects.consume(code2);
          return tagCloseStart;
        }
        if (code2 === 63) {
          effects.consume(code2);
          kind = 3;
          return self2.interrupt ? ok2 : continuationDeclarationInside;
        }
        if (asciiAlpha$2(code2)) {
          effects.consume(code2);
          buffer2 = fromCharCode(code2);
          startTag = true;
          return tagName;
        }
        return nok(code2);
      }
      function declarationStart(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          kind = 2;
          return commentOpenInside;
        }
        if (code2 === 91) {
          effects.consume(code2);
          kind = 5;
          buffer2 = "CDATA[";
          index2 = 0;
          return cdataOpenInside;
        }
        if (asciiAlpha$2(code2)) {
          effects.consume(code2);
          kind = 4;
          return self2.interrupt ? ok2 : continuationDeclarationInside;
        }
        return nok(code2);
      }
      function commentOpenInside(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return self2.interrupt ? ok2 : continuationDeclarationInside;
        }
        return nok(code2);
      }
      function cdataOpenInside(code2) {
        if (code2 === buffer2.charCodeAt(index2++)) {
          effects.consume(code2);
          return index2 === buffer2.length ? self2.interrupt ? ok2 : continuation : cdataOpenInside;
        }
        return nok(code2);
      }
      function tagCloseStart(code2) {
        if (asciiAlpha$2(code2)) {
          effects.consume(code2);
          buffer2 = fromCharCode(code2);
          return tagName;
        }
        return nok(code2);
      }
      function tagName(code2) {
        if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace$3(code2)) {
          if (code2 !== 47 && startTag && htmlRawNames.indexOf(buffer2.toLowerCase()) > -1) {
            kind = 1;
            return self2.interrupt ? ok2(code2) : continuation(code2);
          }
          if (htmlBlockNames.indexOf(buffer2.toLowerCase()) > -1) {
            kind = 6;
            if (code2 === 47) {
              effects.consume(code2);
              return basicSelfClosing;
            }
            return self2.interrupt ? ok2(code2) : continuation(code2);
          }
          kind = 7;
          return self2.interrupt ? nok(code2) : startTag ? completeAttributeNameBefore(code2) : completeClosingTagAfter(code2);
        }
        if (code2 === 45 || asciiAlphanumeric$2(code2)) {
          effects.consume(code2);
          buffer2 += fromCharCode(code2);
          return tagName;
        }
        return nok(code2);
      }
      function basicSelfClosing(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          return self2.interrupt ? ok2 : continuation;
        }
        return nok(code2);
      }
      function completeClosingTagAfter(code2) {
        if (markdownSpace$3(code2)) {
          effects.consume(code2);
          return completeClosingTagAfter;
        }
        return completeEnd(code2);
      }
      function completeAttributeNameBefore(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          return completeEnd;
        }
        if (code2 === 58 || code2 === 95 || asciiAlpha$2(code2)) {
          effects.consume(code2);
          return completeAttributeName;
        }
        if (markdownSpace$3(code2)) {
          effects.consume(code2);
          return completeAttributeNameBefore;
        }
        return completeEnd(code2);
      }
      function completeAttributeName(code2) {
        if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric$2(code2)) {
          effects.consume(code2);
          return completeAttributeName;
        }
        return completeAttributeNameAfter(code2);
      }
      function completeAttributeNameAfter(code2) {
        if (code2 === 61) {
          effects.consume(code2);
          return completeAttributeValueBefore;
        }
        if (markdownSpace$3(code2)) {
          effects.consume(code2);
          return completeAttributeNameAfter;
        }
        return completeAttributeNameBefore(code2);
      }
      function completeAttributeValueBefore(code2) {
        if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
          return nok(code2);
        }
        if (code2 === 34 || code2 === 39) {
          effects.consume(code2);
          marker = code2;
          return completeAttributeValueQuoted;
        }
        if (markdownSpace$3(code2)) {
          effects.consume(code2);
          return completeAttributeValueBefore;
        }
        marker = void 0;
        return completeAttributeValueUnquoted(code2);
      }
      function completeAttributeValueQuoted(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          return completeAttributeValueQuotedAfter;
        }
        if (code2 === null || markdownLineEnding$4(code2)) {
          return nok(code2);
        }
        effects.consume(code2);
        return completeAttributeValueQuoted;
      }
      function completeAttributeValueUnquoted(code2) {
        if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace$3(code2)) {
          return completeAttributeNameAfter(code2);
        }
        effects.consume(code2);
        return completeAttributeValueUnquoted;
      }
      function completeAttributeValueQuotedAfter(code2) {
        if (code2 === 47 || code2 === 62 || markdownSpace$3(code2)) {
          return completeAttributeNameBefore(code2);
        }
        return nok(code2);
      }
      function completeEnd(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          return completeAfter;
        }
        return nok(code2);
      }
      function completeAfter(code2) {
        if (markdownSpace$3(code2)) {
          effects.consume(code2);
          return completeAfter;
        }
        return code2 === null || markdownLineEnding$4(code2) ? continuation(code2) : nok(code2);
      }
      function continuation(code2) {
        if (code2 === 45 && kind === 2) {
          effects.consume(code2);
          return continuationCommentInside;
        }
        if (code2 === 60 && kind === 1) {
          effects.consume(code2);
          return continuationRawTagOpen;
        }
        if (code2 === 62 && kind === 4) {
          effects.consume(code2);
          return continuationClose;
        }
        if (code2 === 63 && kind === 3) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        if (code2 === 93 && kind === 5) {
          effects.consume(code2);
          return continuationCharacterDataInside;
        }
        if (markdownLineEnding$4(code2) && (kind === 6 || kind === 7)) {
          return effects.check(
            nextBlankConstruct,
            continuationClose,
            continuationAtLineEnding
          )(code2);
        }
        if (code2 === null || markdownLineEnding$4(code2)) {
          return continuationAtLineEnding(code2);
        }
        effects.consume(code2);
        return continuation;
      }
      function continuationAtLineEnding(code2) {
        effects.exit("htmlFlowData");
        return htmlContinueStart(code2);
      }
      function htmlContinueStart(code2) {
        if (code2 === null) {
          return done(code2);
        }
        if (markdownLineEnding$4(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return htmlContinueStart;
        }
        effects.enter("htmlFlowData");
        return continuation(code2);
      }
      function continuationCommentInside(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        return continuation(code2);
      }
      function continuationRawTagOpen(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          buffer2 = "";
          return continuationRawEndTag;
        }
        return continuation(code2);
      }
      function continuationRawEndTag(code2) {
        if (code2 === 62 && htmlRawNames.indexOf(buffer2.toLowerCase()) > -1) {
          effects.consume(code2);
          return continuationClose;
        }
        if (asciiAlpha$2(code2) && buffer2.length < 8) {
          effects.consume(code2);
          buffer2 += fromCharCode(code2);
          return continuationRawEndTag;
        }
        return continuation(code2);
      }
      function continuationCharacterDataInside(code2) {
        if (code2 === 93) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        return continuation(code2);
      }
      function continuationDeclarationInside(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          return continuationClose;
        }
        return continuation(code2);
      }
      function continuationClose(code2) {
        if (code2 === null || markdownLineEnding$4(code2)) {
          effects.exit("htmlFlowData");
          return done(code2);
        }
        effects.consume(code2);
        return continuationClose;
      }
      function done(code2) {
        effects.exit("htmlFlow");
        return ok2(code2);
      }
    }
    function tokenizeNextBlank(effects, ok2, nok) {
      return start2;
      function start2(code2) {
        effects.exit("htmlFlowData");
        effects.enter("lineEndingBlank");
        effects.consume(code2);
        effects.exit("lineEndingBlank");
        return effects.attempt(partialBlankLine$1, ok2, nok);
      }
    }
    var htmlFlow_1 = htmlFlow$1;
    var asciiAlpha$1 = asciiAlpha_1;
    var asciiAlphanumeric$1 = asciiAlphanumeric_1;
    var markdownLineEnding$3 = markdownLineEnding_1;
    var markdownLineEndingOrSpace$2 = markdownLineEndingOrSpace_1;
    var markdownSpace$2 = markdownSpace_1;
    var factorySpace$4 = factorySpace$h;
    var htmlText$1 = {
      name: "htmlText",
      tokenize: tokenizeHtmlText
    };
    function tokenizeHtmlText(effects, ok2, nok) {
      var self2 = this;
      var marker;
      var buffer2;
      var index2;
      var returnState;
      return start2;
      function start2(code2) {
        effects.enter("htmlText");
        effects.enter("htmlTextData");
        effects.consume(code2);
        return open2;
      }
      function open2(code2) {
        if (code2 === 33) {
          effects.consume(code2);
          return declarationOpen;
        }
        if (code2 === 47) {
          effects.consume(code2);
          return tagCloseStart;
        }
        if (code2 === 63) {
          effects.consume(code2);
          return instruction;
        }
        if (asciiAlpha$1(code2)) {
          effects.consume(code2);
          return tagOpen;
        }
        return nok(code2);
      }
      function declarationOpen(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return commentOpen;
        }
        if (code2 === 91) {
          effects.consume(code2);
          buffer2 = "CDATA[";
          index2 = 0;
          return cdataOpen;
        }
        if (asciiAlpha$1(code2)) {
          effects.consume(code2);
          return declaration2;
        }
        return nok(code2);
      }
      function commentOpen(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return commentStart;
        }
        return nok(code2);
      }
      function commentStart(code2) {
        if (code2 === null || code2 === 62) {
          return nok(code2);
        }
        if (code2 === 45) {
          effects.consume(code2);
          return commentStartDash;
        }
        return comment2(code2);
      }
      function commentStartDash(code2) {
        if (code2 === null || code2 === 62) {
          return nok(code2);
        }
        return comment2(code2);
      }
      function comment2(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 45) {
          effects.consume(code2);
          return commentClose;
        }
        if (markdownLineEnding$3(code2)) {
          returnState = comment2;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return comment2;
      }
      function commentClose(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return end2;
        }
        return comment2(code2);
      }
      function cdataOpen(code2) {
        if (code2 === buffer2.charCodeAt(index2++)) {
          effects.consume(code2);
          return index2 === buffer2.length ? cdata : cdataOpen;
        }
        return nok(code2);
      }
      function cdata(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 93) {
          effects.consume(code2);
          return cdataClose;
        }
        if (markdownLineEnding$3(code2)) {
          returnState = cdata;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return cdata;
      }
      function cdataClose(code2) {
        if (code2 === 93) {
          effects.consume(code2);
          return cdataEnd;
        }
        return cdata(code2);
      }
      function cdataEnd(code2) {
        if (code2 === 62) {
          return end2(code2);
        }
        if (code2 === 93) {
          effects.consume(code2);
          return cdataEnd;
        }
        return cdata(code2);
      }
      function declaration2(code2) {
        if (code2 === null || code2 === 62) {
          return end2(code2);
        }
        if (markdownLineEnding$3(code2)) {
          returnState = declaration2;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return declaration2;
      }
      function instruction(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 63) {
          effects.consume(code2);
          return instructionClose;
        }
        if (markdownLineEnding$3(code2)) {
          returnState = instruction;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return instruction;
      }
      function instructionClose(code2) {
        return code2 === 62 ? end2(code2) : instruction(code2);
      }
      function tagCloseStart(code2) {
        if (asciiAlpha$1(code2)) {
          effects.consume(code2);
          return tagClose;
        }
        return nok(code2);
      }
      function tagClose(code2) {
        if (code2 === 45 || asciiAlphanumeric$1(code2)) {
          effects.consume(code2);
          return tagClose;
        }
        return tagCloseBetween(code2);
      }
      function tagCloseBetween(code2) {
        if (markdownLineEnding$3(code2)) {
          returnState = tagCloseBetween;
          return atLineEnding(code2);
        }
        if (markdownSpace$2(code2)) {
          effects.consume(code2);
          return tagCloseBetween;
        }
        return end2(code2);
      }
      function tagOpen(code2) {
        if (code2 === 45 || asciiAlphanumeric$1(code2)) {
          effects.consume(code2);
          return tagOpen;
        }
        if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace$2(code2)) {
          return tagOpenBetween(code2);
        }
        return nok(code2);
      }
      function tagOpenBetween(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          return end2;
        }
        if (code2 === 58 || code2 === 95 || asciiAlpha$1(code2)) {
          effects.consume(code2);
          return tagOpenAttributeName;
        }
        if (markdownLineEnding$3(code2)) {
          returnState = tagOpenBetween;
          return atLineEnding(code2);
        }
        if (markdownSpace$2(code2)) {
          effects.consume(code2);
          return tagOpenBetween;
        }
        return end2(code2);
      }
      function tagOpenAttributeName(code2) {
        if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric$1(code2)) {
          effects.consume(code2);
          return tagOpenAttributeName;
        }
        return tagOpenAttributeNameAfter(code2);
      }
      function tagOpenAttributeNameAfter(code2) {
        if (code2 === 61) {
          effects.consume(code2);
          return tagOpenAttributeValueBefore;
        }
        if (markdownLineEnding$3(code2)) {
          returnState = tagOpenAttributeNameAfter;
          return atLineEnding(code2);
        }
        if (markdownSpace$2(code2)) {
          effects.consume(code2);
          return tagOpenAttributeNameAfter;
        }
        return tagOpenBetween(code2);
      }
      function tagOpenAttributeValueBefore(code2) {
        if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
          return nok(code2);
        }
        if (code2 === 34 || code2 === 39) {
          effects.consume(code2);
          marker = code2;
          return tagOpenAttributeValueQuoted;
        }
        if (markdownLineEnding$3(code2)) {
          returnState = tagOpenAttributeValueBefore;
          return atLineEnding(code2);
        }
        if (markdownSpace$2(code2)) {
          effects.consume(code2);
          return tagOpenAttributeValueBefore;
        }
        effects.consume(code2);
        marker = void 0;
        return tagOpenAttributeValueUnquoted;
      }
      function tagOpenAttributeValueQuoted(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          return tagOpenAttributeValueQuotedAfter;
        }
        if (code2 === null) {
          return nok(code2);
        }
        if (markdownLineEnding$3(code2)) {
          returnState = tagOpenAttributeValueQuoted;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return tagOpenAttributeValueQuoted;
      }
      function tagOpenAttributeValueQuotedAfter(code2) {
        if (code2 === 62 || code2 === 47 || markdownLineEndingOrSpace$2(code2)) {
          return tagOpenBetween(code2);
        }
        return nok(code2);
      }
      function tagOpenAttributeValueUnquoted(code2) {
        if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
          return nok(code2);
        }
        if (code2 === 62 || markdownLineEndingOrSpace$2(code2)) {
          return tagOpenBetween(code2);
        }
        effects.consume(code2);
        return tagOpenAttributeValueUnquoted;
      }
      function atLineEnding(code2) {
        effects.exit("htmlTextData");
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace$4(
          effects,
          afterPrefix,
          "linePrefix",
          self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
        );
      }
      function afterPrefix(code2) {
        effects.enter("htmlTextData");
        return returnState(code2);
      }
      function end2(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          effects.exit("htmlTextData");
          effects.exit("htmlText");
          return ok2;
        }
        return nok(code2);
      }
    }
    var htmlText_1 = htmlText$1;
    var markdownLineEndingOrSpace$1 = markdownLineEndingOrSpace_1;
    var chunkedPush = chunkedPush_1;
    var chunkedSplice$1 = chunkedSplice_1;
    var normalizeIdentifier$1 = normalizeIdentifier_1;
    var resolveAll$1 = resolveAll_1;
    var shallow$2 = shallow_1;
    var factoryDestination = factoryDestination$2;
    var factoryLabel = factoryLabel$2;
    var factoryTitle = factoryTitle$2;
    var factoryWhitespace = factoryWhitespace$2;
    var labelEnd$3 = {
      name: "labelEnd",
      tokenize: tokenizeLabelEnd,
      resolveTo: resolveToLabelEnd,
      resolveAll: resolveAllLabelEnd
    };
    var resourceConstruct = {
      tokenize: tokenizeResource
    };
    var fullReferenceConstruct = {
      tokenize: tokenizeFullReference
    };
    var collapsedReferenceConstruct = {
      tokenize: tokenizeCollapsedReference
    };
    function resolveAllLabelEnd(events) {
      var index2 = -1;
      var token2;
      while (++index2 < events.length) {
        token2 = events[index2][1];
        if (!token2._used && (token2.type === "labelImage" || token2.type === "labelLink" || token2.type === "labelEnd")) {
          events.splice(index2 + 1, token2.type === "labelImage" ? 4 : 2);
          token2.type = "data";
          index2++;
        }
      }
      return events;
    }
    function resolveToLabelEnd(events, context) {
      var index2 = events.length;
      var offset2 = 0;
      var group;
      var label;
      var text2;
      var token2;
      var open2;
      var close;
      var media;
      while (index2--) {
        token2 = events[index2][1];
        if (open2) {
          if (token2.type === "link" || token2.type === "labelLink" && token2._inactive) {
            break;
          }
          if (events[index2][0] === "enter" && token2.type === "labelLink") {
            token2._inactive = true;
          }
        } else if (close) {
          if (events[index2][0] === "enter" && (token2.type === "labelImage" || token2.type === "labelLink") && !token2._balanced) {
            open2 = index2;
            if (token2.type !== "labelLink") {
              offset2 = 2;
              break;
            }
          }
        } else if (token2.type === "labelEnd") {
          close = index2;
        }
      }
      group = {
        type: events[open2][1].type === "labelLink" ? "link" : "image",
        start: shallow$2(events[open2][1].start),
        end: shallow$2(events[events.length - 1][1].end)
      };
      label = {
        type: "label",
        start: shallow$2(events[open2][1].start),
        end: shallow$2(events[close][1].end)
      };
      text2 = {
        type: "labelText",
        start: shallow$2(events[open2 + offset2 + 2][1].end),
        end: shallow$2(events[close - 2][1].start)
      };
      media = [
        ["enter", group, context],
        ["enter", label, context]
      ];
      media = chunkedPush(media, events.slice(open2 + 1, open2 + offset2 + 3));
      media = chunkedPush(media, [["enter", text2, context]]);
      media = chunkedPush(
        media,
        resolveAll$1(
          context.parser.constructs.insideSpan.null,
          events.slice(open2 + offset2 + 4, close - 3),
          context
        )
      );
      media = chunkedPush(media, [
        ["exit", text2, context],
        events[close - 2],
        events[close - 1],
        ["exit", label, context]
      ]);
      media = chunkedPush(media, events.slice(close + 1));
      media = chunkedPush(media, [["exit", group, context]]);
      chunkedSplice$1(events, open2, events.length, media);
      return events;
    }
    function tokenizeLabelEnd(effects, ok2, nok) {
      var self2 = this;
      var index2 = self2.events.length;
      var labelStart;
      var defined;
      while (index2--) {
        if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
          labelStart = self2.events[index2][1];
          break;
        }
      }
      return start2;
      function start2(code2) {
        if (!labelStart) {
          return nok(code2);
        }
        if (labelStart._inactive)
          return balanced(code2);
        defined = self2.parser.defined.indexOf(
          normalizeIdentifier$1(
            self2.sliceSerialize({
              start: labelStart.end,
              end: self2.now()
            })
          )
        ) > -1;
        effects.enter("labelEnd");
        effects.enter("labelMarker");
        effects.consume(code2);
        effects.exit("labelMarker");
        effects.exit("labelEnd");
        return afterLabelEnd;
      }
      function afterLabelEnd(code2) {
        if (code2 === 40) {
          return effects.attempt(
            resourceConstruct,
            ok2,
            defined ? ok2 : balanced
          )(code2);
        }
        if (code2 === 91) {
          return effects.attempt(
            fullReferenceConstruct,
            ok2,
            defined ? effects.attempt(collapsedReferenceConstruct, ok2, balanced) : balanced
          )(code2);
        }
        return defined ? ok2(code2) : balanced(code2);
      }
      function balanced(code2) {
        labelStart._balanced = true;
        return nok(code2);
      }
    }
    function tokenizeResource(effects, ok2, nok) {
      return start2;
      function start2(code2) {
        effects.enter("resource");
        effects.enter("resourceMarker");
        effects.consume(code2);
        effects.exit("resourceMarker");
        return factoryWhitespace(effects, open2);
      }
      function open2(code2) {
        if (code2 === 41) {
          return end2(code2);
        }
        return factoryDestination(
          effects,
          destinationAfter,
          nok,
          "resourceDestination",
          "resourceDestinationLiteral",
          "resourceDestinationLiteralMarker",
          "resourceDestinationRaw",
          "resourceDestinationString",
          3
        )(code2);
      }
      function destinationAfter(code2) {
        return markdownLineEndingOrSpace$1(code2) ? factoryWhitespace(effects, between)(code2) : end2(code2);
      }
      function between(code2) {
        if (code2 === 34 || code2 === 39 || code2 === 40) {
          return factoryTitle(
            effects,
            factoryWhitespace(effects, end2),
            nok,
            "resourceTitle",
            "resourceTitleMarker",
            "resourceTitleString"
          )(code2);
        }
        return end2(code2);
      }
      function end2(code2) {
        if (code2 === 41) {
          effects.enter("resourceMarker");
          effects.consume(code2);
          effects.exit("resourceMarker");
          effects.exit("resource");
          return ok2;
        }
        return nok(code2);
      }
    }
    function tokenizeFullReference(effects, ok2, nok) {
      var self2 = this;
      return start2;
      function start2(code2) {
        return factoryLabel.call(
          self2,
          effects,
          afterLabel,
          nok,
          "reference",
          "referenceMarker",
          "referenceString"
        )(code2);
      }
      function afterLabel(code2) {
        return self2.parser.defined.indexOf(
          normalizeIdentifier$1(
            self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
          )
        ) < 0 ? nok(code2) : ok2(code2);
      }
    }
    function tokenizeCollapsedReference(effects, ok2, nok) {
      return start2;
      function start2(code2) {
        effects.enter("reference");
        effects.enter("referenceMarker");
        effects.consume(code2);
        effects.exit("referenceMarker");
        return open2;
      }
      function open2(code2) {
        if (code2 === 93) {
          effects.enter("referenceMarker");
          effects.consume(code2);
          effects.exit("referenceMarker");
          effects.exit("reference");
          return ok2;
        }
        return nok(code2);
      }
    }
    var labelEnd_1 = labelEnd$3;
    var labelEnd$2 = labelEnd_1;
    var labelStartImage$1 = {
      name: "labelStartImage",
      tokenize: tokenizeLabelStartImage,
      resolveAll: labelEnd$2.resolveAll
    };
    function tokenizeLabelStartImage(effects, ok2, nok) {
      var self2 = this;
      return start2;
      function start2(code2) {
        effects.enter("labelImage");
        effects.enter("labelImageMarker");
        effects.consume(code2);
        effects.exit("labelImageMarker");
        return open2;
      }
      function open2(code2) {
        if (code2 === 91) {
          effects.enter("labelMarker");
          effects.consume(code2);
          effects.exit("labelMarker");
          effects.exit("labelImage");
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        return code2 === 94 && /* c8 ignore next */
        "_hiddenFootnoteSupport" in self2.parser.constructs ? (
          /* c8 ignore next */
          nok(code2)
        ) : ok2(code2);
      }
    }
    var labelStartImage_1 = labelStartImage$1;
    var labelEnd$1 = labelEnd_1;
    var labelStartLink$1 = {
      name: "labelStartLink",
      tokenize: tokenizeLabelStartLink,
      resolveAll: labelEnd$1.resolveAll
    };
    function tokenizeLabelStartLink(effects, ok2, nok) {
      var self2 = this;
      return start2;
      function start2(code2) {
        effects.enter("labelLink");
        effects.enter("labelMarker");
        effects.consume(code2);
        effects.exit("labelMarker");
        effects.exit("labelLink");
        return after;
      }
      function after(code2) {
        return code2 === 94 && /* c8 ignore next */
        "_hiddenFootnoteSupport" in self2.parser.constructs ? (
          /* c8 ignore next */
          nok(code2)
        ) : ok2(code2);
      }
    }
    var labelStartLink_1 = labelStartLink$1;
    var factorySpace$3 = factorySpace$h;
    var lineEnding$1 = {
      name: "lineEnding",
      tokenize: tokenizeLineEnding
    };
    function tokenizeLineEnding(effects, ok2) {
      return start2;
      function start2(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace$3(effects, ok2, "linePrefix");
      }
    }
    var lineEnding_1 = lineEnding$1;
    var markdownLineEnding$2 = markdownLineEnding_1;
    var markdownSpace$1 = markdownSpace_1;
    var factorySpace$2 = factorySpace$h;
    var thematicBreak$4 = {
      name: "thematicBreak",
      tokenize: tokenizeThematicBreak
    };
    function tokenizeThematicBreak(effects, ok2, nok) {
      var size = 0;
      var marker;
      return start2;
      function start2(code2) {
        effects.enter("thematicBreak");
        marker = code2;
        return atBreak(code2);
      }
      function atBreak(code2) {
        if (code2 === marker) {
          effects.enter("thematicBreakSequence");
          return sequence(code2);
        }
        if (markdownSpace$1(code2)) {
          return factorySpace$2(effects, atBreak, "whitespace")(code2);
        }
        if (size < 3 || code2 !== null && !markdownLineEnding$2(code2)) {
          return nok(code2);
        }
        effects.exit("thematicBreak");
        return ok2(code2);
      }
      function sequence(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          size++;
          return sequence;
        }
        effects.exit("thematicBreakSequence");
        return atBreak(code2);
      }
    }
    var thematicBreak_1$1 = thematicBreak$4;
    var asciiDigit = asciiDigit_1;
    var markdownSpace = markdownSpace_1;
    var prefixSize$1 = prefixSize_1;
    var sizeChunks = sizeChunks_1;
    var factorySpace$1 = factorySpace$h;
    var partialBlankLine = partialBlankLine_1;
    var thematicBreak$3 = thematicBreak_1$1;
    var list$3 = {
      name: "list",
      tokenize: tokenizeListStart,
      continuation: {
        tokenize: tokenizeListContinuation
      },
      exit: tokenizeListEnd
    };
    var listItemPrefixWhitespaceConstruct = {
      tokenize: tokenizeListItemPrefixWhitespace,
      partial: true
    };
    var indentConstruct = {
      tokenize: tokenizeIndent,
      partial: true
    };
    function tokenizeListStart(effects, ok2, nok) {
      var self2 = this;
      var initialSize = prefixSize$1(self2.events, "linePrefix");
      var size = 0;
      return start2;
      function start2(code2) {
        var kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
        if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
          if (!self2.containerState.type) {
            self2.containerState.type = kind;
            effects.enter(kind, {
              _container: true
            });
          }
          if (kind === "listUnordered") {
            effects.enter("listItemPrefix");
            return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$3, nok, atMarker)(code2) : atMarker(code2);
          }
          if (!self2.interrupt || code2 === 49) {
            effects.enter("listItemPrefix");
            effects.enter("listItemValue");
            return inside(code2);
          }
        }
        return nok(code2);
      }
      function inside(code2) {
        if (asciiDigit(code2) && ++size < 10) {
          effects.consume(code2);
          return inside;
        }
        if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
          effects.exit("listItemValue");
          return atMarker(code2);
        }
        return nok(code2);
      }
      function atMarker(code2) {
        effects.enter("listItemMarker");
        effects.consume(code2);
        effects.exit("listItemMarker");
        self2.containerState.marker = self2.containerState.marker || code2;
        return effects.check(
          partialBlankLine,
          // Can’t be empty when interrupting.
          self2.interrupt ? nok : onBlank,
          effects.attempt(
            listItemPrefixWhitespaceConstruct,
            endOfPrefix,
            otherPrefix
          )
        );
      }
      function onBlank(code2) {
        self2.containerState.initialBlankLine = true;
        initialSize++;
        return endOfPrefix(code2);
      }
      function otherPrefix(code2) {
        if (markdownSpace(code2)) {
          effects.enter("listItemPrefixWhitespace");
          effects.consume(code2);
          effects.exit("listItemPrefixWhitespace");
          return endOfPrefix;
        }
        return nok(code2);
      }
      function endOfPrefix(code2) {
        self2.containerState.size = initialSize + sizeChunks(self2.sliceStream(effects.exit("listItemPrefix")));
        return ok2(code2);
      }
    }
    function tokenizeListContinuation(effects, ok2, nok) {
      var self2 = this;
      self2.containerState._closeFlow = void 0;
      return effects.check(partialBlankLine, onBlank, notBlank);
      function onBlank(code2) {
        self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
        return factorySpace$1(
          effects,
          ok2,
          "listItemIndent",
          self2.containerState.size + 1
        )(code2);
      }
      function notBlank(code2) {
        if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
          self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = void 0;
          return notInCurrentItem(code2);
        }
        self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = void 0;
        return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
      }
      function notInCurrentItem(code2) {
        self2.containerState._closeFlow = true;
        self2.interrupt = void 0;
        return factorySpace$1(
          effects,
          effects.attempt(list$3, ok2, nok),
          "linePrefix",
          self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
        )(code2);
      }
    }
    function tokenizeIndent(effects, ok2, nok) {
      var self2 = this;
      return factorySpace$1(
        effects,
        afterPrefix,
        "listItemIndent",
        self2.containerState.size + 1
      );
      function afterPrefix(code2) {
        return prefixSize$1(self2.events, "listItemIndent") === self2.containerState.size ? ok2(code2) : nok(code2);
      }
    }
    function tokenizeListEnd(effects) {
      effects.exit(this.containerState.type);
    }
    function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
      var self2 = this;
      return factorySpace$1(
        effects,
        afterPrefix,
        "listItemPrefixWhitespace",
        self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4 + 1
      );
      function afterPrefix(code2) {
        return markdownSpace(code2) || !prefixSize$1(self2.events, "listItemPrefixWhitespace") ? nok(code2) : ok2(code2);
      }
    }
    var list_1$1 = list$3;
    var markdownLineEnding$1 = markdownLineEnding_1;
    var shallow$1 = shallow_1;
    var factorySpace = factorySpace$h;
    var setextUnderline$1 = {
      name: "setextUnderline",
      tokenize: tokenizeSetextUnderline,
      resolveTo: resolveToSetextUnderline
    };
    function resolveToSetextUnderline(events, context) {
      var index2 = events.length;
      var content2;
      var text2;
      var definition2;
      var heading2;
      while (index2--) {
        if (events[index2][0] === "enter") {
          if (events[index2][1].type === "content") {
            content2 = index2;
            break;
          }
          if (events[index2][1].type === "paragraph") {
            text2 = index2;
          }
        } else {
          if (events[index2][1].type === "content") {
            events.splice(index2, 1);
          }
          if (!definition2 && events[index2][1].type === "definition") {
            definition2 = index2;
          }
        }
      }
      heading2 = {
        type: "setextHeading",
        start: shallow$1(events[text2][1].start),
        end: shallow$1(events[events.length - 1][1].end)
      };
      events[text2][1].type = "setextHeadingText";
      if (definition2) {
        events.splice(text2, 0, ["enter", heading2, context]);
        events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]);
        events[content2][1].end = shallow$1(events[definition2][1].end);
      } else {
        events[content2][1] = heading2;
      }
      events.push(["exit", heading2, context]);
      return events;
    }
    function tokenizeSetextUnderline(effects, ok2, nok) {
      var self2 = this;
      var index2 = self2.events.length;
      var marker;
      var paragraph2;
      while (index2--) {
        if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
          paragraph2 = self2.events[index2][1].type === "paragraph";
          break;
        }
      }
      return start2;
      function start2(code2) {
        if (!self2.lazy && (self2.interrupt || paragraph2)) {
          effects.enter("setextHeadingLine");
          effects.enter("setextHeadingLineSequence");
          marker = code2;
          return closingSequence(code2);
        }
        return nok(code2);
      }
      function closingSequence(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          return closingSequence;
        }
        effects.exit("setextHeadingLineSequence");
        return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code2);
      }
      function closingSequenceEnd(code2) {
        if (code2 === null || markdownLineEnding$1(code2)) {
          effects.exit("setextHeadingLine");
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    var setextUnderline_1 = setextUnderline$1;
    Object.defineProperty(constructs$1, "__esModule", { value: true });
    var text$1$1 = text$5;
    var attention = attention_1;
    var autolink$1 = autolink_1;
    var blockQuote = blockQuote_1;
    var characterEscape = characterEscape_1;
    var characterReference = characterReference_1;
    var codeFenced = codeFenced_1;
    var codeIndented = codeIndented_1;
    var codeText = codeText_1;
    var definition = definition_1;
    var hardBreakEscape = hardBreakEscape_1;
    var headingAtx = headingAtx_1;
    var htmlFlow = htmlFlow_1;
    var htmlText = htmlText_1;
    var labelEnd = labelEnd_1;
    var labelStartImage = labelStartImage_1;
    var labelStartLink = labelStartLink_1;
    var lineEnding = lineEnding_1;
    var list$2 = list_1$1;
    var setextUnderline = setextUnderline_1;
    var thematicBreak$2 = thematicBreak_1$1;
    var document$2 = {
      42: list$2,
      // Asterisk
      43: list$2,
      // Plus sign
      45: list$2,
      // Dash
      48: list$2,
      // 0
      49: list$2,
      // 1
      50: list$2,
      // 2
      51: list$2,
      // 3
      52: list$2,
      // 4
      53: list$2,
      // 5
      54: list$2,
      // 6
      55: list$2,
      // 7
      56: list$2,
      // 8
      57: list$2,
      // 9
      62: blockQuote
      // Greater than
    };
    var contentInitial = {
      91: definition
      // Left square bracket
    };
    var flowInitial = {
      "-2": codeIndented,
      // Horizontal tab
      "-1": codeIndented,
      // Virtual space
      32: codeIndented
      // Space
    };
    var flow$1 = {
      35: headingAtx,
      // Number sign
      42: thematicBreak$2,
      // Asterisk
      45: [setextUnderline, thematicBreak$2],
      // Dash
      60: htmlFlow,
      // Less than
      61: setextUnderline,
      // Equals to
      95: thematicBreak$2,
      // Underscore
      96: codeFenced,
      // Grave accent
      126: codeFenced
      // Tilde
    };
    var string = {
      38: characterReference,
      // Ampersand
      92: characterEscape
      // Backslash
    };
    var text$3 = {
      "-5": lineEnding,
      // Carriage return
      "-4": lineEnding,
      // Line feed
      "-3": lineEnding,
      // Carriage return + line feed
      33: labelStartImage,
      // Exclamation mark
      38: characterReference,
      // Ampersand
      42: attention,
      // Asterisk
      60: [autolink$1, htmlText],
      // Less than
      91: labelStartLink,
      // Left square bracket
      92: [hardBreakEscape, characterEscape],
      // Backslash
      93: labelEnd,
      // Right square bracket
      95: attention,
      // Underscore
      96: codeText
      // Grave accent
    };
    var insideSpan = {
      null: [attention, text$1$1.resolver]
    };
    var disable = {
      null: []
    };
    constructs$1.contentInitial = contentInitial;
    constructs$1.disable = disable;
    constructs$1.document = document$2;
    constructs$1.flow = flow$1;
    constructs$1.flowInitial = flowInitial;
    constructs$1.insideSpan = insideSpan;
    constructs$1.string = string;
    constructs$1.text = text$3;
    var content = content$3;
    var document$1 = document$3;
    var flow = flow$2;
    var text$2 = text$5;
    var combineExtensions = combineExtensions_1;
    var createTokenizer = createTokenizer_1;
    var miniflat = miniflat_1;
    var constructs = constructs$1;
    function parse(options) {
      var settings = options || {};
      var parser2 = {
        defined: [],
        constructs: combineExtensions(
          [constructs].concat(miniflat(settings.extensions))
        ),
        content: create2(content),
        document: create2(document$1),
        flow: create2(flow),
        string: create2(text$2.string),
        text: create2(text$2.text)
      };
      return parser2;
      function create2(initializer) {
        return creator;
        function creator(from2) {
          return createTokenizer(parser2, initializer, from2);
        }
      }
    }
    var parse_1 = parse;
    var search$1 = /[\0\t\n\r]/g;
    function preprocess() {
      var start2 = true;
      var column2 = 1;
      var buffer2 = "";
      var atCarriageReturn;
      return preprocessor2;
      function preprocessor2(value, encoding, end2) {
        var chunks = [];
        var match2;
        var next2;
        var startPosition;
        var endPosition;
        var code2;
        value = buffer2 + value.toString(encoding);
        startPosition = 0;
        buffer2 = "";
        if (start2) {
          if (value.charCodeAt(0) === 65279) {
            startPosition++;
          }
          start2 = void 0;
        }
        while (startPosition < value.length) {
          search$1.lastIndex = startPosition;
          match2 = search$1.exec(value);
          endPosition = match2 ? match2.index : value.length;
          code2 = value.charCodeAt(endPosition);
          if (!match2) {
            buffer2 = value.slice(startPosition);
            break;
          }
          if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
            chunks.push(-3);
            atCarriageReturn = void 0;
          } else {
            if (atCarriageReturn) {
              chunks.push(-5);
              atCarriageReturn = void 0;
            }
            if (startPosition < endPosition) {
              chunks.push(value.slice(startPosition, endPosition));
              column2 += endPosition - startPosition;
            }
            if (code2 === 0) {
              chunks.push(65533);
              column2++;
            } else if (code2 === 9) {
              next2 = Math.ceil(column2 / 4) * 4;
              chunks.push(-2);
              while (column2++ < next2)
                chunks.push(-1);
            } else if (code2 === 10) {
              chunks.push(-4);
              column2 = 1;
            } else {
              atCarriageReturn = true;
              column2 = 1;
            }
          }
          startPosition = endPosition + 1;
        }
        if (end2) {
          if (atCarriageReturn)
            chunks.push(-5);
          if (buffer2)
            chunks.push(buffer2);
          chunks.push(null);
        }
        return chunks;
      }
    }
    var preprocess_1 = preprocess;
    var subtokenize = subtokenize_1;
    function postprocess$1(events) {
      while (!subtokenize(events)) {
      }
      return events;
    }
    var postprocess_1 = postprocess$1;
    var dist$1 = fromMarkdown$4;
    var toString$1 = mdastUtilToString;
    var assign = assign_1;
    var own$3 = hasOwnProperty$5;
    var normalizeIdentifier = normalizeIdentifier_1;
    var safeFromInt = safeFromInt_1;
    var parser = parse_1;
    var preprocessor = preprocess_1;
    var postprocess = postprocess_1;
    var decode$1 = decodeEntity_browser;
    var stringifyPosition = unistUtilStringifyPosition;
    function fromMarkdown$4(value, encoding, options) {
      if (typeof encoding !== "string") {
        options = encoding;
        encoding = void 0;
      }
      return compiler(options)(
        postprocess(
          parser(options).document().write(preprocessor()(value, encoding, true))
        )
      );
    }
    function compiler(options) {
      var settings = options || {};
      var config = configure$1(
        {
          transforms: [],
          canContainEols: [
            "emphasis",
            "fragment",
            "heading",
            "paragraph",
            "strong"
          ],
          enter: {
            autolink: opener(link2),
            autolinkProtocol: onenterdata,
            autolinkEmail: onenterdata,
            atxHeading: opener(heading2),
            blockQuote: opener(blockQuote2),
            characterEscape: onenterdata,
            characterReference: onenterdata,
            codeFenced: opener(codeFlow),
            codeFencedFenceInfo: buffer2,
            codeFencedFenceMeta: buffer2,
            codeIndented: opener(codeFlow, buffer2),
            codeText: opener(codeText2, buffer2),
            codeTextData: onenterdata,
            data: onenterdata,
            codeFlowValue: onenterdata,
            definition: opener(definition2),
            definitionDestinationString: buffer2,
            definitionLabelString: buffer2,
            definitionTitleString: buffer2,
            emphasis: opener(emphasis2),
            hardBreakEscape: opener(hardBreak2),
            hardBreakTrailing: opener(hardBreak2),
            htmlFlow: opener(html2, buffer2),
            htmlFlowData: onenterdata,
            htmlText: opener(html2, buffer2),
            htmlTextData: onenterdata,
            image: opener(image2),
            label: buffer2,
            link: opener(link2),
            listItem: opener(listItem2),
            listItemValue: onenterlistitemvalue,
            listOrdered: opener(list2, onenterlistordered),
            listUnordered: opener(list2),
            paragraph: opener(paragraph2),
            reference: onenterreference,
            referenceString: buffer2,
            resourceDestinationString: buffer2,
            resourceTitleString: buffer2,
            setextHeading: opener(heading2),
            strong: opener(strong2),
            thematicBreak: opener(thematicBreak2)
          },
          exit: {
            atxHeading: closer(),
            atxHeadingSequence: onexitatxheadingsequence,
            autolink: closer(),
            autolinkEmail: onexitautolinkemail,
            autolinkProtocol: onexitautolinkprotocol,
            blockQuote: closer(),
            characterEscapeValue: onexitdata,
            characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
            characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
            characterReferenceValue: onexitcharacterreferencevalue,
            codeFenced: closer(onexitcodefenced),
            codeFencedFence: onexitcodefencedfence,
            codeFencedFenceInfo: onexitcodefencedfenceinfo,
            codeFencedFenceMeta: onexitcodefencedfencemeta,
            codeFlowValue: onexitdata,
            codeIndented: closer(onexitcodeindented),
            codeText: closer(onexitcodetext),
            codeTextData: onexitdata,
            data: onexitdata,
            definition: closer(),
            definitionDestinationString: onexitdefinitiondestinationstring,
            definitionLabelString: onexitdefinitionlabelstring,
            definitionTitleString: onexitdefinitiontitlestring,
            emphasis: closer(),
            hardBreakEscape: closer(onexithardbreak),
            hardBreakTrailing: closer(onexithardbreak),
            htmlFlow: closer(onexithtmlflow),
            htmlFlowData: onexitdata,
            htmlText: closer(onexithtmltext),
            htmlTextData: onexitdata,
            image: closer(onexitimage),
            label: onexitlabel,
            labelText: onexitlabeltext,
            lineEnding: onexitlineending,
            link: closer(onexitlink),
            listItem: closer(),
            listOrdered: closer(),
            listUnordered: closer(),
            paragraph: closer(),
            referenceString: onexitreferencestring,
            resourceDestinationString: onexitresourcedestinationstring,
            resourceTitleString: onexitresourcetitlestring,
            resource: onexitresource,
            setextHeading: closer(onexitsetextheading),
            setextHeadingLineSequence: onexitsetextheadinglinesequence,
            setextHeadingText: onexitsetextheadingtext,
            strong: closer(),
            thematicBreak: closer()
          }
        },
        settings.mdastExtensions || []
      );
      var data2 = {};
      return compile2;
      function compile2(events) {
        var tree = { type: "root", children: [] };
        var stack = [tree];
        var tokenStack = [];
        var listStack = [];
        var index2 = -1;
        var handler;
        var listStart;
        var context = {
          stack,
          tokenStack,
          config,
          enter,
          exit: exit2,
          buffer: buffer2,
          resume,
          setData,
          getData
        };
        while (++index2 < events.length) {
          if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
            if (events[index2][0] === "enter") {
              listStack.push(index2);
            } else {
              listStart = listStack.pop(index2);
              index2 = prepareList(events, listStart, index2);
            }
          }
        }
        index2 = -1;
        while (++index2 < events.length) {
          handler = config[events[index2][0]];
          if (own$3.call(handler, events[index2][1].type)) {
            handler[events[index2][1].type].call(
              assign({ sliceSerialize: events[index2][2].sliceSerialize }, context),
              events[index2][1]
            );
          }
        }
        if (tokenStack.length) {
          throw new Error(
            "Cannot close document, a token (`" + tokenStack[tokenStack.length - 1].type + "`, " + stringifyPosition({
              start: tokenStack[tokenStack.length - 1].start,
              end: tokenStack[tokenStack.length - 1].end
            }) + ") is still open"
          );
        }
        tree.position = {
          start: point2(
            events.length ? events[0][1].start : { line: 1, column: 1, offset: 0 }
          ),
          end: point2(
            events.length ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
          )
        };
        index2 = -1;
        while (++index2 < config.transforms.length) {
          tree = config.transforms[index2](tree) || tree;
        }
        return tree;
      }
      function prepareList(events, start2, length2) {
        var index2 = start2 - 1;
        var containerBalance = -1;
        var listSpread = false;
        var listItem3;
        var tailIndex;
        var lineIndex;
        var tailEvent;
        var event;
        var firstBlankLineIndex;
        var atMarker;
        while (++index2 <= length2) {
          event = events[index2];
          if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
            if (event[0] === "enter") {
              containerBalance++;
            } else {
              containerBalance--;
            }
            atMarker = void 0;
          } else if (event[1].type === "lineEndingBlank") {
            if (event[0] === "enter") {
              if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
                firstBlankLineIndex = index2;
              }
              atMarker = void 0;
            }
          } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace")
            ;
          else {
            atMarker = void 0;
          }
          if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
            if (listItem3) {
              tailIndex = index2;
              lineIndex = void 0;
              while (tailIndex--) {
                tailEvent = events[tailIndex];
                if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
                  if (tailEvent[0] === "exit")
                    continue;
                  if (lineIndex) {
                    events[lineIndex][1].type = "lineEndingBlank";
                    listSpread = true;
                  }
                  tailEvent[1].type = "lineEnding";
                  lineIndex = tailIndex;
                } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")
                  ;
                else {
                  break;
                }
              }
              if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
                listItem3._spread = true;
              }
              listItem3.end = point2(
                lineIndex ? events[lineIndex][1].start : event[1].end
              );
              events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
              index2++;
              length2++;
            }
            if (event[1].type === "listItemPrefix") {
              listItem3 = {
                type: "listItem",
                _spread: false,
                start: point2(event[1].start)
              };
              events.splice(index2, 0, ["enter", listItem3, event[2]]);
              index2++;
              length2++;
              firstBlankLineIndex = void 0;
              atMarker = true;
            }
          }
        }
        events[start2][1]._spread = listSpread;
        return length2;
      }
      function setData(key, value) {
        data2[key] = value;
      }
      function getData(key) {
        return data2[key];
      }
      function point2(d2) {
        return { line: d2.line, column: d2.column, offset: d2.offset };
      }
      function opener(create2, and) {
        return open2;
        function open2(token2) {
          enter.call(this, create2(token2), token2);
          if (and)
            and.call(this, token2);
        }
      }
      function buffer2() {
        this.stack.push({ type: "fragment", children: [] });
      }
      function enter(node2, token2) {
        this.stack[this.stack.length - 1].children.push(node2);
        this.stack.push(node2);
        this.tokenStack.push(token2);
        node2.position = { start: point2(token2.start) };
        return node2;
      }
      function closer(and) {
        return close;
        function close(token2) {
          if (and)
            and.call(this, token2);
          exit2.call(this, token2);
        }
      }
      function exit2(token2) {
        var node2 = this.stack.pop();
        var open2 = this.tokenStack.pop();
        if (!open2) {
          throw new Error(
            "Cannot close `" + token2.type + "` (" + stringifyPosition({ start: token2.start, end: token2.end }) + "): it’s not open"
          );
        } else if (open2.type !== token2.type) {
          throw new Error(
            "Cannot close `" + token2.type + "` (" + stringifyPosition({ start: token2.start, end: token2.end }) + "): a different token (`" + open2.type + "`, " + stringifyPosition({ start: open2.start, end: open2.end }) + ") is open"
          );
        }
        node2.position.end = point2(token2.end);
        return node2;
      }
      function resume() {
        return toString$1(this.stack.pop());
      }
      function onenterlistordered() {
        setData("expectingFirstListItemValue", true);
      }
      function onenterlistitemvalue(token2) {
        if (getData("expectingFirstListItemValue")) {
          this.stack[this.stack.length - 2].start = parseInt(
            this.sliceSerialize(token2),
            10
          );
          setData("expectingFirstListItemValue");
        }
      }
      function onexitcodefencedfenceinfo() {
        var data3 = this.resume();
        this.stack[this.stack.length - 1].lang = data3;
      }
      function onexitcodefencedfencemeta() {
        var data3 = this.resume();
        this.stack[this.stack.length - 1].meta = data3;
      }
      function onexitcodefencedfence() {
        if (getData("flowCodeInside"))
          return;
        this.buffer();
        setData("flowCodeInside", true);
      }
      function onexitcodefenced() {
        var data3 = this.resume();
        this.stack[this.stack.length - 1].value = data3.replace(
          /^(\r?\n|\r)|(\r?\n|\r)$/g,
          ""
        );
        setData("flowCodeInside");
      }
      function onexitcodeindented() {
        var data3 = this.resume();
        this.stack[this.stack.length - 1].value = data3;
      }
      function onexitdefinitionlabelstring(token2) {
        var label = this.resume();
        this.stack[this.stack.length - 1].label = label;
        this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
          this.sliceSerialize(token2)
        ).toLowerCase();
      }
      function onexitdefinitiontitlestring() {
        var data3 = this.resume();
        this.stack[this.stack.length - 1].title = data3;
      }
      function onexitdefinitiondestinationstring() {
        var data3 = this.resume();
        this.stack[this.stack.length - 1].url = data3;
      }
      function onexitatxheadingsequence(token2) {
        if (!this.stack[this.stack.length - 1].depth) {
          this.stack[this.stack.length - 1].depth = this.sliceSerialize(
            token2
          ).length;
        }
      }
      function onexitsetextheadingtext() {
        setData("setextHeadingSlurpLineEnding", true);
      }
      function onexitsetextheadinglinesequence(token2) {
        this.stack[this.stack.length - 1].depth = this.sliceSerialize(token2).charCodeAt(0) === 61 ? 1 : 2;
      }
      function onexitsetextheading() {
        setData("setextHeadingSlurpLineEnding");
      }
      function onenterdata(token2) {
        var siblings = this.stack[this.stack.length - 1].children;
        var tail = siblings[siblings.length - 1];
        if (!tail || tail.type !== "text") {
          tail = text2();
          tail.position = { start: point2(token2.start) };
          this.stack[this.stack.length - 1].children.push(tail);
        }
        this.stack.push(tail);
      }
      function onexitdata(token2) {
        var tail = this.stack.pop();
        tail.value += this.sliceSerialize(token2);
        tail.position.end = point2(token2.end);
      }
      function onexitlineending(token2) {
        var context = this.stack[this.stack.length - 1];
        if (getData("atHardBreak")) {
          context.children[context.children.length - 1].position.end = point2(
            token2.end
          );
          setData("atHardBreak");
          return;
        }
        if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.indexOf(context.type) > -1) {
          onenterdata.call(this, token2);
          onexitdata.call(this, token2);
        }
      }
      function onexithardbreak() {
        setData("atHardBreak", true);
      }
      function onexithtmlflow() {
        var data3 = this.resume();
        this.stack[this.stack.length - 1].value = data3;
      }
      function onexithtmltext() {
        var data3 = this.resume();
        this.stack[this.stack.length - 1].value = data3;
      }
      function onexitcodetext() {
        var data3 = this.resume();
        this.stack[this.stack.length - 1].value = data3;
      }
      function onexitlink() {
        var context = this.stack[this.stack.length - 1];
        if (getData("inReference")) {
          context.type += "Reference";
          context.referenceType = getData("referenceType") || "shortcut";
          delete context.url;
          delete context.title;
        } else {
          delete context.identifier;
          delete context.label;
          delete context.referenceType;
        }
        setData("referenceType");
      }
      function onexitimage() {
        var context = this.stack[this.stack.length - 1];
        if (getData("inReference")) {
          context.type += "Reference";
          context.referenceType = getData("referenceType") || "shortcut";
          delete context.url;
          delete context.title;
        } else {
          delete context.identifier;
          delete context.label;
          delete context.referenceType;
        }
        setData("referenceType");
      }
      function onexitlabeltext(token2) {
        this.stack[this.stack.length - 2].identifier = normalizeIdentifier(
          this.sliceSerialize(token2)
        ).toLowerCase();
      }
      function onexitlabel() {
        var fragment = this.stack[this.stack.length - 1];
        var value = this.resume();
        this.stack[this.stack.length - 1].label = value;
        setData("inReference", true);
        if (this.stack[this.stack.length - 1].type === "link") {
          this.stack[this.stack.length - 1].children = fragment.children;
        } else {
          this.stack[this.stack.length - 1].alt = value;
        }
      }
      function onexitresourcedestinationstring() {
        var data3 = this.resume();
        this.stack[this.stack.length - 1].url = data3;
      }
      function onexitresourcetitlestring() {
        var data3 = this.resume();
        this.stack[this.stack.length - 1].title = data3;
      }
      function onexitresource() {
        setData("inReference");
      }
      function onenterreference() {
        setData("referenceType", "collapsed");
      }
      function onexitreferencestring(token2) {
        var label = this.resume();
        this.stack[this.stack.length - 1].label = label;
        this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
          this.sliceSerialize(token2)
        ).toLowerCase();
        setData("referenceType", "full");
      }
      function onexitcharacterreferencemarker(token2) {
        setData("characterReferenceType", token2.type);
      }
      function onexitcharacterreferencevalue(token2) {
        var data3 = this.sliceSerialize(token2);
        var type2 = getData("characterReferenceType");
        var value;
        var tail;
        if (type2) {
          value = safeFromInt(
            data3,
            type2 === "characterReferenceMarkerNumeric" ? 10 : 16
          );
          setData("characterReferenceType");
        } else {
          value = decode$1(data3);
        }
        tail = this.stack.pop();
        tail.value += value;
        tail.position.end = point2(token2.end);
      }
      function onexitautolinkprotocol(token2) {
        onexitdata.call(this, token2);
        this.stack[this.stack.length - 1].url = this.sliceSerialize(token2);
      }
      function onexitautolinkemail(token2) {
        onexitdata.call(this, token2);
        this.stack[this.stack.length - 1].url = "mailto:" + this.sliceSerialize(token2);
      }
      function blockQuote2() {
        return { type: "blockquote", children: [] };
      }
      function codeFlow() {
        return { type: "code", lang: null, meta: null, value: "" };
      }
      function codeText2() {
        return { type: "inlineCode", value: "" };
      }
      function definition2() {
        return {
          type: "definition",
          identifier: "",
          label: null,
          title: null,
          url: ""
        };
      }
      function emphasis2() {
        return { type: "emphasis", children: [] };
      }
      function heading2() {
        return { type: "heading", depth: void 0, children: [] };
      }
      function hardBreak2() {
        return { type: "break" };
      }
      function html2() {
        return { type: "html", value: "" };
      }
      function image2() {
        return { type: "image", title: null, url: "", alt: null };
      }
      function link2() {
        return { type: "link", title: null, url: "", children: [] };
      }
      function list2(token2) {
        return {
          type: "list",
          ordered: token2.type === "listOrdered",
          start: null,
          spread: token2._spread,
          children: []
        };
      }
      function listItem2(token2) {
        return {
          type: "listItem",
          spread: token2._spread,
          checked: null,
          children: []
        };
      }
      function paragraph2() {
        return { type: "paragraph", children: [] };
      }
      function strong2() {
        return { type: "strong", children: [] };
      }
      function text2() {
        return { type: "text", value: "" };
      }
      function thematicBreak2() {
        return { type: "thematicBreak" };
      }
    }
    function configure$1(config, extensions) {
      var index2 = -1;
      while (++index2 < extensions.length) {
        extension$1(config, extensions[index2]);
      }
      return config;
    }
    function extension$1(config, extension2) {
      var key;
      var left;
      for (key in extension2) {
        left = own$3.call(config, key) ? config[key] : config[key] = {};
        if (key === "canContainEols" || key === "transforms") {
          config[key] = [].concat(left, extension2[key]);
        } else {
          Object.assign(left, extension2[key]);
        }
      }
    }
    (function(module2) {
      module2.exports = dist$1;
    })(mdastUtilFromMarkdown);
    var mdastUtilToHastExports = {};
    var mdastUtilToHast = {
      get exports() {
        return mdastUtilToHastExports;
      },
      set exports(v2) {
        mdastUtilToHastExports = v2;
      }
    };
    var unistBuilder = u$c;
    function u$c(type2, props, value) {
      var node2;
      if ((value === null || value === void 0) && (typeof props !== "object" || Array.isArray(props))) {
        value = props;
        props = {};
      }
      node2 = Object.assign({ type: String(type2) }, props);
      if (Array.isArray(value)) {
        node2.children = value;
      } else if (value !== null && value !== void 0) {
        node2.value = String(value);
      }
      return node2;
    }
    var convert_1 = convert$2;
    function convert$2(test) {
      if (test == null) {
        return ok;
      }
      if (typeof test === "string") {
        return typeFactory(test);
      }
      if (typeof test === "object") {
        return "length" in test ? anyFactory(test) : allFactory(test);
      }
      if (typeof test === "function") {
        return test;
      }
      throw new Error("Expected function, string, or object as test");
    }
    function allFactory(test) {
      return all2;
      function all2(node2) {
        var key;
        for (key in test) {
          if (node2[key] !== test[key])
            return false;
        }
        return true;
      }
    }
    function anyFactory(tests) {
      var checks2 = [];
      var index2 = -1;
      while (++index2 < tests.length) {
        checks2[index2] = convert$2(tests[index2]);
      }
      return any2;
      function any2() {
        var index3 = -1;
        while (++index3 < checks2.length) {
          if (checks2[index3].apply(this, arguments)) {
            return true;
          }
        }
        return false;
      }
    }
    function typeFactory(test) {
      return type2;
      function type2(node2) {
        return Boolean(node2 && node2.type === test);
      }
    }
    function ok() {
      return true;
    }
    var color_browser = identity;
    function identity(d2) {
      return d2;
    }
    var unistUtilVisitParents = visitParents$1;
    var convert$1 = convert_1;
    var color = color_browser;
    var CONTINUE$1 = true;
    var SKIP$1 = "skip";
    var EXIT$1 = false;
    visitParents$1.CONTINUE = CONTINUE$1;
    visitParents$1.SKIP = SKIP$1;
    visitParents$1.EXIT = EXIT$1;
    function visitParents$1(tree, test, visitor, reverse) {
      var step;
      var is2;
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      is2 = convert$1(test);
      step = reverse ? -1 : 1;
      factory2(tree, null, [])();
      function factory2(node2, index2, parents) {
        var value = typeof node2 === "object" && node2 !== null ? node2 : {};
        var name;
        if (typeof value.type === "string") {
          name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
          visit2.displayName = "node (" + color(value.type + (name ? "<" + name + ">" : "")) + ")";
        }
        return visit2;
        function visit2() {
          var grandparents = parents.concat(node2);
          var result = [];
          var subresult;
          var offset2;
          if (!test || is2(node2, index2, parents[parents.length - 1] || null)) {
            result = toResult(visitor(node2, parents));
            if (result[0] === EXIT$1) {
              return result;
            }
          }
          if (node2.children && result[0] !== SKIP$1) {
            offset2 = (reverse ? node2.children.length : -1) + step;
            while (offset2 > -1 && offset2 < node2.children.length) {
              subresult = factory2(node2.children[offset2], offset2, grandparents)();
              if (subresult[0] === EXIT$1) {
                return subresult;
              }
              offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
            }
          }
          return result;
        }
      }
    }
    function toResult(value) {
      if (value !== null && typeof value === "object" && "length" in value) {
        return value;
      }
      if (typeof value === "number") {
        return [CONTINUE$1, value];
      }
      return [value];
    }
    var unistUtilVisit = visit$3;
    var visitParents = unistUtilVisitParents;
    var CONTINUE = visitParents.CONTINUE;
    var SKIP = visitParents.SKIP;
    var EXIT = visitParents.EXIT;
    visit$3.CONTINUE = CONTINUE;
    visit$3.SKIP = SKIP;
    visit$3.EXIT = EXIT;
    function visit$3(tree, test, visitor, reverse) {
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      visitParents(tree, test, overload, reverse);
      function overload(node2, parents) {
        var parent = parents[parents.length - 1];
        var index2 = parent ? parent.children.indexOf(node2) : null;
        return visitor(node2, index2, parent);
      }
    }
    var start = factory$1("start");
    var end = factory$1("end");
    var unistUtilPosition = position$2;
    position$2.start = start;
    position$2.end = end;
    function position$2(node2) {
      return { start: start(node2), end: end(node2) };
    }
    function factory$1(type2) {
      point2.displayName = type2;
      return point2;
      function point2(node2) {
        var point3 = node2 && node2.position && node2.position[type2] || {};
        return {
          line: point3.line || null,
          column: point3.column || null,
          offset: isNaN(point3.offset) ? null : point3.offset
        };
      }
    }
    var unistUtilGenerated = generated$1;
    function generated$1(node2) {
      return !node2 || !node2.position || !node2.position.start || !node2.position.start.line || !node2.position.start.column || !node2.position.end || !node2.position.end.line || !node2.position.end.column;
    }
    var visit$2 = unistUtilVisit;
    var mdastUtilDefinitions = getDefinitionFactory;
    var own$2 = {}.hasOwnProperty;
    function getDefinitionFactory(node2, options) {
      return getterFactory(gather(node2));
    }
    function gather(node2) {
      var cache2 = {};
      if (!node2 || !node2.type) {
        throw new Error("mdast-util-definitions expected node");
      }
      visit$2(node2, "definition", ondefinition);
      return cache2;
      function ondefinition(definition2) {
        var id2 = normalise(definition2.identifier);
        if (!own$2.call(cache2, id2)) {
          cache2[id2] = definition2;
        }
      }
    }
    function getterFactory(cache2) {
      return getter;
      function getter(identifier2) {
        var id2 = identifier2 && normalise(identifier2);
        return id2 && own$2.call(cache2, id2) ? cache2[id2] : null;
      }
    }
    function normalise(identifier2) {
      return identifier2.toUpperCase();
    }
    var all_1;
    var hasRequiredAll;
    function requireAll() {
      if (hasRequiredAll)
        return all_1;
      hasRequiredAll = 1;
      all_1 = all2;
      var one2 = requireOne();
      function all2(h2, parent) {
        var nodes = parent.children || [];
        var length2 = nodes.length;
        var values = [];
        var index2 = -1;
        var result;
        var head;
        while (++index2 < length2) {
          result = one2(h2, nodes[index2], parent);
          if (result) {
            if (index2 && nodes[index2 - 1].type === "break") {
              if (result.value) {
                result.value = result.value.replace(/^\s+/, "");
              }
              head = result.children && result.children[0];
              if (head && head.value) {
                head.value = head.value.replace(/^\s+/, "");
              }
            }
            values = values.concat(result);
          }
        }
        return values;
      }
      return all_1;
    }
    var one_1;
    var hasRequiredOne;
    function requireOne() {
      if (hasRequiredOne)
        return one_1;
      hasRequiredOne = 1;
      one_1 = one2;
      var u2 = unistBuilder;
      var all2 = requireAll();
      var own2 = {}.hasOwnProperty;
      function unknown(h2, node2) {
        if (text2(node2)) {
          return h2.augment(node2, u2("text", node2.value));
        }
        return h2(node2, "div", all2(h2, node2));
      }
      function one2(h2, node2, parent) {
        var type2 = node2 && node2.type;
        var fn;
        if (!type2) {
          throw new Error("Expected node, got `" + node2 + "`");
        }
        if (own2.call(h2.handlers, type2)) {
          fn = h2.handlers[type2];
        } else if (h2.passThrough && h2.passThrough.indexOf(type2) > -1) {
          fn = returnNode;
        } else {
          fn = h2.unknownHandler;
        }
        return (typeof fn === "function" ? fn : unknown)(h2, node2, parent);
      }
      function text2(node2) {
        var data2 = node2.data || {};
        if (own2.call(data2, "hName") || own2.call(data2, "hProperties") || own2.call(data2, "hChildren")) {
          return false;
        }
        return "value" in node2;
      }
      function returnNode(h2, node2) {
        var clone;
        if (node2.children) {
          clone = Object.assign({}, node2);
          clone.children = all2(h2, node2);
          return clone;
        }
        return node2;
      }
      return one_1;
    }
    var thematicBreak_1 = thematicBreak$1;
    function thematicBreak$1(h2, node2) {
      return h2(node2, "hr");
    }
    var wrap_1 = wrap$5;
    var u$b = unistBuilder;
    function wrap$5(nodes, loose) {
      var result = [];
      var index2 = -1;
      var length2 = nodes.length;
      if (loose) {
        result.push(u$b("text", "\n"));
      }
      while (++index2 < length2) {
        if (index2) {
          result.push(u$b("text", "\n"));
        }
        result.push(nodes[index2]);
      }
      if (loose && nodes.length > 0) {
        result.push(u$b("text", "\n"));
      }
      return result;
    }
    var list_1 = list$1;
    var wrap$4 = wrap_1;
    var all$c = requireAll();
    function list$1(h2, node2) {
      var props = {};
      var name = node2.ordered ? "ol" : "ul";
      var items;
      var index2 = -1;
      var length2;
      if (typeof node2.start === "number" && node2.start !== 1) {
        props.start = node2.start;
      }
      items = all$c(h2, node2);
      length2 = items.length;
      while (++index2 < length2) {
        if (items[index2].properties.className && items[index2].properties.className.indexOf("task-list-item") !== -1) {
          props.className = ["contains-task-list"];
          break;
        }
      }
      return h2(node2, name, props, wrap$4(items, true));
    }
    var footer$1 = generateFootnotes;
    var thematicBreak = thematicBreak_1;
    var list = list_1;
    var wrap$3 = wrap_1;
    function generateFootnotes(h2) {
      var footnoteById = h2.footnoteById;
      var footnoteOrder = h2.footnoteOrder;
      var length2 = footnoteOrder.length;
      var index2 = -1;
      var listItems = [];
      var def;
      var backReference;
      var content2;
      var tail;
      while (++index2 < length2) {
        def = footnoteById[footnoteOrder[index2].toUpperCase()];
        if (!def) {
          continue;
        }
        content2 = def.children.concat();
        tail = content2[content2.length - 1];
        backReference = {
          type: "link",
          url: "#fnref-" + def.identifier,
          data: { hProperties: { className: ["footnote-backref"] } },
          children: [{ type: "text", value: "↩" }]
        };
        if (!tail || tail.type !== "paragraph") {
          tail = { type: "paragraph", children: [] };
          content2.push(tail);
        }
        tail.children.push(backReference);
        listItems.push({
          type: "listItem",
          data: { hProperties: { id: "fn-" + def.identifier } },
          children: content2,
          position: def.position
        });
      }
      if (listItems.length === 0) {
        return null;
      }
      return h2(
        null,
        "div",
        { className: ["footnotes"] },
        wrap$3(
          [
            thematicBreak(h2),
            list(h2, { type: "list", ordered: true, children: listItems })
          ],
          true
        )
      );
    }
    var blockquote_1 = blockquote;
    var wrap$2 = wrap_1;
    var all$b = requireAll();
    function blockquote(h2, node2) {
      return h2(node2, "blockquote", wrap$2(all$b(h2, node2), true));
    }
    var _break = hardBreak;
    var u$a = unistBuilder;
    function hardBreak(h2, node2) {
      return [h2(node2, "br"), u$a("text", "\n")];
    }
    var code_1 = code$1;
    var u$9 = unistBuilder;
    function code$1(h2, node2) {
      var value = node2.value ? node2.value + "\n" : "";
      var lang = node2.lang && node2.lang.match(/^[^ \t]+(?=[ \t]|$)/);
      var props = {};
      var code2;
      if (lang) {
        props.className = ["language-" + lang];
      }
      code2 = h2(node2, "code", props, [u$9("text", value)]);
      if (node2.meta) {
        code2.data = { meta: node2.meta };
      }
      return h2(node2.position, "pre", [code2]);
    }
    var _delete = strikethrough$2;
    var all$a = requireAll();
    function strikethrough$2(h2, node2) {
      return h2(node2, "del", all$a(h2, node2));
    }
    var emphasis_1 = emphasis;
    var all$9 = requireAll();
    function emphasis(h2, node2) {
      return h2(node2, "em", all$9(h2, node2));
    }
    var footnoteReference_1 = footnoteReference$1;
    var u$8 = unistBuilder;
    function footnoteReference$1(h2, node2) {
      var footnoteOrder = h2.footnoteOrder;
      var identifier2 = String(node2.identifier);
      if (footnoteOrder.indexOf(identifier2) === -1) {
        footnoteOrder.push(identifier2);
      }
      return h2(node2.position, "sup", { id: "fnref-" + identifier2 }, [
        h2(node2, "a", { href: "#fn-" + identifier2, className: ["footnote-ref"] }, [
          u$8("text", node2.label || identifier2)
        ])
      ]);
    }
    var footnote_1 = footnote;
    var footnoteReference = footnoteReference_1;
    function footnote(h2, node2) {
      var footnoteById = h2.footnoteById;
      var footnoteOrder = h2.footnoteOrder;
      var identifier2 = 1;
      while (identifier2 in footnoteById) {
        identifier2++;
      }
      identifier2 = String(identifier2);
      footnoteOrder.push(identifier2);
      footnoteById[identifier2] = {
        type: "footnoteDefinition",
        identifier: identifier2,
        children: [{ type: "paragraph", children: node2.children }],
        position: node2.position
      };
      return footnoteReference(h2, {
        type: "footnoteReference",
        identifier: identifier2,
        position: node2.position
      });
    }
    var heading_1 = heading;
    var all$8 = requireAll();
    function heading(h2, node2) {
      return h2(node2, "h" + node2.depth, all$8(h2, node2));
    }
    var html_1 = html$2;
    var u$7 = unistBuilder;
    function html$2(h2, node2) {
      return h2.dangerous ? h2.augment(node2, u$7("raw", node2.value)) : null;
    }
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i2, ch2, cache2 = encodeCache[exclude];
      if (cache2) {
        return cache2;
      }
      cache2 = encodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch2 = String.fromCharCode(i2);
        if (/^[0-9a-z]$/i.test(ch2)) {
          cache2.push(ch2);
        } else {
          cache2.push("%" + ("0" + i2.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        cache2[exclude.charCodeAt(i2)] = exclude[i2];
      }
      return cache2;
    }
    function encode$1(string2, exclude, keepEscaped) {
      var i2, l2, code2, nextCode, cache2, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode$1.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache2 = getEncodeCache(exclude);
      for (i2 = 0, l2 = string2.length; i2 < l2; i2++) {
        code2 = string2.charCodeAt(i2);
        if (keepEscaped && code2 === 37 && i2 + 2 < l2) {
          if (/^[0-9a-f]{2}$/i.test(string2.slice(i2 + 1, i2 + 3))) {
            result += string2.slice(i2, i2 + 3);
            i2 += 2;
            continue;
          }
        }
        if (code2 < 128) {
          result += cache2[code2];
          continue;
        }
        if (code2 >= 55296 && code2 <= 57343) {
          if (code2 >= 55296 && code2 <= 56319 && i2 + 1 < l2) {
            nextCode = string2.charCodeAt(i2 + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string2[i2] + string2[i2 + 1]);
              i2++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string2[i2]);
      }
      return result;
    }
    encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode$1.componentChars = "-_.!~*'()";
    var encode_1 = encode$1;
    var revert_1 = revert$2;
    var u$6 = unistBuilder;
    var all$7 = requireAll();
    function revert$2(h2, node2) {
      var subtype = node2.referenceType;
      var suffix = "]";
      var contents;
      var head;
      var tail;
      if (subtype === "collapsed") {
        suffix += "[]";
      } else if (subtype === "full") {
        suffix += "[" + (node2.label || node2.identifier) + "]";
      }
      if (node2.type === "imageReference") {
        return u$6("text", "![" + node2.alt + suffix);
      }
      contents = all$7(h2, node2);
      head = contents[0];
      if (head && head.type === "text") {
        head.value = "[" + head.value;
      } else {
        contents.unshift(u$6("text", "["));
      }
      tail = contents[contents.length - 1];
      if (tail && tail.type === "text") {
        tail.value += suffix;
      } else {
        contents.push(u$6("text", suffix));
      }
      return contents;
    }
    var imageReference_1 = imageReference;
    var normalize$5 = encode_1;
    var revert$1 = revert_1;
    function imageReference(h2, node2) {
      var def = h2.definition(node2.identifier);
      var props;
      if (!def) {
        return revert$1(h2, node2);
      }
      props = { src: normalize$5(def.url || ""), alt: node2.alt };
      if (def.title !== null && def.title !== void 0) {
        props.title = def.title;
      }
      return h2(node2, "img", props);
    }
    var normalize$4 = encode_1;
    var image_1 = image;
    function image(h2, node2) {
      var props = { src: normalize$4(node2.url), alt: node2.alt };
      if (node2.title !== null && node2.title !== void 0) {
        props.title = node2.title;
      }
      return h2(node2, "img", props);
    }
    var inlineCode_1 = inlineCode;
    var u$5 = unistBuilder;
    function inlineCode(h2, node2) {
      var value = node2.value.replace(/\r?\n|\r/g, " ");
      return h2(node2, "code", [u$5("text", value)]);
    }
    var linkReference_1 = linkReference;
    var normalize$3 = encode_1;
    var revert = revert_1;
    var all$6 = requireAll();
    function linkReference(h2, node2) {
      var def = h2.definition(node2.identifier);
      var props;
      if (!def) {
        return revert(h2, node2);
      }
      props = { href: normalize$3(def.url || "") };
      if (def.title !== null && def.title !== void 0) {
        props.title = def.title;
      }
      return h2(node2, "a", props, all$6(h2, node2));
    }
    var normalize$2 = encode_1;
    var all$5 = requireAll();
    var link_1 = link;
    function link(h2, node2) {
      var props = { href: normalize$2(node2.url) };
      if (node2.title !== null && node2.title !== void 0) {
        props.title = node2.title;
      }
      return h2(node2, "a", props, all$5(h2, node2));
    }
    var listItem_1 = listItem;
    var u$4 = unistBuilder;
    var all$4 = requireAll();
    function listItem(h2, node2, parent) {
      var result = all$4(h2, node2);
      var head = result[0];
      var loose = parent ? listLoose(parent) : listItemLoose(node2);
      var props = {};
      var wrapped = [];
      var length2;
      var index2;
      var child;
      if (typeof node2.checked === "boolean") {
        if (!head || head.tagName !== "p") {
          head = h2(null, "p", []);
          result.unshift(head);
        }
        if (head.children.length > 0) {
          head.children.unshift(u$4("text", " "));
        }
        head.children.unshift(
          h2(null, "input", {
            type: "checkbox",
            checked: node2.checked,
            disabled: true
          })
        );
        props.className = ["task-list-item"];
      }
      length2 = result.length;
      index2 = -1;
      while (++index2 < length2) {
        child = result[index2];
        if (loose || index2 !== 0 || child.tagName !== "p") {
          wrapped.push(u$4("text", "\n"));
        }
        if (child.tagName === "p" && !loose) {
          wrapped = wrapped.concat(child.children);
        } else {
          wrapped.push(child);
        }
      }
      if (length2 && (loose || child.tagName !== "p")) {
        wrapped.push(u$4("text", "\n"));
      }
      return h2(node2, "li", props, wrapped);
    }
    function listLoose(node2) {
      var loose = node2.spread;
      var children = node2.children;
      var length2 = children.length;
      var index2 = -1;
      while (!loose && ++index2 < length2) {
        loose = listItemLoose(children[index2]);
      }
      return loose;
    }
    function listItemLoose(node2) {
      var spread2 = node2.spread;
      return spread2 === void 0 || spread2 === null ? node2.children.length > 1 : spread2;
    }
    var paragraph_1 = paragraph;
    var all$3 = requireAll();
    function paragraph(h2, node2) {
      return h2(node2, "p", all$3(h2, node2));
    }
    var root_1 = root$1;
    var u$3 = unistBuilder;
    var wrap$1 = wrap_1;
    var all$2 = requireAll();
    function root$1(h2, node2) {
      return h2.augment(node2, u$3("root", wrap$1(all$2(h2, node2))));
    }
    var strong_1 = strong;
    var all$1 = requireAll();
    function strong(h2, node2) {
      return h2(node2, "strong", all$1(h2, node2));
    }
    var table_1 = table$3;
    var position$1 = unistUtilPosition;
    var wrap = wrap_1;
    var all = requireAll();
    function table$3(h2, node2) {
      var rows = node2.children;
      var index2 = rows.length;
      var align = node2.align || [];
      var alignLength = align.length;
      var result = [];
      var pos;
      var row;
      var out;
      var name;
      var cell;
      while (index2--) {
        row = rows[index2].children;
        name = index2 === 0 ? "th" : "td";
        pos = alignLength || row.length;
        out = [];
        while (pos--) {
          cell = row[pos];
          out[pos] = h2(cell, name, { align: align[pos] }, cell ? all(h2, cell) : []);
        }
        result[index2] = h2(rows[index2], "tr", wrap(out, true));
      }
      return h2(
        node2,
        "table",
        wrap(
          [h2(result[0].position, "thead", wrap([result[0]], true))].concat(
            result[1] ? h2(
              {
                start: position$1.start(result[1]),
                end: position$1.end(result[result.length - 1])
              },
              "tbody",
              wrap(result.slice(1), true)
            ) : []
          ),
          true
        )
      );
    }
    var text_1 = text$1;
    var u$2 = unistBuilder;
    function text$1(h2, node2) {
      return h2.augment(
        node2,
        u$2("text", String(node2.value).replace(/[ \t]*(\r?\n|\r)[ \t]*/g, "$1"))
      );
    }
    var handlers$1 = {
      blockquote: blockquote_1,
      break: _break,
      code: code_1,
      delete: _delete,
      emphasis: emphasis_1,
      footnoteReference: footnoteReference_1,
      footnote: footnote_1,
      heading: heading_1,
      html: html_1,
      imageReference: imageReference_1,
      image: image_1,
      inlineCode: inlineCode_1,
      linkReference: linkReference_1,
      link: link_1,
      listItem: listItem_1,
      list: list_1,
      paragraph: paragraph_1,
      root: root_1,
      strong: strong_1,
      table: table_1,
      text: text_1,
      thematicBreak: thematicBreak_1,
      toml: ignore,
      yaml: ignore,
      definition: ignore,
      footnoteDefinition: ignore
    };
    function ignore() {
      return null;
    }
    var lib$2 = toHast;
    var u$1 = unistBuilder;
    var visit$1 = unistUtilVisit;
    var position = unistUtilPosition;
    var generated = unistUtilGenerated;
    var definitions = mdastUtilDefinitions;
    var one = requireOne();
    var footer = footer$1;
    var handlers = handlers$1;
    var own$1 = {}.hasOwnProperty;
    var deprecationWarningIssued = false;
    function factory(tree, options) {
      var settings = options || {};
      if (settings.allowDangerousHTML !== void 0 && !deprecationWarningIssued) {
        deprecationWarningIssued = true;
        console.warn(
          "mdast-util-to-hast: deprecation: `allowDangerousHTML` is nonstandard, use `allowDangerousHtml` instead"
        );
      }
      var dangerous = settings.allowDangerousHtml || settings.allowDangerousHTML;
      var footnoteById = {};
      h2.dangerous = dangerous;
      h2.definition = definitions(tree);
      h2.footnoteById = footnoteById;
      h2.footnoteOrder = [];
      h2.augment = augment;
      h2.handlers = Object.assign({}, handlers, settings.handlers);
      h2.unknownHandler = settings.unknownHandler;
      h2.passThrough = settings.passThrough;
      visit$1(tree, "footnoteDefinition", onfootnotedefinition);
      return h2;
      function augment(left, right) {
        var data2;
        var ctx;
        if (left && left.data) {
          data2 = left.data;
          if (data2.hName) {
            if (right.type !== "element") {
              right = {
                type: "element",
                tagName: "",
                properties: {},
                children: []
              };
            }
            right.tagName = data2.hName;
          }
          if (right.type === "element" && data2.hProperties) {
            right.properties = Object.assign({}, right.properties, data2.hProperties);
          }
          if (right.children && data2.hChildren) {
            right.children = data2.hChildren;
          }
        }
        ctx = left && left.position ? left : { position: left };
        if (!generated(ctx)) {
          right.position = {
            start: position.start(ctx),
            end: position.end(ctx)
          };
        }
        return right;
      }
      function h2(node2, tagName, props, children) {
        if ((children === void 0 || children === null) && typeof props === "object" && "length" in props) {
          children = props;
          props = {};
        }
        return augment(node2, {
          type: "element",
          tagName,
          properties: props || {},
          children: children || []
        });
      }
      function onfootnotedefinition(definition2) {
        var id2 = String(definition2.identifier).toUpperCase();
        if (!own$1.call(footnoteById, id2)) {
          footnoteById[id2] = definition2;
        }
      }
    }
    function toHast(tree, options) {
      var h2 = factory(tree, options);
      var node2 = one(h2, tree);
      var foot = footer(h2);
      if (foot) {
        node2.children = node2.children.concat(u$1("text", "\n"), foot);
      }
      return node2;
    }
    (function(module2) {
      module2.exports = lib$2;
    })(mdastUtilToHast);
    var propTypesExports = {};
    var propTypes = {
      get exports() {
        return propTypesExports;
      },
      set exports(v2) {
        propTypesExports = v2;
      }
    };
    var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
    var ReactPropTypesSecret = ReactPropTypesSecret_1;
    function emptyFunction() {
    }
    function emptyFunctionWithReset() {
    }
    emptyFunctionWithReset.resetWarningCache = emptyFunction;
    var factoryWithThrowingShims = function() {
      function shim2(props, propName, componentName, location2, propFullName, secret) {
        if (secret === ReactPropTypesSecret) {
          return;
        }
        var err = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        err.name = "Invariant Violation";
        throw err;
      }
      shim2.isRequired = shim2;
      function getShim() {
        return shim2;
      }
      var ReactPropTypes = {
        array: shim2,
        bigint: shim2,
        bool: shim2,
        func: shim2,
        number: shim2,
        object: shim2,
        string: shim2,
        symbol: shim2,
        any: shim2,
        arrayOf: getShim,
        element: shim2,
        elementType: shim2,
        instanceOf: getShim,
        node: shim2,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
    {
      propTypes.exports = factoryWithThrowingShims();
    }
    var immutable = extend$1;
    var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    function extend$1() {
      var target = {};
      for (var i2 = 0; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (hasOwnProperty$3.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
    var schema = Schema$2;
    var proto$1 = Schema$2.prototype;
    proto$1.space = null;
    proto$1.normal = {};
    proto$1.property = {};
    function Schema$2(property2, normal, space) {
      this.property = property2;
      this.normal = normal;
      if (space) {
        this.space = space;
      }
    }
    var xtend = immutable;
    var Schema$1 = schema;
    var merge_1 = merge$3;
    function merge$3(definitions2) {
      var length2 = definitions2.length;
      var property2 = [];
      var normal = [];
      var index2 = -1;
      var info2;
      var space;
      while (++index2 < length2) {
        info2 = definitions2[index2];
        property2.push(info2.property);
        normal.push(info2.normal);
        space = info2.space;
      }
      return new Schema$1(
        xtend.apply(null, property2),
        xtend.apply(null, normal),
        space
      );
    }
    var normalize_1 = normalize$1;
    function normalize$1(value) {
      return value.toLowerCase();
    }
    var info = Info$1;
    var proto = Info$1.prototype;
    proto.space = null;
    proto.attribute = null;
    proto.property = null;
    proto.boolean = false;
    proto.booleanish = false;
    proto.overloadedBoolean = false;
    proto.number = false;
    proto.commaSeparated = false;
    proto.spaceSeparated = false;
    proto.commaOrSpaceSeparated = false;
    proto.mustUseProperty = false;
    proto.defined = false;
    function Info$1(property2, attribute) {
      this.property = property2;
      this.attribute = attribute;
    }
    var types$5 = {};
    var powers = 0;
    types$5.boolean = increment();
    types$5.booleanish = increment();
    types$5.overloadedBoolean = increment();
    types$5.number = increment();
    types$5.spaceSeparated = increment();
    types$5.commaSeparated = increment();
    types$5.commaOrSpaceSeparated = increment();
    function increment() {
      return Math.pow(2, ++powers);
    }
    var Info = info;
    var types$4 = types$5;
    var definedInfo = DefinedInfo$1;
    DefinedInfo$1.prototype = new Info();
    DefinedInfo$1.prototype.defined = true;
    var checks = [
      "boolean",
      "booleanish",
      "overloadedBoolean",
      "number",
      "commaSeparated",
      "spaceSeparated",
      "commaOrSpaceSeparated"
    ];
    var checksLength = checks.length;
    function DefinedInfo$1(property2, attribute, mask, space) {
      var index2 = -1;
      var check;
      mark(this, "space", space);
      Info.call(this, property2, attribute);
      while (++index2 < checksLength) {
        check = checks[index2];
        mark(this, check, (mask & types$4[check]) === types$4[check]);
      }
    }
    function mark(values, key, value) {
      if (value) {
        values[key] = value;
      }
    }
    var normalize = normalize_1;
    var Schema = schema;
    var DefinedInfo = definedInfo;
    var create_1 = create$8;
    function create$8(definition2) {
      var space = definition2.space;
      var mustUseProperty = definition2.mustUseProperty || [];
      var attributes2 = definition2.attributes || {};
      var props = definition2.properties;
      var transform = definition2.transform;
      var property2 = {};
      var normal = {};
      var prop;
      var info2;
      for (prop in props) {
        info2 = new DefinedInfo(
          prop,
          transform(attributes2, prop),
          props[prop],
          space
        );
        if (mustUseProperty.indexOf(prop) !== -1) {
          info2.mustUseProperty = true;
        }
        property2[prop] = info2;
        normal[normalize(prop)] = prop;
        normal[normalize(info2.attribute)] = prop;
      }
      return new Schema(property2, normal, space);
    }
    var create$7 = create_1;
    var xlink$2 = create$7({
      space: "xlink",
      transform: xlinkTransform,
      properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
      }
    });
    function xlinkTransform(_, prop) {
      return "xlink:" + prop.slice(5).toLowerCase();
    }
    var create$6 = create_1;
    var xml$2 = create$6({
      space: "xml",
      transform: xmlTransform,
      properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
      }
    });
    function xmlTransform(_, prop) {
      return "xml:" + prop.slice(3).toLowerCase();
    }
    var caseSensitiveTransform_1 = caseSensitiveTransform$2;
    function caseSensitiveTransform$2(attributes2, attribute) {
      return attribute in attributes2 ? attributes2[attribute] : attribute;
    }
    var caseSensitiveTransform$1 = caseSensitiveTransform_1;
    var caseInsensitiveTransform_1 = caseInsensitiveTransform$2;
    function caseInsensitiveTransform$2(attributes2, property2) {
      return caseSensitiveTransform$1(attributes2, property2.toLowerCase());
    }
    var create$5 = create_1;
    var caseInsensitiveTransform$1 = caseInsensitiveTransform_1;
    var xmlns$2 = create$5({
      space: "xmlns",
      attributes: {
        xmlnsxlink: "xmlns:xlink"
      },
      transform: caseInsensitiveTransform$1,
      properties: {
        xmlns: null,
        xmlnsXLink: null
      }
    });
    var types$3 = types$5;
    var create$4 = create_1;
    var booleanish$1 = types$3.booleanish;
    var number$2 = types$3.number;
    var spaceSeparated$2 = types$3.spaceSeparated;
    var aria$2 = create$4({
      transform: ariaTransform,
      properties: {
        ariaActiveDescendant: null,
        ariaAtomic: booleanish$1,
        ariaAutoComplete: null,
        ariaBusy: booleanish$1,
        ariaChecked: booleanish$1,
        ariaColCount: number$2,
        ariaColIndex: number$2,
        ariaColSpan: number$2,
        ariaControls: spaceSeparated$2,
        ariaCurrent: null,
        ariaDescribedBy: spaceSeparated$2,
        ariaDetails: null,
        ariaDisabled: booleanish$1,
        ariaDropEffect: spaceSeparated$2,
        ariaErrorMessage: null,
        ariaExpanded: booleanish$1,
        ariaFlowTo: spaceSeparated$2,
        ariaGrabbed: booleanish$1,
        ariaHasPopup: null,
        ariaHidden: booleanish$1,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: spaceSeparated$2,
        ariaLevel: number$2,
        ariaLive: null,
        ariaModal: booleanish$1,
        ariaMultiLine: booleanish$1,
        ariaMultiSelectable: booleanish$1,
        ariaOrientation: null,
        ariaOwns: spaceSeparated$2,
        ariaPlaceholder: null,
        ariaPosInSet: number$2,
        ariaPressed: booleanish$1,
        ariaReadOnly: booleanish$1,
        ariaRelevant: null,
        ariaRequired: booleanish$1,
        ariaRoleDescription: spaceSeparated$2,
        ariaRowCount: number$2,
        ariaRowIndex: number$2,
        ariaRowSpan: number$2,
        ariaSelected: booleanish$1,
        ariaSetSize: number$2,
        ariaSort: null,
        ariaValueMax: number$2,
        ariaValueMin: number$2,
        ariaValueNow: number$2,
        ariaValueText: null,
        role: null
      }
    });
    function ariaTransform(_, prop) {
      return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
    }
    var types$2 = types$5;
    var create$3 = create_1;
    var caseInsensitiveTransform = caseInsensitiveTransform_1;
    var boolean$1 = types$2.boolean;
    var overloadedBoolean = types$2.overloadedBoolean;
    var booleanish = types$2.booleanish;
    var number$1 = types$2.number;
    var spaceSeparated$1 = types$2.spaceSeparated;
    var commaSeparated$1 = types$2.commaSeparated;
    var html$1 = create$3({
      space: "html",
      attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
      },
      transform: caseInsensitiveTransform,
      mustUseProperty: ["checked", "multiple", "muted", "selected"],
      properties: {
        // Standard Properties.
        abbr: null,
        accept: commaSeparated$1,
        acceptCharset: spaceSeparated$1,
        accessKey: spaceSeparated$1,
        action: null,
        allow: null,
        allowFullScreen: boolean$1,
        allowPaymentRequest: boolean$1,
        allowUserMedia: boolean$1,
        alt: null,
        as: null,
        async: boolean$1,
        autoCapitalize: null,
        autoComplete: spaceSeparated$1,
        autoFocus: boolean$1,
        autoPlay: boolean$1,
        capture: boolean$1,
        charSet: null,
        checked: boolean$1,
        cite: null,
        className: spaceSeparated$1,
        cols: number$1,
        colSpan: null,
        content: null,
        contentEditable: booleanish,
        controls: boolean$1,
        controlsList: spaceSeparated$1,
        coords: number$1 | commaSeparated$1,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: boolean$1,
        defer: boolean$1,
        dir: null,
        dirName: null,
        disabled: boolean$1,
        download: overloadedBoolean,
        draggable: booleanish,
        encType: null,
        enterKeyHint: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: boolean$1,
        formTarget: null,
        headers: spaceSeparated$1,
        height: number$1,
        hidden: boolean$1,
        high: number$1,
        href: null,
        hrefLang: null,
        htmlFor: spaceSeparated$1,
        httpEquiv: spaceSeparated$1,
        id: null,
        imageSizes: null,
        imageSrcSet: commaSeparated$1,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: boolean$1,
        itemId: null,
        itemProp: spaceSeparated$1,
        itemRef: spaceSeparated$1,
        itemScope: boolean$1,
        itemType: spaceSeparated$1,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: boolean$1,
        low: number$1,
        manifest: null,
        max: null,
        maxLength: number$1,
        media: null,
        method: null,
        min: null,
        minLength: number$1,
        multiple: boolean$1,
        muted: boolean$1,
        name: null,
        nonce: null,
        noModule: boolean$1,
        noValidate: boolean$1,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforePrint: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextMenu: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: boolean$1,
        optimum: number$1,
        pattern: null,
        ping: spaceSeparated$1,
        placeholder: null,
        playsInline: boolean$1,
        poster: null,
        preload: null,
        readOnly: boolean$1,
        referrerPolicy: null,
        rel: spaceSeparated$1,
        required: boolean$1,
        reversed: boolean$1,
        rows: number$1,
        rowSpan: number$1,
        sandbox: spaceSeparated$1,
        scope: null,
        scoped: boolean$1,
        seamless: boolean$1,
        selected: boolean$1,
        shape: null,
        size: number$1,
        sizes: null,
        slot: null,
        span: number$1,
        spellCheck: booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: commaSeparated$1,
        start: number$1,
        step: null,
        style: null,
        tabIndex: number$1,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: boolean$1,
        useMap: null,
        value: booleanish,
        width: number$1,
        wrap: null,
        // Legacy.
        // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
        align: null,
        // Several. Use CSS `text-align` instead,
        aLink: null,
        // `<body>`. Use CSS `a:active {color}` instead
        archive: spaceSeparated$1,
        // `<object>`. List of URIs to archives
        axis: null,
        // `<td>` and `<th>`. Use `scope` on `<th>`
        background: null,
        // `<body>`. Use CSS `background-image` instead
        bgColor: null,
        // `<body>` and table elements. Use CSS `background-color` instead
        border: number$1,
        // `<table>`. Use CSS `border-width` instead,
        borderColor: null,
        // `<table>`. Use CSS `border-color` instead,
        bottomMargin: number$1,
        // `<body>`
        cellPadding: null,
        // `<table>`
        cellSpacing: null,
        // `<table>`
        char: null,
        // Several table elements. When `align=char`, sets the character to align on
        charOff: null,
        // Several table elements. When `char`, offsets the alignment
        classId: null,
        // `<object>`
        clear: null,
        // `<br>`. Use CSS `clear` instead
        code: null,
        // `<object>`
        codeBase: null,
        // `<object>`
        codeType: null,
        // `<object>`
        color: null,
        // `<font>` and `<hr>`. Use CSS instead
        compact: boolean$1,
        // Lists. Use CSS to reduce space between items instead
        declare: boolean$1,
        // `<object>`
        event: null,
        // `<script>`
        face: null,
        // `<font>`. Use CSS instead
        frame: null,
        // `<table>`
        frameBorder: null,
        // `<iframe>`. Use CSS `border` instead
        hSpace: number$1,
        // `<img>` and `<object>`
        leftMargin: number$1,
        // `<body>`
        link: null,
        // `<body>`. Use CSS `a:link {color: *}` instead
        longDesc: null,
        // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
        lowSrc: null,
        // `<img>`. Use a `<picture>`
        marginHeight: number$1,
        // `<body>`
        marginWidth: number$1,
        // `<body>`
        noResize: boolean$1,
        // `<frame>`
        noHref: boolean$1,
        // `<area>`. Use no href instead of an explicit `nohref`
        noShade: boolean$1,
        // `<hr>`. Use background-color and height instead of borders
        noWrap: boolean$1,
        // `<td>` and `<th>`
        object: null,
        // `<applet>`
        profile: null,
        // `<head>`
        prompt: null,
        // `<isindex>`
        rev: null,
        // `<link>`
        rightMargin: number$1,
        // `<body>`
        rules: null,
        // `<table>`
        scheme: null,
        // `<meta>`
        scrolling: booleanish,
        // `<frame>`. Use overflow in the child context
        standby: null,
        // `<object>`
        summary: null,
        // `<table>`
        text: null,
        // `<body>`. Use CSS `color` instead
        topMargin: number$1,
        // `<body>`
        valueType: null,
        // `<param>`
        version: null,
        // `<html>`. Use a doctype.
        vAlign: null,
        // Several. Use CSS `vertical-align` instead
        vLink: null,
        // `<body>`. Use CSS `a:visited {color}` instead
        vSpace: number$1,
        // `<img>` and `<object>`
        // Non-standard Properties.
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: boolean$1,
        disableRemotePlayback: boolean$1,
        prefix: null,
        property: null,
        results: number$1,
        security: null,
        unselectable: null
      }
    });
    var merge$2 = merge_1;
    var xlink$1 = xlink$2;
    var xml$1 = xml$2;
    var xmlns$1 = xmlns$2;
    var aria$1 = aria$2;
    var html = html$1;
    merge$2([xml$1, xlink$1, xmlns$1, aria$1, html]);
    var reactIsExports = {};
    var reactIs = {
      get exports() {
        return reactIsExports;
      },
      set exports(v2) {
        reactIsExports = v2;
      }
    };
    var reactIs_production_min = {};
    /** @license React v17.0.2
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b = 60103, c = 60106, d = 60107, e = 60108, f$1 = 60114, g = 60109, h = 60110, k$1 = 60112, l = 60113, m$1 = 60120, n = 60115, p$1 = 60116, q = 60121, r = 60122, u = 60117, v$1 = 60129, w$1 = 60131;
    if ("function" === typeof Symbol && Symbol.for) {
      var x = Symbol.for;
      b = x("react.element");
      c = x("react.portal");
      d = x("react.fragment");
      e = x("react.strict_mode");
      f$1 = x("react.profiler");
      g = x("react.provider");
      h = x("react.context");
      k$1 = x("react.forward_ref");
      l = x("react.suspense");
      m$1 = x("react.suspense_list");
      n = x("react.memo");
      p$1 = x("react.lazy");
      q = x("react.block");
      r = x("react.server.block");
      u = x("react.fundamental");
      v$1 = x("react.debug_trace_mode");
      w$1 = x("react.legacy_hidden");
    }
    function y(a) {
      if ("object" === typeof a && null !== a) {
        var t2 = a.$$typeof;
        switch (t2) {
          case b:
            switch (a = a.type, a) {
              case d:
              case f$1:
              case e:
              case l:
              case m$1:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case h:
                  case k$1:
                  case p$1:
                  case n:
                  case g:
                    return a;
                  default:
                    return t2;
                }
            }
          case c:
            return t2;
        }
      }
    }
    var z = g, A$1 = b, B = k$1, C = d, D = p$1, E$1 = n, F = c, G = f$1, H$1 = e, I = l;
    reactIs_production_min.ContextConsumer = h;
    reactIs_production_min.ContextProvider = z;
    reactIs_production_min.Element = A$1;
    reactIs_production_min.ForwardRef = B;
    reactIs_production_min.Fragment = C;
    reactIs_production_min.Lazy = D;
    reactIs_production_min.Memo = E$1;
    reactIs_production_min.Portal = F;
    reactIs_production_min.Profiler = G;
    reactIs_production_min.StrictMode = H$1;
    reactIs_production_min.Suspense = I;
    reactIs_production_min.isAsyncMode = function() {
      return false;
    };
    reactIs_production_min.isConcurrentMode = function() {
      return false;
    };
    reactIs_production_min.isContextConsumer = function(a) {
      return y(a) === h;
    };
    reactIs_production_min.isContextProvider = function(a) {
      return y(a) === g;
    };
    reactIs_production_min.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === b;
    };
    reactIs_production_min.isForwardRef = function(a) {
      return y(a) === k$1;
    };
    reactIs_production_min.isFragment = function(a) {
      return y(a) === d;
    };
    reactIs_production_min.isLazy = function(a) {
      return y(a) === p$1;
    };
    reactIs_production_min.isMemo = function(a) {
      return y(a) === n;
    };
    reactIs_production_min.isPortal = function(a) {
      return y(a) === c;
    };
    reactIs_production_min.isProfiler = function(a) {
      return y(a) === f$1;
    };
    reactIs_production_min.isStrictMode = function(a) {
      return y(a) === e;
    };
    reactIs_production_min.isSuspense = function(a) {
      return y(a) === l;
    };
    reactIs_production_min.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === d || a === f$1 || a === v$1 || a === e || a === l || a === m$1 || a === w$1 || "object" === typeof a && null !== a && (a.$$typeof === p$1 || a.$$typeof === n || a.$$typeof === g || a.$$typeof === h || a.$$typeof === k$1 || a.$$typeof === u || a.$$typeof === q || a[0] === r) ? true : false;
    };
    reactIs_production_min.typeOf = y;
    (function(module2) {
      {
        module2.exports = reactIs_production_min;
      }
    })(reactIs);
    var types$1 = types$5;
    var create$2 = create_1;
    var caseSensitiveTransform = caseSensitiveTransform_1;
    var boolean = types$1.boolean;
    var number = types$1.number;
    var spaceSeparated = types$1.spaceSeparated;
    var commaSeparated = types$1.commaSeparated;
    var commaOrSpaceSeparated = types$1.commaOrSpaceSeparated;
    var svg$1 = create$2({
      space: "svg",
      attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        // These were camelcased in Tiny. Now lowercased in SVG 2
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
      },
      transform: caseSensitiveTransform,
      properties: {
        about: commaOrSpaceSeparated,
        accentHeight: number,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: number,
        amplitude: number,
        arabicForm: null,
        ascent: number,
        attributeName: null,
        attributeType: null,
        azimuth: number,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: number,
        by: null,
        calcMode: null,
        capHeight: number,
        className: spaceSeparated,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: number,
        diffuseConstant: number,
        direction: null,
        display: null,
        dur: null,
        divisor: number,
        dominantBaseline: null,
        download: boolean,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: number,
        enableBackground: null,
        end: null,
        event: null,
        exponent: number,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: number,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: commaSeparated,
        g2: commaSeparated,
        glyphName: commaSeparated,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: number,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: number,
        horizOriginX: number,
        horizOriginY: number,
        id: null,
        ideographic: number,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: number,
        k: number,
        k1: number,
        k2: number,
        k3: number,
        k4: number,
        kernelMatrix: commaOrSpaceSeparated,
        kernelUnitLength: null,
        keyPoints: null,
        // SEMI_COLON_SEPARATED
        keySplines: null,
        // SEMI_COLON_SEPARATED
        keyTimes: null,
        // SEMI_COLON_SEPARATED
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: number,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: number,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: number,
        overlineThickness: number,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: number,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: spaceSeparated,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: number,
        pointsAtY: number,
        pointsAtZ: number,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: commaOrSpaceSeparated,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: commaOrSpaceSeparated,
        rev: commaOrSpaceSeparated,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: commaOrSpaceSeparated,
        requiredFeatures: commaOrSpaceSeparated,
        requiredFonts: commaOrSpaceSeparated,
        requiredFormats: commaOrSpaceSeparated,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: number,
        specularExponent: number,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: number,
        strikethroughThickness: number,
        string: null,
        stroke: null,
        strokeDashArray: commaOrSpaceSeparated,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: number,
        strokeOpacity: number,
        strokeWidth: null,
        style: null,
        surfaceScale: number,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: commaOrSpaceSeparated,
        tabIndex: number,
        tableValues: null,
        target: null,
        targetX: number,
        targetY: number,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: commaOrSpaceSeparated,
        to: null,
        transform: null,
        u1: null,
        u2: null,
        underlinePosition: number,
        underlineThickness: number,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: number,
        values: null,
        vAlphabetic: number,
        vMathematical: number,
        vectorEffect: null,
        vHanging: number,
        vIdeographic: number,
        version: null,
        vertAdvY: number,
        vertOriginX: number,
        vertOriginY: number,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: number,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
      }
    });
    var merge$1 = merge_1;
    var xlink = xlink$2;
    var xml = xml$2;
    var xmlns = xmlns$2;
    var aria = aria$2;
    var svg = svg$1;
    merge$1([xml, xlink, xmlns, aria, svg]);
    const PropTypes = propTypesExports;
    ({
      // Core options:
      children: PropTypes.string,
      // Layout options:
      className: PropTypes.string,
      // Filter options:
      allowElement: PropTypes.func,
      allowedElements: PropTypes.arrayOf(PropTypes.string),
      disallowedElements: PropTypes.arrayOf(PropTypes.string),
      unwrapDisallowed: PropTypes.bool,
      // Plugin options:
      // type-coverage:ignore-next-line
      remarkPlugins: PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.object, PropTypes.func]))
        ])
      ),
      // type-coverage:ignore-next-line
      rehypePlugins: PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.object, PropTypes.func]))
        ])
      ),
      // Transform options:
      sourcePos: PropTypes.bool,
      rawSourcePos: PropTypes.bool,
      skipHtml: PropTypes.bool,
      includeElementIndex: PropTypes.bool,
      transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
      linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
      transformImageUri: PropTypes.func,
      components: PropTypes.object
    });
    var micromarkExtensionGfmExports = {};
    var micromarkExtensionGfm = {
      get exports() {
        return micromarkExtensionGfmExports;
      },
      set exports(v2) {
        micromarkExtensionGfmExports = v2;
      }
    };
    var micromarkExtensionGfmAutolinkLiteralExports = {};
    var micromarkExtensionGfmAutolinkLiteral = {
      get exports() {
        return micromarkExtensionGfmAutolinkLiteralExports;
      },
      set exports(v2) {
        micromarkExtensionGfmAutolinkLiteralExports = v2;
      }
    };
    var syntax$3 = {};
    var asciiAlpha = asciiAlpha_1;
    var asciiAlphanumeric = asciiAlphanumeric_1;
    var asciiControl = asciiControl_1;
    var markdownLineEnding = markdownLineEnding_1;
    var unicodePunctuation$1 = unicodePunctuation_1;
    var unicodeWhitespace$1 = unicodeWhitespace_1;
    var www = { tokenize: tokenizeWww, partial: true };
    var domain = { tokenize: tokenizeDomain, partial: true };
    var path = { tokenize: tokenizePath, partial: true };
    var punctuation = { tokenize: tokenizePunctuation, partial: true };
    var namedCharacterReference = {
      tokenize: tokenizeNamedCharacterReference,
      partial: true
    };
    var wwwAutolink = { tokenize: tokenizeWwwAutolink, previous: previousWww };
    var httpAutolink = { tokenize: tokenizeHttpAutolink, previous: previousHttp };
    var emailAutolink = { tokenize: tokenizeEmailAutolink, previous: previousEmail };
    var text = {};
    syntax$3.text = text;
    var code = 48;
    while (code < 123) {
      text[code] = emailAutolink;
      code++;
      if (code === 58)
        code = 65;
      else if (code === 91)
        code = 97;
    }
    text[43] = emailAutolink;
    text[45] = emailAutolink;
    text[46] = emailAutolink;
    text[95] = emailAutolink;
    text[72] = [emailAutolink, httpAutolink];
    text[104] = [emailAutolink, httpAutolink];
    text[87] = [emailAutolink, wwwAutolink];
    text[119] = [emailAutolink, wwwAutolink];
    function tokenizeEmailAutolink(effects, ok2, nok) {
      var self2 = this;
      var hasDot;
      return start2;
      function start2(code2) {
        if (!gfmAtext(code2) || !previousEmail(self2.previous) || previous$1(self2.events)) {
          return nok(code2);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkEmail");
        return atext(code2);
      }
      function atext(code2) {
        if (gfmAtext(code2)) {
          effects.consume(code2);
          return atext;
        }
        if (code2 === 64) {
          effects.consume(code2);
          return label;
        }
        return nok(code2);
      }
      function label(code2) {
        if (code2 === 46) {
          return effects.check(punctuation, done, dotContinuation)(code2);
        }
        if (
          // `-`
          code2 === 45 || // `_`
          code2 === 95
        ) {
          return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code2);
        }
        if (asciiAlphanumeric(code2)) {
          effects.consume(code2);
          return label;
        }
        return done(code2);
      }
      function dotContinuation(code2) {
        effects.consume(code2);
        hasDot = true;
        return label;
      }
      function dashOrUnderscoreContinuation(code2) {
        effects.consume(code2);
        return afterDashOrUnderscore;
      }
      function afterDashOrUnderscore(code2) {
        if (code2 === 46) {
          return effects.check(punctuation, nok, dotContinuation)(code2);
        }
        return label(code2);
      }
      function done(code2) {
        if (hasDot) {
          effects.exit("literalAutolinkEmail");
          effects.exit("literalAutolink");
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    function tokenizeWwwAutolink(effects, ok2, nok) {
      var self2 = this;
      return start2;
      function start2(code2) {
        if (code2 !== 87 && code2 - 32 !== 87 || !previousWww(self2.previous) || previous$1(self2.events)) {
          return nok(code2);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkWww");
        return effects.check(
          www,
          effects.attempt(domain, effects.attempt(path, done), nok),
          nok
        )(code2);
      }
      function done(code2) {
        effects.exit("literalAutolinkWww");
        effects.exit("literalAutolink");
        return ok2(code2);
      }
    }
    function tokenizeHttpAutolink(effects, ok2, nok) {
      var self2 = this;
      return start2;
      function start2(code2) {
        if (code2 !== 72 && code2 - 32 !== 72 || !previousHttp(self2.previous) || previous$1(self2.events)) {
          return nok(code2);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkHttp");
        effects.consume(code2);
        return t1;
      }
      function t1(code2) {
        if (code2 === 84 || code2 - 32 === 84) {
          effects.consume(code2);
          return t2;
        }
        return nok(code2);
      }
      function t2(code2) {
        if (code2 === 84 || code2 - 32 === 84) {
          effects.consume(code2);
          return p2;
        }
        return nok(code2);
      }
      function p2(code2) {
        if (code2 === 80 || code2 - 32 === 80) {
          effects.consume(code2);
          return s;
        }
        return nok(code2);
      }
      function s(code2) {
        if (code2 === 83 || code2 - 32 === 83) {
          effects.consume(code2);
          return colon;
        }
        return colon(code2);
      }
      function colon(code2) {
        if (code2 === 58) {
          effects.consume(code2);
          return slash1;
        }
        return nok(code2);
      }
      function slash1(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          return slash2;
        }
        return nok(code2);
      }
      function slash2(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        return asciiControl(code2) || unicodeWhitespace$1(code2) || unicodePunctuation$1(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path, done), nok)(code2);
      }
      function done(code2) {
        effects.exit("literalAutolinkHttp");
        effects.exit("literalAutolink");
        return ok2(code2);
      }
    }
    function tokenizeWww(effects, ok2, nok) {
      return start2;
      function start2(code2) {
        effects.consume(code2);
        return w2;
      }
      function w2(code2) {
        if (code2 === 87 || code2 - 32 === 87) {
          effects.consume(code2);
          return w3;
        }
        return nok(code2);
      }
      function w3(code2) {
        if (code2 === 87 || code2 - 32 === 87) {
          effects.consume(code2);
          return dot;
        }
        return nok(code2);
      }
      function dot(code2) {
        if (code2 === 46) {
          effects.consume(code2);
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        return code2 === null || markdownLineEnding(code2) ? nok(code2) : ok2(code2);
      }
    }
    function tokenizeDomain(effects, ok2, nok) {
      var hasUnderscoreInLastSegment;
      var hasUnderscoreInLastLastSegment;
      return domain2;
      function domain2(code2) {
        if (code2 === 38) {
          return effects.check(
            namedCharacterReference,
            done,
            punctuationContinuation
          )(code2);
        }
        if (code2 === 46 || code2 === 95) {
          return effects.check(punctuation, done, punctuationContinuation)(code2);
        }
        if (asciiControl(code2) || unicodeWhitespace$1(code2) || code2 !== 45 && unicodePunctuation$1(code2)) {
          return done(code2);
        }
        effects.consume(code2);
        return domain2;
      }
      function punctuationContinuation(code2) {
        if (code2 === 46) {
          hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;
          hasUnderscoreInLastSegment = void 0;
          effects.consume(code2);
          return domain2;
        }
        if (code2 === 95)
          hasUnderscoreInLastSegment = true;
        effects.consume(code2);
        return domain2;
      }
      function done(code2) {
        if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    function tokenizePath(effects, ok2) {
      var balance = 0;
      return inPath;
      function inPath(code2) {
        if (code2 === 38) {
          return effects.check(
            namedCharacterReference,
            ok2,
            continuedPunctuation
          )(code2);
        }
        if (code2 === 40) {
          balance++;
        }
        if (code2 === 41) {
          return effects.check(
            punctuation,
            parenAtPathEnd,
            continuedPunctuation
          )(code2);
        }
        if (pathEnd(code2)) {
          return ok2(code2);
        }
        if (trailingPunctuation(code2)) {
          return effects.check(punctuation, ok2, continuedPunctuation)(code2);
        }
        effects.consume(code2);
        return inPath;
      }
      function continuedPunctuation(code2) {
        effects.consume(code2);
        return inPath;
      }
      function parenAtPathEnd(code2) {
        balance--;
        return balance < 0 ? ok2(code2) : continuedPunctuation(code2);
      }
    }
    function tokenizeNamedCharacterReference(effects, ok2, nok) {
      return start2;
      function start2(code2) {
        effects.consume(code2);
        return inside;
      }
      function inside(code2) {
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          return inside;
        }
        if (code2 === 59) {
          effects.consume(code2);
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        return pathEnd(code2) ? ok2(code2) : nok(code2);
      }
    }
    function tokenizePunctuation(effects, ok2, nok) {
      return start2;
      function start2(code2) {
        effects.consume(code2);
        return after;
      }
      function after(code2) {
        if (trailingPunctuation(code2)) {
          effects.consume(code2);
          return after;
        }
        return pathEnd(code2) ? ok2(code2) : nok(code2);
      }
    }
    function trailingPunctuation(code2) {
      return (
        // `!`
        code2 === 33 || // `"`
        code2 === 34 || // `'`
        code2 === 39 || // `)`
        code2 === 41 || // `*`
        code2 === 42 || // `,`
        code2 === 44 || // `.`
        code2 === 46 || // `:`
        code2 === 58 || // `;`
        code2 === 59 || // `<`
        code2 === 60 || // `?`
        code2 === 63 || // `_`.
        code2 === 95 || // `~`
        code2 === 126
      );
    }
    function pathEnd(code2) {
      return (
        // EOF.
        code2 === null || // CR, LF, CRLF, HT, VS.
        code2 < 0 || // Space.
        code2 === 32 || // `<`
        code2 === 60
      );
    }
    function gfmAtext(code2) {
      return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
    }
    function previousWww(code2) {
      return code2 === null || code2 < 0 || code2 === 32 || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 126;
    }
    function previousHttp(code2) {
      return code2 === null || !asciiAlpha(code2);
    }
    function previousEmail(code2) {
      return code2 !== 47 && previousHttp(code2);
    }
    function previous$1(events) {
      var index2 = events.length;
      while (index2--) {
        if ((events[index2][1].type === "labelLink" || events[index2][1].type === "labelImage") && !events[index2][1]._balanced) {
          return true;
        }
      }
    }
    (function(module2) {
      module2.exports = syntax$3;
    })(micromarkExtensionGfmAutolinkLiteral);
    var micromarkExtensionGfmStrikethrough = create$1;
    var classifyCharacter = classifyCharacter_1;
    var chunkedSplice = chunkedSplice_1;
    var resolveAll = resolveAll_1;
    var shallow = shallow_1;
    function create$1(options) {
      var settings = options || {};
      var single = settings.singleTilde;
      var tokenizer = {
        tokenize: tokenizeStrikethrough,
        resolveAll: resolveAllStrikethrough
      };
      if (single === null || single === void 0) {
        single = true;
      }
      return { text: { 126: tokenizer }, insideSpan: { null: tokenizer } };
      function resolveAllStrikethrough(events, context) {
        var index2 = -1;
        var strikethrough2;
        var text2;
        var open2;
        var nextEvents;
        while (++index2 < events.length) {
          if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
            open2 = index2;
            while (open2--) {
              if (events[open2][0] === "exit" && events[open2][1].type === "strikethroughSequenceTemporary" && events[open2][1]._open && // If the sizes are the same:
              events[index2][1].end.offset - events[index2][1].start.offset === events[open2][1].end.offset - events[open2][1].start.offset) {
                events[index2][1].type = "strikethroughSequence";
                events[open2][1].type = "strikethroughSequence";
                strikethrough2 = {
                  type: "strikethrough",
                  start: shallow(events[open2][1].start),
                  end: shallow(events[index2][1].end)
                };
                text2 = {
                  type: "strikethroughText",
                  start: shallow(events[open2][1].end),
                  end: shallow(events[index2][1].start)
                };
                nextEvents = [
                  ["enter", strikethrough2, context],
                  ["enter", events[open2][1], context],
                  ["exit", events[open2][1], context],
                  ["enter", text2, context]
                ];
                chunkedSplice(
                  nextEvents,
                  nextEvents.length,
                  0,
                  resolveAll(
                    context.parser.constructs.insideSpan.null,
                    events.slice(open2 + 1, index2),
                    context
                  )
                );
                chunkedSplice(nextEvents, nextEvents.length, 0, [
                  ["exit", text2, context],
                  ["enter", events[index2][1], context],
                  ["exit", events[index2][1], context],
                  ["exit", strikethrough2, context]
                ]);
                chunkedSplice(events, open2 - 1, index2 - open2 + 3, nextEvents);
                index2 = open2 + nextEvents.length - 2;
                break;
              }
            }
          }
        }
        return removeRemainingSequences(events);
      }
      function removeRemainingSequences(events) {
        var index2 = -1;
        var length2 = events.length;
        while (++index2 < length2) {
          if (events[index2][1].type === "strikethroughSequenceTemporary") {
            events[index2][1].type = "data";
          }
        }
        return events;
      }
      function tokenizeStrikethrough(effects, ok2, nok) {
        var previous2 = this.previous;
        var events = this.events;
        var size = 0;
        return start2;
        function start2(code2) {
          if (code2 !== 126 || previous2 === 126 && events[events.length - 1][1].type !== "characterEscape") {
            return nok(code2);
          }
          effects.enter("strikethroughSequenceTemporary");
          return more(code2);
        }
        function more(code2) {
          var before = classifyCharacter(previous2);
          var token2;
          var after;
          if (code2 === 126) {
            if (size > 1)
              return nok(code2);
            effects.consume(code2);
            size++;
            return more;
          }
          if (size < 2 && !single)
            return nok(code2);
          token2 = effects.exit("strikethroughSequenceTemporary");
          after = classifyCharacter(code2);
          token2._open = !after || after === 2 && before;
          token2._close = !before || before === 2 && after;
          return ok2(code2);
        }
      }
    }
    var micromarkExtensionGfmTableExports = {};
    var micromarkExtensionGfmTable = {
      get exports() {
        return micromarkExtensionGfmTableExports;
      },
      set exports(v2) {
        micromarkExtensionGfmTableExports = v2;
      }
    };
    var syntax$2 = {};
    syntax$2.flow = {
      null: { tokenize: tokenizeTable, resolve: resolveTable, interruptible: true }
    };
    var createSpace = factorySpace$h;
    var setextUnderlineMini = { tokenize: tokenizeSetextUnderlineMini, partial: true };
    var nextPrefixedOrBlank = { tokenize: tokenizeNextPrefixedOrBlank, partial: true };
    function resolveTable(events, context) {
      var length2 = events.length;
      var index2 = -1;
      var token2;
      var inHead;
      var inDelimiterRow;
      var inRow;
      var cell;
      var content2;
      var text2;
      var contentStart;
      var contentEnd;
      var cellStart;
      while (++index2 < length2) {
        token2 = events[index2][1];
        if (inRow) {
          if (token2.type === "temporaryTableCellContent") {
            contentStart = contentStart || index2;
            contentEnd = index2;
          }
          if (
            // Combine separate content parts into one.
            (token2.type === "tableCellDivider" || token2.type === "tableRow") && contentEnd
          ) {
            content2 = {
              type: "tableContent",
              start: events[contentStart][1].start,
              end: events[contentEnd][1].end
            };
            text2 = {
              type: "chunkText",
              start: content2.start,
              end: content2.end,
              contentType: "text"
            };
            events.splice(
              contentStart,
              contentEnd - contentStart + 1,
              ["enter", content2, context],
              ["enter", text2, context],
              ["exit", text2, context],
              ["exit", content2, context]
            );
            index2 -= contentEnd - contentStart - 3;
            length2 = events.length;
            contentStart = void 0;
            contentEnd = void 0;
          }
        }
        if (events[index2][0] === "exit" && cellStart && cellStart + 1 < index2 && (token2.type === "tableCellDivider" || token2.type === "tableRow" && (cellStart + 3 < index2 || events[cellStart][1].type !== "whitespace"))) {
          cell = {
            type: inDelimiterRow ? "tableDelimiter" : inHead ? "tableHeader" : "tableData",
            start: events[cellStart][1].start,
            end: events[index2][1].end
          };
          events.splice(index2 + (token2.type === "tableCellDivider" ? 1 : 0), 0, [
            "exit",
            cell,
            context
          ]);
          events.splice(cellStart, 0, ["enter", cell, context]);
          index2 += 2;
          length2 = events.length;
          cellStart = index2 + 1;
        }
        if (token2.type === "tableRow") {
          inRow = events[index2][0] === "enter";
          if (inRow) {
            cellStart = index2 + 1;
          }
        }
        if (token2.type === "tableDelimiterRow") {
          inDelimiterRow = events[index2][0] === "enter";
          if (inDelimiterRow) {
            cellStart = index2 + 1;
          }
        }
        if (token2.type === "tableHead") {
          inHead = events[index2][0] === "enter";
        }
      }
      return events;
    }
    function tokenizeTable(effects, ok2, nok) {
      var align = [];
      var tableHeaderCount = 0;
      var seenDelimiter;
      var hasDash;
      return start2;
      function start2(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return nok(code2);
        }
        effects.enter("table")._align = align;
        effects.enter("tableHead");
        effects.enter("tableRow");
        if (code2 === 124) {
          return cellDividerHead(code2);
        }
        tableHeaderCount++;
        effects.enter("temporaryTableCellContent");
        return inCellContentHead(code2);
      }
      function cellDividerHead(code2) {
        effects.enter("tableCellDivider");
        effects.consume(code2);
        effects.exit("tableCellDivider");
        seenDelimiter = true;
        return cellBreakHead;
      }
      function cellBreakHead(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return atRowEndHead(code2);
        }
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.enter("whitespace");
          effects.consume(code2);
          return inWhitespaceHead;
        }
        if (seenDelimiter) {
          seenDelimiter = void 0;
          tableHeaderCount++;
        }
        if (code2 === 124) {
          return cellDividerHead(code2);
        }
        effects.enter("temporaryTableCellContent");
        return inCellContentHead(code2);
      }
      function inWhitespaceHead(code2) {
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.consume(code2);
          return inWhitespaceHead;
        }
        effects.exit("whitespace");
        return cellBreakHead(code2);
      }
      function inCellContentHead(code2) {
        if (code2 === null || code2 < 0 || code2 === 32 || code2 === 124) {
          effects.exit("temporaryTableCellContent");
          return cellBreakHead(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? inCellContentEscapeHead : inCellContentHead;
      }
      function inCellContentEscapeHead(code2) {
        if (code2 === 92 || code2 === 124) {
          effects.consume(code2);
          return inCellContentHead;
        }
        return inCellContentHead(code2);
      }
      function atRowEndHead(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        effects.exit("tableRow");
        effects.exit("tableHead");
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return effects.check(
          setextUnderlineMini,
          nok,
          // Support an indent before the delimiter row.
          createSpace(effects, rowStartDelimiter, "linePrefix", 4)
        );
      }
      function rowStartDelimiter(code2) {
        if (code2 === null || code2 < 0 || code2 === 32) {
          return nok(code2);
        }
        effects.enter("tableDelimiterRow");
        return atDelimiterRowBreak(code2);
      }
      function atDelimiterRowBreak(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return rowEndDelimiter(code2);
        }
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.enter("whitespace");
          effects.consume(code2);
          return inWhitespaceDelimiter;
        }
        if (code2 === 45) {
          effects.enter("tableDelimiterFiller");
          effects.consume(code2);
          hasDash = true;
          align.push(null);
          return inFillerDelimiter;
        }
        if (code2 === 58) {
          effects.enter("tableDelimiterAlignment");
          effects.consume(code2);
          effects.exit("tableDelimiterAlignment");
          align.push("left");
          return afterLeftAlignment;
        }
        if (code2 === 124) {
          effects.enter("tableCellDivider");
          effects.consume(code2);
          effects.exit("tableCellDivider");
          return atDelimiterRowBreak;
        }
        return nok(code2);
      }
      function inWhitespaceDelimiter(code2) {
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.consume(code2);
          return inWhitespaceDelimiter;
        }
        effects.exit("whitespace");
        return atDelimiterRowBreak(code2);
      }
      function inFillerDelimiter(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return inFillerDelimiter;
        }
        effects.exit("tableDelimiterFiller");
        if (code2 === 58) {
          effects.enter("tableDelimiterAlignment");
          effects.consume(code2);
          effects.exit("tableDelimiterAlignment");
          align[align.length - 1] = align[align.length - 1] === "left" ? "center" : "right";
          return afterRightAlignment;
        }
        return atDelimiterRowBreak(code2);
      }
      function afterLeftAlignment(code2) {
        if (code2 === 45) {
          effects.enter("tableDelimiterFiller");
          effects.consume(code2);
          hasDash = true;
          return inFillerDelimiter;
        }
        return nok(code2);
      }
      function afterRightAlignment(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return rowEndDelimiter(code2);
        }
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.enter("whitespace");
          effects.consume(code2);
          return inWhitespaceDelimiter;
        }
        if (code2 === 124) {
          effects.enter("tableCellDivider");
          effects.consume(code2);
          effects.exit("tableCellDivider");
          return atDelimiterRowBreak;
        }
        return nok(code2);
      }
      function rowEndDelimiter(code2) {
        effects.exit("tableDelimiterRow");
        if (!hasDash || tableHeaderCount !== align.length) {
          return nok(code2);
        }
        if (code2 === null) {
          return tableClose(code2);
        }
        return effects.check(nextPrefixedOrBlank, tableClose, tableContinue)(code2);
      }
      function tableClose(code2) {
        effects.exit("table");
        return ok2(code2);
      }
      function tableContinue(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return createSpace(effects, bodyStart, "linePrefix", 4);
      }
      function bodyStart(code2) {
        effects.enter("tableBody");
        return rowStartBody(code2);
      }
      function rowStartBody(code2) {
        effects.enter("tableRow");
        if (code2 === 124) {
          return cellDividerBody(code2);
        }
        effects.enter("temporaryTableCellContent");
        return inCellContentBody(code2);
      }
      function cellDividerBody(code2) {
        effects.enter("tableCellDivider");
        effects.consume(code2);
        effects.exit("tableCellDivider");
        return cellBreakBody;
      }
      function cellBreakBody(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return atRowEndBody(code2);
        }
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.enter("whitespace");
          effects.consume(code2);
          return inWhitespaceBody;
        }
        if (code2 === 124) {
          return cellDividerBody(code2);
        }
        effects.enter("temporaryTableCellContent");
        return inCellContentBody(code2);
      }
      function inWhitespaceBody(code2) {
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.consume(code2);
          return inWhitespaceBody;
        }
        effects.exit("whitespace");
        return cellBreakBody(code2);
      }
      function inCellContentBody(code2) {
        if (code2 === null || code2 < 0 || code2 === 32 || code2 === 124) {
          effects.exit("temporaryTableCellContent");
          return cellBreakBody(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? inCellContentEscapeBody : inCellContentBody;
      }
      function inCellContentEscapeBody(code2) {
        if (code2 === 92 || code2 === 124) {
          effects.consume(code2);
          return inCellContentBody;
        }
        return inCellContentBody(code2);
      }
      function atRowEndBody(code2) {
        effects.exit("tableRow");
        if (code2 === null) {
          return tableBodyClose(code2);
        }
        return effects.check(
          nextPrefixedOrBlank,
          tableBodyClose,
          tableBodyContinue
        )(code2);
      }
      function tableBodyClose(code2) {
        effects.exit("tableBody");
        return tableClose(code2);
      }
      function tableBodyContinue(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return createSpace(effects, rowStartBody, "linePrefix", 4);
      }
    }
    function tokenizeSetextUnderlineMini(effects, ok2, nok) {
      return start2;
      function start2(code2) {
        if (code2 !== 45) {
          return nok(code2);
        }
        effects.enter("setextUnderline");
        return sequence(code2);
      }
      function sequence(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return sequence;
        }
        return whitespace2(code2);
      }
      function whitespace2(code2) {
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.consume(code2);
          return whitespace2;
        }
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    function tokenizeNextPrefixedOrBlank(effects, ok2, nok) {
      var size = 0;
      return start2;
      function start2(code2) {
        effects.enter("check");
        effects.consume(code2);
        return whitespace2;
      }
      function whitespace2(code2) {
        if (code2 === -1 || code2 === 32) {
          effects.consume(code2);
          size++;
          return size === 4 ? ok2 : whitespace2;
        }
        if (code2 === null || code2 < 0) {
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    (function(module2) {
      module2.exports = syntax$2;
    })(micromarkExtensionGfmTable);
    var micromarkExtensionGfmTaskListItemExports = {};
    var micromarkExtensionGfmTaskListItem = {
      get exports() {
        return micromarkExtensionGfmTaskListItemExports;
      },
      set exports(v2) {
        micromarkExtensionGfmTaskListItemExports = v2;
      }
    };
    var syntax$1 = {};
    var markdownLineEndingOrSpace = markdownLineEndingOrSpace_1;
    var spaceFactory = factorySpace$h;
    var prefixSize = prefixSize_1;
    var tasklistCheck = { tokenize: tokenizeTasklistCheck };
    syntax$1.text = { 91: tasklistCheck };
    function tokenizeTasklistCheck(effects, ok2, nok) {
      var self2 = this;
      return open2;
      function open2(code2) {
        if (
          // Exit if not `[`.
          code2 !== 91 || // Exit if there’s stuff before.
          self2.previous !== null || // Exit if not in the first content that is the first child of a list
          // item.
          !self2._gfmTasklistFirstContentOfListItem
        ) {
          return nok(code2);
        }
        effects.enter("taskListCheck");
        effects.enter("taskListCheckMarker");
        effects.consume(code2);
        effects.exit("taskListCheckMarker");
        return inside;
      }
      function inside(code2) {
        if (code2 === -2 || code2 === 32) {
          effects.enter("taskListCheckValueUnchecked");
          effects.consume(code2);
          effects.exit("taskListCheckValueUnchecked");
          return close;
        }
        if (code2 === 88 || code2 === 120) {
          effects.enter("taskListCheckValueChecked");
          effects.consume(code2);
          effects.exit("taskListCheckValueChecked");
          return close;
        }
        return nok(code2);
      }
      function close(code2) {
        if (code2 === 93) {
          effects.enter("taskListCheckMarker");
          effects.consume(code2);
          effects.exit("taskListCheckMarker");
          effects.exit("taskListCheck");
          return effects.check({ tokenize: spaceThenNonSpace }, ok2, nok);
        }
        return nok(code2);
      }
    }
    function spaceThenNonSpace(effects, ok2, nok) {
      var self2 = this;
      return spaceFactory(effects, after, "whitespace");
      function after(code2) {
        return prefixSize(self2.events, "whitespace") && code2 !== null && !markdownLineEndingOrSpace(code2) ? ok2(code2) : nok(code2);
      }
    }
    (function(module2) {
      module2.exports = syntax$1;
    })(micromarkExtensionGfmTaskListItem);
    var combine = combineExtensions_1;
    var autolink = micromarkExtensionGfmAutolinkLiteralExports;
    var strikethrough$1 = micromarkExtensionGfmStrikethrough;
    var table$2 = micromarkExtensionGfmTableExports;
    var tasklist = micromarkExtensionGfmTaskListItemExports;
    var syntax = create;
    function create(options) {
      return combine([autolink, strikethrough$1(options), table$2, tasklist]);
    }
    (function(module2) {
      module2.exports = syntax;
    })(micromarkExtensionGfm);
    var fromMarkdown$3 = {};
    var ccount_1 = ccount$1;
    function ccount$1(source, character2) {
      var value = String(source);
      var count = 0;
      var index2;
      if (typeof character2 !== "string") {
        throw new Error("Expected character");
      }
      index2 = value.indexOf(character2);
      while (index2 !== -1) {
        count++;
        index2 = value.indexOf(character2, index2 + character2.length);
      }
      return count;
    }
    var escapeStringRegexp = (string2) => {
      if (typeof string2 !== "string") {
        throw new TypeError("Expected a string");
      }
      return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
    var mdastUtilFindAndReplace = findAndReplace$1;
    var visit = unistUtilVisitParents;
    var convert = convert_1;
    var escape$1 = escapeStringRegexp;
    var splice = [].splice;
    function findAndReplace$1(tree, find, replace2, options) {
      var settings;
      var schema2;
      if (typeof find === "string" || find && typeof find.exec === "function") {
        schema2 = [[find, replace2]];
      } else {
        schema2 = find;
        options = replace2;
      }
      settings = options || {};
      search(tree, settings, handlerFactory(toPairs(schema2)));
      return tree;
      function handlerFactory(pairs) {
        var pair = pairs[0];
        return handler;
        function handler(node2, parent) {
          var find2 = pair[0];
          var replace3 = pair[1];
          var nodes = [];
          var start2 = 0;
          var index2 = parent.children.indexOf(node2);
          var position2;
          var match2;
          var subhandler;
          var value;
          find2.lastIndex = 0;
          match2 = find2.exec(node2.value);
          while (match2) {
            position2 = match2.index;
            value = replace3.apply(
              null,
              [].concat(match2, { index: match2.index, input: match2.input })
            );
            if (value !== false) {
              if (start2 !== position2) {
                nodes.push({ type: "text", value: node2.value.slice(start2, position2) });
              }
              if (typeof value === "string" && value.length > 0) {
                value = { type: "text", value };
              }
              if (value) {
                nodes = [].concat(nodes, value);
              }
              start2 = position2 + match2[0].length;
            }
            if (!find2.global) {
              break;
            }
            match2 = find2.exec(node2.value);
          }
          if (position2 === void 0) {
            nodes = [node2];
            index2--;
          } else {
            if (start2 < node2.value.length) {
              nodes.push({ type: "text", value: node2.value.slice(start2) });
            }
            nodes.unshift(index2, 1);
            splice.apply(parent.children, nodes);
          }
          if (pairs.length > 1) {
            subhandler = handlerFactory(pairs.slice(1));
            position2 = -1;
            while (++position2 < nodes.length) {
              node2 = nodes[position2];
              if (node2.type === "text") {
                subhandler(node2, parent);
              } else {
                search(node2, settings, subhandler);
              }
            }
          }
          return index2 + nodes.length + 1;
        }
      }
    }
    function search(tree, settings, handler) {
      var ignored = convert(settings.ignore || []);
      var result = [];
      visit(tree, "text", visitor);
      return result;
      function visitor(node2, parents) {
        var index2 = -1;
        var parent;
        var grandparent;
        while (++index2 < parents.length) {
          parent = parents[index2];
          if (ignored(
            parent,
            grandparent ? grandparent.children.indexOf(parent) : void 0,
            grandparent
          )) {
            return;
          }
          grandparent = parent;
        }
        return handler(node2, grandparent);
      }
    }
    function toPairs(schema2) {
      var result = [];
      var key;
      var index2;
      if (typeof schema2 !== "object") {
        throw new Error("Expected array or object as schema");
      }
      if ("length" in schema2) {
        index2 = -1;
        while (++index2 < schema2.length) {
          result.push([
            toExpression(schema2[index2][0]),
            toFunction(schema2[index2][1])
          ]);
        }
      } else {
        for (key in schema2) {
          result.push([toExpression(key), toFunction(schema2[key])]);
        }
      }
      return result;
    }
    function toExpression(find) {
      return typeof find === "string" ? new RegExp(escape$1(find), "g") : find;
    }
    function toFunction(replace2) {
      return typeof replace2 === "function" ? replace2 : returner;
      function returner() {
        return replace2;
      }
    }
    var ccount = ccount_1;
    var findAndReplace = mdastUtilFindAndReplace;
    var unicodePunctuation = unicodePunctuation_1;
    var unicodeWhitespace = unicodeWhitespace_1;
    fromMarkdown$3.transforms = [transformGfmAutolinkLiterals];
    fromMarkdown$3.enter = {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    };
    fromMarkdown$3.exit = {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    };
    function enterLiteralAutolink(token2) {
      this.enter({ type: "link", title: null, url: "", children: [] }, token2);
    }
    function enterLiteralAutolinkValue(token2) {
      this.config.enter.autolinkProtocol.call(this, token2);
    }
    function exitLiteralAutolinkHttp(token2) {
      this.config.exit.autolinkProtocol.call(this, token2);
    }
    function exitLiteralAutolinkWww(token2) {
      this.config.exit.data.call(this, token2);
      this.stack[this.stack.length - 1].url = "http://" + this.sliceSerialize(token2);
    }
    function exitLiteralAutolinkEmail(token2) {
      this.config.exit.autolinkEmail.call(this, token2);
    }
    function exitLiteralAutolink(token2) {
      this.exit(token2);
    }
    function transformGfmAutolinkLiterals(tree) {
      findAndReplace(
        tree,
        [
          [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/i, findUrl],
          [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/, findEmail]
        ],
        { ignore: ["link", "linkReference"] }
      );
    }
    function findUrl($0, protocol, domain2, path2, match2) {
      var prefix = "";
      var parts;
      var result;
      if (!previous(match2)) {
        return false;
      }
      if (/^w/i.test(protocol)) {
        domain2 = protocol + domain2;
        protocol = "";
        prefix = "http://";
      }
      if (!isCorrectDomain(domain2)) {
        return false;
      }
      parts = splitUrl(domain2 + path2);
      if (!parts[0])
        return false;
      result = {
        type: "link",
        title: null,
        url: prefix + protocol + parts[0],
        children: [{ type: "text", value: protocol + parts[0] }]
      };
      if (parts[1]) {
        result = [result, { type: "text", value: parts[1] }];
      }
      return result;
    }
    function findEmail($0, atext, label, match2) {
      if (!previous(match2, true) || /[_-]$/.test(label)) {
        return false;
      }
      return {
        type: "link",
        title: null,
        url: "mailto:" + atext + "@" + label,
        children: [{ type: "text", value: atext + "@" + label }]
      };
    }
    function isCorrectDomain(domain2) {
      var parts = domain2.split(".");
      if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
        return false;
      }
      return true;
    }
    function splitUrl(url) {
      var trail = /[!"&'),.:;<>?\]}]+$/.exec(url);
      var closingParenIndex;
      var openingParens;
      var closingParens;
      if (trail) {
        url = url.slice(0, trail.index);
        trail = trail[0];
        closingParenIndex = trail.indexOf(")");
        openingParens = ccount(url, "(");
        closingParens = ccount(url, ")");
        while (closingParenIndex !== -1 && openingParens > closingParens) {
          url += trail.slice(0, closingParenIndex + 1);
          trail = trail.slice(closingParenIndex + 1);
          closingParenIndex = trail.indexOf(")");
          closingParens++;
        }
      }
      return [url, trail];
    }
    function previous(match2, email) {
      var code2 = match2.input.charCodeAt(match2.index - 1);
      return (code2 !== code2 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email || code2 !== 47);
    }
    var fromMarkdown$2 = {};
    fromMarkdown$2.canContainEols = ["delete"];
    fromMarkdown$2.enter = { strikethrough: enterStrikethrough };
    fromMarkdown$2.exit = { strikethrough: exitStrikethrough };
    function enterStrikethrough(token2) {
      this.enter({ type: "delete", children: [] }, token2);
    }
    function exitStrikethrough(token2) {
      this.exit(token2);
    }
    var fromMarkdown$1 = {};
    fromMarkdown$1.enter = {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    };
    fromMarkdown$1.exit = {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit,
      tableHeader: exit,
      tableRow: exit
    };
    function enterTable(token2) {
      this.enter({ type: "table", align: token2._align, children: [] }, token2);
      this.setData("inTable", true);
    }
    function exitTable(token2) {
      this.exit(token2);
      this.setData("inTable");
    }
    function enterRow(token2) {
      this.enter({ type: "tableRow", children: [] }, token2);
    }
    function exit(token2) {
      this.exit(token2);
    }
    function enterCell(token2) {
      this.enter({ type: "tableCell", children: [] }, token2);
    }
    function exitCodeText(token2) {
      var value = this.resume();
      if (this.getData("inTable")) {
        value = value.replace(/\\([\\|])/g, replace);
      }
      this.stack[this.stack.length - 1].value = value;
      this.exit(token2);
    }
    function replace($0, $1) {
      return $1 === "|" ? $1 : $0;
    }
    var fromMarkdown = {};
    fromMarkdown.exit = {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    };
    function exitCheck(token2) {
      this.stack[this.stack.length - 2].checked = token2.type === "taskListCheckValueChecked";
    }
    function exitParagraphWithTaskListItem(token2) {
      var parent = this.stack[this.stack.length - 2];
      var node2 = this.stack[this.stack.length - 1];
      var siblings = parent.children;
      var head = node2.children[0];
      var index2 = -1;
      var firstParaghraph;
      if (parent && parent.type === "listItem" && typeof parent.checked === "boolean" && head && head.type === "text") {
        while (++index2 < siblings.length) {
          if (siblings[index2].type === "paragraph") {
            firstParaghraph = siblings[index2];
            break;
          }
        }
        if (firstParaghraph === node2) {
          head.value = head.value.slice(1);
          if (head.value.length === 0) {
            node2.children.shift();
          } else {
            head.position.start.column++;
            head.position.start.offset++;
            node2.position.start = Object.assign({}, head.position.start);
          }
        }
      }
      this.exit(token2);
    }
    var autolinkLiteral = fromMarkdown$3;
    var strikethrough = fromMarkdown$2;
    var table$1 = fromMarkdown$1;
    var taskListItem = fromMarkdown;
    var own = {}.hasOwnProperty;
    configure([
      autolinkLiteral,
      strikethrough,
      table$1,
      taskListItem
    ]);
    function configure(extensions) {
      var config = { transforms: [], canContainEols: [] };
      var length2 = extensions.length;
      var index2 = -1;
      while (++index2 < length2) {
        extension(config, extensions[index2]);
      }
      return config;
    }
    function extension(config, extension2) {
      var key;
      var left;
      var right;
      for (key in extension2) {
        left = own.call(config, key) ? config[key] : config[key] = {};
        right = extension2[key];
        if (key === "canContainEols" || key === "transforms") {
          config[key] = [].concat(left, right);
        } else {
          Object.assign(left, right);
        }
      }
    }
    var containerPhrasing = phrasing$1;
    function phrasing$1(parent, context, safeOptions) {
      var children = parent.children || [];
      var results = [];
      var index2 = -1;
      var before = safeOptions.before;
      var after;
      var handle;
      var child;
      while (++index2 < children.length) {
        child = children[index2];
        if (index2 + 1 < children.length) {
          handle = context.handle.handlers[children[index2 + 1].type];
          if (handle && handle.peek)
            handle = handle.peek;
          after = handle ? handle(children[index2 + 1], parent, context, {
            before: "",
            after: ""
          }).charAt(0) : "";
        } else {
          after = safeOptions.after;
        }
        if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
          results[results.length - 1] = results[results.length - 1].replace(
            /(\r?\n|\r)$/,
            " "
          );
          before = " ";
        }
        results.push(
          context.handle(child, parent, context, {
            before,
            after
          })
        );
        before = results[results.length - 1].slice(-1);
      }
      return results.join("");
    }
    var phrasing = containerPhrasing;
    handleDelete.peek = peekDelete;
    function handleDelete(node2, _, context) {
      var exit2 = context.enter("emphasis");
      var value = phrasing(node2, context, { before: "~", after: "~" });
      exit2();
      return "~~" + value + "~~";
    }
    function peekDelete() {
      return "~";
    }
    const SWRGlobalState = /* @__PURE__ */ new WeakMap();
    const EMPTY_CACHE = {};
    const INITIAL_CACHE = {};
    const noop = () => {
    };
    const UNDEFINED = (
      /*#__NOINLINE__*/
      noop()
    );
    const OBJECT = Object;
    const isUndefined$2 = (v2) => v2 === UNDEFINED;
    const isFunction$2 = (v2) => typeof v2 == "function";
    const mergeObjects = (a, b2) => ({
      ...a,
      ...b2
    });
    const STR_UNDEFINED = "undefined";
    const isWindowDefined = typeof window != STR_UNDEFINED;
    const isDocumentDefined = typeof document != STR_UNDEFINED;
    const createCacheHelper = (cache2, key) => {
      const state = SWRGlobalState.get(cache2);
      return [
        // Getter
        () => cache2.get(key) || EMPTY_CACHE,
        // Setter
        (info2) => {
          if (!isUndefined$2(key)) {
            const prev2 = cache2.get(key);
            if (!(key in INITIAL_CACHE)) {
              INITIAL_CACHE[key] = prev2;
            }
            state[5](key, mergeObjects(prev2, info2), prev2 || EMPTY_CACHE);
          }
        },
        // Subscriber
        state[6],
        // Get server cache snapshot
        () => {
          if (!isUndefined$2(key)) {
            if (key in INITIAL_CACHE)
              return INITIAL_CACHE[key];
          }
          return cache2.get(key) || EMPTY_CACHE;
        }
      ];
    };
    const table = /* @__PURE__ */ new WeakMap();
    let counter = 0;
    const stableHash = (arg) => {
      const type2 = typeof arg;
      const constructor = arg && arg.constructor;
      const isDate2 = constructor == Date;
      let result;
      let index2;
      if (OBJECT(arg) === arg && !isDate2 && constructor != RegExp) {
        result = table.get(arg);
        if (result)
          return result;
        result = ++counter + "~";
        table.set(arg, result);
        if (constructor == Array) {
          result = "@";
          for (index2 = 0; index2 < arg.length; index2++) {
            result += stableHash(arg[index2]) + ",";
          }
          table.set(arg, result);
        }
        if (constructor == OBJECT) {
          result = "#";
          const keys2 = OBJECT.keys(arg).sort();
          while (!isUndefined$2(index2 = keys2.pop())) {
            if (!isUndefined$2(arg[index2])) {
              result += index2 + ":" + stableHash(arg[index2]) + ",";
            }
          }
          table.set(arg, result);
        }
      } else {
        result = isDate2 ? arg.toJSON() : type2 == "symbol" ? arg.toString() : type2 == "string" ? JSON.stringify(arg) : "" + arg;
      }
      return result;
    };
    let online = true;
    const isOnline = () => online;
    const [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [
      window.addEventListener.bind(window),
      window.removeEventListener.bind(window)
    ] : [
      noop,
      noop
    ];
    const isVisible = () => {
      const visibilityState = isDocumentDefined && document.visibilityState;
      return isUndefined$2(visibilityState) || visibilityState !== "hidden";
    };
    const initFocus = (callback) => {
      if (isDocumentDefined) {
        document.addEventListener("visibilitychange", callback);
      }
      onWindowEvent("focus", callback);
      return () => {
        if (isDocumentDefined) {
          document.removeEventListener("visibilitychange", callback);
        }
        offWindowEvent("focus", callback);
      };
    };
    const initReconnect = (callback) => {
      const onOnline = () => {
        online = true;
        callback();
      };
      const onOffline = () => {
        online = false;
      };
      onWindowEvent("online", onOnline);
      onWindowEvent("offline", onOffline);
      return () => {
        offWindowEvent("online", onOnline);
        offWindowEvent("offline", onOffline);
      };
    };
    const preset = {
      isOnline,
      isVisible
    };
    const defaultConfigOptions = {
      initFocus,
      initReconnect
    };
    !React$3.useId;
    const IS_SERVER = !isWindowDefined || "Deno" in window;
    const navigatorConnection = typeof navigator !== "undefined" && navigator.connection;
    const slowConnection = !IS_SERVER && navigatorConnection && ([
      "slow-2g",
      "2g"
    ].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);
    const serialize = (key) => {
      if (isFunction$2(key)) {
        try {
          key = key();
        } catch (err) {
          key = "";
        }
      }
      const args = key;
      key = typeof key == "string" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : "";
      return [
        key,
        args
      ];
    };
    let __timestamp = 0;
    const getTimestamp = () => ++__timestamp;
    const FOCUS_EVENT = 0;
    const RECONNECT_EVENT = 1;
    const MUTATE_EVENT = 2;
    async function internalMutate(...args) {
      const [cache2, _key, _data, _opts] = args;
      const options = mergeObjects({
        populateCache: true,
        throwOnError: true
      }, typeof _opts === "boolean" ? {
        revalidate: _opts
      } : _opts || {});
      let populateCache = options.populateCache;
      const rollbackOnErrorOption = options.rollbackOnError;
      let optimisticData = options.optimisticData;
      const revalidate = options.revalidate !== false;
      const rollbackOnError = (error) => {
        return typeof rollbackOnErrorOption === "function" ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;
      };
      const throwOnError = options.throwOnError;
      if (isFunction$2(_key)) {
        const keyFilter = _key;
        const matchedKeys = [];
        const it2 = cache2.keys();
        for (let keyIt = it2.next(); !keyIt.done; keyIt = it2.next()) {
          const key = keyIt.value;
          if (
            // Skip the special useSWRInfinite and useSWRSubscription keys.
            !/^\$(inf|sub)\$/.test(key) && keyFilter(cache2.get(key)._k)
          ) {
            matchedKeys.push(key);
          }
        }
        return Promise.all(matchedKeys.map(mutateByKey));
      }
      return mutateByKey(_key);
      async function mutateByKey(_k) {
        const [key] = serialize(_k);
        if (!key)
          return;
        const [get2, set2] = createCacheHelper(cache2, key);
        const [EVENT_REVALIDATORS, MUTATION, FETCH] = SWRGlobalState.get(cache2);
        const revalidators = EVENT_REVALIDATORS[key];
        const startRevalidate = () => {
          if (revalidate) {
            delete FETCH[key];
            if (revalidators && revalidators[0]) {
              return revalidators[0](MUTATE_EVENT).then(() => get2().data);
            }
          }
          return get2().data;
        };
        if (args.length < 3) {
          return startRevalidate();
        }
        let data2 = _data;
        let error;
        const beforeMutationTs = getTimestamp();
        MUTATION[key] = [
          beforeMutationTs,
          0
        ];
        const hasOptimisticData = !isUndefined$2(optimisticData);
        const state = get2();
        const displayedData = state.data;
        const currentData = state._c;
        const committedData = isUndefined$2(currentData) ? displayedData : currentData;
        if (hasOptimisticData) {
          optimisticData = isFunction$2(optimisticData) ? optimisticData(committedData) : optimisticData;
          set2({
            data: optimisticData,
            _c: committedData
          });
        }
        if (isFunction$2(data2)) {
          try {
            data2 = data2(committedData);
          } catch (err) {
            error = err;
          }
        }
        if (data2 && isFunction$2(data2.then)) {
          data2 = await data2.catch((err) => {
            error = err;
          });
          if (beforeMutationTs !== MUTATION[key][0]) {
            if (error)
              throw error;
            return data2;
          } else if (error && hasOptimisticData && rollbackOnError(error)) {
            populateCache = true;
            data2 = committedData;
            set2({
              data: data2,
              _c: UNDEFINED
            });
          }
        }
        if (populateCache) {
          if (!error) {
            if (isFunction$2(populateCache)) {
              data2 = populateCache(data2, committedData);
            }
            set2({
              data: data2,
              _c: UNDEFINED
            });
          }
        }
        MUTATION[key][1] = getTimestamp();
        const res = await startRevalidate();
        set2({
          _c: UNDEFINED
        });
        if (error) {
          if (throwOnError)
            throw error;
          return;
        }
        return populateCache ? res : data2;
      }
    }
    const revalidateAllKeys = (revalidators, type2) => {
      for (const key in revalidators) {
        if (revalidators[key][0])
          revalidators[key][0](type2);
      }
    };
    const initCache = (provider, options) => {
      if (!SWRGlobalState.has(provider)) {
        const opts = mergeObjects(defaultConfigOptions, options);
        const EVENT_REVALIDATORS = {};
        const mutate2 = internalMutate.bind(UNDEFINED, provider);
        let unmount2 = noop;
        const subscriptions = {};
        const subscribe = (key, callback) => {
          const subs = subscriptions[key] || [];
          subscriptions[key] = subs;
          subs.push(callback);
          return () => subs.splice(subs.indexOf(callback), 1);
        };
        const setter = (key, value, prev2) => {
          provider.set(key, value);
          const subs = subscriptions[key];
          if (subs) {
            for (const fn of subs) {
              fn(value, prev2);
            }
          }
        };
        const initProvider = () => {
          if (!SWRGlobalState.has(provider)) {
            SWRGlobalState.set(provider, [
              EVENT_REVALIDATORS,
              {},
              {},
              {},
              mutate2,
              setter,
              subscribe
            ]);
            if (!IS_SERVER) {
              const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));
              const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));
              unmount2 = () => {
                releaseFocus && releaseFocus();
                releaseReconnect && releaseReconnect();
                SWRGlobalState.delete(provider);
              };
            }
          }
        };
        initProvider();
        return [
          provider,
          mutate2,
          initProvider,
          unmount2
        ];
      }
      return [
        provider,
        SWRGlobalState.get(provider)[4]
      ];
    };
    const onErrorRetry = (_, __, config, revalidate, opts) => {
      const maxRetryCount = config.errorRetryCount;
      const currentRetryCount = opts.retryCount;
      const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;
      if (!isUndefined$2(maxRetryCount) && currentRetryCount > maxRetryCount) {
        return;
      }
      setTimeout(revalidate, timeout, opts);
    };
    const compare = (currentData, newData) => stableHash(currentData) == stableHash(newData);
    const [cache, mutate] = initCache(/* @__PURE__ */ new Map());
    mergeObjects(
      {
        // events
        onLoadingSlow: noop,
        onSuccess: noop,
        onError: noop,
        onErrorRetry,
        onDiscarded: noop,
        // switches
        revalidateOnFocus: true,
        revalidateOnReconnect: true,
        revalidateIfStale: true,
        shouldRetryOnError: true,
        // timeouts
        errorRetryInterval: slowConnection ? 1e4 : 5e3,
        focusThrottleInterval: 5 * 1e3,
        dedupingInterval: 2 * 1e3,
        loadingTimeout: slowConnection ? 5e3 : 3e3,
        // providers
        compare,
        isPaused: () => false,
        cache,
        mutate,
        fallback: {}
      },
      // use web preset by default
      preset
    );
    reactExports.createContext({});
    const enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;
    const use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];
    const setupDevTools = () => {
      if (enableDevtools) {
        window.__SWR_DEVTOOLS_REACT__ = React$3;
      }
    };
    const middleware = (useSWRNext) => (key_, fetcher_, config) => {
      const fetcher = fetcher_ && ((...args) => {
        const key = serialize(key_)[0];
        const [, , , PRELOAD] = SWRGlobalState.get(cache);
        const req = PRELOAD[key];
        if (req) {
          delete PRELOAD[key];
          return req;
        }
        return fetcher_(...args);
      });
      return useSWRNext(key_, fetcher, config);
    };
    use.concat(middleware);
    setupDevTools();
    function _createForOfIteratorHelper(o2, allowArrayLike) {
      var it2 = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
      if (!it2) {
        if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it2)
            o2 = it2;
          var i2 = 0;
          var F2 = function F3() {
          };
          return {
            s: F2,
            n: function n2() {
              if (i2 >= o2.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o2[i2++]
              };
            },
            e: function e2(_e2) {
              throw _e2;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function s() {
          it2 = it2.call(o2);
        },
        n: function n2() {
          var step = it2.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e2(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function f2() {
          try {
            if (!normalCompletion && it2["return"] != null)
              it2["return"]();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    const zhCN = {
      moneySymbol: "￥",
      deleteThisLine: "删除此行",
      copyThisLine: "复制此行",
      form: {
        lightFilter: {
          more: "更多筛选",
          clear: "清除",
          confirm: "确认",
          itemUnit: "项"
        }
      },
      tableForm: {
        search: "查询",
        reset: "重置",
        submit: "提交",
        collapsed: "展开",
        expand: "收起",
        inputPlaceholder: "请输入",
        selectPlaceholder: "请选择"
      },
      alert: {
        clear: "取消选择",
        selected: "已选择",
        item: "项"
      },
      pagination: {
        total: {
          range: "第",
          total: "条/总共",
          item: "条"
        }
      },
      tableToolBar: {
        leftPin: "固定在列首",
        rightPin: "固定在列尾",
        noPin: "不固定",
        leftFixedTitle: "固定在左侧",
        rightFixedTitle: "固定在右侧",
        noFixedTitle: "不固定",
        reset: "重置",
        columnDisplay: "列展示",
        columnSetting: "列设置",
        fullScreen: "全屏",
        exitFullScreen: "退出全屏",
        reload: "刷新",
        density: "密度",
        densityDefault: "正常",
        densityLarger: "默认",
        densityMiddle: "中等",
        densitySmall: "紧凑"
      },
      stepsForm: {
        next: "下一步",
        prev: "上一步",
        submit: "提交"
      },
      loginForm: {
        submitText: "登录"
      },
      editableTable: {
        onlyOneLineEditor: "只能同时编辑一行",
        action: {
          save: "保存",
          cancel: "取消",
          delete: "删除",
          add: "添加一行数据"
        }
      },
      switch: {
        open: "打开",
        close: "关闭"
      }
    };
    function get$1(source, path2, defaultValue) {
      var paths = path2.replace(/\[(\d+)\]/g, ".$1").split(".");
      var result = source;
      var message2 = defaultValue;
      var _iterator = _createForOfIteratorHelper(paths), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var p2 = _step.value;
          message2 = Object(result)[p2];
          result = Object(result)[p2];
          if (message2 === void 0) {
            return defaultValue;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return message2;
    }
    var createIntl = function createIntl2(locale2, localeMap2) {
      return {
        getMessage: function getMessage(id2, defaultMessage2) {
          return get$1(localeMap2, id2, defaultMessage2) || defaultMessage2;
        },
        locale: locale2
      };
    };
    var zhCNIntl = createIntl("zh_CN", zhCN);
    var _theme$defaultAlgorit;
    var defaultToken = {
      blue: "#1677ff",
      purple: "#722ED1",
      cyan: "#13C2C2",
      green: "#52C41A",
      magenta: "#EB2F96",
      pink: "#eb2f96",
      red: "#F5222D",
      orange: "#FA8C16",
      yellow: "#FADB14",
      volcano: "#FA541C",
      geekblue: "#2F54EB",
      gold: "#FAAD14",
      lime: "#A0D911",
      colorPrimary: "#1677ff",
      colorSuccess: "#52c41a",
      colorWarning: "#faad14",
      colorError: "#ff7875",
      colorInfo: "#1677ff",
      colorTextBase: "#000",
      colorBgBase: "#fff",
      fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
      fontSize: 14,
      lineWidth: 1,
      lineType: "solid",
      motionUnit: 0.1,
      motionBase: 0,
      motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
      motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
      motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
      motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
      motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
      motionEaseInQuint: "cubic-bezier(0.645, 0.045, 0.355, 1)",
      motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
      borderRadius: 4,
      sizeUnit: 4,
      sizeStep: 4,
      sizePopupArrow: 16,
      controlHeight: 32,
      zIndexBase: 0,
      zIndexPopupBase: 1e3,
      opacityImage: 1,
      wireframe: false,
      "blue-1": "#e6f4ff",
      "blue-2": "#bae0ff",
      "blue-3": "#91caff",
      "blue-4": "#69b1ff",
      "blue-5": "#4096ff",
      "blue-6": "#1677ff",
      "blue-7": "#0958d9",
      "blue-8": "#003eb3",
      "blue-9": "#002c8c",
      "blue-10": "#001d66",
      "purple-1": "#f9f0ff",
      "purple-2": "#efdbff",
      "purple-3": "#d3adf7",
      "purple-4": "#b37feb",
      "purple-5": "#9254de",
      "purple-6": "#722ed1",
      "purple-7": "#531dab",
      "purple-8": "#391085",
      "purple-9": "#22075e",
      "purple-10": "#120338",
      "cyan-1": "#e6fffb",
      "cyan-2": "#b5f5ec",
      "cyan-3": "#87e8de",
      "cyan-4": "#5cdbd3",
      "cyan-5": "#36cfc9",
      "cyan-6": "#13c2c2",
      "cyan-7": "#08979c",
      "cyan-8": "#006d75",
      "cyan-9": "#00474f",
      "cyan-10": "#002329",
      "green-1": "#f6ffed",
      "green-2": "#d9f7be",
      "green-3": "#b7eb8f",
      "green-4": "#95de64",
      "green-5": "#73d13d",
      "green-6": "#52c41a",
      "green-7": "#389e0d",
      "green-8": "#237804",
      "green-9": "#135200",
      "green-10": "#092b00",
      "magenta-1": "#fff0f6",
      "magenta-2": "#ffd6e7",
      "magenta-3": "#ffadd2",
      "magenta-4": "#ff85c0",
      "magenta-5": "#f759ab",
      "magenta-6": "#eb2f96",
      "magenta-7": "#c41d7f",
      "magenta-8": "#9e1068",
      "magenta-9": "#780650",
      "magenta-10": "#520339",
      "pink-1": "#fff0f6",
      "pink-2": "#ffd6e7",
      "pink-3": "#ffadd2",
      "pink-4": "#ff85c0",
      "pink-5": "#f759ab",
      "pink-6": "#eb2f96",
      "pink-7": "#c41d7f",
      "pink-8": "#9e1068",
      "pink-9": "#780650",
      "pink-10": "#520339",
      "red-1": "#fff1f0",
      "red-2": "#ffccc7",
      "red-3": "#ffa39e",
      "red-4": "#ff7875",
      "red-5": "#ff4d4f",
      "red-6": "#f5222d",
      "red-7": "#cf1322",
      "red-8": "#a8071a",
      "red-9": "#820014",
      "red-10": "#5c0011",
      "orange-1": "#fff7e6",
      "orange-2": "#ffe7ba",
      "orange-3": "#ffd591",
      "orange-4": "#ffc069",
      "orange-5": "#ffa940",
      "orange-6": "#fa8c16",
      "orange-7": "#d46b08",
      "orange-8": "#ad4e00",
      "orange-9": "#873800",
      "orange-10": "#612500",
      "yellow-1": "#feffe6",
      "yellow-2": "#ffffb8",
      "yellow-3": "#fffb8f",
      "yellow-4": "#fff566",
      "yellow-5": "#ffec3d",
      "yellow-6": "#fadb14",
      "yellow-7": "#d4b106",
      "yellow-8": "#ad8b00",
      "yellow-9": "#876800",
      "yellow-10": "#614700",
      "volcano-1": "#fff2e8",
      "volcano-2": "#ffd8bf",
      "volcano-3": "#ffbb96",
      "volcano-4": "#ff9c6e",
      "volcano-5": "#ff7a45",
      "volcano-6": "#fa541c",
      "volcano-7": "#d4380d",
      "volcano-8": "#ad2102",
      "volcano-9": "#871400",
      "volcano-10": "#610b00",
      "geekblue-1": "#f0f5ff",
      "geekblue-2": "#d6e4ff",
      "geekblue-3": "#adc6ff",
      "geekblue-4": "#85a5ff",
      "geekblue-5": "#597ef7",
      "geekblue-6": "#2f54eb",
      "geekblue-7": "#1d39c4",
      "geekblue-8": "#10239e",
      "geekblue-9": "#061178",
      "geekblue-10": "#030852",
      "gold-1": "#fffbe6",
      "gold-2": "#fff1b8",
      "gold-3": "#ffe58f",
      "gold-4": "#ffd666",
      "gold-5": "#ffc53d",
      "gold-6": "#faad14",
      "gold-7": "#d48806",
      "gold-8": "#ad6800",
      "gold-9": "#874d00",
      "gold-10": "#613400",
      "lime-1": "#fcffe6",
      "lime-2": "#f4ffb8",
      "lime-3": "#eaff8f",
      "lime-4": "#d3f261",
      "lime-5": "#bae637",
      "lime-6": "#a0d911",
      "lime-7": "#7cb305",
      "lime-8": "#5b8c00",
      "lime-9": "#3f6600",
      "lime-10": "#254000",
      colorText: "rgba(0, 0, 0, 0.88)",
      colorTextSecondary: "rgba(0, 0, 0, 0.65)",
      colorTextTertiary: "rgba(0, 0, 0, 0.45)",
      colorTextQuaternary: "rgba(0, 0, 0, 0.25)",
      colorFill: "rgba(0, 0, 0, 0.15)",
      colorFillSecondary: "rgba(0, 0, 0, 0.06)",
      colorFillTertiary: "rgba(0, 0, 0, 0.04)",
      colorFillQuaternary: "rgba(0, 0, 0, 0.02)",
      colorBgLayout: "hsl(220,23%,97%)",
      colorBgContainer: "#ffffff",
      colorBgElevated: "#ffffff",
      colorBgSpotlight: "rgba(0, 0, 0, 0.85)",
      colorBorder: "#d9d9d9",
      colorBorderSecondary: "#f0f0f0",
      colorPrimaryBg: "#e6f4ff",
      colorPrimaryBgHover: "#bae0ff",
      colorPrimaryBorder: "#91caff",
      colorPrimaryBorderHover: "#69b1ff",
      colorPrimaryHover: "#4096ff",
      colorPrimaryActive: "#0958d9",
      colorPrimaryTextHover: "#4096ff",
      colorPrimaryText: "#1677ff",
      colorPrimaryTextActive: "#0958d9",
      colorSuccessBg: "#f6ffed",
      colorSuccessBgHover: "#d9f7be",
      colorSuccessBorder: "#b7eb8f",
      colorSuccessBorderHover: "#95de64",
      colorSuccessHover: "#95de64",
      colorSuccessActive: "#389e0d",
      colorSuccessTextHover: "#73d13d",
      colorSuccessText: "#52c41a",
      colorSuccessTextActive: "#389e0d",
      colorErrorBg: "#fff2f0",
      colorErrorBgHover: "#fff1f0",
      colorErrorBorder: "#ffccc7",
      colorErrorBorderHover: "#ffa39e",
      colorErrorHover: "#ffa39e",
      colorErrorActive: "#d9363e",
      colorErrorTextHover: "#ff7875",
      colorErrorText: "#ff4d4f",
      colorErrorTextActive: "#d9363e",
      colorWarningBg: "#fffbe6",
      colorWarningBgHover: "#fff1b8",
      colorWarningBorder: "#ffe58f",
      colorWarningBorderHover: "#ffd666",
      colorWarningHover: "#ffd666",
      colorWarningActive: "#d48806",
      colorWarningTextHover: "#ffc53d",
      colorWarningText: "#faad14",
      colorWarningTextActive: "#d48806",
      colorInfoBg: "#e6f4ff",
      colorInfoBgHover: "#bae0ff",
      colorInfoBorder: "#91caff",
      colorInfoBorderHover: "#69b1ff",
      colorInfoHover: "#69b1ff",
      colorInfoActive: "#0958d9",
      colorInfoTextHover: "#4096ff",
      colorInfoText: "#1677ff",
      colorInfoTextActive: "#0958d9",
      colorBgMask: "rgba(0, 0, 0, 0.45)",
      colorWhite: "#fff",
      sizeXXL: 48,
      sizeXL: 32,
      sizeLG: 24,
      sizeMD: 20,
      sizeMS: 16,
      size: 16,
      sizeSM: 12,
      sizeXS: 8,
      sizeXXS: 4,
      controlHeightSM: 24,
      controlHeightXS: 16,
      controlHeightLG: 40,
      motionDurationFast: "0.1s",
      motionDurationMid: "0.2s",
      motionDurationSlow: "0.3s",
      fontSizes: [12, 14, 16, 20, 24, 30, 38, 46, 56, 68],
      lineHeights: [1.6666666666666667, 1.5714285714285714, 1.5, 1.4, 1.3333333333333333, 1.2666666666666666, 1.2105263157894737, 1.173913043478261, 1.1428571428571428, 1.1176470588235294],
      lineWidthBold: 2,
      borderRadiusXS: 1,
      borderRadiusSM: 4,
      borderRadiusLG: 8,
      borderRadiusOuter: 4,
      colorLink: "#1677ff",
      colorLinkHover: "#69b1ff",
      colorLinkActive: "#0958d9",
      colorFillContent: "rgba(0, 0, 0, 0.06)",
      colorFillContentHover: "rgba(0, 0, 0, 0.15)",
      colorFillAlter: "rgba(0, 0, 0, 0.02)",
      colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
      colorBorderBg: "#ffffff",
      colorSplit: "rgba(5, 5, 5, 0.06)",
      colorTextPlaceholder: "rgba(0, 0, 0, 0.25)",
      colorTextDisabled: "rgba(0, 0, 0, 0.25)",
      colorTextHeading: "rgba(0, 0, 0, 0.88)",
      colorTextLabel: "rgba(0, 0, 0, 0.65)",
      colorTextDescription: "rgba(0, 0, 0, 0.45)",
      colorTextLightSolid: "#fff",
      colorHighlight: "#ff7875",
      colorBgTextHover: "rgba(0, 0, 0, 0.06)",
      colorBgTextActive: "rgba(0, 0, 0, 0.15)",
      colorIcon: "rgba(0, 0, 0, 0.45)",
      colorIconHover: "rgba(0, 0, 0, 0.88)",
      colorErrorOutline: "rgba(255, 38, 5, 0.06)",
      colorWarningOutline: "rgba(255, 215, 5, 0.1)",
      fontSizeSM: 12,
      fontSizeLG: 16,
      fontSizeXL: 20,
      fontSizeHeading1: 38,
      fontSizeHeading2: 30,
      fontSizeHeading3: 24,
      fontSizeHeading4: 20,
      fontSizeHeading5: 16,
      fontSizeIcon: 12,
      lineHeight: 1.5714285714285714,
      lineHeightLG: 1.5,
      lineHeightSM: 1.6666666666666667,
      lineHeightHeading1: 1.2105263157894737,
      lineHeightHeading2: 1.2666666666666666,
      lineHeightHeading3: 1.3333333333333333,
      lineHeightHeading4: 1.4,
      lineHeightHeading5: 1.5,
      controlOutlineWidth: 2,
      controlInteractiveSize: 16,
      controlItemBgHover: "rgba(0, 0, 0, 0.04)",
      controlItemBgActive: "#e6f4ff",
      controlItemBgActiveHover: "#bae0ff",
      controlItemBgActiveDisabled: "rgba(0, 0, 0, 0.15)",
      controlTmpOutline: "rgba(0, 0, 0, 0.02)",
      controlOutline: "rgba(5, 145, 255, 0.1)",
      fontWeightStrong: 600,
      opacityLoading: 0.65,
      linkDecoration: "none",
      linkHoverDecoration: "none",
      linkFocusDecoration: "none",
      controlPaddingHorizontal: 12,
      controlPaddingHorizontalSM: 8,
      paddingXXS: 4,
      paddingXS: 8,
      paddingSM: 12,
      padding: 16,
      paddingMD: 20,
      paddingLG: 24,
      paddingXL: 32,
      paddingContentHorizontalLG: 24,
      paddingContentVerticalLG: 16,
      paddingContentHorizontal: 16,
      paddingContentVertical: 12,
      paddingContentHorizontalSM: 16,
      paddingContentVerticalSM: 8,
      marginXXS: 4,
      marginXS: 8,
      marginSM: 12,
      margin: 16,
      marginMD: 20,
      marginLG: 24,
      marginXL: 32,
      marginXXL: 48,
      boxShadow: "0 1px 2px 0 rgba(0, 0, 0, 0.03),0 1px 6px -1px rgba(0, 0, 0, 0.02),0 2px 4px 0 rgba(0, 0, 0, 0.02)",
      boxShadowSecondary: "0 6px 16px 0 rgba(0, 0, 0, 0.08),0 3px 6px -4px rgba(0, 0, 0, 0.12),0 9px 28px 8px rgba(0, 0, 0, 0.05)",
      screenXS: 480,
      screenXSMin: 480,
      screenXSMax: 479,
      screenSM: 576,
      screenSMMin: 576,
      screenSMMax: 575,
      screenMD: 768,
      screenMDMin: 768,
      screenMDMax: 767,
      screenLG: 992,
      screenLGMin: 992,
      screenLGMax: 991,
      screenXL: 1200,
      screenXLMin: 1200,
      screenXLMax: 1199,
      screenXXL: 1600,
      screenXXLMin: 1600,
      screenXXLMax: 1599,
      boxShadowPopoverArrow: "3px 3px 7px rgba(0, 0, 0, 0.1)",
      boxShadowCard: "0 1px 2px -2px rgba(0, 0, 0, 0.16),0 3px 6px 0 rgba(0, 0, 0, 0.12),0 5px 12px 4px rgba(0, 0, 0, 0.09)",
      boxShadowDrawerRight: "-6px 0 16px 0 rgba(0, 0, 0, 0.08),-3px 0 6px -4px rgba(0, 0, 0, 0.12),-9px 0 28px 8px rgba(0, 0, 0, 0.05)",
      boxShadowDrawerLeft: "6px 0 16px 0 rgba(0, 0, 0, 0.08),3px 0 6px -4px rgba(0, 0, 0, 0.12),9px 0 28px 8px rgba(0, 0, 0, 0.05)",
      boxShadowDrawerUp: "0 6px 16px 0 rgba(0, 0, 0, 0.08),0 3px 6px -4px rgba(0, 0, 0, 0.12),0 9px 28px 8px rgba(0, 0, 0, 0.05)",
      boxShadowDrawerDown: "0 -6px 16px 0 rgba(0, 0, 0, 0.08),0 -3px 6px -4px rgba(0, 0, 0, 0.12),0 -9px 28px 8px rgba(0, 0, 0, 0.05)",
      boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)",
      _tokenKey: "19w80ff",
      _hashId: "css-dev-only-do-not-override-i2zu9q"
    };
    var hashCode = function hashCode2(str) {
      var seed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
      for (var i2 = 0, ch2; i2 < str.length; i2++) {
        ch2 = str.charCodeAt(i2);
        h1 = Math.imul(h1 ^ ch2, 2654435761);
        h2 = Math.imul(h2 ^ ch2, 1597334677);
      }
      h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
      h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
      return 4294967296 * (2097151 & h2) + (h1 >>> 0);
    };
    var emptyTheme = createTheme(function(token2) {
      return token2;
    });
    var token$1 = {
      theme: emptyTheme,
      token: _objectSpread2$3(_objectSpread2$3({}, defaultToken), theme === null || theme === void 0 ? void 0 : (_theme$defaultAlgorit = theme.defaultAlgorithm) === null || _theme$defaultAlgorit === void 0 ? void 0 : _theme$defaultAlgorit.call(theme, theme === null || theme === void 0 ? void 0 : theme.defaultSeed)),
      hashId: "pro-".concat(hashCode(JSON.stringify(defaultToken)))
    };
    var useToken = function useToken2() {
      return token$1;
    };
    const batToken = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      defaultToken,
      emptyTheme,
      hashCode,
      token: token$1,
      useToken
    }, Symbol.toStringTag, { value: "Module" }));
    var genTheme = function genTheme2() {
      if (typeof theme === "undefined" || !theme)
        return batToken;
      return theme;
    };
    var proTheme = genTheme();
    proTheme.useToken;
    var resetComponent = function resetComponent2(token2) {
      return {
        boxSizing: "border-box",
        margin: 0,
        padding: 0,
        color: token2.colorText,
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        listStyle: "none"
      };
    };
    var operationUnit = function operationUnit2(token2) {
      return {
        // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
        // And Typography use this to generate link style which should not do this.
        color: token2.colorLink,
        outline: "none",
        cursor: "pointer",
        transition: "color ".concat(token2.motionDurationSlow),
        "&:focus, &:hover": {
          color: token2.colorLinkHover
        },
        "&:active": {
          color: token2.colorLinkActive
        }
      };
    };
    function useStyle$1(componentName, styleFn) {
      var _useContext = reactExports.useContext(ProProvider), _useContext$token = _useContext.token, token2 = _useContext$token === void 0 ? {} : _useContext$token, _useContext$hashId = _useContext.hashId, hashId = _useContext$hashId === void 0 ? "" : _useContext$hashId, theme2 = _useContext.theme;
      var _useContext2 = reactExports.useContext(ConfigProvider$1.ConfigContext), getPrefixCls = _useContext2.getPrefixCls;
      token2.antCls = ".".concat(getPrefixCls());
      return {
        wrapSSR: useStyleRegister({
          theme: theme2,
          token: token2,
          hashId,
          path: [componentName]
        }, function() {
          return styleFn(token2);
        }),
        hashId
      };
    }
    var ProConfigContext = /* @__PURE__ */ React$3.createContext({
      intl: _objectSpread2$3(_objectSpread2$3({}, zhCNIntl), {}, {
        locale: "default"
      }),
      valueTypeMap: {},
      theme: emptyTheme,
      hashed: true,
      dark: false,
      token: defaultToken
    });
    ProConfigContext.Consumer;
    ProConfigContext.displayName = "ProProvider";
    var ProProvider = ProConfigContext;
    var _typeofExports = {};
    var _typeof$2 = {
      get exports() {
        return _typeofExports;
      },
      set exports(v2) {
        _typeofExports = v2;
      }
    };
    (function(module2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        return module2.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof2(obj);
      }
      module2.exports = _typeof2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(_typeof$2);
    var interopRequireDefaultExports = {};
    var interopRequireDefault = {
      get exports() {
        return interopRequireDefaultExports;
      },
      set exports(v2) {
        interopRequireDefaultExports = v2;
      }
    };
    (function(module2) {
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      module2.exports = _interopRequireDefault2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(interopRequireDefault);
    var Context = {};
    Object.defineProperty(Context, "__esModule", {
      value: true
    });
    Context.default = void 0;
    var _react = reactExports;
    var IconContext = /* @__PURE__ */ (0, _react.createContext)({});
    var _default$3 = IconContext;
    Context.default = _default$3;
    var objectSpread2Exports = {};
    var objectSpread2 = {
      get exports() {
        return objectSpread2Exports;
      },
      set exports(v2) {
        objectSpread2Exports = v2;
      }
    };
    var definePropertyExports = {};
    var defineProperty = {
      get exports() {
        return definePropertyExports;
      },
      set exports(v2) {
        definePropertyExports = v2;
      }
    };
    var toPropertyKeyExports = {};
    var toPropertyKey = {
      get exports() {
        return toPropertyKeyExports;
      },
      set exports(v2) {
        toPropertyKeyExports = v2;
      }
    };
    var toPrimitiveExports = {};
    var toPrimitive = {
      get exports() {
        return toPrimitiveExports;
      },
      set exports(v2) {
        toPrimitiveExports = v2;
      }
    };
    (function(module2) {
      var _typeof2 = _typeofExports["default"];
      function _toPrimitive2(input, hint) {
        if (_typeof2(input) !== "object" || input === null)
          return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof2(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      module2.exports = _toPrimitive2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(toPrimitive);
    (function(module2) {
      var _typeof2 = _typeofExports["default"];
      var toPrimitive2 = toPrimitiveExports;
      function _toPropertyKey2(arg) {
        var key = toPrimitive2(arg, "string");
        return _typeof2(key) === "symbol" ? key : String(key);
      }
      module2.exports = _toPropertyKey2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(toPropertyKey);
    (function(module2) {
      var toPropertyKey2 = toPropertyKeyExports;
      function _defineProperty2(obj, key, value) {
        key = toPropertyKey2(key);
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      module2.exports = _defineProperty2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(defineProperty);
    (function(module2) {
      var defineProperty2 = definePropertyExports;
      function ownKeys2(object2, enumerableOnly) {
        var keys2 = Object.keys(object2);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object2);
          enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
          })), keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread22(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = null != arguments[i2] ? arguments[i2] : {};
          i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
            defineProperty2(target, key, source[key]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
        return target;
      }
      module2.exports = _objectSpread22, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(objectSpread2);
    var warning$1 = {};
    Object.defineProperty(warning$1, "__esModule", {
      value: true
    });
    warning$1.call = call;
    warning$1.default = void 0;
    warning$1.note = note;
    warning$1.noteOnce = noteOnce;
    warning$1.resetWarned = resetWarned;
    warning$1.warning = warning;
    warning$1.warningOnce = warningOnce;
    var warned = {};
    function warning(valid, message2) {
    }
    function note(valid, message2) {
    }
    function resetWarned() {
      warned = {};
    }
    function call(method2, valid, message2) {
      if (!valid && !warned[message2]) {
        method2(false, message2);
        warned[message2] = true;
      }
    }
    function warningOnce(valid, message2) {
      call(warning, valid, message2);
    }
    function noteOnce(valid, message2) {
      call(note, valid, message2);
    }
    var _default$2 = warningOnce;
    warning$1.default = _default$2;
    const require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(es);
    var canUseDom$1 = {};
    Object.defineProperty(canUseDom$1, "__esModule", {
      value: true
    });
    canUseDom$1.default = canUseDom;
    function canUseDom() {
      return !!(typeof window !== "undefined" && window.document && window.document.createElement);
    }
    var dynamicCSS = {};
    var contains$1 = {};
    Object.defineProperty(contains$1, "__esModule", {
      value: true
    });
    contains$1.default = contains;
    function contains(root2, n2) {
      if (!root2) {
        return false;
      }
      if (root2.contains) {
        return root2.contains(n2);
      }
      var node2 = n2;
      while (node2) {
        if (node2 === root2) {
          return true;
        }
        node2 = node2.parentNode;
      }
      return false;
    }
    var _interopRequireDefault$2 = interopRequireDefaultExports.default;
    Object.defineProperty(dynamicCSS, "__esModule", {
      value: true
    });
    dynamicCSS.clearContainerCache = clearContainerCache;
    dynamicCSS.injectCSS = injectCSS;
    dynamicCSS.removeCSS = removeCSS;
    dynamicCSS.updateCSS = updateCSS;
    var _canUseDom = _interopRequireDefault$2(canUseDom$1);
    var _contains = _interopRequireDefault$2(contains$1);
    var APPEND_ORDER = "data-rc-order";
    var MARK_KEY = "rc-util-key";
    var containerCache = /* @__PURE__ */ new Map();
    function getMark() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark2 = _ref.mark;
      if (mark2) {
        return mark2.startsWith("data-") ? mark2 : "data-".concat(mark2);
      }
      return MARK_KEY;
    }
    function getContainer(option) {
      if (option.attachTo) {
        return option.attachTo;
      }
      var head = document.querySelector("head");
      return head || document.body;
    }
    function getOrder(prepend) {
      if (prepend === "queue") {
        return "prependQueue";
      }
      return prepend ? "prepend" : "append";
    }
    function findStyles(container2) {
      return Array.from((containerCache.get(container2) || container2).children).filter(function(node2) {
        return node2.tagName === "STYLE";
      });
    }
    function injectCSS(css2) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!(0, _canUseDom.default)()) {
        return null;
      }
      var csp = option.csp, prepend = option.prepend;
      var styleNode = document.createElement("style");
      styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
      if (csp !== null && csp !== void 0 && csp.nonce) {
        styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
      }
      styleNode.innerHTML = css2;
      var container2 = getContainer(option);
      var firstChild = container2.firstChild;
      if (prepend) {
        if (prepend === "queue") {
          var existStyle = findStyles(container2).filter(function(node2) {
            return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER));
          });
          if (existStyle.length) {
            container2.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
            return styleNode;
          }
        }
        container2.insertBefore(styleNode, firstChild);
      } else {
        container2.appendChild(styleNode);
      }
      return styleNode;
    }
    function findExistNode(key) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var container2 = getContainer(option);
      return findStyles(container2).find(function(node2) {
        return node2.getAttribute(getMark(option)) === key;
      });
    }
    function removeCSS(key) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var existNode = findExistNode(key, option);
      if (existNode) {
        var container2 = getContainer(option);
        container2.removeChild(existNode);
      }
    }
    function syncRealContainer(container2, option) {
      var cachedRealContainer = containerCache.get(container2);
      if (!cachedRealContainer || !(0, _contains.default)(document, cachedRealContainer)) {
        var placeholderStyle = injectCSS("", option);
        var parentNode = placeholderStyle.parentNode;
        containerCache.set(container2, parentNode);
        container2.removeChild(placeholderStyle);
      }
    }
    function clearContainerCache() {
      containerCache.clear();
    }
    function updateCSS(css2, key) {
      var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var container2 = getContainer(option);
      syncRealContainer(container2, option);
      var existNode = findExistNode(key, option);
      if (existNode) {
        var _option$csp, _option$csp2;
        if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
          var _option$csp3;
          existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
        }
        if (existNode.innerHTML !== css2) {
          existNode.innerHTML = css2;
        }
        return existNode;
      }
      var newNode = injectCSS(css2, option);
      newNode.setAttribute(getMark(option), key);
      return newNode;
    }
    var ArrowLeftOutlinedExports = {};
    var ArrowLeftOutlined$4 = {
      get exports() {
        return ArrowLeftOutlinedExports;
      },
      set exports(v2) {
        ArrowLeftOutlinedExports = v2;
      }
    };
    var ArrowLeftOutlined$3 = {};
    var ArrowLeftOutlined$2 = {};
    var hasRequiredArrowLeftOutlined;
    function requireArrowLeftOutlined() {
      if (hasRequiredArrowLeftOutlined)
        return ArrowLeftOutlined$2;
      hasRequiredArrowLeftOutlined = 1;
      Object.defineProperty(ArrowLeftOutlined$2, "__esModule", { value: true });
      var ArrowLeftOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M872 474H286.9l350.2-304c5.6-4.9 2.2-14-5.2-14h-88.5c-3.9 0-7.6 1.4-10.5 3.9L155 487.8a31.96 31.96 0 000 48.3L535.1 866c1.5 1.3 3.3 2 5.2 2h91.5c7.4 0 10.8-9.2 5.2-14L286.9 550H872c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, "name": "arrow-left", "theme": "outlined" };
      ArrowLeftOutlined$2.default = ArrowLeftOutlined2;
      return ArrowLeftOutlined$2;
    }
    var AntdIcon = {};
    const require$$3 = /* @__PURE__ */ getAugmentedNamespace(slicedToArray);
    const require$$4 = /* @__PURE__ */ getAugmentedNamespace(defineProperty$2);
    const require$$5 = /* @__PURE__ */ getAugmentedNamespace(objectWithoutProperties);
    var IconBase = {};
    var utils$b = {};
    var hasRequiredUtils;
    function requireUtils() {
      if (hasRequiredUtils)
        return utils$b;
      hasRequiredUtils = 1;
      var _interopRequireDefault2 = interopRequireDefaultExports;
      var _typeof3 = _typeofExports;
      Object.defineProperty(utils$b, "__esModule", {
        value: true
      });
      utils$b.generate = generate2;
      utils$b.getSecondaryColor = getSecondaryColor2;
      utils$b.iconStyles = void 0;
      utils$b.isIconDefinition = isIconDefinition2;
      utils$b.normalizeAttrs = normalizeAttrs2;
      utils$b.normalizeTwoToneColors = normalizeTwoToneColors2;
      utils$b.useInsertStyles = utils$b.svgBaseProps = void 0;
      utils$b.warning = warning2;
      var _objectSpread22 = _interopRequireDefault2(objectSpread2Exports);
      var _typeof2 = _interopRequireDefault2(_typeofExports);
      var _colors = require$$3$1;
      var _react2 = _interopRequireWildcard2(reactExports);
      var _warning = _interopRequireDefault2(warning$1);
      var _dynamicCSS = dynamicCSS;
      var _Context = _interopRequireDefault2(Context);
      function _getRequireWildcardCache2(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache2 = function _getRequireWildcardCache3(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard2(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") {
          return { default: obj };
        }
        var cache2 = _getRequireWildcardCache2(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function warning2(valid, message2) {
        (0, _warning.default)(valid, "[@ant-design/icons] ".concat(message2));
      }
      function isIconDefinition2(target) {
        return (0, _typeof2.default)(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && ((0, _typeof2.default)(target.icon) === "object" || typeof target.icon === "function");
      }
      function normalizeAttrs2() {
        var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return Object.keys(attrs).reduce(function(acc, key) {
          var val = attrs[key];
          switch (key) {
            case "class":
              acc.className = val;
              delete acc.class;
              break;
            default:
              acc[key] = val;
          }
          return acc;
        }, {});
      }
      function generate2(node2, key, rootProps) {
        if (!rootProps) {
          return /* @__PURE__ */ _react2.default.createElement(node2.tag, (0, _objectSpread22.default)({
            key
          }, normalizeAttrs2(node2.attrs)), (node2.children || []).map(function(child, index2) {
            return generate2(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
          }));
        }
        return /* @__PURE__ */ _react2.default.createElement(node2.tag, (0, _objectSpread22.default)((0, _objectSpread22.default)({
          key
        }, normalizeAttrs2(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
          return generate2(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
        }));
      }
      function getSecondaryColor2(primaryColor) {
        return (0, _colors.generate)(primaryColor)[0];
      }
      function normalizeTwoToneColors2(twoToneColor) {
        if (!twoToneColor) {
          return [];
        }
        return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
      }
      var svgBaseProps2 = {
        width: "1em",
        height: "1em",
        fill: "currentColor",
        "aria-hidden": "true",
        focusable: "false"
      };
      utils$b.svgBaseProps = svgBaseProps2;
      var iconStyles2 = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
      utils$b.iconStyles = iconStyles2;
      var useInsertStyles2 = function useInsertStyles3() {
        var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles2;
        var _useContext = (0, _react2.useContext)(_Context.default), csp = _useContext.csp, prefixCls = _useContext.prefixCls;
        var mergedStyleStr = styleStr;
        if (prefixCls) {
          mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
        }
        (0, _react2.useEffect)(function() {
          (0, _dynamicCSS.updateCSS)(mergedStyleStr, "@ant-design-icons", {
            prepend: true,
            csp
          });
        }, []);
      };
      utils$b.useInsertStyles = useInsertStyles2;
      return utils$b;
    }
    var hasRequiredIconBase;
    function requireIconBase() {
      if (hasRequiredIconBase)
        return IconBase;
      hasRequiredIconBase = 1;
      var _interopRequireDefault2 = interopRequireDefaultExports;
      Object.defineProperty(IconBase, "__esModule", {
        value: true
      });
      IconBase.default = void 0;
      var _objectWithoutProperties2 = _interopRequireDefault2(require$$5);
      var _objectSpread22 = _interopRequireDefault2(objectSpread2Exports);
      var _utils = requireUtils();
      var _excluded4 = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
      var twoToneColorPalette2 = {
        primaryColor: "#333",
        secondaryColor: "#E6E6E6",
        calculated: false
      };
      function setTwoToneColors2(_ref) {
        var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
        twoToneColorPalette2.primaryColor = primaryColor;
        twoToneColorPalette2.secondaryColor = secondaryColor || (0, _utils.getSecondaryColor)(primaryColor);
        twoToneColorPalette2.calculated = !!secondaryColor;
      }
      function getTwoToneColors2() {
        return (0, _objectSpread22.default)({}, twoToneColorPalette2);
      }
      var IconBase$12 = function IconBase2(props) {
        var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = (0, _objectWithoutProperties2.default)(props, _excluded4);
        var colors = twoToneColorPalette2;
        if (primaryColor) {
          colors = {
            primaryColor,
            secondaryColor: secondaryColor || (0, _utils.getSecondaryColor)(primaryColor)
          };
        }
        (0, _utils.useInsertStyles)();
        (0, _utils.warning)((0, _utils.isIconDefinition)(icon), "icon should be icon definiton, but got ".concat(icon));
        if (!(0, _utils.isIconDefinition)(icon)) {
          return null;
        }
        var target = icon;
        if (target && typeof target.icon === "function") {
          target = (0, _objectSpread22.default)((0, _objectSpread22.default)({}, target), {}, {
            icon: target.icon(colors.primaryColor, colors.secondaryColor)
          });
        }
        return (0, _utils.generate)(target.icon, "svg-".concat(target.name), (0, _objectSpread22.default)({
          className,
          onClick,
          style: style2,
          "data-icon": target.name,
          width: "1em",
          height: "1em",
          fill: "currentColor",
          "aria-hidden": "true"
        }, restProps));
      };
      IconBase$12.displayName = "IconReact";
      IconBase$12.getTwoToneColors = getTwoToneColors2;
      IconBase$12.setTwoToneColors = setTwoToneColors2;
      var _default2 = IconBase$12;
      IconBase.default = _default2;
      return IconBase;
    }
    var twoTonePrimaryColor = {};
    var hasRequiredTwoTonePrimaryColor;
    function requireTwoTonePrimaryColor() {
      if (hasRequiredTwoTonePrimaryColor)
        return twoTonePrimaryColor;
      hasRequiredTwoTonePrimaryColor = 1;
      var _interopRequireDefault2 = interopRequireDefaultExports;
      Object.defineProperty(twoTonePrimaryColor, "__esModule", {
        value: true
      });
      twoTonePrimaryColor.getTwoToneColor = getTwoToneColor2;
      twoTonePrimaryColor.setTwoToneColor = setTwoToneColor2;
      var _slicedToArray2 = _interopRequireDefault2(require$$3);
      var _IconBase = _interopRequireDefault2(requireIconBase());
      var _utils = requireUtils();
      function setTwoToneColor2(twoToneColor) {
        var _normalizeTwoToneColo = (0, _utils.normalizeTwoToneColors)(twoToneColor), _normalizeTwoToneColo2 = (0, _slicedToArray2.default)(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
        return _IconBase.default.setTwoToneColors({
          primaryColor,
          secondaryColor
        });
      }
      function getTwoToneColor2() {
        var colors = _IconBase.default.getTwoToneColors();
        if (!colors.calculated) {
          return colors.primaryColor;
        }
        return [colors.primaryColor, colors.secondaryColor];
      }
      return twoTonePrimaryColor;
    }
    var hasRequiredAntdIcon;
    function requireAntdIcon() {
      if (hasRequiredAntdIcon)
        return AntdIcon;
      hasRequiredAntdIcon = 1;
      var _interopRequireDefault2 = interopRequireDefaultExports;
      var _typeof2 = _typeofExports;
      Object.defineProperty(AntdIcon, "__esModule", {
        value: true
      });
      AntdIcon.default = void 0;
      var _objectSpread22 = _interopRequireDefault2(objectSpread2Exports);
      var _slicedToArray2 = _interopRequireDefault2(require$$3);
      var _defineProperty2 = _interopRequireDefault2(require$$4);
      var _objectWithoutProperties2 = _interopRequireDefault2(require$$5);
      var React2 = _interopRequireWildcard2(reactExports);
      var _classnames = _interopRequireDefault2(classnamesExports);
      var _Context = _interopRequireDefault2(Context);
      var _IconBase = _interopRequireDefault2(requireIconBase());
      var _twoTonePrimaryColor = requireTwoTonePrimaryColor();
      var _utils = requireUtils();
      var _excluded4 = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
      function _getRequireWildcardCache2(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache2 = function _getRequireWildcardCache3(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard2(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
          return { default: obj };
        }
        var cache2 = _getRequireWildcardCache2(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      (0, _twoTonePrimaryColor.setTwoToneColor)("#1890ff");
      var Icon2 = /* @__PURE__ */ React2.forwardRef(function(props, ref) {
        var _classNames;
        var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = (0, _objectWithoutProperties2.default)(props, _excluded4);
        var _React$useContext = React2.useContext(_Context.default), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
        var classString = (0, _classnames.default)(rootClassName, prefixCls, (_classNames = {}, (0, _defineProperty2.default)(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), (0, _defineProperty2.default)(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _classNames), className);
        var iconTabIndex = tabIndex;
        if (iconTabIndex === void 0 && onClick) {
          iconTabIndex = -1;
        }
        var svgStyle = rotate ? {
          msTransform: "rotate(".concat(rotate, "deg)"),
          transform: "rotate(".concat(rotate, "deg)")
        } : void 0;
        var _normalizeTwoToneColo = (0, _utils.normalizeTwoToneColors)(twoToneColor), _normalizeTwoToneColo2 = (0, _slicedToArray2.default)(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
        return /* @__PURE__ */ React2.createElement("span", (0, _objectSpread22.default)((0, _objectSpread22.default)({
          role: "img",
          "aria-label": icon.name
        }, restProps), {}, {
          ref,
          tabIndex: iconTabIndex,
          onClick,
          className: classString
        }), /* @__PURE__ */ React2.createElement(_IconBase.default, {
          icon,
          primaryColor,
          secondaryColor,
          style: svgStyle
        }));
      });
      Icon2.displayName = "AntdIcon";
      Icon2.getTwoToneColor = _twoTonePrimaryColor.getTwoToneColor;
      Icon2.setTwoToneColor = _twoTonePrimaryColor.setTwoToneColor;
      var _default2 = Icon2;
      AntdIcon.default = _default2;
      return AntdIcon;
    }
    var _interopRequireDefault$1 = interopRequireDefaultExports;
    var _typeof$1 = _typeofExports;
    Object.defineProperty(ArrowLeftOutlined$3, "__esModule", {
      value: true
    });
    ArrowLeftOutlined$3.default = void 0;
    var _objectSpread2$1 = _interopRequireDefault$1(objectSpread2Exports);
    var React$2 = _interopRequireWildcard$1(reactExports);
    var _ArrowLeftOutlined = _interopRequireDefault$1(requireArrowLeftOutlined());
    var _AntdIcon$1 = _interopRequireDefault$1(requireAntdIcon());
    function _getRequireWildcardCache$1(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache$1 = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard$1(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof$1(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache2 = _getRequireWildcardCache$1(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    var ArrowLeftOutlined$1 = function ArrowLeftOutlined2(props, ref) {
      return /* @__PURE__ */ React$2.createElement(_AntdIcon$1.default, (0, _objectSpread2$1.default)((0, _objectSpread2$1.default)({}, props), {}, {
        ref,
        icon: _ArrowLeftOutlined.default
      }));
    };
    ArrowLeftOutlined$1.displayName = "ArrowLeftOutlined";
    var _default$1 = /* @__PURE__ */ React$2.forwardRef(ArrowLeftOutlined$1);
    ArrowLeftOutlined$3.default = _default$1;
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _ArrowLeftOutlined2 = _interopRequireDefault2(ArrowLeftOutlined$3);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _default2 = _ArrowLeftOutlined2;
      exports2.default = _default2;
      module2.exports = _default2;
    })(ArrowLeftOutlined$4, ArrowLeftOutlinedExports);
    const ArrowLeftOutlined = /* @__PURE__ */ getDefaultExportFromCjs(ArrowLeftOutlinedExports);
    var ArrowRightOutlinedExports = {};
    var ArrowRightOutlined$4 = {
      get exports() {
        return ArrowRightOutlinedExports;
      },
      set exports(v2) {
        ArrowRightOutlinedExports = v2;
      }
    };
    var ArrowRightOutlined$3 = {};
    var ArrowRightOutlined$2 = {};
    var hasRequiredArrowRightOutlined;
    function requireArrowRightOutlined() {
      if (hasRequiredArrowRightOutlined)
        return ArrowRightOutlined$2;
      hasRequiredArrowRightOutlined = 1;
      Object.defineProperty(ArrowRightOutlined$2, "__esModule", { value: true });
      var ArrowRightOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M869 487.8L491.2 159.9c-2.9-2.5-6.6-3.9-10.5-3.9h-88.5c-7.4 0-10.8 9.2-5.2 14l350.2 304H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h585.1L386.9 854c-5.6 4.9-2.2 14 5.2 14h91.5c1.9 0 3.8-.7 5.2-2L869 536.2a32.07 32.07 0 000-48.4z" } }] }, "name": "arrow-right", "theme": "outlined" };
      ArrowRightOutlined$2.default = ArrowRightOutlined2;
      return ArrowRightOutlined$2;
    }
    var _interopRequireDefault = interopRequireDefaultExports;
    var _typeof = _typeofExports;
    Object.defineProperty(ArrowRightOutlined$3, "__esModule", {
      value: true
    });
    ArrowRightOutlined$3.default = void 0;
    var _objectSpread2 = _interopRequireDefault(objectSpread2Exports);
    var React$1 = _interopRequireWildcard(reactExports);
    var _ArrowRightOutlined = _interopRequireDefault(requireArrowRightOutlined());
    var _AntdIcon = _interopRequireDefault(requireAntdIcon());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    var ArrowRightOutlined$1 = function ArrowRightOutlined2(props, ref) {
      return /* @__PURE__ */ React$1.createElement(_AntdIcon.default, (0, _objectSpread2.default)((0, _objectSpread2.default)({}, props), {}, {
        ref,
        icon: _ArrowRightOutlined.default
      }));
    };
    ArrowRightOutlined$1.displayName = "ArrowRightOutlined";
    var _default = /* @__PURE__ */ React$1.forwardRef(ArrowRightOutlined$1);
    ArrowRightOutlined$3.default = _default;
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _ArrowRightOutlined2 = _interopRequireDefault2(ArrowRightOutlined$3);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _default2 = _ArrowRightOutlined2;
      exports2.default = _default2;
      module2.exports = _default2;
    })(ArrowRightOutlined$4, ArrowRightOutlinedExports);
    const ArrowRightOutlined = /* @__PURE__ */ getDefaultExportFromCjs(ArrowRightOutlinedExports);
    var textOverflowEllipsis = function textOverflowEllipsis2() {
      return {
        overflow: "hidden",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis"
      };
    };
    var genPageHeaderStyle = function genPageHeaderStyle2(token2) {
      var _extra, _objectSpread4;
      return _defineProperty$7({}, token2.componentCls, _objectSpread2$3(_objectSpread2$3({}, resetComponent === null || resetComponent === void 0 ? void 0 : resetComponent(token2)), {}, (_objectSpread4 = {
        position: "relative",
        backgroundColor: token2.pageHeaderBgGhost,
        paddingBlock: token2.pageHeaderPaddingVertical + 2,
        paddingInline: token2.pageHeaderPadding,
        "& &-has-breadcrumb": {
          paddingBlockStart: token2.pageHeaderPaddingBreadCrumb
        },
        "& &-has-footer": {
          paddingBlockEnd: 0
        },
        "& &-back": _defineProperty$7({
          marginInlineEnd: token2.margin,
          fontSize: 16,
          lineHeight: 1,
          "&-button": _objectSpread2$3(_objectSpread2$3({
            fontSize: 16
          }, operationUnit === null || operationUnit === void 0 ? void 0 : operationUnit(token2)), {}, {
            color: token2.pageHeaderColorBack,
            cursor: "pointer"
          })
        }, "".concat(token2.componentCls, "-rlt &"), {
          float: "right",
          marginInlineEnd: 0,
          marginInlineStart: 0
        })
      }, _defineProperty$7(_objectSpread4, "& ".concat("ant", "-divider-vertical"), {
        height: 14,
        marginBlock: 0,
        marginInline: token2.marginSM,
        verticalAlign: "middle"
      }), _defineProperty$7(_objectSpread4, "& &-breadcrumb + &-heading", {
        marginBlockStart: token2.marginXS
      }), _defineProperty$7(_objectSpread4, "& &-heading", {
        display: "flex",
        justifyContent: "space-between",
        "&-left": {
          display: "flex",
          alignItems: "center",
          marginBlock: token2.marginXS / 2,
          marginInlineEnd: 0,
          marginInlineStart: 0,
          overflow: "hidden"
        },
        "&-title": _objectSpread2$3(_objectSpread2$3({
          marginInlineEnd: token2.marginSM,
          marginBlockEnd: 0,
          color: token2.colorTextHeading,
          fontWeight: 600,
          fontSize: token2.pageHeaderFontSizeHeaderTitle,
          lineHeight: token2.controlHeight + "px"
        }, textOverflowEllipsis()), {}, _defineProperty$7({}, "".concat(token2.componentCls, "-rlt &"), {
          marginInlineEnd: 0,
          marginInlineStart: token2.marginSM
        })),
        "&-avatar": _defineProperty$7({
          marginInlineEnd: token2.marginSM
        }, "".concat(token2.componentCls, "-rlt &"), {
          float: "right",
          marginInlineEnd: 0,
          marginInlineStart: token2.marginSM
        }),
        "&-tags": _defineProperty$7({}, "".concat(token2.componentCls, "-rlt &"), {
          float: "right"
        }),
        "&-sub-title": _objectSpread2$3(_objectSpread2$3({
          marginInlineEnd: token2.marginSM,
          color: token2.colorTextSecondary,
          fontSize: token2.pageHeaderFontSizeHeaderSubTitle,
          lineHeight: token2.lineHeight
        }, textOverflowEllipsis()), {}, _defineProperty$7({}, "".concat(token2.componentCls, "-rlt &"), {
          float: "right",
          marginInlineEnd: 0,
          marginInlineStart: 12
        })),
        "&-extra": (_extra = {
          marginBlock: token2.marginXS / 2,
          marginInlineEnd: 0,
          marginInlineStart: 0,
          whiteSpace: "nowrap",
          "> *": _defineProperty$7({
            "white-space": "unset"
          }, "".concat(token2.componentCls, "-rlt &"), {
            marginInlineEnd: token2.marginSM,
            marginInlineStart: 0
          })
        }, _defineProperty$7(_extra, "".concat(token2.componentCls, "-rlt &"), {
          float: "left"
        }), _defineProperty$7(_extra, "*:first-child", _defineProperty$7({}, "".concat(token2.componentCls, "-rlt &"), {
          marginInlineEnd: 0
        })), _extra)
      }), _defineProperty$7(_objectSpread4, "&-content", {
        paddingBlockStart: token2.pageHeaderPaddingContentPadding
      }), _defineProperty$7(_objectSpread4, "&-footer", {
        marginBlockStart: token2.margin
      }), _defineProperty$7(_objectSpread4, "&-compact &-heading", {
        flexWrap: "wrap"
      }), _defineProperty$7(_objectSpread4, "&-wide", {
        maxWidth: 1152,
        margin: "0 auto"
      }), _defineProperty$7(_objectSpread4, "&-rtl", {
        direction: "rtl"
      }), _objectSpread4)));
    };
    function useStyle(prefixCls) {
      return useStyle$1("ProLayoutPageHeader", function(token2) {
        var proCardToken = _objectSpread2$3(_objectSpread2$3({}, token2), {}, {
          componentCls: ".".concat(prefixCls),
          pageHeaderBgGhost: "transparent",
          pageHeaderPadding: 16,
          pageHeaderPaddingVertical: 4,
          pageHeaderPaddingBreadCrumb: token2.paddingSM,
          pageHeaderColorBack: token2.colorTextHeading,
          pageHeaderFontSizeHeaderTitle: token2.fontSizeHeading4,
          pageHeaderFontSizeHeaderSubTitle: 14,
          pageHeaderPaddingContentPadding: token2.paddingSM
        });
        return [genPageHeaderStyle(proCardToken)];
      });
    }
    var renderBack = function renderBack2(prefixCls, hashId, backIcon, onBack) {
      if (!backIcon || !onBack) {
        return null;
      }
      return /* @__PURE__ */ jsx("div", {
        className: "".concat(prefixCls, "-back ").concat(hashId),
        children: /* @__PURE__ */ jsx("div", {
          role: "button",
          onClick: function onClick(e2) {
            onBack === null || onBack === void 0 ? void 0 : onBack(e2);
          },
          className: "".concat(prefixCls, "-back-button ").concat(hashId),
          "aria-label": "back",
          children: backIcon
        })
      });
    };
    var renderBreadcrumb = function renderBreadcrumb2(breadcrumb, prefixCls) {
      var _breadcrumb$items;
      if (!((_breadcrumb$items = breadcrumb.items) !== null && _breadcrumb$items !== void 0 && _breadcrumb$items.length))
        return null;
      return /* @__PURE__ */ jsx(Breadcrumb$1, _objectSpread2$3(_objectSpread2$3({}, breadcrumb), {}, {
        className: classNames("".concat(prefixCls, "-breadcrumb"), breadcrumb.className)
      }));
    };
    var getBackIcon = function getBackIcon2(props) {
      var direction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ltr";
      if (props.backIcon !== void 0) {
        return props.backIcon;
      }
      return direction === "rtl" ? /* @__PURE__ */ jsx(ArrowRightOutlined, {}) : /* @__PURE__ */ jsx(ArrowLeftOutlined, {});
    };
    var renderTitle = function renderTitle2(prefixCls, props) {
      var direction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "ltr";
      var hashId = arguments.length > 3 ? arguments[3] : void 0;
      var title = props.title, avatar = props.avatar, subTitle = props.subTitle, tags = props.tags, extra = props.extra, onBack = props.onBack;
      var headingPrefixCls = "".concat(prefixCls, "-heading");
      var hasHeading = title || subTitle || tags || extra;
      if (!hasHeading) {
        return null;
      }
      var backIcon = getBackIcon(props, direction);
      var backIconDom = renderBack(prefixCls, hashId, backIcon, onBack);
      var hasTitle = backIconDom || avatar || hasHeading;
      return /* @__PURE__ */ jsxs("div", {
        className: headingPrefixCls + " " + hashId,
        children: [hasTitle && /* @__PURE__ */ jsxs("div", {
          className: "".concat(headingPrefixCls, "-left ").concat(hashId),
          children: [backIconDom, avatar && /* @__PURE__ */ jsx(Avatar$1, _objectSpread2$3({
            className: classNames("".concat(headingPrefixCls, "-avatar"), hashId, avatar.className)
          }, avatar)), title && /* @__PURE__ */ jsx("span", {
            className: "".concat(headingPrefixCls, "-title ").concat(hashId),
            title: typeof title === "string" ? title : void 0,
            children: title
          }), subTitle && /* @__PURE__ */ jsx("span", {
            className: "".concat(headingPrefixCls, "-sub-title ").concat(hashId),
            title: typeof subTitle === "string" ? subTitle : void 0,
            children: subTitle
          }), tags && /* @__PURE__ */ jsx("span", {
            className: "".concat(headingPrefixCls, "-tags ").concat(hashId),
            children: tags
          })]
        }), extra && /* @__PURE__ */ jsx("span", {
          className: "".concat(headingPrefixCls, "-extra ").concat(hashId),
          children: /* @__PURE__ */ jsx(Space$1, {
            children: extra
          })
        })]
      });
    };
    var renderFooter = function renderFooter2(prefixCls, footer2, hashId) {
      if (footer2) {
        return /* @__PURE__ */ jsx("div", {
          className: "".concat(prefixCls, "-footer ").concat(hashId),
          children: footer2
        });
      }
      return null;
    };
    var renderChildren = function renderChildren2(prefixCls, children, hashId) {
      return /* @__PURE__ */ jsx("div", {
        className: "".concat(prefixCls, "-content ").concat(hashId),
        children
      });
    };
    var PageHeader = function PageHeader2(props) {
      var _breadcrumbRender, _classNames;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), compact2 = _React$useState2[0], updateCompact = _React$useState2[1];
      var onResize2 = function onResize3(_ref) {
        var width = _ref.width;
        updateCompact(width < 768);
      };
      var _React$useContext = reactExports.useContext(ConfigProvider$1.ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
      var customizePrefixCls = props.prefixCls, style2 = props.style, footer2 = props.footer, children = props.children, breadcrumb = props.breadcrumb, breadcrumbRender = props.breadcrumbRender, customizeClassName = props.className, contentWidth = props.contentWidth;
      var prefixCls = getPrefixCls("page-header", customizePrefixCls);
      var _useStyle = useStyle(prefixCls), wrapSSR = _useStyle.wrapSSR, hashId = _useStyle.hashId;
      var getDefaultBreadcrumbDom = function getDefaultBreadcrumbDom2() {
        if (breadcrumb && !(breadcrumb !== null && breadcrumb !== void 0 && breadcrumb.items) && breadcrumb !== null && breadcrumb !== void 0 && breadcrumb.routes) {
          breadcrumb.items = breadcrumb.routes;
        }
        if (breadcrumb !== null && breadcrumb !== void 0 && breadcrumb.items) {
          return renderBreadcrumb(breadcrumb, prefixCls);
        }
        return null;
      };
      var defaultBreadcrumbDom = getDefaultBreadcrumbDom();
      var isBreadcrumbComponent = breadcrumb && "props" in breadcrumb;
      var breadcrumbRenderDomFromProps = (_breadcrumbRender = breadcrumbRender === null || breadcrumbRender === void 0 ? void 0 : breadcrumbRender(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
        prefixCls
      }), defaultBreadcrumbDom)) !== null && _breadcrumbRender !== void 0 ? _breadcrumbRender : defaultBreadcrumbDom;
      var breadcrumbDom = isBreadcrumbComponent ? breadcrumb : breadcrumbRenderDomFromProps;
      var className = classNames(prefixCls, hashId, customizeClassName, (_classNames = {}, _defineProperty$7(_classNames, "".concat(prefixCls, "-has-breadcrumb"), !!breadcrumbDom), _defineProperty$7(_classNames, "".concat(prefixCls, "-has-footer"), !!footer2), _defineProperty$7(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$7(_classNames, "".concat(prefixCls, "-compact"), compact2), _defineProperty$7(_classNames, "".concat(prefixCls, "-wide"), contentWidth === "Fixed"), _defineProperty$7(_classNames, "".concat(prefixCls, "-ghost"), true), _classNames));
      var title = renderTitle(prefixCls, props, direction, hashId);
      var childDom = children && renderChildren(prefixCls, children, hashId);
      var footerDom = renderFooter(prefixCls, footer2, hashId);
      if (!breadcrumbDom && !title && !footerDom && !childDom) {
        return null;
      }
      return wrapSSR(/* @__PURE__ */ jsx(RefResizeObserver, {
        onResize: onResize2,
        children: /* @__PURE__ */ jsxs("div", {
          className,
          style: style2,
          children: [breadcrumbDom, title, childDom, footerDom]
        })
      }));
    };
    var ee = ({ action: e2, resource: r2, onMutationSuccess: t2, onMutationError: o2, submitOnEnter: s = false, warnWhenUnsavedChanges: n2, redirect: a, successNotification: l2, errorNotification: m2, metaData: p2, liveMode: d2, liveParams: c2, mutationMode: f2, dataProviderName: g2, onLiveEvent: T2, invalidates: i2, undoableTimeout: y2, queryOptions: u2, createMutationOptions: F2, updateMutationOptions: x2, id: b2 } = {}) => {
      var Y2, Z2;
      let [P2] = Form$1.useForm(), C2 = useForm({ form: P2 }), { form: v2 } = C2, U2 = Td({ onMutationSuccess: t2 || void 0, onMutationError: o2, redirect: a, action: e2, resource: r2, successNotification: l2, errorNotification: m2, metaData: p2, liveMode: d2, liveParams: c2, mutationMode: f2, dataProviderName: g2, onLiveEvent: T2, invalidates: i2, undoableTimeout: y2, queryOptions: u2, createMutationOptions: F2, updateMutationOptions: x2, id: b2 }), { formLoading: S2, onFinish: I2, queryResult: E2, id: R2 } = U2, { warnWhenUnsavedChanges: h2, setWarnWhen: D2 } = qe$1(), O2 = n2 != null ? n2 : h2;
      React$3.useEffect(() => {
        v2.resetFields();
      }, [(Y2 = E2 == null ? void 0 : E2.data) == null ? void 0 : Y2.data, R2]);
      let L2 = (N2) => {
        s && N2.key === "Enter" && v2.submit();
      }, q2 = (N2) => (N2 && O2 && D2(true), N2), V2 = { disabled: S2, onClick: () => {
        v2.submit();
      } };
      return { form: C2.form, formProps: { ...C2.formProps, onFinish: (N2) => I2(N2).catch((G2) => G2), onKeyUp: L2, onValuesChange: q2, initialValues: (Z2 = E2 == null ? void 0 : E2.data) == null ? void 0 : Z2.data }, saveButtonProps: V2, ...U2, onFinish: async (N2) => await I2(N2 != null ? N2 : C2.form.getFieldsValue(true)) };
    };
    var ur = ({ mutationMode: e2, ...r2 }) => {
      var h2;
      let t2 = ee({ ...r2, mutationMode: e2 }), { form: o2, formProps: s, setId: n2, formLoading: a, mutationResult: l2 } = t2, m2 = M(), { warnWhen: p2, setWarnWhen: d2 } = qe$1(), c2 = useModalForm({ ...r2, form: o2 }), { visible: f2, close: g2, form: T2, formProps: i2, modalProps: y2 } = c2, { mutationMode: u2 } = le$1(), F2 = e2 != null ? e2 : u2, { isLoading: x2, isSuccess: b2, reset: P2 } = l2 != null ? l2 : {};
      reactExports.useEffect(() => {
        f2 && F2 === "pessimistic" && b2 && !x2 && (g2(), P2 == null || P2(), setTimeout(() => {
          o2.resetFields();
        }));
      }, [b2, x2]);
      let C2 = { disabled: a, onClick: () => {
        T2.submit(), F2 !== "pessimistic" && (g2(), setTimeout(() => {
          o2.resetFields();
        }));
      }, loading: a }, { useParams: v2 } = w$3(), { resource: U2 } = v2(), I2 = J()((h2 = r2.resource) != null ? h2 : U2), E2 = reactExports.useCallback(() => {
        if (p2)
          if (window.confirm(m2("warnWhenUnsavedChanges", "Are you sure you want to leave? You have unsaved changes.")))
            d2(false);
          else
            return;
        n2 == null || n2(void 0), c2.close();
      }, [p2]), R2 = reactExports.useCallback((D2) => {
        n2 == null || n2(D2), c2.show();
      }, []);
      return { ...t2, ...c2, show: R2, close: E2, open: f2, formProps: { ...i2, ...t2.formProps, onValuesChange: s == null ? void 0 : s.onValuesChange, onKeyUp: s == null ? void 0 : s.onKeyUp, onFinish: s.onFinish }, modalProps: { ...y2, width: "1000px", okButtonProps: C2, title: m2(`${I2.name}.titles.${r2.action}`, `${Qe(`${r2.action} ${I2.name}`, "singular")}`), okText: m2("buttons.save", "Save"), cancelText: m2("buttons.cancel", "Cancel"), onCancel: E2, forceRender: true }, formLoading: a };
    };
    var no = (e2, r2) => {
      let t2 = So(e2, r2);
      if (t2)
        return `${t2}end`;
    }, Ue = (e2) => {
      var t2;
      let r2 = [];
      if (Array.isArray(e2))
        e2.sort((o2, s) => {
          var n2, a, l2, m2;
          return ((a = ((n2 = o2.column) == null ? void 0 : n2.sorter).multiple) != null ? a : 0) < ((m2 = ((l2 = s.column) == null ? void 0 : l2.sorter).multiple) != null ? m2 : 0) ? -1 : 0;
        }).map((o2) => {
          var s;
          if (o2.field && o2.order) {
            let n2 = Array.isArray(o2.field) ? o2.field.join(".") : `${o2.field}`;
            r2.push({ field: `${(s = o2.columnKey) != null ? s : n2}`, order: o2.order.replace("end", "") });
          }
        });
      else if (e2.field && e2.order) {
        let o2 = Array.isArray(e2.field) ? e2.field.join(".") : `${e2.field}`;
        r2.push({ field: `${(t2 = e2.columnKey) != null ? t2 : o2}`, order: e2.order.replace("end", "") });
      }
      return r2;
    }, ke$1 = (e2, r2, t2) => {
      let o2 = [], s = (t2 != null ? t2 : []).reduce((n2, a) => {
        let l2 = a.key || a.field;
        return { ...n2, [l2]: a };
      }, {});
      return Object.keys(e2).map((n2) => {
        var m2, p2;
        let a = e2[n2], l2 = ((m2 = r2.filter((d2) => d2.operator !== "or").find((d2) => d2.field === n2)) == null ? void 0 : m2.operator) || ((p2 = s[n2]) == null ? void 0 : p2.operator);
        l2 !== "or" && l2 !== "and" && o2.push({ field: n2, operator: l2 != null ? l2 : Array.isArray(a) ? "in" : "eq", value: a });
      }), o2;
    };
    var oe = ({ to: e2, element: r2 }) => {
      let { Link: t2 } = w$3();
      return React$3.createElement(t2, { to: e2, replace: false, onClick: (o2) => {
        o2.preventDefault();
      } }, r2);
    };
    var Ie = ({ onSearch: e2, initialCurrent: r2, initialPageSize: t2, hasPagination: o2 = true, initialSorter: s, permanentSorter: n2, initialFilter: a, permanentFilter: l2, defaultSetFilterBehavior: m2, syncWithLocation: p2, resource: d2, successNotification: c2, errorNotification: f2, queryOptions: g2, liveMode: T2, onLiveEvent: i2, liveParams: y2, metaData: u2, dataProviderName: F2 } = { hasPagination: true }) => {
      let { tableQueryResult: x2, current: b2, setCurrent: P2, pageSize: C2, setPageSize: v2, filters: U2, setFilters: S2, sorter: I2, setSorter: E2, createLinkForSyncWithLocation: R2, pageCount: h2 } = Em({ permanentSorter: n2, permanentFilter: l2, initialCurrent: r2, initialPageSize: t2, hasPagination: o2, initialSorter: s, initialFilter: a, syncWithLocation: p2, resource: d2, defaultSetFilterBehavior: m2, successNotification: c2, errorNotification: f2, queryOptions: g2, liveMode: T2, onLiveEvent: i2, liveParams: y2, metaData: u2, dataProviderName: F2 }), D2 = Grid.useBreakpoint(), [O2] = Form$1.useForm(), L2 = useForm({ form: O2 }), q2 = Tr(T2), { data: V2, isFetched: Y2, isLoading: Z2 } = x2, N2 = (j, z2, $2) => {
        if (z2 && Object.keys(z2).length > 0) {
          let J2 = ke$1(z2, U2, a);
          S2(J2);
        }
        if ($2 && Object.keys($2).length > 0) {
          let J2 = Ue($2);
          E2(J2);
        }
        o2 && (P2 == null || P2(j.current || 1), v2 == null || v2(j.pageSize || 10));
      }, G2 = async (j) => {
        if (e2) {
          let z2 = await e2(j);
          S2(z2), o2 && (P2 == null || P2(1));
        }
      }, X2 = () => o2 ? { itemRender: (j, z2, $2) => {
        var nr2;
        let J2 = R2({ pagination: { pageSize: C2, current: j }, sorter: I2, filters: U2 });
        if (z2 === "page")
          return reactExports.createElement(oe, { to: J2, element: `${j}` });
        if (z2 === "next" || z2 === "prev")
          return reactExports.createElement(oe, { to: J2, element: $2 });
        if (z2 === "jump-next" || z2 === "jump-prev") {
          let Le2 = (nr2 = $2 == null ? void 0 : $2.props) == null ? void 0 : nr2.children;
          return reactExports.createElement(oe, { to: J2, element: reactExports.Children.count(Le2) > 1 ? reactExports.createElement(reactExports.Fragment, {}, Le2) : Le2 });
        }
        return $2;
      }, pageSize: C2, current: b2, simple: !D2.sm, position: D2.sm ? ["bottomRight"] : ["bottomCenter"], total: V2 == null ? void 0 : V2.total } : false;
      return { searchFormProps: { ...L2.formProps, onFinish: G2 }, tableProps: { dataSource: V2 == null ? void 0 : V2.data, loading: q2 === "auto" ? Z2 : !Y2, onChange: N2, pagination: X2(), scroll: { x: true } }, tableQueryResult: x2, sorter: I2, filters: U2, setSorter: E2, setFilters: S2, current: b2, setCurrent: P2, pageSize: C2, setPageSize: v2, pageCount: h2 };
    };
    var Zl = (e2) => {
      let { queryResult: r2, defaultValueQueryResult: t2, onSearch: o2, options: s } = gm(e2);
      return { selectProps: { options: s, onSearch: o2, loading: t2.isFetching, showSearch: true, filterOption: false }, queryResult: r2, defaultValueQueryResult: t2 };
    };
    var cr = ({ notificationKey: e2, message: r2, cancelMutation: t2, undoableTimeout: o2 }) => React$3.createElement("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginTop: "-7px" } }, React$3.createElement(Progress$1, { type: "circle", percent: (o2 != null ? o2 : 0) * 20, format: (s) => s && s / 20, width: 50, strokeColor: "#1890ff", status: "normal" }), React$3.createElement("span", { style: { marginLeft: 8, width: "100%" } }, r2), React$3.createElement(Button$2, { style: { flexShrink: 0 }, onClick: () => {
      t2 == null || t2(), notification$1.destroy(e2 != null ? e2 : "");
    }, disabled: o2 === 0, icon: React$3.createElement(qo, null) }));
    var wp = { open: ({ key: e2, message: r2, description: t2, type: o2, cancelMutation: s, undoableTimeout: n2 }) => {
      o2 === "progress" ? notification$1.open({ key: e2, description: React$3.createElement(cr, { notificationKey: e2, message: r2, cancelMutation: s, undoableTimeout: n2 }), message: null, duration: 0, closeIcon: React$3.createElement(React$3.Fragment, null) }) : notification$1.open({ key: e2, description: r2, message: t2 != null ? t2 : null, type: o2 });
    }, close: (e2) => notification$1.destroy(e2) };
    var gr = { borderTopLeftRadius: 0, borderBottomLeftRadius: 0, position: "fixed", top: 64, zIndex: 999 };
    var { SubMenu: it } = Menu$1, Ne = ({ render: e2 }) => {
      let [r2, t2] = reactExports.useState(false), [o2, s] = reactExports.useState(false), n2 = vo(), { Link: a } = w$3(), { mutate: l2 } = Ct(), m2 = Ns(), p2 = M(), { menuItems: d2, selectedKey: c2, defaultOpenKeys: f2 } = da(), g2 = Grid.useBreakpoint(), { hasDashboard: T2 } = Se(), i2 = typeof g2.lg > "u" ? false : !g2.lg, y2 = m2 != null ? m2 : Ae, u2 = (S2, I2) => S2.map((E2) => {
        let { icon: R2, label: h2, route: D2, name: O2, children: L2, parentName: q2 } = E2;
        if (L2.length > 0)
          return React$3.createElement(Va, { key: D2, resource: O2.toLowerCase(), action: "list", params: { resource: E2 } }, React$3.createElement(it, { key: D2, icon: R2 != null ? R2 : React$3.createElement(yr, null), title: h2 }, u2(L2, I2)));
        let V2 = D2 === I2, Y2 = !(q2 !== void 0 && L2.length === 0);
        return React$3.createElement(Va, { key: D2, resource: O2.toLowerCase(), action: "list", params: { resource: E2 } }, React$3.createElement(Menu$1.Item, { key: D2, style: { fontWeight: V2 ? "bold" : "normal" }, icon: R2 != null ? R2 : Y2 && React$3.createElement(yr, null) }, React$3.createElement(a, { to: D2 }, h2), !r2 && V2 && React$3.createElement("div", { className: "ant-menu-tree-arrow" })));
      }), F2 = n2 && React$3.createElement(Menu$1.Item, { key: "logout", onClick: () => l2(), icon: React$3.createElement(Jo, null) }, p2("buttons.logout", "Logout")), x2 = T2 ? React$3.createElement(Menu$1.Item, { key: "dashboard", style: { fontWeight: c2 === "/" ? "bold" : "normal" }, icon: React$3.createElement(Xo, null) }, React$3.createElement(a, { to: "/" }, p2("dashboard.title", "Dashboard")), !r2 && c2 === "/" && React$3.createElement("div", { className: "ant-menu-tree-arrow" })) : null, b2 = u2(d2, c2), P2 = () => e2 ? e2({ dashboard: x2, items: b2, logout: F2, collapsed: r2 }) : React$3.createElement(React$3.Fragment, null, x2, b2, F2), C2 = () => React$3.createElement(React$3.Fragment, null, React$3.createElement(Menu$1, { theme: "dark", selectedKeys: [c2], defaultOpenKeys: f2, mode: "inline", onClick: () => {
        s(false), g2.lg || t2(true);
      } }, P2())), v2 = () => React$3.createElement(React$3.Fragment, null, React$3.createElement(Drawer, { open: o2, onClose: () => s(false), placement: "left", closable: false, width: 200, bodyStyle: { padding: 0 }, maskClosable: true }, React$3.createElement(AntdLayout, null, React$3.createElement(AntdLayout.Sider, { style: { height: "100vh", overflow: "hidden" } }, React$3.createElement(y2, { collapsed: false }), C2()))), React$3.createElement(Button$2, { style: gr, size: "large", onClick: () => s(true), icon: React$3.createElement(ss, null) }));
      return React$3.createElement(ConfigProvider$1, { theme: { components: { Menu: { colorItemBg: "transparent", colorItemText: "#fff", colorItemTextSelected: "#fff", colorItemBgSelected: "transparent", colorItemTextHover: "#fff" } } } }, (() => i2 ? v2() : React$3.createElement(AntdLayout.Sider, { collapsible: true, collapsed: r2, onCollapse: (S2) => t2(S2), collapsedWidth: 80, breakpoint: "lg" }, React$3.createElement(y2, { collapsed: r2 }), C2()))());
    };
    var { Text: ft } = Typography$1, ze = () => {
      let { data: e2 } = gt$1();
      return e2 && (e2.name || e2.avatar) ? React$3.createElement(AntdLayout.Header, { style: { display: "flex", justifyContent: "flex-end", alignItems: "center", padding: "0px 24px", height: "64px" } }, React$3.createElement(Space$1, null, e2.name && React$3.createElement(ft, { ellipsis: true, strong: true }, e2.name), e2.avatar && React$3.createElement(Avatar$1, { size: "large", src: e2 == null ? void 0 : e2.avatar, alt: e2 == null ? void 0 : e2.name }))) : null;
    };
    var gt = ({ children: e2, Header: r2, Sider: t2, Footer: o2, OffLayoutArea: s }) => {
      let n2 = Grid.useBreakpoint(), a = t2 != null ? t2 : Ne, l2 = r2 != null ? r2 : ze, m2 = typeof n2.sm > "u" ? true : n2.sm;
      return React$3.createElement(AntdLayout, { style: { minHeight: "100vh" } }, React$3.createElement(a, null), React$3.createElement(AntdLayout, null, React$3.createElement(l2, null), React$3.createElement(AntdLayout.Content, null, React$3.createElement("div", { style: { minHeight: 360, padding: m2 ? 24 : 12 } }, e2), s && React$3.createElement(s, null)), o2 && React$3.createElement(o2, null)));
    };
    var Ae = ({ collapsed: e2 }) => {
      let { Link: r2 } = w$3();
      return React$3.createElement(r2, { to: "/" }, e2 ? React$3.createElement("div", { style: { display: "flex", alignItems: "center", justifyContent: "center" } }, React$3.createElement("img", { src: "https://refine.ams3.cdn.digitaloceanspaces.com/logo/refine-mini.svg", alt: "Refine", style: { margin: "0 auto", padding: "12px 0", maxHeight: "65.5px" } })) : React$3.createElement("img", { src: "https://refine.ams3.cdn.digitaloceanspaces.com/logo/refine.svg", alt: "Refine", style: { width: "200px", padding: "12px 24px" } }));
    };
    var je = ({ resourceName: e2, resourceNameOrRouteName: r2, hideText: t2 = false, accessControl: o2, ignoreAccessControlProvider: s = false, children: n2, onClick: a, ...l2 }) => {
      var F2, x2;
      let m2 = (F2 = o2 == null ? void 0 : o2.enabled) != null ? F2 : !s, p2 = (x2 = o2 == null ? void 0 : o2.hideIfUnauthorized) != null ? x2 : false, d2 = M(), { Link: c2 } = w$3(), { createUrl: f2 } = q$2(), { resourceName: g2, resource: T2 } = B$1({ resourceName: e2, resourceNameOrRouteName: r2 }), { data: i2 } = wr({ resource: g2, action: "create", queryOptions: { enabled: m2 }, params: { resource: T2 } }), y2 = () => i2 != null && i2.can ? "" : i2 != null && i2.reason ? i2.reason : d2("buttons.notAccessTitle", "You don't have permission to access"), u2 = f2(e2 != null ? e2 : T2.route);
      return m2 && p2 && !(i2 != null && i2.can) ? null : React$3.createElement(c2, { to: u2, replace: false, onClick: (b2) => {
        if ((i2 == null ? void 0 : i2.can) === false) {
          b2.preventDefault();
          return;
        }
        a && (b2.preventDefault(), a(b2));
      } }, React$3.createElement(Button$2, { icon: React$3.createElement(Cs, null), disabled: (i2 == null ? void 0 : i2.can) === false, title: y2(), ...l2 }, !t2 && (n2 != null ? n2 : d2("buttons.create", "Create"))));
    };
    var qe = ({ resourceName: e2, resourceNameOrRouteName: r2, recordItemId: t2, hideText: o2 = false, accessControl: s, ignoreAccessControlProvider: n2 = false, children: a, onClick: l2, ...m2 }) => {
      var b2, P2;
      let p2 = (b2 = s == null ? void 0 : s.enabled) != null ? b2 : !n2, d2 = (P2 = s == null ? void 0 : s.hideIfUnauthorized) != null ? P2 : false, c2 = M(), { editUrl: f2 } = q$2(), { Link: g2 } = w$3(), { resourceName: T2, id: i2, resource: y2 } = B$1({ resourceName: e2, resourceNameOrRouteName: r2, recordItemId: t2 }), { data: u2 } = wr({ resource: T2, action: "edit", params: { id: i2, resource: y2 }, queryOptions: { enabled: p2 } }), F2 = () => u2 != null && u2.can ? "" : u2 != null && u2.reason ? u2.reason : c2("buttons.notAccessTitle", "You don't have permission to access"), x2 = f2(e2 != null ? e2 : y2.route, i2);
      return p2 && d2 && !(u2 != null && u2.can) ? null : React$3.createElement(g2, { to: x2, replace: false, onClick: (C2) => {
        if ((u2 == null ? void 0 : u2.can) === false) {
          C2.preventDefault();
          return;
        }
        l2 && (C2.preventDefault(), l2(C2));
      } }, React$3.createElement(Button$2, { icon: React$3.createElement(vt, null), disabled: (u2 == null ? void 0 : u2.can) === false, title: F2(), ...m2 }, !o2 && (a != null ? a : c2("buttons.edit", "Edit"))));
    };
    var ye = ({ resourceName: e2, resourceNameOrRouteName: r2, recordItemId: t2, onSuccess: o2, mutationMode: s, children: n2, successNotification: a, errorNotification: l2, hideText: m2 = false, accessControl: p2, ignoreAccessControlProvider: d2 = false, metaData: c2, dataProviderName: f2, confirmTitle: g2, confirmOkText: T2, confirmCancelText: i2, invalidates: y2, ...u2 }) => {
      var D2, O2;
      let F2 = (D2 = p2 == null ? void 0 : p2.enabled) != null ? D2 : !d2, x2 = (O2 = p2 == null ? void 0 : p2.hideIfUnauthorized) != null ? O2 : false, b2 = M(), { resourceName: P2, id: C2, resource: v2 } = B$1({ resourceNameOrRouteName: r2, resourceName: e2, recordItemId: t2 }), { mutationMode: U2 } = le$1(), S2 = s != null ? s : U2, { mutate: I2, isLoading: E2, variables: R2 } = Go(), { data: h2 } = wr({ resource: P2, action: "delete", params: { id: C2, resource: v2 }, queryOptions: { enabled: F2 } });
      return F2 && x2 && !(h2 != null && h2.can) ? null : React$3.createElement(It, { key: "delete", okText: T2 != null ? T2 : b2("buttons.delete", "Delete"), cancelText: i2 != null ? i2 : b2("buttons.cancel", "Cancel"), okType: "danger", title: g2 != null ? g2 : b2("buttons.confirm", "Are you sure?"), okButtonProps: { disabled: E2 }, onConfirm: () => {
        I2({ id: C2 || "", resource: P2, mutationMode: S2, successNotification: a, errorNotification: l2, metaData: c2, dataProviderName: f2, invalidates: y2 }, { onSuccess: (L2) => {
          o2 && o2(L2);
        } });
      }, disabled: typeof (u2 == null ? void 0 : u2.disabled) < "u" ? u2.disabled : (h2 == null ? void 0 : h2.can) === false }, React$3.createElement(Button$2, { danger: true, loading: C2 === (R2 == null ? void 0 : R2.id) && E2, icon: React$3.createElement(Vt, null), disabled: (h2 == null ? void 0 : h2.can) === false, ...u2 }, !m2 && (n2 != null ? n2 : b2("buttons.delete", "Delete"))));
    };
    var be = ({ resourceName: e2, resourceNameOrRouteName: r2, recordItemId: t2, hideText: o2 = false, metaData: s, dataProviderName: n2, children: a, onClick: l2, ...m2 }) => {
      let p2 = M(), { resourceName: d2, id: c2 } = B$1({ resourceName: e2, resourceNameOrRouteName: r2, recordItemId: t2 }), { refetch: f2, isFetching: g2 } = Ge({ resource: d2, id: c2 != null ? c2 : "", queryOptions: { enabled: false }, metaData: s, liveMode: "off", dataProviderName: n2 });
      return React$3.createElement(Button$2, { onClick: (T2) => l2 ? l2(T2) : f2(), icon: React$3.createElement(Gt, { spin: g2 }), ...m2 }, !o2 && (a != null ? a : p2("buttons.refresh", "Refresh")));
    };
    var Pe = ({ resourceName: e2, resourceNameOrRouteName: r2, hideText: t2 = false, accessControl: o2, ignoreAccessControlProvider: s = false, children: n2, onClick: a, ...l2 }) => {
      var F2, x2, b2;
      let m2 = (F2 = o2 == null ? void 0 : o2.enabled) != null ? F2 : !s, p2 = (x2 = o2 == null ? void 0 : o2.hideIfUnauthorized) != null ? x2 : false, { listUrl: d2 } = q$2(), { Link: c2 } = w$3(), f2 = M(), { resourceName: g2, resource: T2 } = B$1({ resourceName: e2, resourceNameOrRouteName: r2 }), { data: i2 } = wr({ resource: g2, action: "list", queryOptions: { enabled: m2 }, params: { resource: T2 } }), y2 = () => i2 != null && i2.can ? "" : i2 != null && i2.reason ? i2.reason : f2("buttons.notAccessTitle", "You don't have permission to access"), u2 = d2(e2 != null ? e2 : T2.route);
      return m2 && p2 && !(i2 != null && i2.can) ? null : React$3.createElement(c2, { to: u2, replace: false, onClick: (P2) => {
        if ((i2 == null ? void 0 : i2.can) === false) {
          P2.preventDefault();
          return;
        }
        a && (P2.preventDefault(), a(P2));
      } }, React$3.createElement(Button$2, { icon: React$3.createElement(ss, null), disabled: (i2 == null ? void 0 : i2.can) === false, title: y2(), ...l2 }, !t2 && (n2 != null ? n2 : f2(`${g2}.titles.list`, Qe((b2 = T2.label) != null ? b2 : g2, "plural")))));
    };
    var Fe = ({ hideText: e2 = false, children: r2, ...t2 }) => {
      let o2 = M();
      return React$3.createElement(Button$2, { type: "primary", icon: React$3.createElement(bs, null), ...t2 }, !e2 && (r2 != null ? r2 : o2("buttons.save", "Save")));
    };
    var Ws = ({ canCreate: e2, title: r2, children: t2, createButtonProps: o2, resource: s, wrapperProps: n2, contentProps: a, headerProps: l2, breadcrumb: m2, headerButtonProps: p2, headerButtons: d2 }) => {
      var b2, P2;
      let { useParams: c2 } = w$3(), { resource: f2 } = c2(), g2 = M(), i2 = J()(s != null ? s : f2), y2 = e2 != null ? e2 : i2.canCreate || o2, { options: u2 } = Se(), F2 = typeof m2 > "u" ? u2 == null ? void 0 : u2.breadcrumb : m2, x2 = y2 ? React$3.createElement(je, { size: "middle", resourceNameOrRouteName: i2.route, ...o2 }) : null;
      return React$3.createElement("div", { ...n2 != null ? n2 : {} }, React$3.createElement(ne, { ghost: false, title: r2 != null ? r2 : g2(`${i2.name}.titles.list`, Qe((b2 = i2.label) != null ? b2 : i2.name, "plural")), extra: d2 ? React$3.createElement(Space$1, { wrap: true, ...p2 }, typeof d2 == "function" ? d2({ defaultButtons: x2 }) : d2) : x2, breadcrumb: typeof F2 < "u" ? (P2 = React$3.createElement(React$3.Fragment, null, F2)) != null ? P2 : void 0 : React$3.createElement(ae, null), ...l2 != null ? l2 : {} }, React$3.createElement("div", { ...a != null ? a : {} }, t2)));
    };
    var Xs = ({ title: e2, saveButtonProps: r2, children: t2, resource: o2, isLoading: s = false, breadcrumb: n2, wrapperProps: a, headerProps: l2, contentProps: m2, headerButtonProps: p2, headerButtons: d2, footerButtonProps: c2, footerButtons: f2, goBack: g2 }) => {
      var U2, S2;
      let { goBack: T2 } = q$2(), i2 = M(), { useParams: y2 } = w$3(), { resource: u2, action: F2 } = y2(), b2 = J()(o2 != null ? o2 : u2), { options: P2 } = Se(), C2 = typeof n2 > "u" ? P2 == null ? void 0 : P2.breadcrumb : n2, v2 = React$3.createElement(React$3.Fragment, null, React$3.createElement(Fe, { ...s ? { disabled: true } : {}, ...r2, htmlType: "submit" }));
      return React$3.createElement("div", { ...a != null ? a : {} }, React$3.createElement(ne, { ghost: false, backIcon: g2, onBack: F2 ? T2 : void 0, title: e2 != null ? e2 : i2(`${b2.name}.titles.create`, `Create ${Qe((U2 = b2.label) != null ? U2 : b2.name, "singular")}`), breadcrumb: typeof C2 < "u" ? (S2 = React$3.createElement(React$3.Fragment, null, C2)) != null ? S2 : void 0 : React$3.createElement(ae, null), extra: React$3.createElement(Space$1, { wrap: true, ...p2 != null ? p2 : {} }, d2 ? typeof d2 == "function" ? d2({ defaultButtons: null }) : d2 : null), ...l2 != null ? l2 : {} }, React$3.createElement(la, { spinning: s }, React$3.createElement(Card$1, { bordered: false, actions: [React$3.createElement(Space$1, { key: "action-buttons", style: { float: "right", marginRight: 24 }, ...c2 != null ? c2 : {} }, f2 ? typeof f2 == "function" ? f2({ defaultButtons: v2 }) : f2 : v2)], ...m2 != null ? m2 : {} }, t2))));
    };
    var ia = ({ title: e2, saveButtonProps: r2, mutationMode: t2, recordItemId: o2, children: s, deleteButtonProps: n2, canDelete: a, resource: l2, isLoading: m2 = false, dataProviderName: p2, breadcrumb: d2, wrapperProps: c2, headerProps: f2, contentProps: g2, headerButtonProps: T2, headerButtons: i2, footerButtonProps: y2, footerButtons: u2, goBack: F2 }) => {
      var Z2, N2;
      let x2 = M(), { goBack: b2, list: P2 } = q$2(), C2 = J(), { mutationMode: v2 } = le$1(), U2 = t2 != null ? t2 : v2, { useParams: S2 } = w$3(), { resource: I2, action: E2, id: R2 } = S2(), h2 = C2(l2 != null ? l2 : I2), D2 = a != null ? a : h2.canDelete || n2, { options: O2 } = Se(), L2 = typeof d2 > "u" ? O2 == null ? void 0 : O2.breadcrumb : d2, q2 = o2 != null ? o2 : R2, V2 = React$3.createElement(React$3.Fragment, null, !o2 && React$3.createElement(Pe, { ...m2 ? { disabled: true } : {}, resourceNameOrRouteName: h2.route }), React$3.createElement(be, { ...m2 ? { disabled: true } : {}, resourceNameOrRouteName: h2.route, recordItemId: q2, dataProviderName: p2 })), Y2 = React$3.createElement(React$3.Fragment, null, D2 && React$3.createElement(ye, { ...m2 ? { disabled: true } : {}, mutationMode: U2, onSuccess: () => {
        var G2;
        P2((G2 = h2.route) != null ? G2 : h2.name);
      }, dataProviderName: p2, ...n2 }), React$3.createElement(Fe, { ...m2 ? { disabled: true } : {}, ...r2 }));
      return React$3.createElement("div", { ...c2 != null ? c2 : {} }, React$3.createElement(ne, { ghost: false, backIcon: F2, onBack: E2 ? b2 : void 0, title: e2 != null ? e2 : x2(`${h2.name}.titles.edit`, `Edit ${Qe((Z2 = h2.label) != null ? Z2 : h2.name, "singular")}`), extra: React$3.createElement(Space$1, { wrap: true, ...T2 != null ? T2 : {} }, i2 ? typeof i2 == "function" ? i2({ defaultButtons: V2 }) : i2 : V2), breadcrumb: typeof L2 < "u" ? (N2 = React$3.createElement(React$3.Fragment, null, L2)) != null ? N2 : void 0 : React$3.createElement(ae, null), ...f2 != null ? f2 : {} }, React$3.createElement(la, { spinning: m2 }, React$3.createElement(Card$1, { bordered: false, actions: [React$3.createElement(Space$1, { key: "footer-buttons", wrap: true, style: { float: "right", marginRight: 24 }, ...y2 != null ? y2 : {} }, u2 ? typeof u2 == "function" ? u2({ defaultButtons: Y2 }) : u2 : Y2)], ...g2 != null ? g2 : {} }, s))));
    };
    var Ta = ({ title: e2, canEdit: r2, canDelete: t2, isLoading: o2 = false, children: s, resource: n2, recordItemId: a, dataProviderName: l2, breadcrumb: m2, contentProps: p2, headerProps: d2, wrapperProps: c2, headerButtons: f2, footerButtons: g2, footerButtonProps: T2, headerButtonProps: i2, goBack: y2 }) => {
      var L2, q2;
      let u2 = M(), { goBack: F2, list: x2 } = q$2(), b2 = J(), { useParams: P2 } = w$3(), { resource: C2, action: v2, id: U2 } = P2(), S2 = b2(n2 != null ? n2 : C2), I2 = t2 != null ? t2 : S2.canDelete, E2 = r2 != null ? r2 : S2.canEdit, { options: R2 } = Se(), h2 = typeof m2 > "u" ? R2 == null ? void 0 : R2.breadcrumb : m2, D2 = a != null ? a : U2, O2 = React$3.createElement(React$3.Fragment, null, !a && React$3.createElement(Pe, { resourceNameOrRouteName: S2.route }), E2 && React$3.createElement(qe, { ...o2 ? { disabled: true } : {}, resourceNameOrRouteName: S2.route, recordItemId: D2 }), I2 && React$3.createElement(ye, { ...o2 ? { disabled: true } : {}, resourceNameOrRouteName: S2.route, recordItemId: D2, onSuccess: () => {
        var V2;
        return x2((V2 = S2.route) != null ? V2 : S2.name);
      }, dataProviderName: l2 }), React$3.createElement(be, { ...o2 ? { disabled: true } : {}, resourceNameOrRouteName: S2.route, recordItemId: D2, dataProviderName: l2 }));
      return React$3.createElement("div", { ...c2 != null ? c2 : {} }, React$3.createElement(ne, { ghost: false, backIcon: y2, onBack: v2 ? F2 : void 0, title: e2 != null ? e2 : u2(`${S2.name}.titles.show`, `Show ${Qe((L2 = S2.label) != null ? L2 : S2.name, "singular")}`), extra: React$3.createElement(Space$1, { key: "extra-buttons", wrap: true, ...i2 != null ? i2 : {} }, f2 ? typeof f2 == "function" ? f2({ defaultButtons: O2 }) : f2 : O2), breadcrumb: typeof h2 < "u" ? (q2 = React$3.createElement(React$3.Fragment, null, h2)) != null ? q2 : void 0 : React$3.createElement(ae, null), ...d2 != null ? d2 : {} }, React$3.createElement(la, { spinning: o2 }, React$3.createElement(Card$1, { bordered: false, actions: g2 ? [React$3.createElement(Space$1, { key: "footer-buttons", wrap: true, ...T2 }, typeof g2 == "function" ? g2({ defaultButtons: null }) : g2)] : void 0, ...p2 != null ? p2 : {} }, s))));
    };
    var { Text: Pa } = Typography$1, Fa = ({ value: e2, ...r2 }) => React$3.createElement(Pa, { ...r2 }, e2);
    var Sa = ({ value: e2, ...r2 }) => React$3.createElement(Ca, { ...r2 }, e2 == null ? void 0 : e2.toString());
    var { Link: va } = Typography$1, Ea = ({ value: e2, ...r2 }) => React$3.createElement(va, { href: `mailto:${e2}`, ...r2 }, e2);
    dayjs.extend(Ha);
    var Oa = dayjs.locale(), Na = ({ value: e2, locales: r2, format: t2 = "L", ...o2 }) => {
      let { Text: s } = Typography$1;
      return React$3.createElement(s, { ...o2 }, dayjs(e2).locale(r2 || Oa).format(t2));
    };
    var { Link: ja } = Typography$1, Ze = ({ children: e2, value: r2, ...t2 }) => React$3.createElement(ja, { href: r2, ...t2 }, e2 != null ? e2 : r2);
    var sn = (e2) => {
      let { setSelectedKeys: r2, confirm: t2, clearFilters: o2, mapValue: s, selectedKeys: n2, children: a } = e2, [l2, m2] = reactExports.useState(n2), p2 = M(), d2 = () => {
        o2 && (m2([]), o2());
      }, c2 = () => {
        let i2 = f2(l2), y2;
        typeof i2 == "number" ? y2 = `${i2}` : dayjs.isDayjs(i2) ? y2 = [i2.toISOString()] : y2 = i2, r2(y2), t2 == null || t2();
      }, f2 = (i2) => s ? s(i2) : i2, g2 = (i2) => {
        if (typeof i2 == "object") {
          if (Array.isArray(i2)) {
            let b2 = f2(i2);
            return m2(b2), r2(b2);
          }
          let u2 = !i2 || !i2.target || dayjs.isDayjs(i2) ? { target: { value: i2 } } : i2, { target: F2 } = u2, x2 = f2(F2.value);
          m2(x2);
          return;
        }
        let y2 = f2(i2);
        m2(y2);
      }, T2 = React$3.Children.map(a, (i2) => React$3.isValidElement(i2) ? React$3.cloneElement(i2, { onChange: g2, value: f2(l2) }) : i2);
      return React$3.createElement("div", { style: { padding: 10, display: "flex", flexDirection: "column", alignItems: "flex-end" } }, React$3.createElement("div", { style: { marginBottom: 15 } }, T2), React$3.createElement(Space$1, null, React$3.createElement(Button$2, { type: "primary", size: "small", onClick: () => c2() }, React$3.createElement(on, null), " ", p2("buttons.filter", "Filter")), React$3.createElement(Button$2, { danger: true, size: "small", onClick: () => d2() }, p2("buttons.clear", "Clear"))));
    };
    var { Text: yn } = Typography$1, bn = () => {
      let [e2, r2] = reactExports.useState(), { push: t2 } = q$2(), o2 = M(), s = ["edit", "create", "show"], { useParams: n2 } = w$3(), a = n2(), l2 = J();
      return reactExports.useEffect(() => {
        if (a.resource) {
          let m2 = l2(a.resource);
          a.action && s.includes(a.action) && !m2[a.action] && r2(o2("pages.error.info", { action: a.action, resource: a.resource }, `You may have forgotten to add the "${a.action}" component to "${a.resource}" resource.`));
        }
      }, [a]), React$3.createElement(ln, { status: "404", title: "404", extra: React$3.createElement(Space$1, { direction: "vertical", size: "large" }, React$3.createElement(Space$1, null, React$3.createElement(yn, null, o2("pages.error.404", "Sorry, the page you visited does not exist.")), e2 && React$3.createElement(pn, { title: e2 }, React$3.createElement(dn, {}))), React$3.createElement(Button$2, { type: "primary", onClick: () => t2("/") }, o2("pages.error.backHome", "Back Home"))) });
    };
    var de = { root: { height: "100vh", backgroundImage: "url('https://refine.ams3.cdn.digitaloceanspaces.com/login-background/background.png')", backgroundSize: "cover", backgroundColor: "#331049" }, title: { color: "white", fontWeight: 800, fontSize: "64px", marginBottom: "8px" }, p1: { color: "white", marginBottom: 0, fontSize: "20px", fontWeight: "bold" }, p2: { color: "white", fontSize: "20px" }, code: { backgroundColor: "white", color: "#331049" } }, { Title: On } = Typography$1, Nn = () => reactExports.createElement(Row$1, { align: "middle", justify: "center", style: de.root }, reactExports.createElement(Col$1, { style: { textAlign: "center" } }, reactExports.createElement("img", { style: { marginBottom: "48px" }, src: "https://refine.ams3.cdn.digitaloceanspaces.com/logo/refine.svg", alt: "Refine Logo" }), reactExports.createElement(On, { style: de.title }, "Welcome on board"), reactExports.createElement("p", { style: de.p1 }, "Your configuration is completed."), reactExports.createElement("p", { style: de.p2 }, "Now you can get started by adding your resources to the", " ", reactExports.createElement("code", { style: de.code }, "resources"), " property of", " ", reactExports.createElement("code", { style: de.code }, "<Refine>")), reactExports.createElement(Space$1, { size: "large", wrap: true, style: { marginTop: "70px", justifyContent: "center" } }, reactExports.createElement("a", { href: "https://refine.dev", target: "_blank", rel: "noreferrer" }, reactExports.createElement(Button$2, { size: "large", icon: reactExports.createElement(Vn, null) }, "Documentation")), reactExports.createElement("a", { href: "https://refine.dev/examples", target: "_blank", rel: "noreferrer" }, reactExports.createElement(Button$2, { size: "large", icon: reactExports.createElement(Mn, null) }, "Examples")), reactExports.createElement("a", { href: "https://discord.gg/refine", target: "_blank", rel: "noreferrer" }, reactExports.createElement(Button$2, { size: "large", icon: reactExports.createElement(Hn, null) }, "Community")))));
    var ie = { background: "radial-gradient(50% 50% at 50% 50%, #6813CB 0%, #2A2A42 100%)", backgroundSize: "cover" }, ue = { maxWidth: "408px", margin: "auto" }, le = { textAlign: "center", color: "#626262", marginBottom: 0, fontSize: "24px", letterSpacing: "-0.04em", overflowWrap: "break-word", hyphens: "manual", textOverflow: "unset", whiteSpace: "pre-wrap" };
    var { Text: Yn, Title: Xn } = Typography$1, rr = ({ providers: e2, registerLink: r2, forgotPasswordLink: t2, rememberMe: o2, contentProps: s, wrapperProps: n2, renderContent: a, formProps: l2 }) => {
      let [m2] = Form$1.useForm(), p2 = M(), { Link: d2 } = w$3(), { mutate: c2, isLoading: f2 } = $e(), g2 = React$3.createElement(Xn, { level: 3, style: le }, p2("pages.login.title", "Sign in to your account")), T2 = () => e2 && e2.length > 0 ? React$3.createElement(React$3.Fragment, null, e2.map((y2) => React$3.createElement(Button$2, { key: y2.name, type: "default", block: true, icon: y2.icon, style: { display: "flex", justifyContent: "center", alignItems: "center", width: "100%", marginBottom: "8px" }, onClick: () => c2({ providerName: y2.name }) }, y2.label)), React$3.createElement(Divider$1, null, p2("pages.login.divider", "or"))) : null, i2 = React$3.createElement(Card$1, { title: g2, headStyle: { borderBottom: 0 }, style: ue, ...s != null ? s : {} }, T2(), React$3.createElement(Form$1, { layout: "vertical", form: m2, onFinish: (y2) => c2(y2), requiredMark: false, initialValues: { remember: false }, ...l2 }, React$3.createElement(Form$1.Item, { name: "email", label: p2("pages.login.fields.email", "Email"), rules: [{ required: true }, { type: "email", message: p2("pages.login.errors.validEmail", "Invalid email address") }] }, React$3.createElement(Input$1, { size: "large", placeholder: p2("pages.login.fields.email", "Email") })), React$3.createElement(Form$1.Item, { name: "password", label: p2("pages.login.fields.password", "Password"), rules: [{ required: true }], style: { marginBottom: "12px" } }, React$3.createElement(Input$1, { type: "password", placeholder: "●●●●●●●●", size: "large" })), React$3.createElement("div", { style: { display: "flex", justifyContent: "space-between", marginBottom: "12px" } }, o2 != null ? o2 : React$3.createElement(Form$1.Item, { name: "remember", valuePropName: "checked", noStyle: true }, React$3.createElement(Checkbox$1, { style: { fontSize: "12px" } }, p2("pages.login.buttons.rememberMe", "Remember me"))), t2 != null ? t2 : React$3.createElement(d2, { style: { fontSize: "12px", marginLeft: "auto" }, to: "/forgot-password" }, p2("pages.login.buttons.forgotPassword", "Forgot password?"))), React$3.createElement(Form$1.Item, null, React$3.createElement(Button$2, { type: "primary", size: "large", htmlType: "submit", loading: f2, block: true }, p2("pages.login.signin", "Sign in")))), React$3.createElement("div", { style: { marginTop: 8 } }, r2 != null ? r2 : React$3.createElement(Yn, { style: { fontSize: 12 } }, p2("pages.login.buttons.noAccount", "Don’t have an account?"), " ", React$3.createElement(d2, { to: "/register", style: { fontWeight: "bold" } }, p2("pages.login.signup", "Sign up")))));
      return React$3.createElement(AntdLayout, { style: ie, ...n2 != null ? n2 : {} }, React$3.createElement(Row$1, { justify: "center", align: "middle", style: { height: "100vh" } }, React$3.createElement(Col$1, { xs: 22 }, a ? a(i2) : i2)));
    };
    var { Text: ii, Title: ui } = Typography$1, or = ({ providers: e2, loginLink: r2, wrapperProps: t2, contentProps: o2, renderContent: s, formProps: n2 }) => {
      let [a] = Form$1.useForm(), l2 = M(), { Link: m2 } = w$3(), { mutate: p2, isLoading: d2 } = xt(), c2 = React$3.createElement(ui, { level: 3, style: le }, l2("pages.register.title", "Sign up for your account")), f2 = () => e2 && e2.length > 0 ? React$3.createElement(React$3.Fragment, null, e2.map((T2) => React$3.createElement(Button$2, { key: T2.name, type: "ghost", block: true, icon: T2.icon, style: { display: "flex", justifyContent: "center", alignItems: "center", width: "100%", marginBottom: "8px" }, onClick: () => p2({ providerName: T2.name }) }, T2.label)), React$3.createElement(Divider$1, null, l2("pages.login.divider", "or"))) : null, g2 = React$3.createElement(Card$1, { title: c2, headStyle: { borderBottom: 0 }, style: ue, ...o2 != null ? o2 : {} }, f2(), React$3.createElement(Form$1, { layout: "vertical", form: a, onFinish: (T2) => p2(T2), requiredMark: false, ...n2 }, React$3.createElement(Form$1.Item, { name: "email", label: l2("pages.register.email", "Email"), rules: [{ required: true }, { type: "email", message: l2("pages.register.errors.validEmail", "Invalid email address") }] }, React$3.createElement(Input$1, { size: "large", placeholder: l2("pages.register.fields.email", "Email") })), React$3.createElement(Form$1.Item, { name: "password", label: l2("pages.register.fields.password", "Password"), rules: [{ required: true }], style: { marginBottom: "12px" } }, React$3.createElement(Input$1, { type: "password", placeholder: "●●●●●●●●", size: "large" })), React$3.createElement("div", { style: { display: "flex", justifyContent: "space-between", marginBottom: "12px" } }, r2 != null ? r2 : React$3.createElement(ii, { style: { fontSize: 12, marginLeft: "auto" } }, l2("pages.login.buttons.haveAccount", "Have an account?"), " ", React$3.createElement(m2, { style: { fontWeight: "bold" }, to: "/login" }, l2("pages.login.signin", "Sign in")))), React$3.createElement(Form$1.Item, null, React$3.createElement(Button$2, { type: "primary", size: "large", htmlType: "submit", loading: d2, block: true }, l2("pages.register.buttons.submit", "Sign up")))));
      return React$3.createElement(AntdLayout, { style: ie, ...t2 != null ? t2 : {} }, React$3.createElement(Row$1, { justify: "center", align: "middle", style: { height: "100vh" } }, React$3.createElement(Col$1, { xs: 22 }, s ? s(g2) : g2)));
    };
    var { Text: Pi, Title: Fi } = Typography$1, tr = ({ loginLink: e2, wrapperProps: r2, contentProps: t2, renderContent: o2, formProps: s }) => {
      let [n2] = Form$1.useForm(), a = M(), { Link: l2 } = w$3(), { mutate: m2, isLoading: p2 } = Rt(), d2 = React$3.createElement(Fi, { level: 3, style: le }, a("pages.forgotPassword.title", "Forgot your password?")), c2 = React$3.createElement(Card$1, { title: d2, headStyle: { borderBottom: 0 }, style: ue, ...t2 != null ? t2 : {} }, React$3.createElement(Form$1, { layout: "vertical", form: n2, onFinish: (f2) => m2(f2), requiredMark: false, ...s }, React$3.createElement(Form$1.Item, { name: "email", label: a("pages.forgotPassword.fields.email", "Email"), rules: [{ required: true }, { type: "email", message: a("pages.forgotPassword.errors.validEmail", "Invalid email address") }] }, React$3.createElement(Input$1, { type: "email", size: "large", placeholder: a("pages.forgotPassword.fields.email", "Email") })), React$3.createElement("div", { style: { display: "flex", justifyContent: "space-between", marginBottom: "12px" } }, e2 != null ? e2 : React$3.createElement(Pi, { style: { fontSize: 12, marginLeft: "auto" } }, a("pages.register.buttons.haveAccount", "Have an account? "), " ", React$3.createElement(l2, { style: { fontWeight: "bold" }, to: "/login" }, a("pages.login.signin", "Sign in")))), React$3.createElement(Form$1.Item, null, React$3.createElement(Button$2, { type: "primary", size: "large", htmlType: "submit", loading: p2, block: true }, a("pages.forgotPassword.buttons.submit", "Send reset instructions")))));
      return React$3.createElement(AntdLayout, { style: ie, ...r2 != null ? r2 : {} }, React$3.createElement(Row$1, { justify: "center", align: "middle", style: { height: "100vh" } }, React$3.createElement(Col$1, { xs: 22 }, o2 ? o2(c2) : c2)));
    };
    var { Title: Di } = Typography$1, sr = ({ wrapperProps: e2, contentProps: r2, renderContent: t2, formProps: o2 }) => {
      let [s] = Form$1.useForm(), n2 = M(), { mutate: a, isLoading: l2 } = Pt(), m2 = React$3.createElement(Di, { level: 3, style: le }, n2("pages.updatePassword.title", "Set New Password")), p2 = React$3.createElement(Card$1, { title: m2, headStyle: { borderBottom: 0 }, style: ue, ...r2 != null ? r2 : {} }, React$3.createElement(Form$1, { layout: "vertical", form: s, onFinish: (d2) => a(d2), requiredMark: false, ...o2 }, React$3.createElement(Form$1.Item, { name: "password", label: n2("pages.updatePassword.fields.password", "New Password"), rules: [{ required: true }], style: { marginBottom: "12px" } }, React$3.createElement(Input$1, { type: "password", placeholder: "●●●●●●●●", size: "large" })), React$3.createElement(Form$1.Item, { name: "confirmPassword", label: n2("pages.updatePassword.fields.confirmPassword", "Confirm New Password"), hasFeedback: true, dependencies: ["password"], rules: [{ required: true }, ({ getFieldValue: d2 }) => ({ validator(c2, f2) {
        return !f2 || d2("password") === f2 ? Promise.resolve() : Promise.reject(new Error(n2("pages.updatePassword.errors.confirmPasswordNotMatch", "Passwords do not match")));
      } })], style: { marginBottom: "12px" } }, React$3.createElement(Input$1, { type: "password", placeholder: "●●●●●●●●", size: "large" })), React$3.createElement(Form$1.Item, null, React$3.createElement(Button$2, { type: "primary", size: "large", htmlType: "submit", loading: l2, block: true }, n2("pages.updatePassword.buttons.submit", "Update")))));
      return React$3.createElement(AntdLayout, { style: ie, ...e2 != null ? e2 : {} }, React$3.createElement(Row$1, { justify: "center", align: "middle", style: { height: "100vh" } }, React$3.createElement(Col$1, { xs: 22 }, t2 ? t2(p2) : p2)));
    };
    var wi = (e2) => {
      let { type: r2 } = e2;
      return React$3.createElement(React$3.Fragment, null, (() => {
        switch (r2) {
          case "register":
            return React$3.createElement(or, { ...e2 });
          case "forgotPassword":
            return React$3.createElement(tr, { ...e2 });
          case "updatePassword":
            return React$3.createElement(sr, { ...e2 });
          default:
            return React$3.createElement(rr, { ...e2 });
        }
      })());
    };
    var ae = ({ breadcrumbProps: e2, showHome: r2 = true, hideIcons: t2 = false }) => {
      let { breadcrumbs: o2 } = uf(), { Link: s } = w$3(), { hasDashboard: n2 } = Se();
      return o2.length === 1 ? null : React$3.createElement(Breadcrumb$1, { ...e2 }, r2 && n2 && React$3.createElement(Breadcrumb$1.Item, null, React$3.createElement(s, { to: "/" }, React$3.createElement(Ii, null))), o2.map(({ label: a, icon: l2, href: m2 }) => React$3.createElement(Breadcrumb$1.Item, { key: a }, !t2 && l2, m2 ? React$3.createElement(s, { to: m2 }, a) : React$3.createElement("span", null, a))));
    };
    var ne = ({ children: e2, ...r2 }) => {
      let t2 = typeof r2.backIcon > "u" ? React$3.createElement(Button$2, { type: "text", icon: React$3.createElement(Hi, null) }) : r2.backIcon, o2 = typeof r2.title == "string" ? React$3.createElement(Typography$1.Title, { level: 4, style: { marginBottom: 0 } }, r2.title) : r2.title, s = typeof r2.title == "string" ? React$3.createElement(Typography$1.Title, { level: 5, type: "secondary", style: { marginBottom: 0 } }, r2.subTitle) : r2.subTitle;
      return React$3.createElement(PageHeader, { ...r2, backIcon: t2, title: o2, subTitle: s, style: { padding: 0, ...r2.style } }, e2);
    };
    var Oi = (e2) => {
      let { fileList: r2 } = e2;
      return [...r2];
    };
    var axiosExports$1 = {};
    var axios$2 = {
      get exports() {
        return axiosExports$1;
      },
      set exports(v2) {
        axiosExports$1 = v2;
      }
    };
    var axiosExports = {};
    var axios$1 = {
      get exports() {
        return axiosExports;
      },
      set exports(v2) {
        axiosExports = v2;
      }
    };
    var bind$2 = function bind2(fn, thisArg) {
      return function wrap2() {
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        return fn.apply(thisArg, args);
      };
    };
    var bind$1 = bind$2;
    var toString = Object.prototype.toString;
    function isArray$1(val) {
      return Array.isArray(val);
    }
    function isUndefined$1(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return toString.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString$1(val) {
      return typeof val === "string";
    }
    function isNumber$1(val) {
      return typeof val === "number";
    }
    function isObject$1(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject$1(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype2 = Object.getPrototypeOf(val);
      return prototype2 === null || prototype2 === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction$1(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject$1(val) && isFunction$1(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray$1(obj)) {
        for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          fn.call(null, obj[i2], i2, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject$1(result[key]) && isPlainObject$1(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject$1(val)) {
          result[key] = merge({}, val);
        } else if (isArray$1(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
        forEach(arguments[i2], assignValue);
      }
      return result;
    }
    function extend(a, b2, thisArg) {
      forEach(b2, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind$1(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content2) {
      if (content2.charCodeAt(0) === 65279) {
        content2 = content2.slice(1);
      }
      return content2;
    }
    var utils$a = {
      isArray: isArray$1,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString$1,
      isNumber: isNumber$1,
      isObject: isObject$1,
      isPlainObject: isPlainObject$1,
      isUndefined: isUndefined$1,
      isDate,
      isFile,
      isBlob,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
    var utils$9 = utils$a;
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    var buildURL$1 = function buildURL2(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils$9.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils$9.forEach(params, function serialize2(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils$9.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils$9.forEach(val, function parseValue2(v2) {
            if (utils$9.isDate(v2)) {
              v2 = v2.toISOString();
            } else if (utils$9.isObject(v2)) {
              v2 = JSON.stringify(v2);
            }
            parts.push(encode(key) + "=" + encode(v2));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
    var utils$8 = utils$a;
    function InterceptorManager$1() {
      this.handlers = [];
    }
    InterceptorManager$1.prototype.use = function use2(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager$1.prototype.eject = function eject(id2) {
      if (this.handlers[id2]) {
        this.handlers[id2] = null;
      }
    };
    InterceptorManager$1.prototype.forEach = function forEach2(fn) {
      utils$8.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn(h2);
        }
      });
    };
    var InterceptorManager_1 = InterceptorManager$1;
    var utils$7 = utils$a;
    var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
      utils$7.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
    var enhanceError$1 = function enhanceError2(error, config, code2, request, response) {
      error.config = config;
      if (code2) {
        error.code = code2;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
    var transitional = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var createError;
    var hasRequiredCreateError;
    function requireCreateError() {
      if (hasRequiredCreateError)
        return createError;
      hasRequiredCreateError = 1;
      var enhanceError2 = enhanceError$1;
      createError = function createError2(message2, config, code2, request, response) {
        var error = new Error(message2);
        return enhanceError2(error, config, code2, request, response);
      };
      return createError;
    }
    var settle;
    var hasRequiredSettle;
    function requireSettle() {
      if (hasRequiredSettle)
        return settle;
      hasRequiredSettle = 1;
      var createError2 = requireCreateError();
      settle = function settle2(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(createError2(
            "Request failed with status code " + response.status,
            response.config,
            null,
            response.request,
            response
          ));
        }
      };
      return settle;
    }
    var cookies;
    var hasRequiredCookies;
    function requireCookies() {
      if (hasRequiredCookies)
        return cookies;
      hasRequiredCookies = 1;
      var utils2 = utils$a;
      cookies = utils2.isStandardBrowserEnv() ? (
        // Standard browser envs support document.cookie
        function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path2, domain2, secure) {
              var cookie = [];
              cookie.push(name + "=" + encodeURIComponent(value));
              if (utils2.isNumber(expires)) {
                cookie.push("expires=" + new Date(expires).toGMTString());
              }
              if (utils2.isString(path2)) {
                cookie.push("path=" + path2);
              }
              if (utils2.isString(domain2)) {
                cookie.push("domain=" + domain2);
              }
              if (secure === true) {
                cookie.push("secure");
              }
              document.cookie = cookie.join("; ");
            },
            read: function read(name) {
              var match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
              return match2 ? decodeURIComponent(match2[3]) : null;
            },
            remove: function remove(name) {
              this.write(name, "", Date.now() - 864e5);
            }
          };
        }()
      ) : (
        // Non standard browser env (web workers, react-native) lack needed support.
        function nonStandardBrowserEnv() {
          return {
            write: function write() {
            },
            read: function read() {
              return null;
            },
            remove: function remove() {
            }
          };
        }()
      );
      return cookies;
    }
    var isAbsoluteURL;
    var hasRequiredIsAbsoluteURL;
    function requireIsAbsoluteURL() {
      if (hasRequiredIsAbsoluteURL)
        return isAbsoluteURL;
      hasRequiredIsAbsoluteURL = 1;
      isAbsoluteURL = function isAbsoluteURL2(url) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
      };
      return isAbsoluteURL;
    }
    var combineURLs;
    var hasRequiredCombineURLs;
    function requireCombineURLs() {
      if (hasRequiredCombineURLs)
        return combineURLs;
      hasRequiredCombineURLs = 1;
      combineURLs = function combineURLs2(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      };
      return combineURLs;
    }
    var buildFullPath;
    var hasRequiredBuildFullPath;
    function requireBuildFullPath() {
      if (hasRequiredBuildFullPath)
        return buildFullPath;
      hasRequiredBuildFullPath = 1;
      var isAbsoluteURL2 = requireIsAbsoluteURL();
      var combineURLs2 = requireCombineURLs();
      buildFullPath = function buildFullPath2(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL2(requestedURL)) {
          return combineURLs2(baseURL, requestedURL);
        }
        return requestedURL;
      };
      return buildFullPath;
    }
    var parseHeaders;
    var hasRequiredParseHeaders;
    function requireParseHeaders() {
      if (hasRequiredParseHeaders)
        return parseHeaders;
      hasRequiredParseHeaders = 1;
      var utils2 = utils$a;
      var ignoreDuplicateOf2 = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      parseHeaders = function parseHeaders2(headers) {
        var parsed = {};
        var key;
        var val;
        var i2;
        if (!headers) {
          return parsed;
        }
        utils2.forEach(headers.split("\n"), function parser2(line2) {
          i2 = line2.indexOf(":");
          key = utils2.trim(line2.substr(0, i2)).toLowerCase();
          val = utils2.trim(line2.substr(i2 + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf2.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
      return parseHeaders;
    }
    var isURLSameOrigin;
    var hasRequiredIsURLSameOrigin;
    function requireIsURLSameOrigin() {
      if (hasRequiredIsURLSameOrigin)
        return isURLSameOrigin;
      hasRequiredIsURLSameOrigin = 1;
      var utils2 = utils$a;
      isURLSameOrigin = utils2.isStandardBrowserEnv() ? (
        // Standard browser envs have full support of the APIs needed to test
        // whether the request URL is of the same origin as current location.
        function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement("a");
          var originURL;
          function resolveURL(url) {
            var href = url;
            if (msie) {
              urlParsingNode.setAttribute("href", href);
              href = urlParsingNode.href;
            }
            urlParsingNode.setAttribute("href", href);
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            };
          }
          originURL = resolveURL(window.location.href);
          return function isURLSameOrigin2(requestURL) {
            var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
            return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
          };
        }()
      ) : (
        // Non standard browser envs (web workers, react-native) lack needed support.
        function nonStandardBrowserEnv() {
          return function isURLSameOrigin2() {
            return true;
          };
        }()
      );
      return isURLSameOrigin;
    }
    var Cancel_1;
    var hasRequiredCancel;
    function requireCancel() {
      if (hasRequiredCancel)
        return Cancel_1;
      hasRequiredCancel = 1;
      function Cancel2(message2) {
        this.message = message2;
      }
      Cancel2.prototype.toString = function toString2() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      };
      Cancel2.prototype.__CANCEL__ = true;
      Cancel_1 = Cancel2;
      return Cancel_1;
    }
    var xhr;
    var hasRequiredXhr;
    function requireXhr() {
      if (hasRequiredXhr)
        return xhr;
      hasRequiredXhr = 1;
      var utils2 = utils$a;
      var settle2 = requireSettle();
      var cookies2 = requireCookies();
      var buildURL2 = buildURL$1;
      var buildFullPath2 = requireBuildFullPath();
      var parseHeaders2 = requireParseHeaders();
      var isURLSameOrigin2 = requireIsURLSameOrigin();
      var createError2 = requireCreateError();
      var transitionalDefaults2 = transitional;
      var Cancel2 = requireCancel();
      xhr = function xhrAdapter2(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config.data;
          var requestHeaders = config.headers;
          var responseType = config.responseType;
          var onCanceled;
          function done() {
            if (config.cancelToken) {
              config.cancelToken.unsubscribe(onCanceled);
            }
            if (config.signal) {
              config.signal.removeEventListener("abort", onCanceled);
            }
          }
          if (utils2.isFormData(requestData)) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath2(config.baseURL, config.url);
          request.open(config.method.toUpperCase(), buildURL2(fullPath, config.params, config.paramsSerializer), true);
          request.timeout = config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders2(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config,
              request
            };
            settle2(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(createError2("Request aborted", config, "ECONNABORTED", request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(createError2("Network Error", config, null, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            var transitional2 = config.transitional || transitionalDefaults2;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(createError2(
              timeoutErrorMessage,
              config,
              transitional2.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
              request
            ));
            request = null;
          };
          if (utils2.isStandardBrowserEnv()) {
            var xsrfValue = (config.withCredentials || isURLSameOrigin2(fullPath)) && config.xsrfCookieName ? cookies2.read(config.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils2.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
          }
          if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", config.onDownloadProgress);
          }
          if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config.onUploadProgress);
          }
          if (config.cancelToken || config.signal) {
            onCanceled = function(cancel) {
              if (!request) {
                return;
              }
              reject(!cancel || cancel && cancel.type ? new Cancel2("canceled") : cancel);
              request.abort();
              request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) {
              config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
            }
          }
          if (!requestData) {
            requestData = null;
          }
          request.send(requestData);
        });
      };
      return xhr;
    }
    var utils$6 = utils$a;
    var normalizeHeaderName = normalizeHeaderName$1;
    var enhanceError = enhanceError$1;
    var transitionalDefaults = transitional;
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils$6.isUndefined(headers) && utils$6.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = requireXhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = requireXhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser2, encoder) {
      if (utils$6.isString(rawValue)) {
        try {
          (parser2 || JSON.parse)(rawValue);
          return utils$6.trim(rawValue);
        } catch (e2) {
          if (e2.name !== "SyntaxError") {
            throw e2;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults$3 = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data2, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils$6.isFormData(data2) || utils$6.isArrayBuffer(data2) || utils$6.isBuffer(data2) || utils$6.isStream(data2) || utils$6.isFile(data2) || utils$6.isBlob(data2)) {
          return data2;
        }
        if (utils$6.isArrayBufferView(data2)) {
          return data2.buffer;
        }
        if (utils$6.isURLSearchParams(data2)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data2.toString();
        }
        if (utils$6.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data2);
        }
        return data2;
      }],
      transformResponse: [function transformResponse(data2) {
        var transitional2 = this.transitional || defaults$3.transitional;
        var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
        var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils$6.isString(data2) && data2.length) {
          try {
            return JSON.parse(data2);
          } catch (e2) {
            if (strictJSONParsing) {
              if (e2.name === "SyntaxError") {
                throw enhanceError(e2, this, "E_JSON_PARSE");
              }
              throw e2;
            }
          }
        }
        return data2;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils$6.forEach(["delete", "get", "head"], function forEachMethodNoData(method2) {
      defaults$3.headers[method2] = {};
    });
    utils$6.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
      defaults$3.headers[method2] = utils$6.merge(DEFAULT_CONTENT_TYPE);
    });
    var defaults_1 = defaults$3;
    var utils$5 = utils$a;
    var defaults$2 = defaults_1;
    var transformData$1 = function transformData2(data2, headers, fns) {
      var context = this || defaults$2;
      utils$5.forEach(fns, function transform(fn) {
        data2 = fn.call(context, data2, headers);
      });
      return data2;
    };
    var isCancel$1;
    var hasRequiredIsCancel;
    function requireIsCancel() {
      if (hasRequiredIsCancel)
        return isCancel$1;
      hasRequiredIsCancel = 1;
      isCancel$1 = function isCancel2(value) {
        return !!(value && value.__CANCEL__);
      };
      return isCancel$1;
    }
    var utils$4 = utils$a;
    var transformData = transformData$1;
    var isCancel = requireIsCancel();
    var defaults$1 = defaults_1;
    var Cancel = requireCancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    var dispatchRequest$1 = function dispatchRequest2(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils$4.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils$4.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method2) {
          delete config.headers[method2];
        }
      );
      var adapter = config.adapter || defaults$1.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
    var utils$3 = utils$a;
    var mergeConfig$2 = function mergeConfig2(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils$3.isPlainObject(target) && utils$3.isPlainObject(source)) {
          return utils$3.merge(target, source);
        } else if (utils$3.isPlainObject(source)) {
          return utils$3.merge({}, source);
        } else if (utils$3.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils$3.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils$3.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils$3.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils$3.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils$3.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils$3.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge2 = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge2(prop);
        utils$3.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
    var data;
    var hasRequiredData;
    function requireData() {
      if (hasRequiredData)
        return data;
      hasRequiredData = 1;
      data = {
        "version": "0.26.1"
      };
      return data;
    }
    var VERSION = requireData().version;
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type2, i2) {
      validators$1[type2] = function validator2(thing) {
        return typeof thing === type2 || "a" + (i2 < 1 ? "n " : " ") + type2;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional2(validator2, version2, message2) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
      }
      return function(value, opt, opts) {
        if (validator2 === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema2, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys2 = Object.keys(options);
      var i2 = keys2.length;
      while (i2-- > 0) {
        var opt = keys2[i2];
        var validator2 = schema2[opt];
        if (validator2) {
          var value = options[opt];
          var result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    var validator$1 = {
      assertOptions,
      validators: validators$1
    };
    var utils$2 = utils$a;
    var buildURL = buildURL$1;
    var InterceptorManager = InterceptorManager_1;
    var dispatchRequest = dispatchRequest$1;
    var mergeConfig$1 = mergeConfig$2;
    var validator = validator$1;
    var validators = validator.validators;
    function Axios$1(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios$1.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig$1(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional2 = config.transitional;
      if (transitional2 !== void 0) {
        validator.assertOptions(transitional2, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios$1.prototype.getUri = function getUri(config) {
      config = mergeConfig$1(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils$2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method2) {
      Axios$1.prototype[method2] = function(url, config) {
        return this.request(mergeConfig$1(config || {}, {
          method: method2,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$2.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
      Axios$1.prototype[method2] = function(url, data2, config) {
        return this.request(mergeConfig$1(config || {}, {
          method: method2,
          url,
          data: data2
        }));
      };
    });
    var Axios_1 = Axios$1;
    var CancelToken_1;
    var hasRequiredCancelToken;
    function requireCancelToken() {
      if (hasRequiredCancelToken)
        return CancelToken_1;
      hasRequiredCancelToken = 1;
      var Cancel2 = requireCancel();
      function CancelToken2(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        var token2 = this;
        this.promise.then(function(cancel) {
          if (!token2._listeners)
            return;
          var i2;
          var l2 = token2._listeners.length;
          for (i2 = 0; i2 < l2; i2++) {
            token2._listeners[i2](cancel);
          }
          token2._listeners = null;
        });
        this.promise.then = function(onfulfilled) {
          var _resolve;
          var promise = new Promise(function(resolve) {
            token2.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token2.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message2) {
          if (token2.reason) {
            return;
          }
          token2.reason = new Cancel2(message2);
          resolvePromise(token2.reason);
        });
      }
      CancelToken2.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken2.prototype.subscribe = function subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      };
      CancelToken2.prototype.unsubscribe = function unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        var index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      };
      CancelToken2.source = function source() {
        var cancel;
        var token2 = new CancelToken2(function executor(c2) {
          cancel = c2;
        });
        return {
          token: token2,
          cancel
        };
      };
      CancelToken_1 = CancelToken2;
      return CancelToken_1;
    }
    var spread;
    var hasRequiredSpread;
    function requireSpread() {
      if (hasRequiredSpread)
        return spread;
      hasRequiredSpread = 1;
      spread = function spread2(callback) {
        return function wrap2(arr) {
          return callback.apply(null, arr);
        };
      };
      return spread;
    }
    var isAxiosError;
    var hasRequiredIsAxiosError;
    function requireIsAxiosError() {
      if (hasRequiredIsAxiosError)
        return isAxiosError;
      hasRequiredIsAxiosError = 1;
      var utils2 = utils$a;
      isAxiosError = function isAxiosError2(payload) {
        return utils2.isObject(payload) && payload.isAxiosError === true;
      };
      return isAxiosError;
    }
    var utils$1 = utils$a;
    var bind = bind$2;
    var Axios = Axios_1;
    var mergeConfig = mergeConfig$2;
    var defaults = defaults_1;
    function createInstance(defaultConfig2) {
      var context = new Axios(defaultConfig2);
      var instance = bind(Axios.prototype.request, context);
      utils$1.extend(instance, Axios.prototype, context);
      utils$1.extend(instance, context);
      instance.create = function create2(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig2, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.Cancel = requireCancel();
    axios.CancelToken = requireCancelToken();
    axios.isCancel = requireIsCancel();
    axios.VERSION = requireData().version;
    axios.all = function all2(promises) {
      return Promise.all(promises);
    };
    axios.spread = requireSpread();
    axios.isAxiosError = requireIsAxiosError();
    axios$1.exports = axios;
    axiosExports.default = axios;
    (function(module2) {
      module2.exports = axiosExports;
    })(axios$2);
    const E = /* @__PURE__ */ getDefaultExportFromCjs(axiosExports$1);
    var lib$1 = {};
    var exceptions = {};
    var requestQuery_exception = {};
    Object.defineProperty(requestQuery_exception, "__esModule", { value: true });
    class RequestQueryException extends Error {
      constructor(msg) {
        super(msg);
      }
    }
    requestQuery_exception.RequestQueryException = RequestQueryException;
    (function(exports2) {
      function __export(m2) {
        for (var p2 in m2)
          if (!exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      __export(requestQuery_exception);
    })(exceptions);
    var requestQuery_builder = {};
    var lib = {};
    var checks_util = {};
    var obj_util = {};
    Object.defineProperty(obj_util, "__esModule", { value: true });
    obj_util.objKeys = (val) => Object.keys(val);
    obj_util.getOwnPropNames = (val) => Object.getOwnPropertyNames(val);
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      const obj_util_1 = obj_util;
      exports2.isUndefined = (val) => typeof val === "undefined";
      exports2.isNull = (val) => val === null;
      exports2.isNil = (val) => exports2.isUndefined(val) || exports2.isNull(val);
      exports2.isString = (val) => typeof val === "string";
      exports2.hasLength = (val) => val.length > 0;
      exports2.isStringFull = (val) => exports2.isString(val) && exports2.hasLength(val);
      exports2.isArrayFull = (val) => Array.isArray(val) && exports2.hasLength(val);
      exports2.isArrayStrings = (val) => exports2.isArrayFull(val) && val.every((v2) => exports2.isStringFull(v2));
      exports2.isObject = (val) => typeof val === "object" && !exports2.isNull(val);
      exports2.isObjectFull = (val) => exports2.isObject(val) && exports2.hasLength(obj_util_1.objKeys(val));
      exports2.isNumber = (val) => typeof val === "number" && !Number.isNaN(val) && Number.isFinite(val);
      exports2.isEqual = (val, eq2) => val === eq2;
      exports2.isFalse = (val) => val === false;
      exports2.isTrue = (val) => val === true;
      exports2.isIn = (val, arr = []) => arr.some((o2) => exports2.isEqual(val, o2));
      exports2.isBoolean = (val) => typeof val === "boolean";
      exports2.isNumeric = (val) => /^[+-]?([0-9]*[.])?[0-9]+$/.test(val);
      exports2.isDateString = (val) => exports2.isStringFull(val) && /^\d{4}-[01]\d-[0-3]\d(?:T[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:Z|[-+][0-2]\d(?::?[0-5]\d)?)?)?$/g.test(val);
      exports2.isDate = (val) => val instanceof Date;
      exports2.isValue = (val) => exports2.isStringFull(val) || exports2.isNumber(val) || exports2.isBoolean(val) || exports2.isDate(val);
      exports2.hasValue = (val) => exports2.isArrayFull(val) ? val.every((o2) => exports2.isValue(o2)) : exports2.isValue(val);
      exports2.isFunction = (val) => typeof val === "function";
    })(checks_util);
    (function(exports2) {
      function __export(m2) {
        for (var p2 in m2)
          if (!exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      __export(checks_util);
      __export(obj_util);
    })(lib);
    var requestQuery_validator = {};
    var types = {};
    var requestQuery_types = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      (function(CondOperator) {
        CondOperator["EQUALS"] = "$eq";
        CondOperator["NOT_EQUALS"] = "$ne";
        CondOperator["GREATER_THAN"] = "$gt";
        CondOperator["LOWER_THAN"] = "$lt";
        CondOperator["GREATER_THAN_EQUALS"] = "$gte";
        CondOperator["LOWER_THAN_EQUALS"] = "$lte";
        CondOperator["STARTS"] = "$starts";
        CondOperator["ENDS"] = "$ends";
        CondOperator["CONTAINS"] = "$cont";
        CondOperator["EXCLUDES"] = "$excl";
        CondOperator["IN"] = "$in";
        CondOperator["NOT_IN"] = "$notin";
        CondOperator["IS_NULL"] = "$isnull";
        CondOperator["NOT_NULL"] = "$notnull";
        CondOperator["BETWEEN"] = "$between";
        CondOperator["EQUALS_LOW"] = "$eqL";
        CondOperator["NOT_EQUALS_LOW"] = "$neL";
        CondOperator["STARTS_LOW"] = "$startsL";
        CondOperator["ENDS_LOW"] = "$endsL";
        CondOperator["CONTAINS_LOW"] = "$contL";
        CondOperator["EXCLUDES_LOW"] = "$exclL";
        CondOperator["IN_LOW"] = "$inL";
        CondOperator["NOT_IN_LOW"] = "$notinL";
      })(exports2.CondOperator || (exports2.CondOperator = {}));
    })(requestQuery_types);
    (function(exports2) {
      function __export(m2) {
        for (var p2 in m2)
          if (!exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      __export(requestQuery_types);
    })(types);
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      const util_12 = lib;
      const exceptions_12 = exceptions;
      const types_1 = types;
      exports2.deprecatedComparisonOperatorsList = [
        "eq",
        "ne",
        "gt",
        "lt",
        "gte",
        "lte",
        "starts",
        "ends",
        "cont",
        "excl",
        "in",
        "notin",
        "isnull",
        "notnull",
        "between"
      ];
      exports2.comparisonOperatorsList = [
        ...exports2.deprecatedComparisonOperatorsList,
        ...util_12.objKeys(types_1.CondOperator).map((n2) => types_1.CondOperator[n2])
      ];
      exports2.sortOrdersList = ["ASC", "DESC"];
      const comparisonOperatorsListStr = exports2.comparisonOperatorsList.join();
      const sortOrdersListStr = exports2.sortOrdersList.join();
      function validateFields(fields) {
        if (!util_12.isArrayStrings(fields)) {
          throw new exceptions_12.RequestQueryException("Invalid fields. Array of strings expected");
        }
      }
      exports2.validateFields = validateFields;
      function validateCondition(val, cond) {
        if (!util_12.isObject(val) || !util_12.isStringFull(val.field)) {
          throw new exceptions_12.RequestQueryException(`Invalid field type in ${cond} condition. String expected`);
        }
        validateComparisonOperator(val.operator);
      }
      exports2.validateCondition = validateCondition;
      function validateComparisonOperator(operator) {
        if (!exports2.comparisonOperatorsList.includes(operator)) {
          throw new exceptions_12.RequestQueryException(`Invalid comparison operator. ${comparisonOperatorsListStr} expected`);
        }
      }
      exports2.validateComparisonOperator = validateComparisonOperator;
      function validateJoin(join2) {
        if (!util_12.isObject(join2) || !util_12.isStringFull(join2.field)) {
          throw new exceptions_12.RequestQueryException("Invalid join field. String expected");
        }
        if (!util_12.isUndefined(join2.select) && !util_12.isArrayStrings(join2.select)) {
          throw new exceptions_12.RequestQueryException("Invalid join select. Array of strings expected");
        }
      }
      exports2.validateJoin = validateJoin;
      function validateSort(sort) {
        if (!util_12.isObject(sort) || !util_12.isStringFull(sort.field)) {
          throw new exceptions_12.RequestQueryException("Invalid sort field. String expected");
        }
        if (!util_12.isEqual(sort.order, exports2.sortOrdersList[0]) && !util_12.isEqual(sort.order, exports2.sortOrdersList[1])) {
          throw new exceptions_12.RequestQueryException(`Invalid sort order. ${sortOrdersListStr} expected`);
        }
      }
      exports2.validateSort = validateSort;
      function validateNumeric(val, num) {
        if (!util_12.isNumber(val)) {
          throw new exceptions_12.RequestQueryException(`Invalid ${num}. Number expected`);
        }
      }
      exports2.validateNumeric = validateNumeric;
      function validateParamOption(options, name) {
        if (!util_12.isObject(options)) {
          throw new exceptions_12.RequestQueryException(`Invalid param ${name}. Invalid crud options`);
        }
        const option = options[name];
        if (option && option.disabled) {
          return;
        }
        if (!util_12.isObject(option) || util_12.isNil(option.field) || util_12.isNil(option.type)) {
          throw new exceptions_12.RequestQueryException(`Invalid param option in Crud`);
        }
      }
      exports2.validateParamOption = validateParamOption;
      function validateUUID(str, name) {
        const uuid2 = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        const uuidV4 = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        if (!uuidV4.test(str) && !uuid2.test(str)) {
          throw new exceptions_12.RequestQueryException(`Invalid param ${name}. UUID string expected`);
        }
      }
      exports2.validateUUID = validateUUID;
    })(requestQuery_validator);
    Object.defineProperty(requestQuery_builder, "__esModule", { value: true });
    const util_1$1 = lib;
    const qs_1 = lib$4;
    const request_query_validator_1$1 = requestQuery_validator;
    class RequestQueryBuilder {
      constructor() {
        this.paramNames = {};
        this.queryObject = {};
        this.setParamNames();
      }
      static setOptions(options) {
        RequestQueryBuilder._options = {
          ...RequestQueryBuilder._options,
          ...options,
          paramNamesMap: {
            ...RequestQueryBuilder._options.paramNamesMap,
            ...options.paramNamesMap ? options.paramNamesMap : {}
          }
        };
      }
      static getOptions() {
        return RequestQueryBuilder._options;
      }
      static create(params) {
        const qb2 = new RequestQueryBuilder();
        return util_1$1.isObject(params) ? qb2.createFromParams(params) : qb2;
      }
      get options() {
        return RequestQueryBuilder._options;
      }
      setParamNames() {
        Object.keys(RequestQueryBuilder._options.paramNamesMap).forEach((key) => {
          const name = RequestQueryBuilder._options.paramNamesMap[key];
          this.paramNames[key] = util_1$1.isString(name) ? name : name[0];
        });
      }
      query(encode2 = true) {
        if (this.queryObject[this.paramNames.search]) {
          this.queryObject[this.paramNames.filter] = void 0;
          this.queryObject[this.paramNames.or] = void 0;
        }
        this.queryString = qs_1.stringify(this.queryObject, { encode: encode2 });
        return this.queryString;
      }
      select(fields) {
        if (util_1$1.isArrayFull(fields)) {
          request_query_validator_1$1.validateFields(fields);
          this.queryObject[this.paramNames.fields] = fields.join(this.options.delimStr);
        }
        return this;
      }
      search(s) {
        if (!util_1$1.isNil(s) && util_1$1.isObject(s)) {
          this.queryObject[this.paramNames.search] = JSON.stringify(s);
        }
        return this;
      }
      setFilter(f2) {
        this.setCondition(f2, "filter");
        return this;
      }
      setOr(f2) {
        this.setCondition(f2, "or");
        return this;
      }
      setJoin(j) {
        if (!util_1$1.isNil(j)) {
          const param = this.checkQueryObjectParam("join", []);
          this.queryObject[param] = [
            ...this.queryObject[param],
            ...Array.isArray(j) && !util_1$1.isString(j[0]) ? j.map((o2) => this.addJoin(o2)) : [this.addJoin(j)]
          ];
        }
        return this;
      }
      sortBy(s) {
        if (!util_1$1.isNil(s)) {
          const param = this.checkQueryObjectParam("sort", []);
          this.queryObject[param] = [
            ...this.queryObject[param],
            ...Array.isArray(s) && !util_1$1.isString(s[0]) ? s.map((o2) => this.addSortBy(o2)) : [this.addSortBy(s)]
          ];
        }
        return this;
      }
      setLimit(n2) {
        this.setNumeric(n2, "limit");
        return this;
      }
      setOffset(n2) {
        this.setNumeric(n2, "offset");
        return this;
      }
      setPage(n2) {
        this.setNumeric(n2, "page");
        return this;
      }
      resetCache() {
        this.setNumeric(0, "cache");
        return this;
      }
      setIncludeDeleted(n2) {
        this.setNumeric(n2, "includeDeleted");
        return this;
      }
      cond(f2, cond = "search") {
        const filter2 = Array.isArray(f2) ? { field: f2[0], operator: f2[1], value: f2[2] } : f2;
        request_query_validator_1$1.validateCondition(filter2, cond);
        const d2 = this.options.delim;
        return filter2.field + d2 + filter2.operator + (util_1$1.hasValue(filter2.value) ? d2 + filter2.value : "");
      }
      addJoin(j) {
        const join2 = Array.isArray(j) ? { field: j[0], select: j[1] } : j;
        request_query_validator_1$1.validateJoin(join2);
        const d2 = this.options.delim;
        const ds = this.options.delimStr;
        return join2.field + (util_1$1.isArrayFull(join2.select) ? d2 + join2.select.join(ds) : "");
      }
      addSortBy(s) {
        const sort = Array.isArray(s) ? { field: s[0], order: s[1] } : s;
        request_query_validator_1$1.validateSort(sort);
        const ds = this.options.delimStr;
        return sort.field + ds + sort.order;
      }
      createFromParams(params) {
        this.select(params.fields);
        this.search(params.search);
        this.setFilter(params.filter);
        this.setOr(params.or);
        this.setJoin(params.join);
        this.setLimit(params.limit);
        this.setOffset(params.offset);
        this.setPage(params.page);
        this.sortBy(params.sort);
        if (params.resetCache) {
          this.resetCache();
        }
        this.setIncludeDeleted(params.includeDeleted);
        return this;
      }
      checkQueryObjectParam(cond, defaults2) {
        const param = this.paramNames[cond];
        if (util_1$1.isNil(this.queryObject[param]) && !util_1$1.isUndefined(defaults2)) {
          this.queryObject[param] = defaults2;
        }
        return param;
      }
      setCondition(f2, cond) {
        if (!util_1$1.isNil(f2)) {
          const param = this.checkQueryObjectParam(cond, []);
          this.queryObject[param] = [
            ...this.queryObject[param],
            ...Array.isArray(f2) && !util_1$1.isString(f2[0]) ? f2.map((o2) => this.cond(o2, cond)) : [this.cond(f2, cond)]
          ];
        }
      }
      setNumeric(n2, cond) {
        if (!util_1$1.isNil(n2)) {
          request_query_validator_1$1.validateNumeric(n2, cond);
          this.queryObject[this.paramNames[cond]] = n2;
        }
      }
    }
    requestQuery_builder.RequestQueryBuilder = RequestQueryBuilder;
    RequestQueryBuilder._options = {
      delim: "||",
      delimStr: ",",
      paramNamesMap: {
        fields: ["fields", "select"],
        search: "s",
        filter: "filter",
        or: "or",
        join: "join",
        sort: "sort",
        limit: ["limit", "per_page"],
        offset: "offset",
        page: "page",
        cache: "cache",
        includeDeleted: "include_deleted"
      }
    };
    var requestQuery_parser = {};
    Object.defineProperty(requestQuery_parser, "__esModule", { value: true });
    const util_1 = lib;
    const exceptions_1 = exceptions;
    const request_query_builder_1 = requestQuery_builder;
    const request_query_validator_1 = requestQuery_validator;
    class RequestQueryParser {
      constructor() {
        this.fields = [];
        this.paramsFilter = [];
        this.authPersist = void 0;
        this.filter = [];
        this.or = [];
        this.join = [];
        this.sort = [];
      }
      get _options() {
        return request_query_builder_1.RequestQueryBuilder.getOptions();
      }
      static create() {
        return new RequestQueryParser();
      }
      getParsed() {
        return {
          fields: this.fields,
          paramsFilter: this.paramsFilter,
          authPersist: this.authPersist,
          search: this.search,
          filter: this.filter,
          or: this.or,
          join: this.join,
          sort: this.sort,
          limit: this.limit,
          offset: this.offset,
          page: this.page,
          cache: this.cache,
          includeDeleted: this.includeDeleted
        };
      }
      parseQuery(query) {
        if (util_1.isObject(query)) {
          const paramNames = util_1.objKeys(query);
          if (util_1.hasLength(paramNames)) {
            this._query = query;
            this._paramNames = paramNames;
            let searchData = this._query[this.getParamNames("search")[0]];
            this.search = this.parseSearchQueryParam(searchData);
            if (util_1.isNil(this.search)) {
              this.filter = this.parseQueryParam("filter", this.conditionParser.bind(this, "filter"));
              this.or = this.parseQueryParam("or", this.conditionParser.bind(this, "or"));
            }
            this.fields = this.parseQueryParam("fields", this.fieldsParser.bind(this))[0] || [];
            this.join = this.parseQueryParam("join", this.joinParser.bind(this));
            this.sort = this.parseQueryParam("sort", this.sortParser.bind(this));
            this.limit = this.parseQueryParam("limit", this.numericParser.bind(this, "limit"))[0];
            this.offset = this.parseQueryParam("offset", this.numericParser.bind(this, "offset"))[0];
            this.page = this.parseQueryParam("page", this.numericParser.bind(this, "page"))[0];
            this.cache = this.parseQueryParam("cache", this.numericParser.bind(this, "cache"))[0];
            this.includeDeleted = this.parseQueryParam("includeDeleted", this.numericParser.bind(this, "includeDeleted"))[0];
          }
        }
        return this;
      }
      parseParams(params, options) {
        if (util_1.isObject(params)) {
          const paramNames = util_1.objKeys(params);
          if (util_1.hasLength(paramNames)) {
            this._params = params;
            this._paramsOptions = options;
            this.paramsFilter = paramNames.map((name) => this.paramParser(name)).filter((filter2) => filter2);
          }
        }
        return this;
      }
      setAuthPersist(persist = {}) {
        this.authPersist = persist || {};
      }
      convertFilterToSearch(filter2) {
        const isEmptyValue2 = {
          isnull: true,
          notnull: true
        };
        return filter2 ? {
          [filter2.field]: {
            [filter2.operator]: isEmptyValue2[filter2.operator] ? isEmptyValue2[filter2.operator] : filter2.value
          }
        } : {};
      }
      getParamNames(type2) {
        return this._paramNames.filter((p2) => {
          const name = this._options.paramNamesMap[type2];
          return util_1.isString(name) ? name === p2 : name.some((m2) => m2 === p2);
        });
      }
      getParamValues(value, parser2) {
        if (util_1.isStringFull(value)) {
          return [parser2.call(this, value)];
        }
        if (util_1.isArrayFull(value)) {
          return value.map((val) => parser2(val));
        }
        return [];
      }
      parseQueryParam(type2, parser2) {
        const param = this.getParamNames(type2);
        if (util_1.isArrayFull(param)) {
          return param.reduce((a, name) => [...a, ...this.getParamValues(this._query[name], parser2)], []);
        }
        return [];
      }
      parseValue(val) {
        try {
          const parsed = JSON.parse(val);
          if (!util_1.isDate(parsed) && util_1.isObject(parsed)) {
            return val;
          } else if (typeof parsed === "number" && parsed.toLocaleString("fullwide", { useGrouping: false }) !== val) {
            return val;
          }
          return parsed;
        } catch (ignored) {
          if (util_1.isDateString(val)) {
            return new Date(val);
          }
          return val;
        }
      }
      parseValues(vals) {
        if (util_1.isArrayFull(vals)) {
          return vals.map((v2) => this.parseValue(v2));
        } else {
          return this.parseValue(vals);
        }
      }
      fieldsParser(data2) {
        return data2.split(this._options.delimStr);
      }
      parseSearchQueryParam(d2) {
        try {
          if (util_1.isNil(d2)) {
            return void 0;
          }
          const data2 = JSON.parse(d2);
          if (!util_1.isObject(data2)) {
            throw new Error();
          }
          return data2;
        } catch (_) {
          throw new exceptions_1.RequestQueryException("Invalid search param. JSON expected");
        }
      }
      conditionParser(cond, data2) {
        const isArrayValue = [
          "in",
          "notin",
          "between",
          "$in",
          "$notin",
          "$between",
          "$inL",
          "$notinL"
        ];
        const isEmptyValue2 = ["isnull", "notnull", "$isnull", "$notnull"];
        const param = data2.split(this._options.delim);
        const field = param[0];
        const operator = param[1];
        let value = param[2] || "";
        if (isArrayValue.some((name) => name === operator)) {
          value = value.split(this._options.delimStr);
        }
        value = this.parseValues(value);
        if (!isEmptyValue2.some((name) => name === operator) && !util_1.hasValue(value)) {
          throw new exceptions_1.RequestQueryException(`Invalid ${cond} value`);
        }
        const condition = { field, operator, value };
        request_query_validator_1.validateCondition(condition, cond);
        return condition;
      }
      joinParser(data2) {
        const param = data2.split(this._options.delim);
        const join2 = {
          field: param[0],
          select: util_1.isStringFull(param[1]) ? param[1].split(this._options.delimStr) : void 0
        };
        request_query_validator_1.validateJoin(join2);
        return join2;
      }
      sortParser(data2) {
        const param = data2.split(this._options.delimStr);
        const sort = {
          field: param[0],
          order: param[1]
        };
        request_query_validator_1.validateSort(sort);
        return sort;
      }
      numericParser(num, data2) {
        const val = this.parseValue(data2);
        request_query_validator_1.validateNumeric(val, num);
        return val;
      }
      paramParser(name) {
        request_query_validator_1.validateParamOption(this._paramsOptions, name);
        const option = this._paramsOptions[name];
        if (option.disabled) {
          return void 0;
        }
        let value = this._params[name];
        switch (option.type) {
          case "number":
            value = this.parseValue(value);
            request_query_validator_1.validateNumeric(value, `param ${name}`);
            break;
          case "uuid":
            request_query_validator_1.validateUUID(value, name);
            break;
        }
        return { field: option.field, operator: "$eq", value };
      }
    }
    requestQuery_parser.RequestQueryParser = RequestQueryParser;
    (function(exports2) {
      function __export(m2) {
        for (var p2 in m2)
          if (!exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      __export(exceptions);
      __export(requestQuery_builder);
      __export(requestQuery_parser);
      __export(types);
    })(lib$1);
    var queryString = {};
    var strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`);
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return [decodeURIComponent(components.join(""))];
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i2 = 1; i2 < tokens.length; i2++) {
          input = decodeComponents(tokens, i2).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "��",
        "%FF%FE": "��"
      };
      var match2 = multiMatcher.exec(input);
      while (match2) {
        try {
          replaceMap[match2[0]] = decodeURIComponent(match2[0]);
        } catch (err) {
          var result = decode(match2[0]);
          if (result !== match2[0]) {
            replaceMap[match2[0]] = result;
          }
        }
        match2 = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "�";
      var entries = Object.keys(replaceMap);
      for (var i2 = 0; i2 < entries.length; i2++) {
        var key = entries[i2];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    var decodeUriComponent = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
    var splitOnFirst = (string2, separator) => {
      if (!(typeof string2 === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string2];
      }
      const separatorIndex = string2.indexOf(separator);
      if (separatorIndex === -1) {
        return [string2];
      }
      return [
        string2.slice(0, separatorIndex),
        string2.slice(separatorIndex + separator.length)
      ];
    };
    var filterObj = function(obj, predicate) {
      var ret = {};
      var keys2 = Object.keys(obj);
      var isArr = Array.isArray(predicate);
      for (var i2 = 0; i2 < keys2.length; i2++) {
        var key = keys2[i2];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
          ret[key] = val;
        }
      }
      return ret;
    };
    (function(exports2) {
      const strictUriEncode$1 = strictUriEncode;
      const decodeComponent = decodeUriComponent;
      const splitOnFirst$1 = splitOnFirst;
      const filterObject = filterObj;
      const isNullOrUndefined = (value) => value === null || value === void 0;
      const encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
      function encoderForArrayFormat(options) {
        switch (options.arrayFormat) {
          case "index":
            return (key) => (result, value) => {
              const index2 = result.length;
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode2(key, options), "[", index2, "]"].join("")];
              }
              return [
                ...result,
                [encode2(key, options), "[", encode2(index2, options), "]=", encode2(value, options)].join("")
              ];
            };
          case "bracket":
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode2(key, options), "[]"].join("")];
              }
              return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
            };
          case "colon-list-separator":
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode2(key, options), ":list="].join("")];
              }
              return [...result, [encode2(key, options), ":list=", encode2(value, options)].join("")];
            };
          case "comma":
          case "separator":
          case "bracket-separator": {
            const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              value = value === null ? "" : value;
              if (result.length === 0) {
                return [[encode2(key, options), keyValueSep, encode2(value, options)].join("")];
              }
              return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
            };
          }
          default:
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, encode2(key, options)];
              }
              return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
            };
        }
      }
      function parserForArrayFormat(options) {
        let result;
        switch (options.arrayFormat) {
          case "index":
            return (key, value, accumulator) => {
              result = /\[(\d*)\]$/.exec(key);
              key = key.replace(/\[\d*\]$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = {};
              }
              accumulator[key][result[1]] = value;
            };
          case "bracket":
            return (key, value, accumulator) => {
              result = /(\[\])$/.exec(key);
              key = key.replace(/\[\]$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = [value];
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
          case "colon-list-separator":
            return (key, value, accumulator) => {
              result = /(:list)$/.exec(key);
              key = key.replace(/:list$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = [value];
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
          case "comma":
          case "separator":
            return (key, value, accumulator) => {
              const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
              const isEncodedArray = typeof value === "string" && !isArray2 && decode2(value, options).includes(options.arrayFormatSeparator);
              value = isEncodedArray ? decode2(value, options) : value;
              const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
              accumulator[key] = newValue;
            };
          case "bracket-separator":
            return (key, value, accumulator) => {
              const isArray2 = /(\[\])$/.test(key);
              key = key.replace(/\[\]$/, "");
              if (!isArray2) {
                accumulator[key] = value ? decode2(value, options) : value;
                return;
              }
              const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode2(item, options));
              if (accumulator[key] === void 0) {
                accumulator[key] = arrayValue;
                return;
              }
              accumulator[key] = [].concat(accumulator[key], arrayValue);
            };
          default:
            return (key, value, accumulator) => {
              if (accumulator[key] === void 0) {
                accumulator[key] = value;
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
        }
      }
      function validateArrayFormatSeparator(value) {
        if (typeof value !== "string" || value.length !== 1) {
          throw new TypeError("arrayFormatSeparator must be single character string");
        }
      }
      function encode2(value, options) {
        if (options.encode) {
          return options.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
        }
        return value;
      }
      function decode2(value, options) {
        if (options.decode) {
          return decodeComponent(value);
        }
        return value;
      }
      function keysSorter(input) {
        if (Array.isArray(input)) {
          return input.sort();
        }
        if (typeof input === "object") {
          return keysSorter(Object.keys(input)).sort((a, b2) => Number(a) - Number(b2)).map((key) => input[key]);
        }
        return input;
      }
      function removeHash(input) {
        const hashStart = input.indexOf("#");
        if (hashStart !== -1) {
          input = input.slice(0, hashStart);
        }
        return input;
      }
      function getHash(url) {
        let hash = "";
        const hashStart = url.indexOf("#");
        if (hashStart !== -1) {
          hash = url.slice(hashStart);
        }
        return hash;
      }
      function extract(input) {
        input = removeHash(input);
        const queryStart = input.indexOf("?");
        if (queryStart === -1) {
          return "";
        }
        return input.slice(queryStart + 1);
      }
      function parseValue2(value, options) {
        if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
          value = Number(value);
        } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
          value = value.toLowerCase() === "true";
        }
        return value;
      }
      function parse2(query, options) {
        options = Object.assign({
          decode: true,
          sort: true,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
          parseNumbers: false,
          parseBooleans: false
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        const formatter = parserForArrayFormat(options);
        const ret = /* @__PURE__ */ Object.create(null);
        if (typeof query !== "string") {
          return ret;
        }
        query = query.trim().replace(/^[?#&]/, "");
        if (!query) {
          return ret;
        }
        for (const param of query.split("&")) {
          if (param === "") {
            continue;
          }
          let [key, value] = splitOnFirst$1(options.decode ? param.replace(/\+/g, " ") : param, "=");
          value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options);
          formatter(decode2(key, options), value, ret);
        }
        for (const key of Object.keys(ret)) {
          const value = ret[key];
          if (typeof value === "object" && value !== null) {
            for (const k2 of Object.keys(value)) {
              value[k2] = parseValue2(value[k2], options);
            }
          } else {
            ret[key] = parseValue2(value, options);
          }
        }
        if (options.sort === false) {
          return ret;
        }
        return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
          const value = ret[key];
          if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
            result[key] = keysSorter(value);
          } else {
            result[key] = value;
          }
          return result;
        }, /* @__PURE__ */ Object.create(null));
      }
      exports2.extract = extract;
      exports2.parse = parse2;
      exports2.stringify = (object2, options) => {
        if (!object2) {
          return "";
        }
        options = Object.assign({
          encode: true,
          strict: true,
          arrayFormat: "none",
          arrayFormatSeparator: ","
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object2[key]) || options.skipEmptyString && object2[key] === "";
        const formatter = encoderForArrayFormat(options);
        const objectCopy = {};
        for (const key of Object.keys(object2)) {
          if (!shouldFilter(key)) {
            objectCopy[key] = object2[key];
          }
        }
        const keys2 = Object.keys(objectCopy);
        if (options.sort !== false) {
          keys2.sort(options.sort);
        }
        return keys2.map((key) => {
          const value = object2[key];
          if (value === void 0) {
            return "";
          }
          if (value === null) {
            return encode2(key, options);
          }
          if (Array.isArray(value)) {
            if (value.length === 0 && options.arrayFormat === "bracket-separator") {
              return encode2(key, options) + "[]";
            }
            return value.reduce(formatter(key), []).join("&");
          }
          return encode2(key, options) + "=" + encode2(value, options);
        }).filter((x2) => x2.length > 0).join("&");
      };
      exports2.parseUrl = (url, options) => {
        options = Object.assign({
          decode: true
        }, options);
        const [url_, hash] = splitOnFirst$1(url, "#");
        return Object.assign(
          {
            url: url_.split("?")[0] || "",
            query: parse2(extract(url), options)
          },
          options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode2(hash, options) } : {}
        );
      };
      exports2.stringifyUrl = (object2, options) => {
        options = Object.assign({
          encode: true,
          strict: true,
          [encodeFragmentIdentifier]: true
        }, options);
        const url = removeHash(object2.url).split("?")[0] || "";
        const queryFromUrl = exports2.extract(object2.url);
        const parsedQueryFromUrl = exports2.parse(queryFromUrl, { sort: false });
        const query = Object.assign(parsedQueryFromUrl, object2.query);
        let queryString2 = exports2.stringify(query, options);
        if (queryString2) {
          queryString2 = `?${queryString2}`;
        }
        let hash = getHash(object2.url);
        if (object2.fragmentIdentifier) {
          hash = `#${options[encodeFragmentIdentifier] ? encode2(object2.fragmentIdentifier, options) : object2.fragmentIdentifier}`;
        }
        return `${url}${queryString2}${hash}`;
      };
      exports2.pick = (input, filter2, options) => {
        options = Object.assign({
          parseFragmentIdentifier: true,
          [encodeFragmentIdentifier]: false
        }, options);
        const { url, query, fragmentIdentifier } = exports2.parseUrl(input, options);
        return exports2.stringifyUrl({
          url,
          query: filterObject(query, filter2),
          fragmentIdentifier
        }, options);
      };
      exports2.exclude = (input, filter2, options) => {
        const exclusionFilter = Array.isArray(filter2) ? (key) => !filter2.includes(key) : (key, value) => !filter2(key, value);
        return exports2.pick(input, exclusionFilter, options);
      };
    })(queryString);
    var w = E.create();
    w.interceptors.response.use((r2) => r2, (r2) => {
      var e2, s, n2;
      let t2 = { ...r2, message: (s = (e2 = r2.response) == null ? void 0 : e2.data) == null ? void 0 : s.message, statusCode: (n2 = r2.response) == null ? void 0 : n2.status };
      return Promise.reject(t2);
    });
    var Q = (r2) => {
      switch (r2) {
        case "and":
          return "$and";
        case "or":
          return "$or";
        case "ne":
          return lib$1.CondOperator.NOT_EQUALS;
        case "lt":
          return lib$1.CondOperator.LOWER_THAN;
        case "gt":
          return lib$1.CondOperator.GREATER_THAN;
        case "lte":
          return lib$1.CondOperator.LOWER_THAN_EQUALS;
        case "gte":
          return lib$1.CondOperator.GREATER_THAN_EQUALS;
        case "in":
          return lib$1.CondOperator.IN;
        case "nin":
          return lib$1.CondOperator.NOT_IN;
        case "contains":
          return lib$1.CondOperator.CONTAINS_LOW;
        case "ncontains":
          return lib$1.CondOperator.EXCLUDES_LOW;
        case "containss":
          return lib$1.CondOperator.CONTAINS;
        case "ncontainss":
          return lib$1.CondOperator.EXCLUDES;
        case "null":
          return lib$1.CondOperator.IS_NULL;
        case "startswith":
          return lib$1.CondOperator.STARTS_LOW;
        case "startswiths":
          return lib$1.CondOperator.STARTS;
        case "endswith":
          return lib$1.CondOperator.ENDS_LOW;
        case "endswiths":
          return lib$1.CondOperator.ENDS;
      }
      return lib$1.CondOperator.EQUALS;
    }, N = (r2) => {
      if (r2 && r2.length > 0) {
        let t2 = [];
        return r2.map(({ field: e2, order: s }) => {
          e2 && s && t2.push({ field: e2, order: s.toUpperCase() });
        }), t2;
      }
    }, f = (r2) => {
      if (r2.operator !== "and" && r2.operator !== "or" && "field" in r2)
        return { [r2.field]: { [Q(r2.operator)]: r2.value } };
      let { operator: t2 } = r2;
      return { [Q(t2)]: r2.value.map((e2) => f(e2)) };
    }, L = (r2) => f({ operator: "and", value: r2 }), A = (r2, t2) => (t2 && r2.search(L(t2)), r2), p = (r2, t2) => (t2 && r2.setJoin(t2), r2), m = (r2, t2, e2, s) => (t2 && r2.setLimit(e2).setPage(s).setOffset((s - 1) * e2), r2), O = (r2, t2) => {
      let e2 = N(t2);
      return e2 && r2.sortBy(e2), r2;
    }, T = (r2, t2 = w) => ({ getList: async ({ resource: e2, hasPagination: s = true, pagination: n2 = { current: 1, pageSize: 10 }, filters: o2, sort: u2, metaData: i2 }) => {
      let S2 = `${r2}/${e2}`, { current: l2 = 1, pageSize: d2 = 10 } = n2 != null ? n2 : {}, c2 = lib$1.RequestQueryBuilder.create();
      c2 = A(c2, o2), c2 = p(c2, i2 == null ? void 0 : i2.join), c2 = m(c2, s, d2, l2), c2 = O(c2, u2);
      let { data: y2 } = await t2.get(`${S2}?${c2.query()}`);
      return { data: y2.data, total: y2.total };
    }, getMany: async ({ resource: e2, ids: s, metaData: n2 }) => {
      let o2 = `${r2}/${e2}`, u2 = lib$1.RequestQueryBuilder.create().setFilter({ field: "id", operator: lib$1.CondOperator.IN, value: s });
      u2 = p(u2, n2 == null ? void 0 : n2.join);
      let { data: i2 } = await t2.get(`${o2}?${u2.query()}`);
      return { data: i2 };
    }, create: async ({ resource: e2, variables: s }) => {
      let n2 = `${r2}/${e2}`, { data: o2 } = await t2.post(n2, s);
      return { data: o2 };
    }, update: async ({ resource: e2, id: s, variables: n2 }) => {
      let o2 = `${r2}/${e2}/${s}`, { data: u2 } = await t2.patch(o2, n2);
      return { data: u2 };
    }, updateMany: async ({ resource: e2, ids: s, variables: n2 }) => ({ data: await Promise.all(s.map(async (u2) => {
      let { data: i2 } = await t2.patch(`${r2}/${e2}/${u2}`, n2);
      return i2;
    })) }), createMany: async ({ resource: e2, variables: s }) => {
      let n2 = `${r2}/${e2}/bulk`, { data: o2 } = await t2.post(n2, { bulk: s });
      return { data: o2 };
    }, getOne: async ({ resource: e2, id: s }) => {
      let n2 = `${r2}/${e2}/${s}`, { data: o2 } = await t2.get(n2);
      return { data: o2 };
    }, deleteOne: async ({ resource: e2, id: s }) => {
      let n2 = `${r2}/${e2}/${s}`, { data: o2 } = await t2.delete(n2);
      return { data: o2 };
    }, deleteMany: async ({ resource: e2, ids: s }) => ({ data: await Promise.all(s.map(async (o2) => {
      let { data: u2 } = await t2.delete(`${r2}/${e2}/${o2}`);
      return u2;
    })) }), getApiUrl: () => r2, custom: async ({ url: e2, method: s, metaData: n2, filters: o2, sort: u2, payload: i2, query: S2, headers: l2 }) => {
      let d2 = lib$1.RequestQueryBuilder.create();
      d2 = A(d2, o2), d2 = p(d2, n2 == null ? void 0 : n2.join), d2 = O(d2, u2);
      let c2 = `${e2}?${d2.query()}`;
      S2 && (c2 = `${c2}&${queryString.stringify(S2)}`), l2 && (t2.defaults.headers = { ...t2.defaults.headers, ...l2 });
      let y2;
      switch (s) {
        case "put":
        case "post":
        case "patch":
          y2 = await t2[s](e2, i2);
          break;
        case "delete":
          y2 = await t2.delete(e2, { data: i2 });
          break;
        default:
          y2 = await t2.get(c2);
          break;
      }
      let { data: g2 } = y2;
      return Promise.resolve({ data: g2 });
    } }), H = T;
    var Action;
    (function(Action2) {
      Action2["Pop"] = "POP";
      Action2["Push"] = "PUSH";
      Action2["Replace"] = "REPLACE";
    })(Action || (Action = {}));
    var readOnly = function(obj) {
      return obj;
    };
    var BeforeUnloadEventType = "beforeunload";
    var PopStateEventType = "popstate";
    function createBrowserHistory(options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, _options$window = _options.window, window2 = _options$window === void 0 ? document.defaultView : _options$window;
      var globalHistory = window2.history;
      function getIndexAndLocation() {
        var _window$location = window2.location, pathname = _window$location.pathname, search2 = _window$location.search, hash = _window$location.hash;
        var state = globalHistory.state || {};
        return [state.idx, readOnly({
          pathname,
          search: search2,
          hash,
          state: state.usr || null,
          key: state.key || "default"
        })];
      }
      var blockedPopTx = null;
      function handlePop() {
        if (blockedPopTx) {
          blockers.call(blockedPopTx);
          blockedPopTx = null;
        } else {
          var nextAction = Action.Pop;
          var _getIndexAndLocation = getIndexAndLocation(), nextIndex = _getIndexAndLocation[0], nextLocation = _getIndexAndLocation[1];
          if (blockers.length) {
            if (nextIndex != null) {
              var delta = index2 - nextIndex;
              if (delta) {
                blockedPopTx = {
                  action: nextAction,
                  location: nextLocation,
                  retry: function retry() {
                    go(delta * -1);
                  }
                };
                go(delta);
              }
            }
          } else {
            applyTx(nextAction);
          }
        }
      }
      window2.addEventListener(PopStateEventType, handlePop);
      var action = Action.Pop;
      var _getIndexAndLocation2 = getIndexAndLocation(), index2 = _getIndexAndLocation2[0], location2 = _getIndexAndLocation2[1];
      var listeners = createEvents();
      var blockers = createEvents();
      if (index2 == null) {
        index2 = 0;
        globalHistory.replaceState(_extends$2({}, globalHistory.state, {
          idx: index2
        }), "");
      }
      function createHref(to) {
        return typeof to === "string" ? to : createPath(to);
      }
      function getNextLocation(to, state) {
        if (state === void 0) {
          state = null;
        }
        return readOnly(_extends$2({
          pathname: location2.pathname,
          hash: "",
          search: ""
        }, typeof to === "string" ? parsePath(to) : to, {
          state,
          key: createKey()
        }));
      }
      function getHistoryStateAndUrl(nextLocation, index3) {
        return [{
          usr: nextLocation.state,
          key: nextLocation.key,
          idx: index3
        }, createHref(nextLocation)];
      }
      function allowTx(action2, location3, retry) {
        return !blockers.length || (blockers.call({
          action: action2,
          location: location3,
          retry
        }), false);
      }
      function applyTx(nextAction) {
        action = nextAction;
        var _getIndexAndLocation3 = getIndexAndLocation();
        index2 = _getIndexAndLocation3[0];
        location2 = _getIndexAndLocation3[1];
        listeners.call({
          action,
          location: location2
        });
      }
      function push2(to, state) {
        var nextAction = Action.Push;
        var nextLocation = getNextLocation(to, state);
        function retry() {
          push2(to, state);
        }
        if (allowTx(nextAction, nextLocation, retry)) {
          var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index2 + 1), historyState = _getHistoryStateAndUr[0], url = _getHistoryStateAndUr[1];
          try {
            globalHistory.pushState(historyState, "", url);
          } catch (error) {
            window2.location.assign(url);
          }
          applyTx(nextAction);
        }
      }
      function replace2(to, state) {
        var nextAction = Action.Replace;
        var nextLocation = getNextLocation(to, state);
        function retry() {
          replace2(to, state);
        }
        if (allowTx(nextAction, nextLocation, retry)) {
          var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index2), historyState = _getHistoryStateAndUr2[0], url = _getHistoryStateAndUr2[1];
          globalHistory.replaceState(historyState, "", url);
          applyTx(nextAction);
        }
      }
      function go(delta) {
        globalHistory.go(delta);
      }
      var history = {
        get action() {
          return action;
        },
        get location() {
          return location2;
        },
        createHref,
        push: push2,
        replace: replace2,
        go,
        back: function back() {
          go(-1);
        },
        forward: function forward() {
          go(1);
        },
        listen: function listen(listener) {
          return listeners.push(listener);
        },
        block: function block(blocker) {
          var unblock = blockers.push(blocker);
          if (blockers.length === 1) {
            window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
          }
          return function() {
            unblock();
            if (!blockers.length) {
              window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
            }
          };
        }
      };
      return history;
    }
    function promptBeforeUnload(event) {
      event.preventDefault();
      event.returnValue = "";
    }
    function createEvents() {
      var handlers2 = [];
      return {
        get length() {
          return handlers2.length;
        },
        push: function push2(fn) {
          handlers2.push(fn);
          return function() {
            handlers2 = handlers2.filter(function(handler) {
              return handler !== fn;
            });
          };
        },
        call: function call2(arg) {
          handlers2.forEach(function(fn) {
            return fn && fn(arg);
          });
        }
      };
    }
    function createKey() {
      return Math.random().toString(36).substr(2, 8);
    }
    function createPath(_ref) {
      var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? "/" : _ref$pathname, _ref$search = _ref.search, search2 = _ref$search === void 0 ? "" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? "" : _ref$hash;
      if (search2 && search2 !== "?")
        pathname += search2.charAt(0) === "?" ? search2 : "?" + search2;
      if (hash && hash !== "#")
        pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
      return pathname;
    }
    function parsePath(path2) {
      var parsedPath = {};
      if (path2) {
        var hashIndex = path2.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path2.substr(hashIndex);
          path2 = path2.substr(0, hashIndex);
        }
        var searchIndex = path2.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path2.substr(searchIndex);
          path2 = path2.substr(0, searchIndex);
        }
        if (path2) {
          parsedPath.pathname = path2;
        }
      }
      return parsedPath;
    }
    /**
     * React Router v6.3.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
    const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
    const RouteContext = /* @__PURE__ */ reactExports.createContext({
      outlet: null,
      matches: []
    });
    function invariant$2(cond, message2) {
      if (!cond)
        throw new Error(message2);
    }
    function matchRoutes(routes, locationArg, basename2) {
      if (basename2 === void 0) {
        basename2 = "/";
      }
      let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location2.pathname || "/", basename2);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes);
      rankRouteBranches(branches);
      let matches = null;
      for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
        matches = matchRouteBranch(branches[i2], pathname);
      }
      return matches;
    }
    function flattenRoutes(routes, branches, parentsMeta, parentPath) {
      if (branches === void 0) {
        branches = [];
      }
      if (parentsMeta === void 0) {
        parentsMeta = [];
      }
      if (parentPath === void 0) {
        parentPath = "";
      }
      routes.forEach((route, index2) => {
        let meta = {
          relativePath: route.path || "",
          caseSensitive: route.caseSensitive === true,
          childrenIndex: index2,
          route
        };
        if (meta.relativePath.startsWith("/")) {
          !meta.relativePath.startsWith(parentPath) ? invariant$2(false) : void 0;
          meta.relativePath = meta.relativePath.slice(parentPath.length);
        }
        let path2 = joinPaths([parentPath, meta.relativePath]);
        let routesMeta = parentsMeta.concat(meta);
        if (route.children && route.children.length > 0) {
          !(route.index !== true) ? invariant$2(false) : void 0;
          flattenRoutes(route.children, branches, routesMeta, path2);
        }
        if (route.path == null && !route.index) {
          return;
        }
        branches.push({
          path: path2,
          score: computeScore(path2, route.index),
          routesMeta
        });
      });
      return branches;
    }
    function rankRouteBranches(branches) {
      branches.sort((a, b2) => a.score !== b2.score ? b2.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
    }
    const paramRe = /^:\w+$/;
    const dynamicSegmentValue = 3;
    const indexRouteValue = 2;
    const emptySegmentValue = 1;
    const staticSegmentValue = 10;
    const splatPenalty = -2;
    const isSplat = (s) => s === "*";
    function computeScore(path2, index2) {
      let segments = path2.split("/");
      let initialScore = segments.length;
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index2) {
        initialScore += indexRouteValue;
      }
      return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
    }
    function compareIndexes(a, b2) {
      let siblings = a.length === b2.length && a.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
      return siblings ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a[a.length - 1] - b2[b2.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname) {
      let {
        routesMeta
      } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches = [];
      for (let i2 = 0; i2 < routesMeta.length; ++i2) {
        let meta = routesMeta[i2];
        let end2 = i2 === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match2 = matchPath({
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: end2
        }, remainingPathname);
        if (!match2)
          return null;
        Object.assign(matchedParams, match2.params);
        let route = meta.route;
        matches.push({
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match2.pathname]),
          pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
          route
        });
        if (match2.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
        }
      }
      return matches;
    }
    function matchPath(pattern2, pathname) {
      if (typeof pattern2 === "string") {
        pattern2 = {
          path: pattern2,
          caseSensitive: false,
          end: true
        };
      }
      let [matcher, paramNames] = compilePath(pattern2.path, pattern2.caseSensitive, pattern2.end);
      let match2 = pathname.match(matcher);
      if (!match2)
        return null;
      let matchedPathname = match2[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match2.slice(1);
      let params = paramNames.reduce((memo, paramName, index2) => {
        if (paramName === "*") {
          let splatValue = captureGroups[index2] || "";
          pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
        }
        memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "");
        return memo;
      }, {});
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern: pattern2
      };
    }
    function compilePath(path2, caseSensitive, end2) {
      if (caseSensitive === void 0) {
        caseSensitive = false;
      }
      if (end2 === void 0) {
        end2 = true;
      }
      let paramNames = [];
      let regexpSource = "^" + path2.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_, paramName) => {
        paramNames.push(paramName);
        return "([^\\/]+)";
      });
      if (path2.endsWith("*")) {
        paramNames.push("*");
        regexpSource += path2 === "*" || path2 === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else {
        regexpSource += end2 ? "\\/*$" : (
          // Otherwise, match a word boundary or a proceeding /. The word boundary restricts
          // parent routes to matching only their own words and nothing more, e.g. parent
          // route "/home" should not match "/home2".
          // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,
          // but do not consume the character in the matched path so they can match against
          // nested paths.
          "(?:(?=[.~-]|%[0-9A-F]{2})|\\b|\\/|$)"
        );
      }
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, paramNames];
    }
    function safelyDecodeURIComponent(value, paramName) {
      try {
        return decodeURIComponent(value);
      } catch (error) {
        return value;
      }
    }
    function resolvePath(to, fromPathname) {
      if (fromPathname === void 0) {
        fromPathname = "/";
      }
      let {
        pathname: toPathname,
        search: search2 = "",
        hash = ""
      } = typeof to === "string" ? parsePath(to) : to;
      let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
      return {
        pathname,
        search: normalizeSearch(search2),
        hash: normalizeHash(hash)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments.length > 1)
            segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });
      return segments.length > 1 ? segments.join("/") : "/";
    }
    function resolveTo(toArg, routePathnames, locationPathname) {
      let to = typeof toArg === "string" ? parsePath(toArg) : toArg;
      let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname;
      let from2;
      if (toPathname == null) {
        from2 = locationPathname;
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to.pathname = toSegments.join("/");
        }
        from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path2 = resolvePath(to, from2);
      if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path2.pathname.endsWith("/")) {
        path2.pathname += "/";
      }
      return path2;
    }
    function getToPathname(to) {
      return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
    }
    function stripBasename(pathname, basename2) {
      if (basename2 === "/")
        return pathname;
      if (!pathname.toLowerCase().startsWith(basename2.toLowerCase())) {
        return null;
      }
      let nextChar = pathname.charAt(basename2.length);
      if (nextChar && nextChar !== "/") {
        return null;
      }
      return pathname.slice(basename2.length) || "/";
    }
    const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    const normalizeSearch = (search2) => !search2 || search2 === "?" ? "" : search2.startsWith("?") ? search2 : "?" + search2;
    const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
    function useHref(to) {
      !useInRouterContext() ? invariant$2(false) : void 0;
      let {
        basename: basename2,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        hash,
        pathname,
        search: search2
      } = useResolvedPath(to);
      let joinedPathname = pathname;
      if (basename2 !== "/") {
        let toPathname = getToPathname(to);
        let endsWithSlash = toPathname != null && toPathname.endsWith("/");
        joinedPathname = pathname === "/" ? basename2 + (endsWithSlash ? "/" : "") : joinPaths([basename2, pathname]);
      }
      return navigator2.createHref({
        pathname: joinedPathname,
        search: search2,
        hash
      });
    }
    function useInRouterContext() {
      return reactExports.useContext(LocationContext) != null;
    }
    function useLocation() {
      !useInRouterContext() ? invariant$2(false) : void 0;
      return reactExports.useContext(LocationContext).location;
    }
    function useNavigate() {
      !useInRouterContext() ? invariant$2(false) : void 0;
      let {
        basename: basename2,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(matches.map((match2) => match2.pathnameBase));
      let activeRef = reactExports.useRef(false);
      reactExports.useEffect(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current)
          return;
        if (typeof to === "number") {
          navigator2.go(to);
          return;
        }
        let path2 = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
        if (basename2 !== "/") {
          path2.pathname = joinPaths([basename2, path2.pathname]);
        }
        (!!options.replace ? navigator2.replace : navigator2.push)(path2, options.state);
      }, [basename2, navigator2, routePathnamesJson, locationPathname]);
      return navigate;
    }
    const OutletContext = /* @__PURE__ */ reactExports.createContext(null);
    function useOutlet(context) {
      let outlet = reactExports.useContext(RouteContext).outlet;
      if (outlet) {
        return /* @__PURE__ */ reactExports.createElement(OutletContext.Provider, {
          value: context
        }, outlet);
      }
      return outlet;
    }
    function useParams() {
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let routeMatch = matches[matches.length - 1];
      return routeMatch ? routeMatch.params : {};
    }
    function useResolvedPath(to) {
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(matches.map((match2) => match2.pathnameBase));
      return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
    }
    function useRoutes(routes, locationArg) {
      !useInRouterContext() ? invariant$2(false) : void 0;
      let {
        matches: parentMatches
      } = reactExports.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      routeMatch && routeMatch.route;
      let locationFromContext = useLocation();
      let location2;
      if (locationArg) {
        var _parsedLocationArg$pa;
        let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
        !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant$2(false) : void 0;
        location2 = parsedLocationArg;
      } else {
        location2 = locationFromContext;
      }
      let pathname = location2.pathname || "/";
      let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
      let matches = matchRoutes(routes, {
        pathname: remainingPathname
      });
      return _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
        params: Object.assign({}, parentParams, match2.params),
        pathname: joinPaths([parentPathnameBase, match2.pathname]),
        pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match2.pathnameBase])
      })), parentMatches);
    }
    function _renderMatches(matches, parentMatches) {
      if (parentMatches === void 0) {
        parentMatches = [];
      }
      if (matches == null)
        return null;
      return matches.reduceRight((outlet, match2, index2) => {
        return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
          children: match2.route.element !== void 0 ? match2.route.element : outlet,
          value: {
            outlet,
            matches: parentMatches.concat(matches.slice(0, index2 + 1))
          }
        });
      }, null);
    }
    function Navigate(_ref2) {
      let {
        to,
        replace: replace2,
        state
      } = _ref2;
      !useInRouterContext() ? invariant$2(false) : void 0;
      let navigate = useNavigate();
      reactExports.useEffect(() => {
        navigate(to, {
          replace: replace2,
          state
        });
      });
      return null;
    }
    function Outlet(props) {
      return useOutlet(props.context);
    }
    function Route(_props) {
      invariant$2(false);
    }
    function Router(_ref3) {
      let {
        basename: basenameProp = "/",
        children = null,
        location: locationProp,
        navigationType = Action.Pop,
        navigator: navigator2,
        static: staticProp = false
      } = _ref3;
      !!useInRouterContext() ? invariant$2(false) : void 0;
      let basename2 = normalizePathname(basenameProp);
      let navigationContext = reactExports.useMemo(() => ({
        basename: basename2,
        navigator: navigator2,
        static: staticProp
      }), [basename2, navigator2, staticProp]);
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search: search2 = "",
        hash = "",
        state = null,
        key = "default"
      } = locationProp;
      let location2 = reactExports.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename2);
        if (trailingPathname == null) {
          return null;
        }
        return {
          pathname: trailingPathname,
          search: search2,
          hash,
          state,
          key
        };
      }, [basename2, pathname, search2, hash, state, key]);
      if (location2 == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
        value: navigationContext
      }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
        children,
        value: {
          location: location2,
          navigationType
        }
      }));
    }
    function Routes(_ref4) {
      let {
        children,
        location: location2
      } = _ref4;
      return useRoutes(createRoutesFromChildren(children), location2);
    }
    function createRoutesFromChildren(children) {
      let routes = [];
      reactExports.Children.forEach(children, (element) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
          return;
        }
        if (element.type === reactExports.Fragment) {
          routes.push.apply(routes, createRoutesFromChildren(element.props.children));
          return;
        }
        !(element.type === Route) ? invariant$2(false) : void 0;
        let route = {
          caseSensitive: element.props.caseSensitive,
          element: element.props.element,
          index: element.props.index,
          path: element.props.path
        };
        if (element.props.children) {
          route.children = createRoutesFromChildren(element.props.children);
        }
        routes.push(route);
      });
      return routes;
    }
    /**
     * React Router DOM v6.3.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose$1(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    const _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"];
    function BrowserRouter(_ref) {
      let {
        basename: basename2,
        children,
        window: window2
      } = _ref;
      let historyRef = reactExports.useRef();
      if (historyRef.current == null) {
        historyRef.current = createBrowserHistory({
          window: window2
        });
      }
      let history = historyRef.current;
      let [state, setState] = reactExports.useState({
        action: history.action,
        location: history.location
      });
      reactExports.useLayoutEffect(() => history.listen(setState), [history]);
      return /* @__PURE__ */ reactExports.createElement(Router, {
        basename: basename2,
        children,
        location: state.location,
        navigationType: state.action,
        navigator: history
      });
    }
    function isModifiedEvent(event) {
      return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
    const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref4, ref) {
      let {
        onClick,
        reloadDocument,
        replace: replace2 = false,
        state,
        target,
        to
      } = _ref4, rest = _objectWithoutPropertiesLoose$1(_ref4, _excluded);
      let href = useHref(to);
      let internalOnClick = useLinkClickHandler(to, {
        replace: replace2,
        state,
        target
      });
      function handleClick(event) {
        if (onClick)
          onClick(event);
        if (!event.defaultPrevented && !reloadDocument) {
          internalOnClick(event);
        }
      }
      return (
        // eslint-disable-next-line jsx-a11y/anchor-has-content
        /* @__PURE__ */ reactExports.createElement("a", _extends({}, rest, {
          href,
          onClick: handleClick,
          ref,
          target
        }))
      );
    });
    function useLinkClickHandler(to, _temp) {
      let {
        target,
        replace: replaceProp,
        state
      } = _temp === void 0 ? {} : _temp;
      let navigate = useNavigate();
      let location2 = useLocation();
      let path2 = useResolvedPath(to);
      return reactExports.useCallback((event) => {
        if (event.button === 0 && // Ignore everything but left clicks
        (!target || target === "_self") && // Let browser handle "target=_blank" etc.
        !isModifiedEvent(event)) {
          event.preventDefault();
          let replace2 = !!replaceProp || createPath(location2) === createPath(path2);
          navigate(to, {
            replace: replace2,
            state
          });
        }
      }, [location2, navigate, path2, replaceProp, state, target, to]);
    }
    var k = ({ route: r2 }) => {
      let { catchAll: o2 } = Se(), { useParams: i2 } = w$3(), { resources: P2 } = B$1(), { action: l2, id: u2 } = i2(), d2 = P2.find((f2) => f2.route === r2);
      if (d2) {
        let { list: f2, create: y2, edit: g2, show: c2, name: a, canCreate: C2, canEdit: R2, canShow: n2, canDelete: t2, options: p2 } = d2, H2 = f2 != null ? f2 : () => null, I2 = y2 != null ? y2 : () => null, D2 = g2 != null ? g2 : () => null, J2 = c2 != null ? c2 : () => null;
        return (() => {
          switch (l2) {
            case void 0:
              return React$3.createElement(Va, { resource: a, action: "list", fallback: o2 != null ? o2 : React$3.createElement(ya, null), params: { resource: d2 } }, f2 ? React$3.createElement(H2, { name: a, canCreate: C2, canEdit: R2, canDelete: t2, canShow: n2, options: p2 }) : o2 != null ? o2 : React$3.createElement(ya, null));
            case "create":
            case "clone":
              return React$3.createElement(Va, { resource: a, action: "create", fallback: o2 != null ? o2 : React$3.createElement(ya, null), params: { id: u2 ? decodeURIComponent(u2) : void 0, resource: d2 } }, y2 ? React$3.createElement(I2, { name: a, canCreate: C2, canEdit: R2, canDelete: t2, canShow: n2, options: p2 }) : o2 != null ? o2 : React$3.createElement(ya, null));
            case "edit":
              return React$3.createElement(Va, { resource: a, action: "edit", params: { id: u2 ? decodeURIComponent(u2) : void 0, resource: d2 }, fallback: o2 != null ? o2 : React$3.createElement(ya, null) }, g2 ? React$3.createElement(D2, { name: a, canCreate: C2, canEdit: R2, canDelete: t2, canShow: n2, options: p2 }) : o2 != null ? o2 : React$3.createElement(ya, null));
            case "show":
              return React$3.createElement(Va, { resource: a, action: "show", params: { id: u2 ? decodeURIComponent(u2) : void 0, resource: d2 }, fallback: o2 != null ? o2 : React$3.createElement(ya, null) }, c2 ? React$3.createElement(J2, { name: a, canCreate: C2, canEdit: R2, canDelete: t2, canShow: n2, options: p2 }) : o2 != null ? o2 : React$3.createElement(ya, null));
            default:
              return React$3.createElement(React$3.Fragment, null, o2 != null ? o2 : React$3.createElement(ya, null));
          }
        })();
      }
      return React$3.createElement(React$3.Fragment, null, o2 != null ? o2 : React$3.createElement(ya, null));
    }, v = ({ initialRoute: r2 }) => {
      let { resources: o2 } = B$1(), { catchAll: i2, DashboardPage: P2, LoginPage: l2 } = Se(), { routes: u2 } = w$3(), { isFetching: d2, isError: f2 } = bt({ type: "routeProvider" });
      if (d2)
        return React$3.createElement(Routes, null, React$3.createElement(Route, { path: "*", element: null }));
      let y2 = !f2, g2 = () => {
        let { pathname: n2, search: t2 } = location, p2 = `${n2}${t2}`;
        return React$3.createElement(Navigate, { to: `/login?to=${encodeURIComponent(p2)}` });
      }, c2 = [];
      o2.map((n2) => {
        let t2 = React$3.createElement(Route, { key: `${n2.route}`, path: `${n2.route}`, element: React$3.createElement(k, { route: n2.route }) }, React$3.createElement(Route, { path: ":action", element: React$3.createElement(k, { route: n2.route }) }, React$3.createElement(Route, { path: ":id", element: React$3.createElement(k, { route: n2.route }) })));
        c2.push(t2);
      });
      let a = () => {
        var n2;
        return React$3.createElement(Routes, null, [...u2 || []].filter((t2) => !t2.layout).map((t2, p2) => React$3.createElement(Route, { key: `custom-route-${p2}`, ...t2, element: t2.element })), React$3.createElement(Route, { path: "/", element: React$3.createElement(Ia, null, React$3.createElement(Outlet, null)) }, [...u2 || []].filter((t2) => t2.layout).map((t2, p2) => React$3.createElement(Route, { key: `custom-route-${p2}`, ...t2, element: t2.element })), React$3.createElement(Route, { index: true, element: P2 ? React$3.createElement(Va, { resource: "dashboard", action: "list", fallback: i2 != null ? i2 : React$3.createElement(ya, null) }, React$3.createElement(P2, null)) : React$3.createElement(Navigate, { to: r2 != null ? r2 : `/${(n2 = o2.find((t2) => t2.list)) == null ? void 0 : n2.route}` }) }), ...[...c2 || []], React$3.createElement(Route, { path: "*", element: React$3.createElement(k, { route: "" }) })));
      }, C2 = () => l2 ? React$3.createElement(l2, null) : React$3.createElement(Et, null);
      return y2 ? a() : (() => React$3.createElement(Routes, null, [...u2 || []].map((n2, t2) => React$3.createElement(Route, { key: `custom-route-${t2}`, ...n2 })), React$3.createElement(Route, { path: "/", element: C2() }), React$3.createElement(Route, { path: "/login", element: C2() }), React$3.createElement(Route, { path: "*", element: React$3.createElement(g2, null) })))();
    };
    function U({ children: r2, ...o2 }) {
      return React$3.createElement(BrowserRouter, { ...o2 }, React$3.createElement(v, { initialRoute: typeof this < "u" ? this.initialRoute : void 0 }), r2);
    }
    var $ = ({ message: r2, when: o2, setWarnWhen: i2 }) => {
      let P2 = reactExports.useContext(NavigationContext).navigator;
      return reactExports.useEffect(() => {
        if (!o2)
          return;
        let l2 = P2.block((u2) => {
          window.confirm(r2) ? (i2 == null || i2(false), l2(), u2.retry()) : P2.location.pathname = window.location.pathname;
        });
        return l2;
      }, [o2, location, r2]), null;
    };
    var W = { useHistory: () => {
      let r2 = useNavigate();
      return { push: r2, replace: (o2) => {
        r2(o2, { replace: true });
      }, goBack: () => {
        r2(-1);
      } };
    }, useLocation, useParams: () => {
      let r2 = useParams(), { pathname: o2 } = useLocation(), i2 = `/${Object.values(r2).join("/")}`;
      return or$1({ ...r2, resource: Object.keys(r2).length === 0 ? o2.substring(1) : decodeURIComponent(o2.substring(1)).replace(i2, "") });
    }, Prompt: $, Link, RouterComponent: U }, ke = W;
    const reset = "";
    const index = "";
    async function validateResponse(res) {
      if (res.ok) {
        return;
      }
      if (res.status === 0) {
        throw new Error("Server unavailable");
      }
      const body = await res.json();
      throw new Error((body == null ? void 0 : body.message) || res.statusText);
    }
    const authProvider = (axiosInstance2) => ({
      login: async (params) => {
        try {
          const res = await fetch(`${"https://nes2.adaptable.app/api/v1"}/auth/login`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(params),
            credentials: "include"
          });
          await validateResponse(res);
          const user = await res.json();
          localStorage.setItem("refine-auth", JSON.stringify(user));
          axiosInstance2.defaults.withCredentials = true;
          return Promise.resolve();
        } catch (err) {
          console.error(err);
          return Promise.reject(err);
        }
      },
      register: async (params) => {
        try {
          const res = await fetch(
            `${"https://nes2.adaptable.app/api/v1"}/profile/signup`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify(params),
              credentials: "include"
            }
          );
          await validateResponse(res);
          notification$1.success({
            message: "Sign Up",
            description: `Verification token sent to "${params.email}". Check your email to complete registration`
          });
          return Promise.resolve();
        } catch (err) {
          return Promise.reject(err);
        }
      },
      updatePassword: async (params) => {
        console.log(params);
        console.log(params.queryStrings);
        const url = `${"https://nes2.adaptable.app/api/v1"}/profile/reset_password`;
        try {
          const res = await fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              password: params.password,
              token: params.token
            }),
            credentials: "include"
          });
          await validateResponse(res);
          notification$1.success({
            message: "Reset Password",
            description: "New password set successfully"
          });
          return Promise.resolve("/login");
        } catch (err) {
          return Promise.reject(err);
        }
      },
      forgotPassword: async ({ email }) => {
        const url = `${"https://nes2.adaptable.app/api/v1"}/profile/send_password_reset_token`;
        try {
          const res = await fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ email }),
            credentials: "include"
          });
          await validateResponse(res);
          notification$1.success({
            message: "Reset Password",
            description: `Reset password link sent to "${email}"`
          });
          return Promise.resolve("/login");
        } catch (err) {
          return Promise.reject(err);
        }
      },
      logout: async () => {
        var _a;
        const url = `${"https://nes2.adaptable.app/api/v1"}/auth/logout`;
        try {
          const res = await fetch(url, {
            credentials: "include"
          });
          await validateResponse(res);
        } catch (err) {
          console.error(err);
        }
        const user = getUser();
        localStorage.removeItem("refine-auth");
        axiosInstance2.defaults.withCredentials = false;
        const email = (user == null ? void 0 : user.email) || "";
        (_a = window.google) == null ? void 0 : _a.accounts.id.revoke(email, () => {
          return Promise.resolve();
        });
        return Promise.resolve("/login");
      },
      checkError: () => Promise.resolve(),
      checkAuth: () => getMe(axiosInstance2),
      getPermissions: () => Promise.resolve(),
      getUserIdentity: () => getMe(axiosInstance2)
    });
    async function getMe(axiosInstance2) {
      const url = `${"https://nes2.adaptable.app/api/v1"}/auth/me`;
      try {
        const res = await fetch(url, {
          credentials: "include"
        });
        await validateResponse(res);
        const user = await res.json();
        const userData = localStorage.getItem("refine-auth");
        if (!userData) {
          localStorage.setItem("refine-auth", JSON.stringify(user));
          axiosInstance2.defaults.withCredentials = true;
        }
        return Promise.resolve({ ...user });
      } catch (err) {
        return Promise.reject(err);
      }
    }
    function getUser() {
      const userData = localStorage.getItem("refine-auth");
      if (!userData) {
        return void 0;
      }
      try {
        const user = JSON.parse(userData);
        return user;
      } catch {
      }
    }
    const { Text: Text$b } = Typography$1;
    const DashboardPage = () => {
      return /* @__PURE__ */ jsxs(Row$1, { gutter: [16, 16], children: [
        /* @__PURE__ */ jsx(Col$1, { md: 24, children: /* @__PURE__ */ jsx(Text$b, { children: "col 1" }) }),
        /* @__PURE__ */ jsx(Col$1, { xl: 17, lg: 16, md: 24, sm: 24, xs: 24, children: /* @__PURE__ */ jsx(Text$b, { children: "col 2" }) }),
        /* @__PURE__ */ jsx(Col$1, { xl: 7, lg: 8, md: 24, sm: 24, xs: 24, children: /* @__PURE__ */ jsx(Text$b, { children: "col 3" }) })
      ] });
    };
    const layoutStyles = {
      background: `radial-gradient(50% 50% at 50% 50%, #6813CB 0%, #2A2A42 100%)`,
      backgroundSize: "cover"
    };
    const containerStyles = {
      maxWidth: "408px",
      margin: "auto"
    };
    const titleStyles = {
      textAlign: "center",
      color: "#626262",
      marginBottom: 0,
      fontSize: "24px",
      letterSpacing: "-0.04em",
      overflowWrap: "break-word",
      hyphens: "manual",
      textOverflow: "unset",
      whiteSpace: "pre-wrap"
    };
    const GoogleButton = () => /* @__PURE__ */ jsx(
      Button$2,
      {
        type: "default",
        block: true,
        icon: /* @__PURE__ */ jsx(GoogleOutlined$1, {}),
        style: {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          width: "100%",
          marginBottom: "8px"
        },
        onClick: (e2) => {
          e2.preventDefault();
          window.location.assign(
            `${"https://nes2.adaptable.app/api/v1"}/auth/login/google`
          );
        },
        children: "Google"
      }
    );
    const { Title: Title$a } = Typography$1;
    const LoginPage = ({
      registerLink,
      forgotPasswordLink,
      contentProps,
      wrapperProps,
      renderContent,
      formProps
    }) => {
      const [form] = Form$1.useForm();
      const translate = M();
      const { mutate: login, isLoading } = $e();
      const { Link: Link2 } = w$3();
      const CardTitle = /* @__PURE__ */ jsx(Title$a, { level: 3, style: titleStyles, children: translate("pages.login.title", "Sign in to Your Account") });
      const CardContent = /* @__PURE__ */ jsxs(
        Card$1,
        {
          title: CardTitle,
          headStyle: { borderBottom: 0 },
          style: containerStyles,
          ...contentProps ?? {},
          children: [
            /* @__PURE__ */ jsx(GoogleButton, {}),
            /* @__PURE__ */ jsx(Divider$1, { children: translate("pages.login.divider", "or") }),
            /* @__PURE__ */ jsxs(
              Form$1,
              {
                layout: "vertical",
                form,
                onFinish: (values) => login(values),
                requiredMark: false,
                initialValues: {
                  remember: false
                },
                ...formProps,
                children: [
                  /* @__PURE__ */ jsx(
                    Form$1.Item,
                    {
                      name: "email",
                      label: translate("pages.login.fields.email", "Email"),
                      rules: [
                        { required: true },
                        {
                          type: "email",
                          message: translate(
                            "pages.login.errors.validEmail",
                            "Invalid email address"
                          )
                        }
                      ],
                      children: /* @__PURE__ */ jsx(
                        Input$1,
                        {
                          size: "large",
                          placeholder: translate("pages.login.fields.email", "Email")
                        }
                      )
                    }
                  ),
                  /* @__PURE__ */ jsx(
                    Form$1.Item,
                    {
                      name: "password",
                      label: translate("pages.login.fields.password", "Password"),
                      rules: [{ required: true }],
                      style: { marginBottom: "12px" },
                      children: /* @__PURE__ */ jsx(Input$1.Password, { placeholder: "●●●●●●●●", size: "large" })
                    }
                  ),
                  /* @__PURE__ */ jsxs(
                    "div",
                    {
                      style: {
                        display: "flex",
                        justifyContent: "space-between",
                        marginBottom: "12px"
                      },
                      children: [
                        registerLink ?? /* @__PURE__ */ jsx(Link2, { to: "/register", style: { fontSize: 12 }, children: translate("pages.login.buttons.noAccount", "Need an account?") }),
                        forgotPasswordLink ?? /* @__PURE__ */ jsx(
                          Link2,
                          {
                            style: {
                              fontSize: "12px",
                              marginLeft: "auto"
                            },
                            to: "/forgot-password",
                            children: translate(
                              "pages.login.buttons.forgotPassword",
                              "Forgot password?"
                            )
                          }
                        )
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsx(Form$1.Item, { children: /* @__PURE__ */ jsx(
                    Button$2,
                    {
                      type: "primary",
                      size: "large",
                      htmlType: "submit",
                      loading: isLoading,
                      block: true,
                      children: translate("pages.login.signin", "Sign in")
                    }
                  ) })
                ]
              }
            )
          ]
        }
      );
      return /* @__PURE__ */ jsx(AntdLayout, { style: layoutStyles, ...wrapperProps ?? {}, children: /* @__PURE__ */ jsxs(
        Row$1,
        {
          justify: "center",
          align: "middle",
          style: {
            height: "100vh"
          },
          children: [
            /* @__PURE__ */ jsx(Col$1, { xs: 24, xl: 18, children: renderContent ? renderContent(CardContent) : CardContent }),
            /* @__PURE__ */ jsxs(Col$1, { xs: 0, xl: 6, style: { position: "relative", padding: "1rem" }, children: [
              /* @__PURE__ */ jsx(
                "img",
                {
                  src: "/images/login-bg.png",
                  style: {
                    position: "absolute",
                    top: 0,
                    left: 0,
                    bottom: 0,
                    right: 0,
                    width: "100%",
                    height: "100%",
                    maxWidth: "none",
                    objectFit: "cover"
                  }
                }
              ),
              /* @__PURE__ */ jsxs(
                "blockquote",
                {
                  style: {
                    position: "relative",
                    zIndex: 20,
                    fontSize: "1.5rem",
                    lineHeight: 1.35,
                    fontWeight: 700
                  },
                  children: [
                    "Apps scary no more",
                    /* @__PURE__ */ jsx("br", {}),
                    "Orchestration too easy",
                    /* @__PURE__ */ jsx("br", {}),
                    "So en-“fly”-tening",
                    /* @__PURE__ */ jsxs("cite", { style: { fontSize: "1.25rem", marginTop: "1.5rem" }, children: [
                      /* @__PURE__ */ jsx("span", { children: "—" }),
                      "A haiku by eric-karambit-ai"
                    ] })
                  ]
                }
              )
            ] })
          ]
        }
      ) });
    };
    const { Title: Title$9 } = Typography$1;
    const RegisterPage = ({
      loginLink,
      wrapperProps,
      contentProps,
      renderContent,
      forgotPasswordLink,
      formProps
    }) => {
      const [form] = Form$1.useForm();
      const translate = M();
      const { Link: Link2 } = w$3();
      const { mutate: register, isLoading } = xt();
      const CardTitle = /* @__PURE__ */ jsx(Title$9, { level: 3, style: titleStyles, children: translate("pages.register.title", "Sign up for your account") });
      const CardContent = /* @__PURE__ */ jsxs(
        Card$1,
        {
          title: CardTitle,
          headStyle: { borderBottom: 0 },
          style: containerStyles,
          ...contentProps ?? {},
          children: [
            /* @__PURE__ */ jsx(GoogleButton, {}),
            /* @__PURE__ */ jsx(Divider$1, { children: translate("pages.register.divider", "or") }),
            /* @__PURE__ */ jsxs(
              Form$1,
              {
                layout: "vertical",
                form,
                onFinish: (values) => register(values),
                requiredMark: false,
                initialValues: {
                  email: "test@a.aa",
                  password: "Abc123!!"
                },
                ...formProps,
                children: [
                  /* @__PURE__ */ jsx(
                    Form$1.Item,
                    {
                      name: "email",
                      label: translate("pages.register.email", "Email"),
                      rules: [
                        { required: true },
                        {
                          type: "email",
                          message: translate(
                            "pages.register.errors.validEmail",
                            "Invalid email address"
                          )
                        }
                      ],
                      children: /* @__PURE__ */ jsx(
                        Input$1,
                        {
                          size: "large",
                          placeholder: translate("pages.register.fields.email", "Email")
                        }
                      )
                    }
                  ),
                  /* @__PURE__ */ jsx(
                    Form$1.Item,
                    {
                      name: "password",
                      label: translate("pages.register.fields.password", "Password"),
                      rules: [{ required: true }],
                      style: { marginBottom: "12px" },
                      children: /* @__PURE__ */ jsx(Input$1.Password, { placeholder: "●●●●●●●●", size: "large" })
                    }
                  ),
                  /* @__PURE__ */ jsxs(
                    "div",
                    {
                      style: {
                        display: "flex",
                        justifyContent: "space-between",
                        marginBottom: "12px"
                      },
                      children: [
                        loginLink ?? /* @__PURE__ */ jsx(Link2, { to: "/login", style: { fontSize: 12 }, children: translate("pages.login.buttons.haveAccount", "Have an account?") }),
                        forgotPasswordLink ?? /* @__PURE__ */ jsx(
                          Link2,
                          {
                            style: {
                              fontSize: "12px",
                              marginLeft: "auto"
                            },
                            to: "/forgot-password",
                            children: translate(
                              "pages.login.buttons.forgotPassword",
                              "Forgot password?"
                            )
                          }
                        )
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsx(Form$1.Item, { children: /* @__PURE__ */ jsx(
                    Button$2,
                    {
                      type: "primary",
                      size: "large",
                      htmlType: "submit",
                      loading: isLoading,
                      block: true,
                      children: translate("pages.register.buttons.submit", "Sign up")
                    }
                  ) })
                ]
              }
            )
          ]
        }
      );
      return /* @__PURE__ */ jsx(AntdLayout, { style: layoutStyles, ...wrapperProps ?? {}, children: /* @__PURE__ */ jsx(
        Row$1,
        {
          justify: "center",
          align: "middle",
          style: {
            height: "100vh"
          },
          children: /* @__PURE__ */ jsx(Col$1, { xs: 22, children: renderContent ? renderContent(CardContent) : CardContent })
        }
      ) });
    };
    const { Text: Text$a, Title: Title$8 } = Typography$1;
    const ForgotPasswordPage = ({
      loginLink,
      wrapperProps,
      contentProps,
      renderContent,
      formProps
    }) => {
      const [form] = Form$1.useForm();
      const translate = M();
      const { Link: Link2 } = w$3();
      const { mutate: forgotPassword, isLoading } = Rt();
      const CardTitle = /* @__PURE__ */ jsx(Title$8, { level: 3, style: titleStyles, children: translate("pages.forgotPassword.title", "Forgot your password?") });
      const CardContent = /* @__PURE__ */ jsx(
        Card$1,
        {
          title: CardTitle,
          headStyle: { borderBottom: 0 },
          style: containerStyles,
          ...contentProps ?? {},
          children: /* @__PURE__ */ jsxs(
            Form$1,
            {
              layout: "vertical",
              form,
              onFinish: (values) => forgotPassword(values),
              requiredMark: false,
              ...formProps,
              children: [
                /* @__PURE__ */ jsx(Space$1, { style: { marginBottom: "1.5rem" }, children: /* @__PURE__ */ jsx(Text$a, { children: "Enter the email associated with your account and we’ll send you password reset instructions." }) }),
                /* @__PURE__ */ jsx(
                  Form$1.Item,
                  {
                    name: "email",
                    label: translate("pages.forgotPassword.fields.email", "Your Email"),
                    rules: [
                      { required: true },
                      {
                        type: "email",
                        message: translate(
                          "pages.forgotPassword.errors.validEmail",
                          "Invalid email address"
                        )
                      }
                    ],
                    children: /* @__PURE__ */ jsx(
                      Input$1,
                      {
                        type: "email",
                        size: "large",
                        placeholder: translate(
                          "pages.forgotPassword.fields.email",
                          "Email"
                        )
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsx(Form$1.Item, { children: /* @__PURE__ */ jsx(
                  Button$2,
                  {
                    type: "primary",
                    size: "large",
                    htmlType: "submit",
                    loading: isLoading,
                    block: true,
                    children: translate(
                      "pages.forgotPassword.buttons.submit",
                      "Send reset instructions"
                    )
                  }
                ) }),
                /* @__PURE__ */ jsx(
                  "div",
                  {
                    style: {
                      display: "flex",
                      justifyContent: "space-between",
                      marginBottom: "12px"
                    },
                    children: loginLink ?? /* @__PURE__ */ jsx(
                      Link2,
                      {
                        style: {
                          fontSize: 12,
                          marginLeft: "auto"
                        },
                        to: "/login",
                        children: "Return to Sign In"
                      }
                    )
                  }
                )
              ]
            }
          )
        }
      );
      return /* @__PURE__ */ jsx(AntdLayout, { style: layoutStyles, ...wrapperProps ?? {}, children: /* @__PURE__ */ jsx(
        Row$1,
        {
          justify: "center",
          align: "middle",
          style: {
            height: "100vh"
          },
          children: /* @__PURE__ */ jsx(Col$1, { xs: 22, children: renderContent ? renderContent(CardContent) : CardContent })
        }
      ) });
    };
    const authWrapperProps = {
      style: {}
    };
    const RenderAuthContent = (content2) => {
      const { Link: Link2 } = w$3();
      return /* @__PURE__ */ jsxs(
        "div",
        {
          style: {
            maxWidth: 408,
            margin: "auto"
          },
          children: [
            /* @__PURE__ */ jsx(Link2, { to: "/", children: /* @__PURE__ */ jsx(
              "img",
              {
                style: { marginBottom: 26 },
                src: "/images/fine-foods-login.svg",
                alt: "Logo",
                width: "100%"
              }
            ) }),
            content2
          ]
        }
      );
    };
    const AuthPage = ({ type: type2, formProps }) => {
      switch (type2) {
        case "login":
          return /* @__PURE__ */ jsx(
            LoginPage,
            {
              wrapperProps: authWrapperProps,
              renderContent: RenderAuthContent,
              formProps
            }
          );
        case "register":
          return /* @__PURE__ */ jsx(
            RegisterPage,
            {
              wrapperProps: authWrapperProps,
              renderContent: RenderAuthContent,
              formProps
            }
          );
        case "forgotPassword":
          return /* @__PURE__ */ jsx(
            ForgotPasswordPage,
            {
              wrapperProps: authWrapperProps,
              renderContent: RenderAuthContent,
              formProps
            }
          );
        default:
          return /* @__PURE__ */ jsx(
            wi,
            {
              type: type2,
              wrapperProps: authWrapperProps,
              renderContent: RenderAuthContent,
              formProps
            }
          );
      }
    };
    const BikeWhiteSVG = (props) => /* @__PURE__ */ jsx(
      "svg",
      {
        width: "32",
        height: "25",
        viewBox: "0 0 32 25",
        fill: "currentColor",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        children: /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M4.19394 8.8654H4.98253C4.64191 9.40654 4.45703 10.0371 4.45703 10.6867V11.3079C2.8182 12.1282 1.9371 13.6087 1.46502 15.0161H0.798792C0.586939 15.0161 0.383763 15.1003 0.233961 15.2501C0.0841582 15.3999 0 15.6031 0 15.8149C0 16.0268 0.0841582 16.2299 0.233961 16.3797C0.383763 16.5295 0.586939 16.6137 0.798792 16.6137H1.07407C0.947456 17.3869 0.927083 18.0168 0.927083 18.323V19.5851C0.927083 19.797 1.01124 20.0001 1.16104 20.1499C1.31085 20.2997 1.51402 20.3839 1.72588 20.3839H2.6671C2.83165 21.3144 3.27834 22.1794 3.95615 22.856C4.82477 23.7232 6.00198 24.2102 7.22935 24.2102C7.83671 24.2102 8.43813 24.0905 8.99926 23.8581C9.56039 23.6257 10.0702 23.285 10.4997 22.8555C10.9292 22.4261 11.2699 21.9162 11.5023 21.3551C11.632 21.0419 11.7266 20.7162 11.7849 20.3839H21.2324C21.5044 20.373 21.7737 20.3429 22.0385 20.2944C22.1897 21.2589 22.643 22.1577 23.3425 22.856C24.2111 23.7232 25.3883 24.2102 26.6157 24.2102L26.6237 24.2421C27.5514 24.2462 28.459 23.9711 29.2283 23.4526C29.9977 22.9341 30.5934 22.1963 30.938 21.3349C31.2825 20.4734 31.3601 19.5283 31.1605 18.6223C31.0255 18.0095 30.768 17.4338 30.4068 16.9282L31.8164 15.2317C31.9492 15.0716 32.0143 14.866 31.9979 14.6587C31.9815 14.4514 31.8848 14.2586 31.7285 14.1214C31.3876 13.8131 31.0124 13.5451 30.6102 13.3226C30.5343 13.2792 30.452 13.2486 30.3665 13.2317C29.3034 12.6863 28.1063 12.4624 26.9217 12.5842C26.7907 11.1651 26.3852 9.79023 25.7334 8.53443C26.0245 8.58492 26.319 8.61815 26.6154 8.63369C26.8273 8.63369 27.0304 8.54953 27.1802 8.39973C27.33 8.24993 27.4142 8.04675 27.4142 7.8349V3.97673C27.4142 3.76488 27.33 3.5617 27.1802 3.4119C27.0304 3.2621 26.8273 3.17794 26.6154 3.17794C25.6986 3.22599 24.8004 3.44327 23.9656 3.81702L22.4302 1.68419C22.3559 1.58242 22.2585 1.4997 22.146 1.44278C22.0336 1.38586 21.9093 1.35637 21.7832 1.35669H20.0019C19.7901 1.35669 19.5869 1.44085 19.4371 1.59065C19.2873 1.74045 19.2031 1.94363 19.2031 2.15548C19.2031 2.36734 19.2873 2.57051 19.4371 2.72032C19.5869 2.87012 19.7901 2.95428 20.0019 2.95428H21.3758L23.0208 5.24708V6.20557C22.9704 6.20659 22.9204 6.21239 22.8717 6.22271C22.8358 6.22781 22.8001 6.23538 22.7649 6.24543C22.006 6.51702 20.2487 7.47557 20.2487 11.0382C20.2487 12.8387 20.3538 14.4244 20.405 15.1281C19.9997 15.4141 19.5299 15.5982 19.0357 15.663H17.3423C17.048 15.548 16.7821 15.3707 16.5628 15.1432C16.3436 14.9157 16.1762 14.6434 16.0722 14.345C15.9647 13.5177 16.1671 12.6805 16.6393 11.9943C16.7571 11.8518 16.8223 11.672 16.8223 11.4855V10.6867C16.8223 9.77996 16.4621 8.91037 15.821 8.26922C15.1798 7.62806 14.3102 7.26786 13.4035 7.26786H11.431V7.26782V1.62835C11.431 1.20464 11.2627 0.798287 10.9631 0.498682C10.6635 0.199077 10.2571 0.0307617 9.83341 0.0307617H7.01364H4.19394C3.77023 0.0307617 3.36388 0.199077 3.06428 0.498682C2.76467 0.798287 2.59635 1.20464 2.59635 1.62835V7.26782C2.59635 7.69152 2.76467 8.09787 3.06428 8.39748C3.36388 8.69708 3.77023 8.8654 4.19394 8.8654ZM7.81243 1.62835H9.83341V7.26782H4.19394V1.62835H6.21484V2.76263C6.21484 2.97448 6.299 3.17766 6.4488 3.32746C6.59861 3.47726 6.80178 3.56142 7.01364 3.56142C7.22549 3.56142 7.42866 3.47726 7.57847 3.32746C7.72827 3.17766 7.81243 2.97448 7.81243 2.76263V1.62835ZM22.6837 18.4289C22.54 18.446 22.4027 18.5019 22.2871 18.5919C21.9491 18.7112 21.5949 18.7879 21.2324 18.8183H11.2791C11.2071 18.7973 11.1319 18.7864 11.0556 18.7864C10.9792 18.7864 10.904 18.7973 10.8321 18.8183H3.61864C3.54666 18.7973 3.47147 18.7864 3.39515 18.7864C3.31883 18.7864 3.24363 18.7973 3.17165 18.8183H2.52467V18.363C2.52702 17.9797 2.55568 17.3388 2.69298 16.6137H11.0553C11.2671 16.6137 11.4703 16.5295 11.6201 16.3797C11.7699 16.2299 11.8541 16.0268 11.8541 15.8149C11.8541 15.6031 11.7699 15.3999 11.6201 15.2501C11.4703 15.1003 11.2671 15.0161 11.0553 15.0161H3.17374C3.73433 13.7335 4.77218 12.5589 6.68637 12.3321H14.7222C14.405 13.1125 14.338 13.9722 14.5305 14.7924C14.7047 15.3426 15.0037 15.8452 15.4041 16.2609C15.8046 16.6766 16.2956 16.9941 16.839 17.1887C16.9411 17.2379 17.0532 17.2625 17.1665 17.2606H19.0357C19.5941 17.2288 20.1402 17.0842 20.6413 16.8358C21.1424 16.5873 21.588 16.24 21.9513 15.8148C22.007 15.7235 22.0437 15.6219 22.0594 15.5161C22.0751 15.4102 22.0693 15.3024 22.0425 15.1988C22.0322 15.159 22.0189 15.1202 22.0027 15.0826C21.957 14.4718 21.8463 12.8321 21.8463 11.0062C21.8463 9.30562 22.3165 8.14862 23.1511 7.80299H23.3885C24.5082 9.29574 25.1817 11.0707 25.3378 12.9224C24.7047 13.1426 24.1309 13.5144 23.6687 14.0096C23.545 14.1795 23.4932 14.3914 23.5246 14.5992C23.556 14.8071 23.6681 14.9942 23.8365 15.1199C23.9709 15.2252 24.1371 15.2816 24.3078 15.2797C24.4311 15.2838 24.5537 15.2592 24.666 15.2079C24.7783 15.1566 24.8771 15.0801 24.9548 14.9842C25.3317 14.6423 25.8015 14.4199 26.3048 14.3451C26.3828 14.3315 26.4583 14.3064 26.5289 14.271L26.7348 14.2252C27.7708 14.0331 28.8414 14.2083 29.7622 14.7205C29.8129 14.7468 29.866 14.7678 29.9205 14.7834L30.0191 14.8403L28.9966 16.0624C28.0926 15.9007 27.1634 15.9507 26.2819 16.2085C25.4005 16.4663 24.5908 16.9248 23.9163 17.5482C23.5589 17.9165 23.1406 18.2135 22.6837 18.4289ZM23.588 19.7746C23.6687 20.4805 23.995 21.1381 24.5131 21.6302C25.0772 22.1661 25.8256 22.4649 26.6037 22.4649C27.3818 22.4649 28.1302 22.1661 28.6943 21.6302C29.2584 21.0943 29.5952 20.3622 29.6351 19.5852C29.6371 19.1778 29.5559 18.7743 29.3966 18.3993C29.2786 18.1217 29.1196 17.864 28.9255 17.6348C27.2762 17.4289 26.0858 17.747 25.0985 18.6745C24.6545 19.125 24.1433 19.4951 23.588 19.7746ZM4.34388 20.3839H10.1068C9.95104 20.8542 9.68113 21.2833 9.31595 21.6302C8.75183 22.1661 8.00345 22.4649 7.22535 22.4649C6.44726 22.4649 5.69888 22.1661 5.13475 21.6302C4.76958 21.2833 4.49967 20.8542 4.34388 20.3839ZM6.55857 10.7105C6.38532 10.7295 6.21739 10.754 6.05462 10.7837V10.6867C6.0546 10.2064 6.24428 9.74558 6.58239 9.40449C6.92049 9.06339 7.37963 8.86966 7.85989 8.86545H13.4035C13.6427 8.86545 13.8795 8.91255 14.1005 9.00408C14.3214 9.09561 14.5222 9.22976 14.6913 9.39888C14.8604 9.568 14.9946 9.76877 15.0861 9.98974C15.1776 10.2107 15.2247 10.4475 15.2247 10.6867V10.7105H6.55857ZM24.6344 6.53286C25.0159 6.70273 25.4115 6.83904 25.8166 6.94024V4.87137C25.4103 4.96873 25.0144 5.10515 24.6344 5.27875V6.53286Z",
            fill: "currentColor"
          }
        )
      }
    );
    const BikeWhiteIcon = (props) => /* @__PURE__ */ jsx(Icon$3, { component: BikeWhiteSVG, ...props });
    const Title$7 = ({ collapsed }) => {
      return /* @__PURE__ */ jsx(
        "div",
        {
          style: {
            height: "72px",
            display: "flex",
            justifyContent: "center",
            alignItems: "center"
          },
          children: collapsed ? /* @__PURE__ */ jsx(BikeWhiteIcon, { style: { color: "white", fontSize: "32px" } }) : /* @__PURE__ */ jsx("img", { src: "/images/fine-foods.svg", alt: "Finefood" })
        }
      );
    };
    const IconMoonStars = () => /* @__PURE__ */ jsxs(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: 24,
        height: 24,
        viewBox: "0 0 24 24",
        strokeWidth: "2",
        stroke: "currentColor",
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
          /* @__PURE__ */ jsx("path", { d: "M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" }),
          /* @__PURE__ */ jsx("path", { d: "M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }),
          /* @__PURE__ */ jsx("path", { d: "M19 11h2m-1 -1v2" })
        ]
      }
    );
    const IconSun = () => /* @__PURE__ */ jsxs(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: 24,
        height: 24,
        viewBox: "0 0 24 24",
        strokeWidth: "2",
        stroke: "currentColor",
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
          /* @__PURE__ */ jsx("path", { d: "M12 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0" }),
          /* @__PURE__ */ jsx("path", { d: "M3 12h1m8 -9v1m8 8h1m-9 8v1m-6.4 -15.4l.7 .7m12.1 -.7l-.7 .7m0 11.4l.7 .7m-12.1 -.7l-.7 .7" })
        ]
      }
    );
    const ThemeSwitch = ({ theme: theme2, setTheme }) => {
      const isLight = theme2 === "light";
      return /* @__PURE__ */ jsx(
        Button$2,
        {
          style: {
            margin: "auto 1rem"
          },
          onClick: () => {
            const newTheme = isLight ? "dark" : "light";
            setTheme(newTheme);
            localStorage.setItem("theme", newTheme);
          },
          icon: isLight ? /* @__PURE__ */ jsx(IconMoonStars, {}) : /* @__PURE__ */ jsx(IconSun, {})
        }
      );
    };
    const { Header: AntdHeader } = AntdLayout;
    const { Text: Text$9 } = Typography$1;
    const { useBreakpoint: useBreakpoint$1 } = Grid;
    const Header = (props) => {
      const screens = useBreakpoint$1();
      const { mutate: logout } = Ct();
      const translate = M();
      const { data: user } = gt$1() || {};
      const { email, firstName, lastName, avatar } = user || {};
      let fullName;
      if (lastName || firstName) {
        fullName = `${firstName || ""} ${lastName || ""}`;
      } else {
        fullName = (email == null ? void 0 : email.split("@", 1)[0]) || "";
      }
      const items = [
        {
          label: /* @__PURE__ */ jsx("a", { href: "https://www.antgroup.com", children: "1st menu item" }),
          key: "0"
        },
        {
          key: "1",
          label: /* @__PURE__ */ jsx("a", { href: "https://www.aliyun.com", children: "Change password" })
        },
        {
          type: "divider"
        },
        {
          key: "3",
          label: translate("buttons.logout", "Logout"),
          icon: /* @__PURE__ */ jsx(LogoutOutlined$2, {}),
          onClick: () => logout()
        }
      ];
      return /* @__PURE__ */ jsx(
        AntdHeader,
        {
          style: {
            padding: "0 24px",
            background: props.theme === "light" ? "white" : "darkgray"
          },
          children: /* @__PURE__ */ jsxs(
            Row$1,
            {
              align: "middle",
              style: {
                justifyContent: screens.sm ? "space-between" : "end"
              },
              children: [
                /* @__PURE__ */ jsx(Col$1, { xs: 0, sm: 12 }),
                /* @__PURE__ */ jsx(Col$1, { children: /* @__PURE__ */ jsxs(
                  Space$1,
                  {
                    size: "middle",
                    align: "center",
                    style: {
                      verticalAlign: "middle"
                    },
                    children: [
                      /* @__PURE__ */ jsx(
                        Dropdown$1,
                        {
                          menu: { items },
                          trigger: ["click"],
                          align: { offset: [0, 25] },
                          children: /* @__PURE__ */ jsx("a", { onClick: (e2) => e2.preventDefault(), children: /* @__PURE__ */ jsxs(Space$1, { size: "middle", align: "center", children: [
                            /* @__PURE__ */ jsx(
                              Text$9,
                              {
                                ellipsis: true,
                                strong: true,
                                style: {
                                  display: "flex"
                                },
                                children: fullName
                              }
                            ),
                            /* @__PURE__ */ jsx(Avatar$1, { size: "large", src: avatar == null ? void 0 : avatar.url, alt: fullName }),
                            /* @__PURE__ */ jsx(DownOutlined$1, {})
                          ] }) })
                        }
                      ),
                      /* @__PURE__ */ jsx(
                        Space$1,
                        {
                          size: "middle",
                          align: "center",
                          style: { verticalAlign: "center" },
                          children: /* @__PURE__ */ jsx(ThemeSwitch, { ...props })
                        }
                      )
                    ]
                  }
                ) })
              ]
            }
          )
        }
      );
    };
    const antLayoutSider = {
      position: "relative"
    };
    const antLayoutSiderMobile = {
      position: "fixed",
      height: "100vh",
      zIndex: 999
    };
    const { SubMenu } = Menu$1;
    const CustomSider = ({ render: render2 }) => {
      const [collapsed, setCollapsed] = reactExports.useState(false);
      const { Link: Link2 } = w$3();
      const Title2 = Ns();
      const translate = M();
      const { menuItems, selectedKey, defaultOpenKeys } = da();
      const breakpoint = Grid.useBreakpoint();
      const { hasDashboard } = Se();
      const isMobile2 = typeof breakpoint.lg === "undefined" ? false : !breakpoint.lg;
      const renderTreeView = (tree, selectedKey2) => {
        return tree.map((item) => {
          const { icon, label, route, name, children, parentName } = item;
          if (children.length > 0) {
            return /* @__PURE__ */ jsx(
              Va,
              {
                resource: name.toLowerCase(),
                action: "list",
                params: {
                  resource: item
                },
                children: /* @__PURE__ */ jsx(
                  SubMenu,
                  {
                    icon: icon ?? /* @__PURE__ */ jsx(UnorderedListOutlined$2, {}),
                    title: label,
                    children: renderTreeView(children, selectedKey2)
                  },
                  route
                )
              },
              route
            );
          }
          const isSelected = route === selectedKey2;
          const isRoute = !(parentName !== void 0 && children.length === 0);
          return /* @__PURE__ */ jsx(
            Va,
            {
              resource: name.toLowerCase(),
              action: "list",
              params: { resource: item },
              children: /* @__PURE__ */ jsxs(
                Menu$1.Item,
                {
                  style: {
                    fontWeight: isSelected ? "bold" : "normal"
                  },
                  icon: icon ?? (isRoute && /* @__PURE__ */ jsx(UnorderedListOutlined$2, {})),
                  children: [
                    /* @__PURE__ */ jsx(Link2, { to: route, children: label }),
                    !collapsed && isSelected && /* @__PURE__ */ jsx("div", { className: "ant-menu-tree-arrow" })
                  ]
                },
                route
              )
            },
            route
          );
        });
      };
      const dashboard = hasDashboard ? /* @__PURE__ */ jsxs(
        Menu$1.Item,
        {
          style: {
            fontWeight: selectedKey === "/" ? "bold" : "normal"
          },
          icon: /* @__PURE__ */ jsx(DashboardOutlined$2, {}),
          children: [
            /* @__PURE__ */ jsx(Link2, { to: "/", children: translate("dashboard.title", "Dashboard") }),
            !collapsed && selectedKey === "/" && /* @__PURE__ */ jsx("div", { className: "ant-menu-tree-arrow" })
          ]
        },
        "dashboard"
      ) : null;
      const items = renderTreeView(menuItems, selectedKey);
      const renderSider = () => {
        if (render2) {
          return render2({
            dashboard,
            items,
            logout: null,
            collapsed
          });
        }
        return /* @__PURE__ */ jsxs(Fragment, { children: [
          dashboard,
          items
        ] });
      };
      const renderMenu = () => {
        return /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx(
          Menu$1,
          {
            theme: "dark",
            selectedKeys: [selectedKey],
            defaultOpenKeys,
            mode: "inline",
            onClick: () => {
              if (!breakpoint.lg) {
                setCollapsed(true);
              }
            },
            children: renderSider()
          }
        ) });
      };
      return /* @__PURE__ */ jsxs(
        AntdLayout.Sider,
        {
          collapsible: true,
          collapsedWidth: isMobile2 ? 0 : 80,
          collapsed,
          breakpoint: "lg",
          onCollapse: (collapsed2) => setCollapsed(collapsed2),
          style: isMobile2 ? antLayoutSiderMobile : antLayoutSider,
          children: [
            Title2 && /* @__PURE__ */ jsx(Title2, { collapsed }),
            renderMenu()
          ]
        }
      );
    };
    const DndContext = reactExports.createContext({
      dragDropManager: void 0
    });
    function formatProdErrorMessage(code2) {
      return "Minified Redux error #" + code2 + "; visit https://redux.js.org/Errors?code=" + code2 + " for the full message or use the non-minified dev environment for full errors. ";
    }
    var $$observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
    var randomString = function randomString2() {
      return Math.random().toString(36).substring(7).split("").join(".");
    };
    var ActionTypes = {
      INIT: "@@redux/INIT" + randomString(),
      REPLACE: "@@redux/REPLACE" + randomString(),
      PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
        return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
      }
    };
    function isPlainObject(obj) {
      if (typeof obj !== "object" || obj === null)
        return false;
      var proto2 = obj;
      while (Object.getPrototypeOf(proto2) !== null) {
        proto2 = Object.getPrototypeOf(proto2);
      }
      return Object.getPrototypeOf(obj) === proto2;
    }
    function createStore(reducer, preloadedState, enhancer) {
      var _ref2;
      if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
        throw new Error(formatProdErrorMessage(0));
      }
      if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
        enhancer = preloadedState;
        preloadedState = void 0;
      }
      if (typeof enhancer !== "undefined") {
        if (typeof enhancer !== "function") {
          throw new Error(formatProdErrorMessage(1));
        }
        return enhancer(createStore)(reducer, preloadedState);
      }
      if (typeof reducer !== "function") {
        throw new Error(formatProdErrorMessage(2));
      }
      var currentReducer = reducer;
      var currentState = preloadedState;
      var currentListeners = [];
      var nextListeners = currentListeners;
      var isDispatching = false;
      function ensureCanMutateNextListeners() {
        if (nextListeners === currentListeners) {
          nextListeners = currentListeners.slice();
        }
      }
      function getState() {
        if (isDispatching) {
          throw new Error(formatProdErrorMessage(3));
        }
        return currentState;
      }
      function subscribe(listener) {
        if (typeof listener !== "function") {
          throw new Error(formatProdErrorMessage(4));
        }
        if (isDispatching) {
          throw new Error(formatProdErrorMessage(5));
        }
        var isSubscribed = true;
        ensureCanMutateNextListeners();
        nextListeners.push(listener);
        return function unsubscribe() {
          if (!isSubscribed) {
            return;
          }
          if (isDispatching) {
            throw new Error(formatProdErrorMessage(6));
          }
          isSubscribed = false;
          ensureCanMutateNextListeners();
          var index2 = nextListeners.indexOf(listener);
          nextListeners.splice(index2, 1);
          currentListeners = null;
        };
      }
      function dispatch(action) {
        if (!isPlainObject(action)) {
          throw new Error(formatProdErrorMessage(7));
        }
        if (typeof action.type === "undefined") {
          throw new Error(formatProdErrorMessage(8));
        }
        if (isDispatching) {
          throw new Error(formatProdErrorMessage(9));
        }
        try {
          isDispatching = true;
          currentState = currentReducer(currentState, action);
        } finally {
          isDispatching = false;
        }
        var listeners = currentListeners = nextListeners;
        for (var i2 = 0; i2 < listeners.length; i2++) {
          var listener = listeners[i2];
          listener();
        }
        return action;
      }
      function replaceReducer(nextReducer) {
        if (typeof nextReducer !== "function") {
          throw new Error(formatProdErrorMessage(10));
        }
        currentReducer = nextReducer;
        dispatch({
          type: ActionTypes.REPLACE
        });
      }
      function observable() {
        var _ref;
        var outerSubscribe = subscribe;
        return _ref = {
          /**
           * The minimal observable subscription method.
           * @param {Object} observer Any object that can be used as an observer.
           * The observer object should have a `next` method.
           * @returns {subscription} An object with an `unsubscribe` method that can
           * be used to unsubscribe the observable from the store, and prevent further
           * emission of values from the observable.
           */
          subscribe: function subscribe2(observer) {
            if (typeof observer !== "object" || observer === null) {
              throw new Error(formatProdErrorMessage(11));
            }
            function observeState() {
              if (observer.next) {
                observer.next(getState());
              }
            }
            observeState();
            var unsubscribe = outerSubscribe(observeState);
            return {
              unsubscribe
            };
          }
        }, _ref[$$observable] = function() {
          return this;
        }, _ref;
      }
      dispatch({
        type: ActionTypes.INIT
      });
      return _ref2 = {
        dispatch,
        subscribe,
        getState,
        replaceReducer
      }, _ref2[$$observable] = observable, _ref2;
    }
    function invariant$1(condition, format2, ...args) {
      if (isProduction()) {
        if (format2 === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        let error;
        if (format2 === void 0) {
          error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        } else {
          let argIndex = 0;
          error = new Error(format2.replace(/%s/g, function() {
            return args[argIndex++];
          }));
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    }
    function isProduction() {
      return typeof process !== "undefined" && process.env["NODE_ENV"] === "production";
    }
    function get(obj, path2, defaultValue) {
      return path2.split(".").reduce(
        (a, c2) => a && a[c2] ? a[c2] : defaultValue || null,
        obj
      );
    }
    function without$1(items, item) {
      return items.filter(
        (i2) => i2 !== item
      );
    }
    function isObject(input) {
      return typeof input === "object";
    }
    function xor(itemsA, itemsB) {
      const map = /* @__PURE__ */ new Map();
      const insertItem = (item) => {
        map.set(item, map.has(item) ? map.get(item) + 1 : 1);
      };
      itemsA.forEach(insertItem);
      itemsB.forEach(insertItem);
      const result = [];
      map.forEach((count, key) => {
        if (count === 1) {
          result.push(key);
        }
      });
      return result;
    }
    function intersection(itemsA, itemsB) {
      return itemsA.filter(
        (t2) => itemsB.indexOf(t2) > -1
      );
    }
    const INIT_COORDS = "dnd-core/INIT_COORDS";
    const BEGIN_DRAG = "dnd-core/BEGIN_DRAG";
    const PUBLISH_DRAG_SOURCE = "dnd-core/PUBLISH_DRAG_SOURCE";
    const HOVER = "dnd-core/HOVER";
    const DROP = "dnd-core/DROP";
    const END_DRAG = "dnd-core/END_DRAG";
    function setClientOffset(clientOffset, sourceClientOffset) {
      return {
        type: INIT_COORDS,
        payload: {
          sourceClientOffset: sourceClientOffset || null,
          clientOffset: clientOffset || null
        }
      };
    }
    const ResetCoordinatesAction = {
      type: INIT_COORDS,
      payload: {
        clientOffset: null,
        sourceClientOffset: null
      }
    };
    function createBeginDrag(manager) {
      return function beginDrag(sourceIds = [], options = {
        publishSource: true
      }) {
        const { publishSource = true, clientOffset, getSourceClientOffset: getSourceClientOffset2 } = options;
        const monitor = manager.getMonitor();
        const registry = manager.getRegistry();
        manager.dispatch(setClientOffset(clientOffset));
        verifyInvariants$1(sourceIds, monitor, registry);
        const sourceId = getDraggableSource(sourceIds, monitor);
        if (sourceId == null) {
          manager.dispatch(ResetCoordinatesAction);
          return;
        }
        let sourceClientOffset = null;
        if (clientOffset) {
          if (!getSourceClientOffset2) {
            throw new Error("getSourceClientOffset must be defined");
          }
          verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2);
          sourceClientOffset = getSourceClientOffset2(sourceId);
        }
        manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));
        const source = registry.getSource(sourceId);
        const item = source.beginDrag(monitor, sourceId);
        if (item == null) {
          return void 0;
        }
        verifyItemIsObject(item);
        registry.pinSource(sourceId);
        const itemType = registry.getSourceType(sourceId);
        return {
          type: BEGIN_DRAG,
          payload: {
            itemType,
            item,
            sourceId,
            clientOffset: clientOffset || null,
            sourceClientOffset: sourceClientOffset || null,
            isSourcePublic: !!publishSource
          }
        };
      };
    }
    function verifyInvariants$1(sourceIds, monitor, registry) {
      invariant$1(!monitor.isDragging(), "Cannot call beginDrag while dragging.");
      sourceIds.forEach(function(sourceId) {
        invariant$1(registry.getSource(sourceId), "Expected sourceIds to be registered.");
      });
    }
    function verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2) {
      invariant$1(typeof getSourceClientOffset2 === "function", "When clientOffset is provided, getSourceClientOffset must be a function.");
    }
    function verifyItemIsObject(item) {
      invariant$1(isObject(item), "Item must be an object.");
    }
    function getDraggableSource(sourceIds, monitor) {
      let sourceId = null;
      for (let i2 = sourceIds.length - 1; i2 >= 0; i2--) {
        if (monitor.canDragSource(sourceIds[i2])) {
          sourceId = sourceIds[i2];
          break;
        }
      }
      return sourceId;
    }
    function _defineProperty$5(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _objectSpread$5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        var ownKeys2 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys2.forEach(function(key) {
          _defineProperty$5(target, key, source[key]);
        });
      }
      return target;
    }
    function createDrop(manager) {
      return function drop(options = {}) {
        const monitor = manager.getMonitor();
        const registry = manager.getRegistry();
        verifyInvariants(monitor);
        const targetIds = getDroppableTargets(monitor);
        targetIds.forEach((targetId, index2) => {
          const dropResult = determineDropResult(targetId, index2, registry, monitor);
          const action = {
            type: DROP,
            payload: {
              dropResult: _objectSpread$5({}, options, dropResult)
            }
          };
          manager.dispatch(action);
        });
      };
    }
    function verifyInvariants(monitor) {
      invariant$1(monitor.isDragging(), "Cannot call drop while not dragging.");
      invariant$1(!monitor.didDrop(), "Cannot call drop twice during one drag operation.");
    }
    function determineDropResult(targetId, index2, registry, monitor) {
      const target = registry.getTarget(targetId);
      let dropResult = target ? target.drop(monitor, targetId) : void 0;
      verifyDropResultType(dropResult);
      if (typeof dropResult === "undefined") {
        dropResult = index2 === 0 ? {} : monitor.getDropResult();
      }
      return dropResult;
    }
    function verifyDropResultType(dropResult) {
      invariant$1(typeof dropResult === "undefined" || isObject(dropResult), "Drop result must either be an object or undefined.");
    }
    function getDroppableTargets(monitor) {
      const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);
      targetIds.reverse();
      return targetIds;
    }
    function createEndDrag(manager) {
      return function endDrag() {
        const monitor = manager.getMonitor();
        const registry = manager.getRegistry();
        verifyIsDragging(monitor);
        const sourceId = monitor.getSourceId();
        if (sourceId != null) {
          const source = registry.getSource(sourceId, true);
          source.endDrag(monitor, sourceId);
          registry.unpinSource();
        }
        return {
          type: END_DRAG
        };
      };
    }
    function verifyIsDragging(monitor) {
      invariant$1(monitor.isDragging(), "Cannot call endDrag while not dragging.");
    }
    function matchesType(targetType, draggedItemType) {
      if (draggedItemType === null) {
        return targetType === null;
      }
      return Array.isArray(targetType) ? targetType.some(
        (t2) => t2 === draggedItemType
      ) : targetType === draggedItemType;
    }
    function createHover(manager) {
      return function hover(targetIdsArg, { clientOffset } = {}) {
        verifyTargetIdsIsArray(targetIdsArg);
        const targetIds = targetIdsArg.slice(0);
        const monitor = manager.getMonitor();
        const registry = manager.getRegistry();
        const draggedItemType = monitor.getItemType();
        removeNonMatchingTargetIds(targetIds, registry, draggedItemType);
        checkInvariants(targetIds, monitor, registry);
        hoverAllTargets(targetIds, monitor, registry);
        return {
          type: HOVER,
          payload: {
            targetIds,
            clientOffset: clientOffset || null
          }
        };
      };
    }
    function verifyTargetIdsIsArray(targetIdsArg) {
      invariant$1(Array.isArray(targetIdsArg), "Expected targetIds to be an array.");
    }
    function checkInvariants(targetIds, monitor, registry) {
      invariant$1(monitor.isDragging(), "Cannot call hover while not dragging.");
      invariant$1(!monitor.didDrop(), "Cannot call hover after drop.");
      for (let i2 = 0; i2 < targetIds.length; i2++) {
        const targetId = targetIds[i2];
        invariant$1(targetIds.lastIndexOf(targetId) === i2, "Expected targetIds to be unique in the passed array.");
        const target = registry.getTarget(targetId);
        invariant$1(target, "Expected targetIds to be registered.");
      }
    }
    function removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {
      for (let i2 = targetIds.length - 1; i2 >= 0; i2--) {
        const targetId = targetIds[i2];
        const targetType = registry.getTargetType(targetId);
        if (!matchesType(targetType, draggedItemType)) {
          targetIds.splice(i2, 1);
        }
      }
    }
    function hoverAllTargets(targetIds, monitor, registry) {
      targetIds.forEach(function(targetId) {
        const target = registry.getTarget(targetId);
        target.hover(monitor, targetId);
      });
    }
    function createPublishDragSource(manager) {
      return function publishDragSource() {
        const monitor = manager.getMonitor();
        if (monitor.isDragging()) {
          return {
            type: PUBLISH_DRAG_SOURCE
          };
        }
        return;
      };
    }
    function createDragDropActions(manager) {
      return {
        beginDrag: createBeginDrag(manager),
        publishDragSource: createPublishDragSource(manager),
        hover: createHover(manager),
        drop: createDrop(manager),
        endDrag: createEndDrag(manager)
      };
    }
    class DragDropManagerImpl {
      receiveBackend(backend) {
        this.backend = backend;
      }
      getMonitor() {
        return this.monitor;
      }
      getBackend() {
        return this.backend;
      }
      getRegistry() {
        return this.monitor.registry;
      }
      getActions() {
        const manager = this;
        const { dispatch } = this.store;
        function bindActionCreator(actionCreator) {
          return (...args) => {
            const action = actionCreator.apply(manager, args);
            if (typeof action !== "undefined") {
              dispatch(action);
            }
          };
        }
        const actions = createDragDropActions(this);
        return Object.keys(actions).reduce((boundActions, key) => {
          const action = actions[key];
          boundActions[key] = bindActionCreator(action);
          return boundActions;
        }, {});
      }
      dispatch(action) {
        this.store.dispatch(action);
      }
      constructor(store, monitor) {
        this.isSetUp = false;
        this.handleRefCountChange = () => {
          const shouldSetUp = this.store.getState().refCount > 0;
          if (this.backend) {
            if (shouldSetUp && !this.isSetUp) {
              this.backend.setup();
              this.isSetUp = true;
            } else if (!shouldSetUp && this.isSetUp) {
              this.backend.teardown();
              this.isSetUp = false;
            }
          }
        };
        this.store = store;
        this.monitor = monitor;
        store.subscribe(this.handleRefCountChange);
      }
    }
    function add(a, b2) {
      return {
        x: a.x + b2.x,
        y: a.y + b2.y
      };
    }
    function subtract(a, b2) {
      return {
        x: a.x - b2.x,
        y: a.y - b2.y
      };
    }
    function getSourceClientOffset(state) {
      const { clientOffset, initialClientOffset, initialSourceClientOffset } = state;
      if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
        return null;
      }
      return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);
    }
    function getDifferenceFromInitialOffset(state) {
      const { clientOffset, initialClientOffset } = state;
      if (!clientOffset || !initialClientOffset) {
        return null;
      }
      return subtract(clientOffset, initialClientOffset);
    }
    const NONE = [];
    const ALL = [];
    NONE.__IS_NONE__ = true;
    ALL.__IS_ALL__ = true;
    function areDirty(dirtyIds, handlerIds) {
      if (dirtyIds === NONE) {
        return false;
      }
      if (dirtyIds === ALL || typeof handlerIds === "undefined") {
        return true;
      }
      const commonIds = intersection(handlerIds, dirtyIds);
      return commonIds.length > 0;
    }
    class DragDropMonitorImpl {
      subscribeToStateChange(listener, options = {}) {
        const { handlerIds } = options;
        invariant$1(typeof listener === "function", "listener must be a function.");
        invariant$1(typeof handlerIds === "undefined" || Array.isArray(handlerIds), "handlerIds, when specified, must be an array of strings.");
        let prevStateId = this.store.getState().stateId;
        const handleChange = () => {
          const state = this.store.getState();
          const currentStateId = state.stateId;
          try {
            const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);
            if (!canSkipListener) {
              listener();
            }
          } finally {
            prevStateId = currentStateId;
          }
        };
        return this.store.subscribe(handleChange);
      }
      subscribeToOffsetChange(listener) {
        invariant$1(typeof listener === "function", "listener must be a function.");
        let previousState = this.store.getState().dragOffset;
        const handleChange = () => {
          const nextState = this.store.getState().dragOffset;
          if (nextState === previousState) {
            return;
          }
          previousState = nextState;
          listener();
        };
        return this.store.subscribe(handleChange);
      }
      canDragSource(sourceId) {
        if (!sourceId) {
          return false;
        }
        const source = this.registry.getSource(sourceId);
        invariant$1(source, `Expected to find a valid source. sourceId=${sourceId}`);
        if (this.isDragging()) {
          return false;
        }
        return source.canDrag(this, sourceId);
      }
      canDropOnTarget(targetId) {
        if (!targetId) {
          return false;
        }
        const target = this.registry.getTarget(targetId);
        invariant$1(target, `Expected to find a valid target. targetId=${targetId}`);
        if (!this.isDragging() || this.didDrop()) {
          return false;
        }
        const targetType = this.registry.getTargetType(targetId);
        const draggedItemType = this.getItemType();
        return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);
      }
      isDragging() {
        return Boolean(this.getItemType());
      }
      isDraggingSource(sourceId) {
        if (!sourceId) {
          return false;
        }
        const source = this.registry.getSource(sourceId, true);
        invariant$1(source, `Expected to find a valid source. sourceId=${sourceId}`);
        if (!this.isDragging() || !this.isSourcePublic()) {
          return false;
        }
        const sourceType = this.registry.getSourceType(sourceId);
        const draggedItemType = this.getItemType();
        if (sourceType !== draggedItemType) {
          return false;
        }
        return source.isDragging(this, sourceId);
      }
      isOverTarget(targetId, options = {
        shallow: false
      }) {
        if (!targetId) {
          return false;
        }
        const { shallow: shallow2 } = options;
        if (!this.isDragging()) {
          return false;
        }
        const targetType = this.registry.getTargetType(targetId);
        const draggedItemType = this.getItemType();
        if (draggedItemType && !matchesType(targetType, draggedItemType)) {
          return false;
        }
        const targetIds = this.getTargetIds();
        if (!targetIds.length) {
          return false;
        }
        const index2 = targetIds.indexOf(targetId);
        if (shallow2) {
          return index2 === targetIds.length - 1;
        } else {
          return index2 > -1;
        }
      }
      getItemType() {
        return this.store.getState().dragOperation.itemType;
      }
      getItem() {
        return this.store.getState().dragOperation.item;
      }
      getSourceId() {
        return this.store.getState().dragOperation.sourceId;
      }
      getTargetIds() {
        return this.store.getState().dragOperation.targetIds;
      }
      getDropResult() {
        return this.store.getState().dragOperation.dropResult;
      }
      didDrop() {
        return this.store.getState().dragOperation.didDrop;
      }
      isSourcePublic() {
        return Boolean(this.store.getState().dragOperation.isSourcePublic);
      }
      getInitialClientOffset() {
        return this.store.getState().dragOffset.initialClientOffset;
      }
      getInitialSourceClientOffset() {
        return this.store.getState().dragOffset.initialSourceClientOffset;
      }
      getClientOffset() {
        return this.store.getState().dragOffset.clientOffset;
      }
      getSourceClientOffset() {
        return getSourceClientOffset(this.store.getState().dragOffset);
      }
      getDifferenceFromInitialOffset() {
        return getDifferenceFromInitialOffset(this.store.getState().dragOffset);
      }
      constructor(store, registry) {
        this.store = store;
        this.registry = registry;
      }
    }
    const scope = typeof global !== "undefined" ? global : self;
    const BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
    function makeRequestCallFromTimer(callback) {
      return function requestCall() {
        const timeoutHandle = setTimeout(handleTimer, 0);
        const intervalHandle = setInterval(handleTimer, 50);
        function handleTimer() {
          clearTimeout(timeoutHandle);
          clearInterval(intervalHandle);
          callback();
        }
      };
    }
    function makeRequestCallFromMutationObserver(callback) {
      let toggle = 1;
      const observer = new BrowserMutationObserver(callback);
      const node2 = document.createTextNode("");
      observer.observe(node2, {
        characterData: true
      });
      return function requestCall() {
        toggle = -toggle;
        node2.data = toggle;
      };
    }
    const makeRequestCall = typeof BrowserMutationObserver === "function" ? (
      // reliably everywhere they are implemented.
      // They are implemented in all modern browsers.
      //
      // - Android 4-4.3
      // - Chrome 26-34
      // - Firefox 14-29
      // - Internet Explorer 11
      // - iPad Safari 6-7.1
      // - iPhone Safari 7-7.1
      // - Safari 6-7
      makeRequestCallFromMutationObserver
    ) : (
      // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
      // 11-12, and in web workers in many engines.
      // Although message channels yield to any queued rendering and IO tasks, they
      // would be better than imposing the 4ms delay of timers.
      // However, they do not work reliably in Internet Explorer or Safari.
      // Internet Explorer 10 is the only browser that has setImmediate but does
      // not have MutationObservers.
      // Although setImmediate yields to the browser's renderer, it would be
      // preferrable to falling back to setTimeout since it does not have
      // the minimum 4ms penalty.
      // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
      // Desktop to a lesser extent) that renders both setImmediate and
      // MessageChannel useless for the purposes of ASAP.
      // https://github.com/kriskowal/q/issues/396
      // Timers are implemented universally.
      // We fall back to timers in workers in most engines, and in foreground
      // contexts in the following browsers.
      // However, note that even this simple case requires nuances to operate in a
      // broad spectrum of browsers.
      //
      // - Firefox 3-13
      // - Internet Explorer 6-9
      // - iPad Safari 4.3
      // - Lynx 2.8.7
      makeRequestCallFromTimer
    );
    class AsapQueue {
      // Use the fastest means possible to execute a task in its own turn, with
      // priority over other events including IO, animation, reflow, and redraw
      // events in browsers.
      //
      // An exception thrown by a task will permanently interrupt the processing of
      // subsequent tasks. The higher level `asap` function ensures that if an
      // exception is thrown by a task, that the task queue will continue flushing as
      // soon as possible, but if you use `rawAsap` directly, you are responsible to
      // either ensure that no exceptions are thrown from your task, or to manually
      // call `rawAsap.requestFlush` if an exception is thrown.
      enqueueTask(task) {
        const { queue: q2, requestFlush } = this;
        if (!q2.length) {
          requestFlush();
          this.flushing = true;
        }
        q2[q2.length] = task;
      }
      constructor() {
        this.queue = [];
        this.pendingErrors = [];
        this.flushing = false;
        this.index = 0;
        this.capacity = 1024;
        this.flush = () => {
          const { queue: q2 } = this;
          while (this.index < q2.length) {
            const currentIndex = this.index;
            this.index++;
            q2[currentIndex].call();
            if (this.index > this.capacity) {
              for (let scan = 0, newLength = q2.length - this.index; scan < newLength; scan++) {
                q2[scan] = q2[scan + this.index];
              }
              q2.length -= this.index;
              this.index = 0;
            }
          }
          q2.length = 0;
          this.index = 0;
          this.flushing = false;
        };
        this.registerPendingError = (err) => {
          this.pendingErrors.push(err);
          this.requestErrorThrow();
        };
        this.requestFlush = makeRequestCall(this.flush);
        this.requestErrorThrow = makeRequestCallFromTimer(() => {
          if (this.pendingErrors.length) {
            throw this.pendingErrors.shift();
          }
        });
      }
    }
    class RawTask {
      call() {
        try {
          this.task && this.task();
        } catch (error) {
          this.onError(error);
        } finally {
          this.task = null;
          this.release(this);
        }
      }
      constructor(onError, release) {
        this.onError = onError;
        this.release = release;
        this.task = null;
      }
    }
    class TaskFactory {
      create(task) {
        const tasks = this.freeTasks;
        const t1 = tasks.length ? tasks.pop() : new RawTask(
          this.onError,
          (t2) => tasks[tasks.length] = t2
        );
        t1.task = task;
        return t1;
      }
      constructor(onError) {
        this.onError = onError;
        this.freeTasks = [];
      }
    }
    const asapQueue = new AsapQueue();
    const taskFactory = new TaskFactory(asapQueue.registerPendingError);
    function asap(task) {
      asapQueue.enqueueTask(taskFactory.create(task));
    }
    const ADD_SOURCE = "dnd-core/ADD_SOURCE";
    const ADD_TARGET = "dnd-core/ADD_TARGET";
    const REMOVE_SOURCE = "dnd-core/REMOVE_SOURCE";
    const REMOVE_TARGET = "dnd-core/REMOVE_TARGET";
    function addSource(sourceId) {
      return {
        type: ADD_SOURCE,
        payload: {
          sourceId
        }
      };
    }
    function addTarget(targetId) {
      return {
        type: ADD_TARGET,
        payload: {
          targetId
        }
      };
    }
    function removeSource(sourceId) {
      return {
        type: REMOVE_SOURCE,
        payload: {
          sourceId
        }
      };
    }
    function removeTarget(targetId) {
      return {
        type: REMOVE_TARGET,
        payload: {
          targetId
        }
      };
    }
    function validateSourceContract(source) {
      invariant$1(typeof source.canDrag === "function", "Expected canDrag to be a function.");
      invariant$1(typeof source.beginDrag === "function", "Expected beginDrag to be a function.");
      invariant$1(typeof source.endDrag === "function", "Expected endDrag to be a function.");
    }
    function validateTargetContract(target) {
      invariant$1(typeof target.canDrop === "function", "Expected canDrop to be a function.");
      invariant$1(typeof target.hover === "function", "Expected hover to be a function.");
      invariant$1(typeof target.drop === "function", "Expected beginDrag to be a function.");
    }
    function validateType(type2, allowArray) {
      if (allowArray && Array.isArray(type2)) {
        type2.forEach(
          (t2) => validateType(t2, false)
        );
        return;
      }
      invariant$1(typeof type2 === "string" || typeof type2 === "symbol", allowArray ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.");
    }
    var HandlerRole;
    (function(HandlerRole2) {
      HandlerRole2["SOURCE"] = "SOURCE";
      HandlerRole2["TARGET"] = "TARGET";
    })(HandlerRole || (HandlerRole = {}));
    let nextUniqueId = 0;
    function getNextUniqueId() {
      return nextUniqueId++;
    }
    function getNextHandlerId(role) {
      const id2 = getNextUniqueId().toString();
      switch (role) {
        case HandlerRole.SOURCE:
          return `S${id2}`;
        case HandlerRole.TARGET:
          return `T${id2}`;
        default:
          throw new Error(`Unknown Handler Role: ${role}`);
      }
    }
    function parseRoleFromHandlerId(handlerId) {
      switch (handlerId[0]) {
        case "S":
          return HandlerRole.SOURCE;
        case "T":
          return HandlerRole.TARGET;
        default:
          throw new Error(`Cannot parse handler ID: ${handlerId}`);
      }
    }
    function mapContainsValue(map, searchValue) {
      const entries = map.entries();
      let isDone = false;
      do {
        const { done, value: [, value] } = entries.next();
        if (value === searchValue) {
          return true;
        }
        isDone = !!done;
      } while (!isDone);
      return false;
    }
    class HandlerRegistryImpl {
      addSource(type2, source) {
        validateType(type2);
        validateSourceContract(source);
        const sourceId = this.addHandler(HandlerRole.SOURCE, type2, source);
        this.store.dispatch(addSource(sourceId));
        return sourceId;
      }
      addTarget(type2, target) {
        validateType(type2, true);
        validateTargetContract(target);
        const targetId = this.addHandler(HandlerRole.TARGET, type2, target);
        this.store.dispatch(addTarget(targetId));
        return targetId;
      }
      containsHandler(handler) {
        return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);
      }
      getSource(sourceId, includePinned = false) {
        invariant$1(this.isSourceId(sourceId), "Expected a valid source ID.");
        const isPinned = includePinned && sourceId === this.pinnedSourceId;
        const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);
        return source;
      }
      getTarget(targetId) {
        invariant$1(this.isTargetId(targetId), "Expected a valid target ID.");
        return this.dropTargets.get(targetId);
      }
      getSourceType(sourceId) {
        invariant$1(this.isSourceId(sourceId), "Expected a valid source ID.");
        return this.types.get(sourceId);
      }
      getTargetType(targetId) {
        invariant$1(this.isTargetId(targetId), "Expected a valid target ID.");
        return this.types.get(targetId);
      }
      isSourceId(handlerId) {
        const role = parseRoleFromHandlerId(handlerId);
        return role === HandlerRole.SOURCE;
      }
      isTargetId(handlerId) {
        const role = parseRoleFromHandlerId(handlerId);
        return role === HandlerRole.TARGET;
      }
      removeSource(sourceId) {
        invariant$1(this.getSource(sourceId), "Expected an existing source.");
        this.store.dispatch(removeSource(sourceId));
        asap(() => {
          this.dragSources.delete(sourceId);
          this.types.delete(sourceId);
        });
      }
      removeTarget(targetId) {
        invariant$1(this.getTarget(targetId), "Expected an existing target.");
        this.store.dispatch(removeTarget(targetId));
        this.dropTargets.delete(targetId);
        this.types.delete(targetId);
      }
      pinSource(sourceId) {
        const source = this.getSource(sourceId);
        invariant$1(source, "Expected an existing source.");
        this.pinnedSourceId = sourceId;
        this.pinnedSource = source;
      }
      unpinSource() {
        invariant$1(this.pinnedSource, "No source is pinned at the time.");
        this.pinnedSourceId = null;
        this.pinnedSource = null;
      }
      addHandler(role, type2, handler) {
        const id2 = getNextHandlerId(role);
        this.types.set(id2, type2);
        if (role === HandlerRole.SOURCE) {
          this.dragSources.set(id2, handler);
        } else if (role === HandlerRole.TARGET) {
          this.dropTargets.set(id2, handler);
        }
        return id2;
      }
      constructor(store) {
        this.types = /* @__PURE__ */ new Map();
        this.dragSources = /* @__PURE__ */ new Map();
        this.dropTargets = /* @__PURE__ */ new Map();
        this.pinnedSourceId = null;
        this.pinnedSource = null;
        this.store = store;
      }
    }
    const strictEquality = (a, b2) => a === b2;
    function areCoordsEqual(offsetA, offsetB) {
      if (!offsetA && !offsetB) {
        return true;
      } else if (!offsetA || !offsetB) {
        return false;
      } else {
        return offsetA.x === offsetB.x && offsetA.y === offsetB.y;
      }
    }
    function areArraysEqual(a, b2, isEqual2 = strictEquality) {
      if (a.length !== b2.length) {
        return false;
      }
      for (let i2 = 0; i2 < a.length; ++i2) {
        if (!isEqual2(a[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    function reduce$5(_state = NONE, action) {
      switch (action.type) {
        case HOVER:
          break;
        case ADD_SOURCE:
        case ADD_TARGET:
        case REMOVE_TARGET:
        case REMOVE_SOURCE:
          return NONE;
        case BEGIN_DRAG:
        case PUBLISH_DRAG_SOURCE:
        case END_DRAG:
        case DROP:
        default:
          return ALL;
      }
      const { targetIds = [], prevTargetIds = [] } = action.payload;
      const result = xor(targetIds, prevTargetIds);
      const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);
      if (!didChange) {
        return NONE;
      }
      const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
      const innermostTargetId = targetIds[targetIds.length - 1];
      if (prevInnermostTargetId !== innermostTargetId) {
        if (prevInnermostTargetId) {
          result.push(prevInnermostTargetId);
        }
        if (innermostTargetId) {
          result.push(innermostTargetId);
        }
      }
      return result;
    }
    function _defineProperty$4(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _objectSpread$4(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        var ownKeys2 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys2.forEach(function(key) {
          _defineProperty$4(target, key, source[key]);
        });
      }
      return target;
    }
    const initialState$1 = {
      initialSourceClientOffset: null,
      initialClientOffset: null,
      clientOffset: null
    };
    function reduce$4(state = initialState$1, action) {
      const { payload } = action;
      switch (action.type) {
        case INIT_COORDS:
        case BEGIN_DRAG:
          return {
            initialSourceClientOffset: payload.sourceClientOffset,
            initialClientOffset: payload.clientOffset,
            clientOffset: payload.clientOffset
          };
        case HOVER:
          if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {
            return state;
          }
          return _objectSpread$4({}, state, {
            clientOffset: payload.clientOffset
          });
        case END_DRAG:
        case DROP:
          return initialState$1;
        default:
          return state;
      }
    }
    function _defineProperty$3(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _objectSpread$3(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        var ownKeys2 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys2.forEach(function(key) {
          _defineProperty$3(target, key, source[key]);
        });
      }
      return target;
    }
    const initialState = {
      itemType: null,
      item: null,
      sourceId: null,
      targetIds: [],
      dropResult: null,
      didDrop: false,
      isSourcePublic: null
    };
    function reduce$3(state = initialState, action) {
      const { payload } = action;
      switch (action.type) {
        case BEGIN_DRAG:
          return _objectSpread$3({}, state, {
            itemType: payload.itemType,
            item: payload.item,
            sourceId: payload.sourceId,
            isSourcePublic: payload.isSourcePublic,
            dropResult: null,
            didDrop: false
          });
        case PUBLISH_DRAG_SOURCE:
          return _objectSpread$3({}, state, {
            isSourcePublic: true
          });
        case HOVER:
          return _objectSpread$3({}, state, {
            targetIds: payload.targetIds
          });
        case REMOVE_TARGET:
          if (state.targetIds.indexOf(payload.targetId) === -1) {
            return state;
          }
          return _objectSpread$3({}, state, {
            targetIds: without$1(state.targetIds, payload.targetId)
          });
        case DROP:
          return _objectSpread$3({}, state, {
            dropResult: payload.dropResult,
            didDrop: true,
            targetIds: []
          });
        case END_DRAG:
          return _objectSpread$3({}, state, {
            itemType: null,
            item: null,
            sourceId: null,
            dropResult: null,
            didDrop: false,
            isSourcePublic: null,
            targetIds: []
          });
        default:
          return state;
      }
    }
    function reduce$2(state = 0, action) {
      switch (action.type) {
        case ADD_SOURCE:
        case ADD_TARGET:
          return state + 1;
        case REMOVE_SOURCE:
        case REMOVE_TARGET:
          return state - 1;
        default:
          return state;
      }
    }
    function reduce$1(state = 0) {
      return state + 1;
    }
    function _defineProperty$2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _objectSpread$2(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        var ownKeys2 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys2.forEach(function(key) {
          _defineProperty$2(target, key, source[key]);
        });
      }
      return target;
    }
    function reduce(state = {}, action) {
      return {
        dirtyHandlerIds: reduce$5(state.dirtyHandlerIds, {
          type: action.type,
          payload: _objectSpread$2({}, action.payload, {
            prevTargetIds: get(state, "dragOperation.targetIds", [])
          })
        }),
        dragOffset: reduce$4(state.dragOffset, action),
        refCount: reduce$2(state.refCount, action),
        dragOperation: reduce$3(state.dragOperation, action),
        stateId: reduce$1(state.stateId)
      };
    }
    function createDragDropManager(backendFactory, globalContext = void 0, backendOptions = {}, debugMode = false) {
      const store = makeStoreInstance(debugMode);
      const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));
      const manager = new DragDropManagerImpl(store, monitor);
      const backend = backendFactory(manager, globalContext, backendOptions);
      manager.receiveBackend(backend);
      return manager;
    }
    function makeStoreInstance(debugMode) {
      const reduxDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__;
      return createStore(reduce, debugMode && reduxDevTools && reduxDevTools({
        name: "dnd-core",
        instanceId: "dnd-core"
      }));
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i2;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
          key = sourceSymbolKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    let refCount = 0;
    const INSTANCE_SYM = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");
    var DndProvider = /* @__PURE__ */ reactExports.memo(function DndProvider2(_param) {
      var { children } = _param, props = _objectWithoutProperties(_param, [
        "children"
      ]);
      const [manager, isGlobalInstance] = getDndContextValue(props);
      reactExports.useEffect(() => {
        if (isGlobalInstance) {
          const context = getGlobalContext();
          ++refCount;
          return () => {
            if (--refCount === 0) {
              context[INSTANCE_SYM] = null;
            }
          };
        }
        return;
      }, []);
      return /* @__PURE__ */ jsx(DndContext.Provider, {
        value: manager,
        children
      });
    });
    function getDndContextValue(props) {
      if ("manager" in props) {
        const manager2 = {
          dragDropManager: props.manager
        };
        return [
          manager2,
          false
        ];
      }
      const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);
      const isGlobalInstance = !props.context;
      return [
        manager,
        isGlobalInstance
      ];
    }
    function createSingletonDndContext(backend, context = getGlobalContext(), options, debugMode) {
      const ctx = context;
      if (!ctx[INSTANCE_SYM]) {
        ctx[INSTANCE_SYM] = {
          dragDropManager: createDragDropManager(backend, context, options, debugMode)
        };
      }
      return ctx[INSTANCE_SYM];
    }
    function getGlobalContext() {
      return typeof global !== "undefined" ? global : window;
    }
    var fastDeepEqual = function equal(a, b2) {
      if (a === b2)
        return true;
      if (a && b2 && typeof a == "object" && typeof b2 == "object") {
        if (a.constructor !== b2.constructor)
          return false;
        var length2, i2, keys2;
        if (Array.isArray(a)) {
          length2 = a.length;
          if (length2 != b2.length)
            return false;
          for (i2 = length2; i2-- !== 0; )
            if (!equal(a[i2], b2[i2]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b2.source && a.flags === b2.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b2.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b2.toString();
        keys2 = Object.keys(a);
        length2 = keys2.length;
        if (length2 !== Object.keys(b2).length)
          return false;
        for (i2 = length2; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
            return false;
        for (i2 = length2; i2-- !== 0; ) {
          var key = keys2[i2];
          if (!equal(a[key], b2[key]))
            return false;
        }
        return true;
      }
      return a !== a && b2 !== b2;
    };
    const useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
    function useCollector(monitor, collect, onUpdate) {
      const [collected, setCollected] = reactExports.useState(
        () => collect(monitor)
      );
      const updateCollected = reactExports.useCallback(() => {
        const nextValue = collect(monitor);
        if (!fastDeepEqual(collected, nextValue)) {
          setCollected(nextValue);
          if (onUpdate) {
            onUpdate();
          }
        }
      }, [
        collected,
        monitor,
        onUpdate
      ]);
      useIsomorphicLayoutEffect(updateCollected);
      return [
        collected,
        updateCollected
      ];
    }
    function useMonitorOutput(monitor, collect, onCollect) {
      const [collected, updateCollected] = useCollector(monitor, collect, onCollect);
      useIsomorphicLayoutEffect(function subscribeToMonitorStateChange() {
        const handlerId = monitor.getHandlerId();
        if (handlerId == null) {
          return;
        }
        return monitor.subscribeToStateChange(updateCollected, {
          handlerIds: [
            handlerId
          ]
        });
      }, [
        monitor,
        updateCollected
      ]);
      return collected;
    }
    function useCollectedProps(collector, monitor, connector) {
      return useMonitorOutput(
        monitor,
        collector || (() => ({})),
        () => connector.reconnect()
      );
    }
    function useOptionalFactory(arg, deps) {
      const memoDeps = [
        ...deps || []
      ];
      if (deps == null && typeof arg !== "function") {
        memoDeps.push(arg);
      }
      return reactExports.useMemo(() => {
        return typeof arg === "function" ? arg() : arg;
      }, memoDeps);
    }
    function useConnectDragSource(connector) {
      return reactExports.useMemo(
        () => connector.hooks.dragSource(),
        [
          connector
        ]
      );
    }
    function useConnectDragPreview(connector) {
      return reactExports.useMemo(
        () => connector.hooks.dragPreview(),
        [
          connector
        ]
      );
    }
    let isCallingCanDrag = false;
    let isCallingIsDragging = false;
    class DragSourceMonitorImpl {
      receiveHandlerId(sourceId) {
        this.sourceId = sourceId;
      }
      getHandlerId() {
        return this.sourceId;
      }
      canDrag() {
        invariant$1(!isCallingCanDrag, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
        try {
          isCallingCanDrag = true;
          return this.internalMonitor.canDragSource(this.sourceId);
        } finally {
          isCallingCanDrag = false;
        }
      }
      isDragging() {
        if (!this.sourceId) {
          return false;
        }
        invariant$1(!isCallingIsDragging, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
        try {
          isCallingIsDragging = true;
          return this.internalMonitor.isDraggingSource(this.sourceId);
        } finally {
          isCallingIsDragging = false;
        }
      }
      subscribeToStateChange(listener, options) {
        return this.internalMonitor.subscribeToStateChange(listener, options);
      }
      isDraggingSource(sourceId) {
        return this.internalMonitor.isDraggingSource(sourceId);
      }
      isOverTarget(targetId, options) {
        return this.internalMonitor.isOverTarget(targetId, options);
      }
      getTargetIds() {
        return this.internalMonitor.getTargetIds();
      }
      isSourcePublic() {
        return this.internalMonitor.isSourcePublic();
      }
      getSourceId() {
        return this.internalMonitor.getSourceId();
      }
      subscribeToOffsetChange(listener) {
        return this.internalMonitor.subscribeToOffsetChange(listener);
      }
      canDragSource(sourceId) {
        return this.internalMonitor.canDragSource(sourceId);
      }
      canDropOnTarget(targetId) {
        return this.internalMonitor.canDropOnTarget(targetId);
      }
      getItemType() {
        return this.internalMonitor.getItemType();
      }
      getItem() {
        return this.internalMonitor.getItem();
      }
      getDropResult() {
        return this.internalMonitor.getDropResult();
      }
      didDrop() {
        return this.internalMonitor.didDrop();
      }
      getInitialClientOffset() {
        return this.internalMonitor.getInitialClientOffset();
      }
      getInitialSourceClientOffset() {
        return this.internalMonitor.getInitialSourceClientOffset();
      }
      getSourceClientOffset() {
        return this.internalMonitor.getSourceClientOffset();
      }
      getClientOffset() {
        return this.internalMonitor.getClientOffset();
      }
      getDifferenceFromInitialOffset() {
        return this.internalMonitor.getDifferenceFromInitialOffset();
      }
      constructor(manager) {
        this.sourceId = null;
        this.internalMonitor = manager.getMonitor();
      }
    }
    let isCallingCanDrop = false;
    class DropTargetMonitorImpl {
      receiveHandlerId(targetId) {
        this.targetId = targetId;
      }
      getHandlerId() {
        return this.targetId;
      }
      subscribeToStateChange(listener, options) {
        return this.internalMonitor.subscribeToStateChange(listener, options);
      }
      canDrop() {
        if (!this.targetId) {
          return false;
        }
        invariant$1(!isCallingCanDrop, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
        try {
          isCallingCanDrop = true;
          return this.internalMonitor.canDropOnTarget(this.targetId);
        } finally {
          isCallingCanDrop = false;
        }
      }
      isOver(options) {
        if (!this.targetId) {
          return false;
        }
        return this.internalMonitor.isOverTarget(this.targetId, options);
      }
      getItemType() {
        return this.internalMonitor.getItemType();
      }
      getItem() {
        return this.internalMonitor.getItem();
      }
      getDropResult() {
        return this.internalMonitor.getDropResult();
      }
      didDrop() {
        return this.internalMonitor.didDrop();
      }
      getInitialClientOffset() {
        return this.internalMonitor.getInitialClientOffset();
      }
      getInitialSourceClientOffset() {
        return this.internalMonitor.getInitialSourceClientOffset();
      }
      getSourceClientOffset() {
        return this.internalMonitor.getSourceClientOffset();
      }
      getClientOffset() {
        return this.internalMonitor.getClientOffset();
      }
      getDifferenceFromInitialOffset() {
        return this.internalMonitor.getDifferenceFromInitialOffset();
      }
      constructor(manager) {
        this.targetId = null;
        this.internalMonitor = manager.getMonitor();
      }
    }
    function registerTarget(type2, target, manager) {
      const registry = manager.getRegistry();
      const targetId = registry.addTarget(type2, target);
      return [
        targetId,
        () => registry.removeTarget(targetId)
      ];
    }
    function registerSource(type2, source, manager) {
      const registry = manager.getRegistry();
      const sourceId = registry.addSource(type2, source);
      return [
        sourceId,
        () => registry.removeSource(sourceId)
      ];
    }
    function shallowEqual$1(objA, objB, compare2, compareContext) {
      let compareResult = compare2 ? compare2.call(compareContext, objA, objB) : void 0;
      if (compareResult !== void 0) {
        return !!compareResult;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      const keysA = Object.keys(objA);
      const keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (let idx = 0; idx < keysA.length; idx++) {
        const key = keysA[idx];
        if (!bHasOwnProperty(key)) {
          return false;
        }
        const valueA = objA[key];
        const valueB = objB[key];
        compareResult = compare2 ? compare2.call(compareContext, valueA, valueB, key) : void 0;
        if (compareResult === false || compareResult === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    }
    function isRef(obj) {
      return (
        // eslint-disable-next-line no-prototype-builtins
        obj !== null && typeof obj === "object" && Object.prototype.hasOwnProperty.call(obj, "current")
      );
    }
    function throwIfCompositeComponentElement(element) {
      if (typeof element.type === "string") {
        return;
      }
      const displayName = element.type.displayName || element.type.name || "the component";
      throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${displayName} into a <div>, or turn it into a drag source or a drop target itself.`);
    }
    function wrapHookToRecognizeElement(hook) {
      return (elementOrNode = null, options = null) => {
        if (!reactExports.isValidElement(elementOrNode)) {
          const node2 = elementOrNode;
          hook(node2, options);
          return node2;
        }
        const element = elementOrNode;
        throwIfCompositeComponentElement(element);
        const ref = options ? (node2) => hook(node2, options) : hook;
        return cloneWithRef(element, ref);
      };
    }
    function wrapConnectorHooks(hooks) {
      const wrappedHooks = {};
      Object.keys(hooks).forEach((key) => {
        const hook = hooks[key];
        if (key.endsWith("Ref")) {
          wrappedHooks[key] = hooks[key];
        } else {
          const wrappedHook = wrapHookToRecognizeElement(hook);
          wrappedHooks[key] = () => wrappedHook;
        }
      });
      return wrappedHooks;
    }
    function setRef(ref, node2) {
      if (typeof ref === "function") {
        ref(node2);
      } else {
        ref.current = node2;
      }
    }
    function cloneWithRef(element, newRef) {
      const previousRef = element.ref;
      invariant$1(typeof previousRef !== "string", "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs");
      if (!previousRef) {
        return reactExports.cloneElement(element, {
          ref: newRef
        });
      } else {
        return reactExports.cloneElement(element, {
          ref: (node2) => {
            setRef(previousRef, node2);
            setRef(newRef, node2);
          }
        });
      }
    }
    class SourceConnector {
      receiveHandlerId(newHandlerId) {
        if (this.handlerId === newHandlerId) {
          return;
        }
        this.handlerId = newHandlerId;
        this.reconnect();
      }
      get connectTarget() {
        return this.dragSource;
      }
      get dragSourceOptions() {
        return this.dragSourceOptionsInternal;
      }
      set dragSourceOptions(options) {
        this.dragSourceOptionsInternal = options;
      }
      get dragPreviewOptions() {
        return this.dragPreviewOptionsInternal;
      }
      set dragPreviewOptions(options) {
        this.dragPreviewOptionsInternal = options;
      }
      reconnect() {
        const didChange = this.reconnectDragSource();
        this.reconnectDragPreview(didChange);
      }
      reconnectDragSource() {
        const dragSource = this.dragSource;
        const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
        if (didChange) {
          this.disconnectDragSource();
        }
        if (!this.handlerId) {
          return didChange;
        }
        if (!dragSource) {
          this.lastConnectedDragSource = dragSource;
          return didChange;
        }
        if (didChange) {
          this.lastConnectedHandlerId = this.handlerId;
          this.lastConnectedDragSource = dragSource;
          this.lastConnectedDragSourceOptions = this.dragSourceOptions;
          this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);
        }
        return didChange;
      }
      reconnectDragPreview(forceDidChange = false) {
        const dragPreview = this.dragPreview;
        const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
        if (didChange) {
          this.disconnectDragPreview();
        }
        if (!this.handlerId) {
          return;
        }
        if (!dragPreview) {
          this.lastConnectedDragPreview = dragPreview;
          return;
        }
        if (didChange) {
          this.lastConnectedHandlerId = this.handlerId;
          this.lastConnectedDragPreview = dragPreview;
          this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;
          this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);
        }
      }
      didHandlerIdChange() {
        return this.lastConnectedHandlerId !== this.handlerId;
      }
      didConnectedDragSourceChange() {
        return this.lastConnectedDragSource !== this.dragSource;
      }
      didConnectedDragPreviewChange() {
        return this.lastConnectedDragPreview !== this.dragPreview;
      }
      didDragSourceOptionsChange() {
        return !shallowEqual$1(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
      }
      didDragPreviewOptionsChange() {
        return !shallowEqual$1(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
      }
      disconnectDragSource() {
        if (this.dragSourceUnsubscribe) {
          this.dragSourceUnsubscribe();
          this.dragSourceUnsubscribe = void 0;
        }
      }
      disconnectDragPreview() {
        if (this.dragPreviewUnsubscribe) {
          this.dragPreviewUnsubscribe();
          this.dragPreviewUnsubscribe = void 0;
          this.dragPreviewNode = null;
          this.dragPreviewRef = null;
        }
      }
      get dragSource() {
        return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
      }
      get dragPreview() {
        return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
      }
      clearDragSource() {
        this.dragSourceNode = null;
        this.dragSourceRef = null;
      }
      clearDragPreview() {
        this.dragPreviewNode = null;
        this.dragPreviewRef = null;
      }
      constructor(backend) {
        this.hooks = wrapConnectorHooks({
          dragSource: (node2, options) => {
            this.clearDragSource();
            this.dragSourceOptions = options || null;
            if (isRef(node2)) {
              this.dragSourceRef = node2;
            } else {
              this.dragSourceNode = node2;
            }
            this.reconnectDragSource();
          },
          dragPreview: (node2, options) => {
            this.clearDragPreview();
            this.dragPreviewOptions = options || null;
            if (isRef(node2)) {
              this.dragPreviewRef = node2;
            } else {
              this.dragPreviewNode = node2;
            }
            this.reconnectDragPreview();
          }
        });
        this.handlerId = null;
        this.dragSourceRef = null;
        this.dragSourceOptionsInternal = null;
        this.dragPreviewRef = null;
        this.dragPreviewOptionsInternal = null;
        this.lastConnectedHandlerId = null;
        this.lastConnectedDragSource = null;
        this.lastConnectedDragSourceOptions = null;
        this.lastConnectedDragPreview = null;
        this.lastConnectedDragPreviewOptions = null;
        this.backend = backend;
      }
    }
    class TargetConnector {
      get connectTarget() {
        return this.dropTarget;
      }
      reconnect() {
        const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
        if (didChange) {
          this.disconnectDropTarget();
        }
        const dropTarget = this.dropTarget;
        if (!this.handlerId) {
          return;
        }
        if (!dropTarget) {
          this.lastConnectedDropTarget = dropTarget;
          return;
        }
        if (didChange) {
          this.lastConnectedHandlerId = this.handlerId;
          this.lastConnectedDropTarget = dropTarget;
          this.lastConnectedDropTargetOptions = this.dropTargetOptions;
          this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);
        }
      }
      receiveHandlerId(newHandlerId) {
        if (newHandlerId === this.handlerId) {
          return;
        }
        this.handlerId = newHandlerId;
        this.reconnect();
      }
      get dropTargetOptions() {
        return this.dropTargetOptionsInternal;
      }
      set dropTargetOptions(options) {
        this.dropTargetOptionsInternal = options;
      }
      didHandlerIdChange() {
        return this.lastConnectedHandlerId !== this.handlerId;
      }
      didDropTargetChange() {
        return this.lastConnectedDropTarget !== this.dropTarget;
      }
      didOptionsChange() {
        return !shallowEqual$1(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
      }
      disconnectDropTarget() {
        if (this.unsubscribeDropTarget) {
          this.unsubscribeDropTarget();
          this.unsubscribeDropTarget = void 0;
        }
      }
      get dropTarget() {
        return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
      }
      clearDropTarget() {
        this.dropTargetRef = null;
        this.dropTargetNode = null;
      }
      constructor(backend) {
        this.hooks = wrapConnectorHooks({
          dropTarget: (node2, options) => {
            this.clearDropTarget();
            this.dropTargetOptions = options;
            if (isRef(node2)) {
              this.dropTargetRef = node2;
            } else {
              this.dropTargetNode = node2;
            }
            this.reconnect();
          }
        });
        this.handlerId = null;
        this.dropTargetRef = null;
        this.dropTargetOptionsInternal = null;
        this.lastConnectedHandlerId = null;
        this.lastConnectedDropTarget = null;
        this.lastConnectedDropTargetOptions = null;
        this.backend = backend;
      }
    }
    function useDragDropManager() {
      const { dragDropManager } = reactExports.useContext(DndContext);
      invariant$1(dragDropManager != null, "Expected drag drop context");
      return dragDropManager;
    }
    function useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {
      const manager = useDragDropManager();
      const connector = reactExports.useMemo(
        () => new SourceConnector(manager.getBackend()),
        [
          manager
        ]
      );
      useIsomorphicLayoutEffect(() => {
        connector.dragSourceOptions = dragSourceOptions || null;
        connector.reconnect();
        return () => connector.disconnectDragSource();
      }, [
        connector,
        dragSourceOptions
      ]);
      useIsomorphicLayoutEffect(() => {
        connector.dragPreviewOptions = dragPreviewOptions || null;
        connector.reconnect();
        return () => connector.disconnectDragPreview();
      }, [
        connector,
        dragPreviewOptions
      ]);
      return connector;
    }
    function useDragSourceMonitor() {
      const manager = useDragDropManager();
      return reactExports.useMemo(
        () => new DragSourceMonitorImpl(manager),
        [
          manager
        ]
      );
    }
    class DragSourceImpl {
      beginDrag() {
        const spec = this.spec;
        const monitor = this.monitor;
        let result = null;
        if (typeof spec.item === "object") {
          result = spec.item;
        } else if (typeof spec.item === "function") {
          result = spec.item(monitor);
        } else {
          result = {};
        }
        return result !== null && result !== void 0 ? result : null;
      }
      canDrag() {
        const spec = this.spec;
        const monitor = this.monitor;
        if (typeof spec.canDrag === "boolean") {
          return spec.canDrag;
        } else if (typeof spec.canDrag === "function") {
          return spec.canDrag(monitor);
        } else {
          return true;
        }
      }
      isDragging(globalMonitor, target) {
        const spec = this.spec;
        const monitor = this.monitor;
        const { isDragging } = spec;
        return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();
      }
      endDrag() {
        const spec = this.spec;
        const monitor = this.monitor;
        const connector = this.connector;
        const { end: end2 } = spec;
        if (end2) {
          end2(monitor.getItem(), monitor);
        }
        connector.reconnect();
      }
      constructor(spec, monitor, connector) {
        this.spec = spec;
        this.monitor = monitor;
        this.connector = connector;
      }
    }
    function useDragSource(spec, monitor, connector) {
      const handler = reactExports.useMemo(
        () => new DragSourceImpl(spec, monitor, connector),
        [
          monitor,
          connector
        ]
      );
      reactExports.useEffect(() => {
        handler.spec = spec;
      }, [
        spec
      ]);
      return handler;
    }
    function useDragType(spec) {
      return reactExports.useMemo(() => {
        const result = spec.type;
        invariant$1(result != null, "spec.type must be defined");
        return result;
      }, [
        spec
      ]);
    }
    function useRegisteredDragSource(spec, monitor, connector) {
      const manager = useDragDropManager();
      const handler = useDragSource(spec, monitor, connector);
      const itemType = useDragType(spec);
      useIsomorphicLayoutEffect(function registerDragSource() {
        if (itemType != null) {
          const [handlerId, unregister] = registerSource(itemType, handler, manager);
          monitor.receiveHandlerId(handlerId);
          connector.receiveHandlerId(handlerId);
          return unregister;
        }
        return;
      }, [
        manager,
        monitor,
        connector,
        handler,
        itemType
      ]);
    }
    function useDrag(specArg, deps) {
      const spec = useOptionalFactory(specArg, deps);
      invariant$1(!spec.begin, `useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`);
      const monitor = useDragSourceMonitor();
      const connector = useDragSourceConnector(spec.options, spec.previewOptions);
      useRegisteredDragSource(spec, monitor, connector);
      return [
        useCollectedProps(spec.collect, monitor, connector),
        useConnectDragSource(connector),
        useConnectDragPreview(connector)
      ];
    }
    function useConnectDropTarget(connector) {
      return reactExports.useMemo(
        () => connector.hooks.dropTarget(),
        [
          connector
        ]
      );
    }
    function useDropTargetConnector(options) {
      const manager = useDragDropManager();
      const connector = reactExports.useMemo(
        () => new TargetConnector(manager.getBackend()),
        [
          manager
        ]
      );
      useIsomorphicLayoutEffect(() => {
        connector.dropTargetOptions = options || null;
        connector.reconnect();
        return () => connector.disconnectDropTarget();
      }, [
        options
      ]);
      return connector;
    }
    function useDropTargetMonitor() {
      const manager = useDragDropManager();
      return reactExports.useMemo(
        () => new DropTargetMonitorImpl(manager),
        [
          manager
        ]
      );
    }
    function useAccept(spec) {
      const { accept } = spec;
      return reactExports.useMemo(() => {
        invariant$1(spec.accept != null, "accept must be defined");
        return Array.isArray(accept) ? accept : [
          accept
        ];
      }, [
        accept
      ]);
    }
    class DropTargetImpl {
      canDrop() {
        const spec = this.spec;
        const monitor = this.monitor;
        return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;
      }
      hover() {
        const spec = this.spec;
        const monitor = this.monitor;
        if (spec.hover) {
          spec.hover(monitor.getItem(), monitor);
        }
      }
      drop() {
        const spec = this.spec;
        const monitor = this.monitor;
        if (spec.drop) {
          return spec.drop(monitor.getItem(), monitor);
        }
        return;
      }
      constructor(spec, monitor) {
        this.spec = spec;
        this.monitor = monitor;
      }
    }
    function useDropTarget(spec, monitor) {
      const dropTarget = reactExports.useMemo(
        () => new DropTargetImpl(spec, monitor),
        [
          monitor
        ]
      );
      reactExports.useEffect(() => {
        dropTarget.spec = spec;
      }, [
        spec
      ]);
      return dropTarget;
    }
    function useRegisteredDropTarget(spec, monitor, connector) {
      const manager = useDragDropManager();
      const dropTarget = useDropTarget(spec, monitor);
      const accept = useAccept(spec);
      useIsomorphicLayoutEffect(function registerDropTarget() {
        const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);
        monitor.receiveHandlerId(handlerId);
        connector.receiveHandlerId(handlerId);
        return unregister;
      }, [
        manager,
        monitor,
        dropTarget,
        connector,
        accept.map(
          (a) => a.toString()
        ).join("|")
      ]);
    }
    function useDrop(specArg, deps) {
      const spec = useOptionalFactory(specArg, deps);
      const monitor = useDropTargetMonitor();
      const connector = useDropTargetConnector(spec.options);
      useRegisteredDropTarget(spec, monitor, connector);
      return [
        useCollectedProps(spec.collect, monitor, connector),
        useConnectDropTarget(connector)
      ];
    }
    function memoize(fn) {
      let result = null;
      const memoized = () => {
        if (result == null) {
          result = fn();
        }
        return result;
      };
      return memoized;
    }
    function without(items, item) {
      return items.filter(
        (i2) => i2 !== item
      );
    }
    function union(itemsA, itemsB) {
      const set2 = /* @__PURE__ */ new Set();
      const insertItem = (item) => set2.add(item);
      itemsA.forEach(insertItem);
      itemsB.forEach(insertItem);
      const result = [];
      set2.forEach(
        (key) => result.push(key)
      );
      return result;
    }
    class EnterLeaveCounter {
      enter(enteringNode) {
        const previousLength = this.entered.length;
        const isNodeEntered = (node2) => this.isNodeInDocument(node2) && (!node2.contains || node2.contains(enteringNode));
        this.entered = union(this.entered.filter(isNodeEntered), [
          enteringNode
        ]);
        return previousLength === 0 && this.entered.length > 0;
      }
      leave(leavingNode) {
        const previousLength = this.entered.length;
        this.entered = without(this.entered.filter(this.isNodeInDocument), leavingNode);
        return previousLength > 0 && this.entered.length === 0;
      }
      reset() {
        this.entered = [];
      }
      constructor(isNodeInDocument) {
        this.entered = [];
        this.isNodeInDocument = isNodeInDocument;
      }
    }
    class NativeDragSource {
      initializeExposedProperties() {
        Object.keys(this.config.exposeProperties).forEach((property2) => {
          Object.defineProperty(this.item, property2, {
            configurable: true,
            enumerable: true,
            get() {
              console.warn(`Browser doesn't allow reading "${property2}" until the drop event.`);
              return null;
            }
          });
        });
      }
      loadDataTransfer(dataTransfer) {
        if (dataTransfer) {
          const newProperties = {};
          Object.keys(this.config.exposeProperties).forEach((property2) => {
            const propertyFn = this.config.exposeProperties[property2];
            if (propertyFn != null) {
              newProperties[property2] = {
                value: propertyFn(dataTransfer, this.config.matchesTypes),
                configurable: true,
                enumerable: true
              };
            }
          });
          Object.defineProperties(this.item, newProperties);
        }
      }
      canDrag() {
        return true;
      }
      beginDrag() {
        return this.item;
      }
      isDragging(monitor, handle) {
        return handle === monitor.getSourceId();
      }
      endDrag() {
      }
      constructor(config) {
        this.config = config;
        this.item = {};
        this.initializeExposedProperties();
      }
    }
    const FILE = "__NATIVE_FILE__";
    const URL$1 = "__NATIVE_URL__";
    const TEXT = "__NATIVE_TEXT__";
    const HTML = "__NATIVE_HTML__";
    const NativeTypes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      FILE,
      HTML,
      TEXT,
      URL: URL$1
    }, Symbol.toStringTag, { value: "Module" }));
    function getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {
      const result = typesToTry.reduce(
        (resultSoFar, typeToTry) => resultSoFar || dataTransfer.getData(typeToTry),
        ""
      );
      return result != null ? result : defaultValue;
    }
    const nativeTypesConfig = {
      [FILE]: {
        exposeProperties: {
          files: (dataTransfer) => Array.prototype.slice.call(dataTransfer.files),
          items: (dataTransfer) => dataTransfer.items,
          dataTransfer: (dataTransfer) => dataTransfer
        },
        matchesTypes: [
          "Files"
        ]
      },
      [HTML]: {
        exposeProperties: {
          html: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
          dataTransfer: (dataTransfer) => dataTransfer
        },
        matchesTypes: [
          "Html",
          "text/html"
        ]
      },
      [URL$1]: {
        exposeProperties: {
          urls: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, "").split("\n"),
          dataTransfer: (dataTransfer) => dataTransfer
        },
        matchesTypes: [
          "Url",
          "text/uri-list"
        ]
      },
      [TEXT]: {
        exposeProperties: {
          text: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
          dataTransfer: (dataTransfer) => dataTransfer
        },
        matchesTypes: [
          "Text",
          "text/plain"
        ]
      }
    };
    function createNativeDragSource(type2, dataTransfer) {
      const config = nativeTypesConfig[type2];
      if (!config) {
        throw new Error(`native type ${type2} has no configuration`);
      }
      const result = new NativeDragSource(config);
      result.loadDataTransfer(dataTransfer);
      return result;
    }
    function matchNativeItemType(dataTransfer) {
      if (!dataTransfer) {
        return null;
      }
      const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);
      return Object.keys(nativeTypesConfig).filter((nativeItemType) => {
        const typeConfig = nativeTypesConfig[nativeItemType];
        if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {
          return false;
        }
        return typeConfig.matchesTypes.some(
          (t2) => dataTransferTypes.indexOf(t2) > -1
        );
      })[0] || null;
    }
    const isFirefox = memoize(
      () => /firefox/i.test(navigator.userAgent)
    );
    const isSafari = memoize(
      () => Boolean(window.safari)
    );
    class MonotonicInterpolant {
      interpolate(x2) {
        const { xs, ys, c1s, c2s, c3s } = this;
        let i2 = xs.length - 1;
        if (x2 === xs[i2]) {
          return ys[i2];
        }
        let low = 0;
        let high = c3s.length - 1;
        let mid;
        while (low <= high) {
          mid = Math.floor(0.5 * (low + high));
          const xHere = xs[mid];
          if (xHere < x2) {
            low = mid + 1;
          } else if (xHere > x2) {
            high = mid - 1;
          } else {
            return ys[mid];
          }
        }
        i2 = Math.max(0, high);
        const diff = x2 - xs[i2];
        const diffSq = diff * diff;
        return ys[i2] + c1s[i2] * diff + c2s[i2] * diffSq + c3s[i2] * diff * diffSq;
      }
      constructor(xs, ys) {
        const { length: length2 } = xs;
        const indexes = [];
        for (let i2 = 0; i2 < length2; i2++) {
          indexes.push(i2);
        }
        indexes.sort(
          (a, b2) => xs[a] < xs[b2] ? -1 : 1
        );
        const dxs = [];
        const ms = [];
        let dx;
        let dy;
        for (let i1 = 0; i1 < length2 - 1; i1++) {
          dx = xs[i1 + 1] - xs[i1];
          dy = ys[i1 + 1] - ys[i1];
          dxs.push(dx);
          ms.push(dy / dx);
        }
        const c1s = [
          ms[0]
        ];
        for (let i2 = 0; i2 < dxs.length - 1; i2++) {
          const m22 = ms[i2];
          const mNext = ms[i2 + 1];
          if (m22 * mNext <= 0) {
            c1s.push(0);
          } else {
            dx = dxs[i2];
            const dxNext = dxs[i2 + 1];
            const common = dx + dxNext;
            c1s.push(3 * common / ((common + dxNext) / m22 + (common + dx) / mNext));
          }
        }
        c1s.push(ms[ms.length - 1]);
        const c2s = [];
        const c3s = [];
        let m2;
        for (let i3 = 0; i3 < c1s.length - 1; i3++) {
          m2 = ms[i3];
          const c1 = c1s[i3];
          const invDx = 1 / dxs[i3];
          const common = c1 + c1s[i3 + 1] - m2 - m2;
          c2s.push((m2 - c1 - common) * invDx);
          c3s.push(common * invDx * invDx);
        }
        this.xs = xs;
        this.ys = ys;
        this.c1s = c1s;
        this.c2s = c2s;
        this.c3s = c3s;
      }
    }
    const ELEMENT_NODE = 1;
    function getNodeClientOffset(node2) {
      const el2 = node2.nodeType === ELEMENT_NODE ? node2 : node2.parentElement;
      if (!el2) {
        return null;
      }
      const { top, left } = el2.getBoundingClientRect();
      return {
        x: left,
        y: top
      };
    }
    function getEventClientOffset(e2) {
      return {
        x: e2.clientX,
        y: e2.clientY
      };
    }
    function isImageNode(node2) {
      var ref;
      return node2.nodeName === "IMG" && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node2)));
    }
    function getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {
      let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;
      let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;
      if (isSafari() && isImage) {
        dragPreviewHeight /= window.devicePixelRatio;
        dragPreviewWidth /= window.devicePixelRatio;
      }
      return {
        dragPreviewWidth,
        dragPreviewHeight
      };
    }
    function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
      const isImage = isImageNode(dragPreview);
      const dragPreviewNode = isImage ? sourceNode : dragPreview;
      const dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
      const offsetFromDragPreview = {
        x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
        y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
      };
      const { offsetWidth: sourceWidth, offsetHeight: sourceHeight } = sourceNode;
      const { anchorX, anchorY } = anchorPoint;
      const { dragPreviewWidth, dragPreviewHeight } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);
      const calculateYOffset = () => {
        const interpolantY = new MonotonicInterpolant([
          0,
          0.5,
          1
        ], [
          // Dock to the top
          offsetFromDragPreview.y,
          // Align at the center
          offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,
          // Dock to the bottom
          offsetFromDragPreview.y + dragPreviewHeight - sourceHeight
        ]);
        let y2 = interpolantY.interpolate(anchorY);
        if (isSafari() && isImage) {
          y2 += (window.devicePixelRatio - 1) * dragPreviewHeight;
        }
        return y2;
      };
      const calculateXOffset = () => {
        const interpolantX = new MonotonicInterpolant([
          0,
          0.5,
          1
        ], [
          // Dock to the left
          offsetFromDragPreview.x,
          // Align at the center
          offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,
          // Dock to the right
          offsetFromDragPreview.x + dragPreviewWidth - sourceWidth
        ]);
        return interpolantX.interpolate(anchorX);
      };
      const { offsetX, offsetY } = offsetPoint;
      const isManualOffsetX = offsetX === 0 || offsetX;
      const isManualOffsetY = offsetY === 0 || offsetY;
      return {
        x: isManualOffsetX ? offsetX : calculateXOffset(),
        y: isManualOffsetY ? offsetY : calculateYOffset()
      };
    }
    class OptionsReader {
      get window() {
        if (this.globalContext) {
          return this.globalContext;
        } else if (typeof window !== "undefined") {
          return window;
        }
        return void 0;
      }
      get document() {
        var ref;
        if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {
          return this.globalContext.document;
        } else if (this.window) {
          return this.window.document;
        } else {
          return void 0;
        }
      }
      get rootElement() {
        var ref;
        return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;
      }
      constructor(globalContext, options) {
        this.ownerDocument = null;
        this.globalContext = globalContext;
        this.optionsArgs = options;
      }
    }
    function _defineProperty$1(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _objectSpread$1(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        var ownKeys2 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys2.forEach(function(key) {
          _defineProperty$1(target, key, source[key]);
        });
      }
      return target;
    }
    class HTML5BackendImpl {
      /**
      * Generate profiling statistics for the HTML5Backend.
      */
      profile() {
        var ref, ref1;
        return {
          sourcePreviewNodes: this.sourcePreviewNodes.size,
          sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
          sourceNodeOptions: this.sourceNodeOptions.size,
          sourceNodes: this.sourceNodes.size,
          dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,
          dropTargetIds: this.dropTargetIds.length,
          dragEnterTargetIds: this.dragEnterTargetIds.length,
          dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0
        };
      }
      // public for test
      get window() {
        return this.options.window;
      }
      get document() {
        return this.options.document;
      }
      /**
      * Get the root element to use for event subscriptions
      */
      get rootElement() {
        return this.options.rootElement;
      }
      setup() {
        const root2 = this.rootElement;
        if (root2 === void 0) {
          return;
        }
        if (root2.__isReactDndBackendSetUp) {
          throw new Error("Cannot have two HTML5 backends at the same time.");
        }
        root2.__isReactDndBackendSetUp = true;
        this.addEventListeners(root2);
      }
      teardown() {
        const root2 = this.rootElement;
        if (root2 === void 0) {
          return;
        }
        root2.__isReactDndBackendSetUp = false;
        this.removeEventListeners(this.rootElement);
        this.clearCurrentDragSourceNode();
        if (this.asyncEndDragFrameId) {
          var ref;
          (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);
        }
      }
      connectDragPreview(sourceId, node2, options) {
        this.sourcePreviewNodeOptions.set(sourceId, options);
        this.sourcePreviewNodes.set(sourceId, node2);
        return () => {
          this.sourcePreviewNodes.delete(sourceId);
          this.sourcePreviewNodeOptions.delete(sourceId);
        };
      }
      connectDragSource(sourceId, node2, options) {
        this.sourceNodes.set(sourceId, node2);
        this.sourceNodeOptions.set(sourceId, options);
        const handleDragStart = (e2) => this.handleDragStart(e2, sourceId);
        const handleSelectStart = (e2) => this.handleSelectStart(e2);
        node2.setAttribute("draggable", "true");
        node2.addEventListener("dragstart", handleDragStart);
        node2.addEventListener("selectstart", handleSelectStart);
        return () => {
          this.sourceNodes.delete(sourceId);
          this.sourceNodeOptions.delete(sourceId);
          node2.removeEventListener("dragstart", handleDragStart);
          node2.removeEventListener("selectstart", handleSelectStart);
          node2.setAttribute("draggable", "false");
        };
      }
      connectDropTarget(targetId, node2) {
        const handleDragEnter = (e2) => this.handleDragEnter(e2, targetId);
        const handleDragOver = (e2) => this.handleDragOver(e2, targetId);
        const handleDrop = (e2) => this.handleDrop(e2, targetId);
        node2.addEventListener("dragenter", handleDragEnter);
        node2.addEventListener("dragover", handleDragOver);
        node2.addEventListener("drop", handleDrop);
        return () => {
          node2.removeEventListener("dragenter", handleDragEnter);
          node2.removeEventListener("dragover", handleDragOver);
          node2.removeEventListener("drop", handleDrop);
        };
      }
      addEventListeners(target) {
        if (!target.addEventListener) {
          return;
        }
        target.addEventListener("dragstart", this.handleTopDragStart);
        target.addEventListener("dragstart", this.handleTopDragStartCapture, true);
        target.addEventListener("dragend", this.handleTopDragEndCapture, true);
        target.addEventListener("dragenter", this.handleTopDragEnter);
        target.addEventListener("dragenter", this.handleTopDragEnterCapture, true);
        target.addEventListener("dragleave", this.handleTopDragLeaveCapture, true);
        target.addEventListener("dragover", this.handleTopDragOver);
        target.addEventListener("dragover", this.handleTopDragOverCapture, true);
        target.addEventListener("drop", this.handleTopDrop);
        target.addEventListener("drop", this.handleTopDropCapture, true);
      }
      removeEventListeners(target) {
        if (!target.removeEventListener) {
          return;
        }
        target.removeEventListener("dragstart", this.handleTopDragStart);
        target.removeEventListener("dragstart", this.handleTopDragStartCapture, true);
        target.removeEventListener("dragend", this.handleTopDragEndCapture, true);
        target.removeEventListener("dragenter", this.handleTopDragEnter);
        target.removeEventListener("dragenter", this.handleTopDragEnterCapture, true);
        target.removeEventListener("dragleave", this.handleTopDragLeaveCapture, true);
        target.removeEventListener("dragover", this.handleTopDragOver);
        target.removeEventListener("dragover", this.handleTopDragOverCapture, true);
        target.removeEventListener("drop", this.handleTopDrop);
        target.removeEventListener("drop", this.handleTopDropCapture, true);
      }
      getCurrentSourceNodeOptions() {
        const sourceId = this.monitor.getSourceId();
        const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);
        return _objectSpread$1({
          dropEffect: this.altKeyPressed ? "copy" : "move"
        }, sourceNodeOptions || {});
      }
      getCurrentDropEffect() {
        if (this.isDraggingNativeItem()) {
          return "copy";
        }
        return this.getCurrentSourceNodeOptions().dropEffect;
      }
      getCurrentSourcePreviewNodeOptions() {
        const sourceId = this.monitor.getSourceId();
        const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);
        return _objectSpread$1({
          anchorX: 0.5,
          anchorY: 0.5,
          captureDraggingState: false
        }, sourcePreviewNodeOptions || {});
      }
      isDraggingNativeItem() {
        const itemType = this.monitor.getItemType();
        return Object.keys(NativeTypes).some(
          (key) => NativeTypes[key] === itemType
        );
      }
      beginDragNativeItem(type2, dataTransfer) {
        this.clearCurrentDragSourceNode();
        this.currentNativeSource = createNativeDragSource(type2, dataTransfer);
        this.currentNativeHandle = this.registry.addSource(type2, this.currentNativeSource);
        this.actions.beginDrag([
          this.currentNativeHandle
        ]);
      }
      setCurrentDragSourceNode(node2) {
        this.clearCurrentDragSourceNode();
        this.currentDragSourceNode = node2;
        const MOUSE_MOVE_TIMEOUT = 1e3;
        this.mouseMoveTimeoutTimer = setTimeout(() => {
          var ref;
          return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
        }, MOUSE_MOVE_TIMEOUT);
      }
      clearCurrentDragSourceNode() {
        if (this.currentDragSourceNode) {
          this.currentDragSourceNode = null;
          if (this.rootElement) {
            var ref;
            (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || void 0);
            this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
          }
          this.mouseMoveTimeoutTimer = null;
          return true;
        }
        return false;
      }
      handleDragStart(e2, sourceId) {
        if (e2.defaultPrevented) {
          return;
        }
        if (!this.dragStartSourceIds) {
          this.dragStartSourceIds = [];
        }
        this.dragStartSourceIds.unshift(sourceId);
      }
      handleDragEnter(_e2, targetId) {
        this.dragEnterTargetIds.unshift(targetId);
      }
      handleDragOver(_e2, targetId) {
        if (this.dragOverTargetIds === null) {
          this.dragOverTargetIds = [];
        }
        this.dragOverTargetIds.unshift(targetId);
      }
      handleDrop(_e2, targetId) {
        this.dropTargetIds.unshift(targetId);
      }
      constructor(manager, globalContext, options) {
        this.sourcePreviewNodes = /* @__PURE__ */ new Map();
        this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map();
        this.sourceNodes = /* @__PURE__ */ new Map();
        this.sourceNodeOptions = /* @__PURE__ */ new Map();
        this.dragStartSourceIds = null;
        this.dropTargetIds = [];
        this.dragEnterTargetIds = [];
        this.currentNativeSource = null;
        this.currentNativeHandle = null;
        this.currentDragSourceNode = null;
        this.altKeyPressed = false;
        this.mouseMoveTimeoutTimer = null;
        this.asyncEndDragFrameId = null;
        this.dragOverTargetIds = null;
        this.lastClientOffset = null;
        this.hoverRafId = null;
        this.getSourceClientOffset = (sourceId) => {
          const source = this.sourceNodes.get(sourceId);
          return source && getNodeClientOffset(source) || null;
        };
        this.endDragNativeItem = () => {
          if (!this.isDraggingNativeItem()) {
            return;
          }
          this.actions.endDrag();
          if (this.currentNativeHandle) {
            this.registry.removeSource(this.currentNativeHandle);
          }
          this.currentNativeHandle = null;
          this.currentNativeSource = null;
        };
        this.isNodeInDocument = (node2) => {
          return Boolean(node2 && this.document && this.document.body && this.document.body.contains(node2));
        };
        this.endDragIfSourceWasRemovedFromDOM = () => {
          const node2 = this.currentDragSourceNode;
          if (node2 == null || this.isNodeInDocument(node2)) {
            return;
          }
          if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
            this.actions.endDrag();
          }
          this.cancelHover();
        };
        this.scheduleHover = (dragOverTargetIds) => {
          if (this.hoverRafId === null && typeof requestAnimationFrame !== "undefined") {
            this.hoverRafId = requestAnimationFrame(() => {
              if (this.monitor.isDragging()) {
                this.actions.hover(dragOverTargetIds || [], {
                  clientOffset: this.lastClientOffset
                });
              }
              this.hoverRafId = null;
            });
          }
        };
        this.cancelHover = () => {
          if (this.hoverRafId !== null && typeof cancelAnimationFrame !== "undefined") {
            cancelAnimationFrame(this.hoverRafId);
            this.hoverRafId = null;
          }
        };
        this.handleTopDragStartCapture = () => {
          this.clearCurrentDragSourceNode();
          this.dragStartSourceIds = [];
        };
        this.handleTopDragStart = (e2) => {
          if (e2.defaultPrevented) {
            return;
          }
          const { dragStartSourceIds } = this;
          this.dragStartSourceIds = null;
          const clientOffset = getEventClientOffset(e2);
          if (this.monitor.isDragging()) {
            this.actions.endDrag();
            this.cancelHover();
          }
          this.actions.beginDrag(dragStartSourceIds || [], {
            publishSource: false,
            getSourceClientOffset: this.getSourceClientOffset,
            clientOffset
          });
          const { dataTransfer } = e2;
          const nativeType = matchNativeItemType(dataTransfer);
          if (this.monitor.isDragging()) {
            if (dataTransfer && typeof dataTransfer.setDragImage === "function") {
              const sourceId = this.monitor.getSourceId();
              const sourceNode = this.sourceNodes.get(sourceId);
              const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;
              if (dragPreview) {
                const { anchorX, anchorY, offsetX, offsetY } = this.getCurrentSourcePreviewNodeOptions();
                const anchorPoint = {
                  anchorX,
                  anchorY
                };
                const offsetPoint = {
                  offsetX,
                  offsetY
                };
                const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);
                dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);
              }
            }
            try {
              dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData("application/json", {});
            } catch (err) {
            }
            this.setCurrentDragSourceNode(e2.target);
            const { captureDraggingState } = this.getCurrentSourcePreviewNodeOptions();
            if (!captureDraggingState) {
              setTimeout(
                () => this.actions.publishDragSource(),
                0
              );
            } else {
              this.actions.publishDragSource();
            }
          } else if (nativeType) {
            this.beginDragNativeItem(nativeType);
          } else if (dataTransfer && !dataTransfer.types && (e2.target && !e2.target.hasAttribute || !e2.target.hasAttribute("draggable"))) {
            return;
          } else {
            e2.preventDefault();
          }
        };
        this.handleTopDragEndCapture = () => {
          if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
            this.actions.endDrag();
          }
          this.cancelHover();
        };
        this.handleTopDragEnterCapture = (e2) => {
          this.dragEnterTargetIds = [];
          if (this.isDraggingNativeItem()) {
            var ref;
            (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e2.dataTransfer);
          }
          const isFirstEnter = this.enterLeaveCounter.enter(e2.target);
          if (!isFirstEnter || this.monitor.isDragging()) {
            return;
          }
          const { dataTransfer } = e2;
          const nativeType = matchNativeItemType(dataTransfer);
          if (nativeType) {
            this.beginDragNativeItem(nativeType, dataTransfer);
          }
        };
        this.handleTopDragEnter = (e2) => {
          const { dragEnterTargetIds } = this;
          this.dragEnterTargetIds = [];
          if (!this.monitor.isDragging()) {
            return;
          }
          this.altKeyPressed = e2.altKey;
          if (dragEnterTargetIds.length > 0) {
            this.actions.hover(dragEnterTargetIds, {
              clientOffset: getEventClientOffset(e2)
            });
          }
          const canDrop = dragEnterTargetIds.some(
            (targetId) => this.monitor.canDropOnTarget(targetId)
          );
          if (canDrop) {
            e2.preventDefault();
            if (e2.dataTransfer) {
              e2.dataTransfer.dropEffect = this.getCurrentDropEffect();
            }
          }
        };
        this.handleTopDragOverCapture = (e2) => {
          this.dragOverTargetIds = [];
          if (this.isDraggingNativeItem()) {
            var ref;
            (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e2.dataTransfer);
          }
        };
        this.handleTopDragOver = (e2) => {
          const { dragOverTargetIds } = this;
          this.dragOverTargetIds = [];
          if (!this.monitor.isDragging()) {
            e2.preventDefault();
            if (e2.dataTransfer) {
              e2.dataTransfer.dropEffect = "none";
            }
            return;
          }
          this.altKeyPressed = e2.altKey;
          this.lastClientOffset = getEventClientOffset(e2);
          this.scheduleHover(dragOverTargetIds);
          const canDrop = (dragOverTargetIds || []).some(
            (targetId) => this.monitor.canDropOnTarget(targetId)
          );
          if (canDrop) {
            e2.preventDefault();
            if (e2.dataTransfer) {
              e2.dataTransfer.dropEffect = this.getCurrentDropEffect();
            }
          } else if (this.isDraggingNativeItem()) {
            e2.preventDefault();
          } else {
            e2.preventDefault();
            if (e2.dataTransfer) {
              e2.dataTransfer.dropEffect = "none";
            }
          }
        };
        this.handleTopDragLeaveCapture = (e2) => {
          if (this.isDraggingNativeItem()) {
            e2.preventDefault();
          }
          const isLastLeave = this.enterLeaveCounter.leave(e2.target);
          if (!isLastLeave) {
            return;
          }
          if (this.isDraggingNativeItem()) {
            setTimeout(
              () => this.endDragNativeItem(),
              0
            );
          }
          this.cancelHover();
        };
        this.handleTopDropCapture = (e2) => {
          this.dropTargetIds = [];
          if (this.isDraggingNativeItem()) {
            var ref;
            e2.preventDefault();
            (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e2.dataTransfer);
          } else if (matchNativeItemType(e2.dataTransfer)) {
            e2.preventDefault();
          }
          this.enterLeaveCounter.reset();
        };
        this.handleTopDrop = (e2) => {
          const { dropTargetIds } = this;
          this.dropTargetIds = [];
          this.actions.hover(dropTargetIds, {
            clientOffset: getEventClientOffset(e2)
          });
          this.actions.drop({
            dropEffect: this.getCurrentDropEffect()
          });
          if (this.isDraggingNativeItem()) {
            this.endDragNativeItem();
          } else if (this.monitor.isDragging()) {
            this.actions.endDrag();
          }
          this.cancelHover();
        };
        this.handleSelectStart = (e2) => {
          const target = e2.target;
          if (typeof target.dragDrop !== "function") {
            return;
          }
          if (target.tagName === "INPUT" || target.tagName === "SELECT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
            return;
          }
          e2.preventDefault();
          target.dragDrop();
        };
        this.options = new OptionsReader(globalContext, options);
        this.actions = manager.getActions();
        this.monitor = manager.getMonitor();
        this.registry = manager.getRegistry();
        this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);
      }
    }
    const HTML5Backend = function createBackend(manager, context, options) {
      return new HTML5BackendImpl(manager, context, options);
    };
    var dist = {};
    var Nestable$2 = {};
    var Nestable$1 = {};
    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    function is(x2, y2) {
      if (x2 === y2) {
        return x2 !== 0 || y2 !== 0 || 1 / x2 === 1 / y2;
      } else {
        return x2 !== x2 && y2 !== y2;
      }
    }
    function shallowEqual(objA, objB) {
      if (is(objA, objB)) {
        return true;
      }
      if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      for (var i2 = 0; i2 < keysA.length; i2++) {
        if (!hasOwnProperty$2.call(objB, keysA[i2]) || !is(objA[keysA[i2]], objB[keysA[i2]])) {
          return false;
        }
      }
      return true;
    }
    function shallowCompare(instance, nextProps, nextState) {
      return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
    }
    var reactAddonsShallowCompare = shallowCompare;
    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
          return test2[n2];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from2 = Object(arguments[s]);
        for (var key in from2) {
          if (hasOwnProperty$1.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from2, symbols[i2])) {
              to[symbols[i2]] = from2[symbols[i2]];
            }
          }
        }
      }
      return to;
    };
    var _assign = objectAssign;
    var hasOwnProperty = {}.hasOwnProperty;
    function invariant(condition, format2, a, b2, c2, d2, e2, f2) {
      if (!condition) {
        var error;
        if (format2 === void 0) {
          error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        } else {
          var args = [a, b2, c2, d2, e2, f2];
          var argIndex = 0;
          error = new Error(format2.replace(/%s/g, function() {
            return args[argIndex++];
          }));
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    }
    function shallowCopy(x2) {
      if (Array.isArray(x2)) {
        return x2.concat();
      } else if (x2 && typeof x2 === "object") {
        return _assign(new x2.constructor(), x2);
      } else {
        return x2;
      }
    }
    var COMMAND_PUSH = "$push";
    var COMMAND_UNSHIFT = "$unshift";
    var COMMAND_SPLICE = "$splice";
    var COMMAND_SET = "$set";
    var COMMAND_MERGE = "$merge";
    var COMMAND_APPLY = "$apply";
    var ALL_COMMANDS_LIST = [
      COMMAND_PUSH,
      COMMAND_UNSHIFT,
      COMMAND_SPLICE,
      COMMAND_SET,
      COMMAND_MERGE,
      COMMAND_APPLY
    ];
    var ALL_COMMANDS_SET = {};
    ALL_COMMANDS_LIST.forEach(function(command) {
      ALL_COMMANDS_SET[command] = true;
    });
    function invariantArrayCase(value, spec, command) {
      invariant(
        Array.isArray(value),
        "update(): expected target of %s to be an array; got %s.",
        command,
        value
      );
      var specValue = spec[command];
      invariant(
        Array.isArray(specValue),
        "update(): expected spec of %s to be an array; got %s. Did you forget to wrap your parameter in an array?",
        command,
        specValue
      );
    }
    function update$1(value, spec) {
      invariant(
        typeof spec === "object",
        "update(): You provided a key path to update() that did not contain one of %s. Did you forget to include {%s: ...}?",
        ALL_COMMANDS_LIST.join(", "),
        COMMAND_SET
      );
      if (hasOwnProperty.call(spec, COMMAND_SET)) {
        invariant(
          Object.keys(spec).length === 1,
          "Cannot have more than one key in an object with %s",
          COMMAND_SET
        );
        return spec[COMMAND_SET];
      }
      var nextValue = shallowCopy(value);
      if (hasOwnProperty.call(spec, COMMAND_MERGE)) {
        var mergeObj = spec[COMMAND_MERGE];
        invariant(
          mergeObj && typeof mergeObj === "object",
          "update(): %s expects a spec of type 'object'; got %s",
          COMMAND_MERGE,
          mergeObj
        );
        invariant(
          nextValue && typeof nextValue === "object",
          "update(): %s expects a target of type 'object'; got %s",
          COMMAND_MERGE,
          nextValue
        );
        _assign(nextValue, spec[COMMAND_MERGE]);
      }
      if (hasOwnProperty.call(spec, COMMAND_PUSH)) {
        invariantArrayCase(value, spec, COMMAND_PUSH);
        spec[COMMAND_PUSH].forEach(function(item) {
          nextValue.push(item);
        });
      }
      if (hasOwnProperty.call(spec, COMMAND_UNSHIFT)) {
        invariantArrayCase(value, spec, COMMAND_UNSHIFT);
        spec[COMMAND_UNSHIFT].forEach(function(item) {
          nextValue.unshift(item);
        });
      }
      if (hasOwnProperty.call(spec, COMMAND_SPLICE)) {
        invariant(
          Array.isArray(value),
          "Expected %s target to be an array; got %s",
          COMMAND_SPLICE,
          value
        );
        invariant(
          Array.isArray(spec[COMMAND_SPLICE]),
          "update(): expected spec of %s to be an array of arrays; got %s. Did you forget to wrap your parameters in an array?",
          COMMAND_SPLICE,
          spec[COMMAND_SPLICE]
        );
        spec[COMMAND_SPLICE].forEach(function(args) {
          invariant(
            Array.isArray(args),
            "update(): expected spec of %s to be an array of arrays; got %s. Did you forget to wrap your parameters in an array?",
            COMMAND_SPLICE,
            spec[COMMAND_SPLICE]
          );
          nextValue.splice.apply(nextValue, args);
        });
      }
      if (hasOwnProperty.call(spec, COMMAND_APPLY)) {
        invariant(
          typeof spec[COMMAND_APPLY] === "function",
          "update(): expected spec of %s to be a function; got %s.",
          COMMAND_APPLY,
          spec[COMMAND_APPLY]
        );
        nextValue = spec[COMMAND_APPLY](nextValue);
      }
      for (var k2 in spec) {
        if (!(ALL_COMMANDS_SET.hasOwnProperty(k2) && ALL_COMMANDS_SET[k2])) {
          nextValue[k2] = update$1(value[k2], spec[k2]);
        }
      }
      return nextValue;
    }
    var reactAddonsUpdate = update$1;
    var utils = {};
    Object.defineProperty(utils, "__esModule", {
      value: true
    });
    utils.getAllNonEmptyNodesIds = utils.listWithChildren = utils.getTransformProps = utils.getTotalScroll = utils.getOffsetRect = utils.closest = utils.isArray = utils.isString = utils.isNumber = utils.isFunction = utils.isUndefined = utils.isDefined = utils.objectType = void 0;
    function ownKeys(object2, enumerableOnly) {
      var keys2 = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        if (i2 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var objectType = function objectType2(obj) {
      return Object.prototype.toString.call(obj).slice(8, -1);
    };
    utils.objectType = objectType;
    var isDefined = function isDefined2(param) {
      return typeof param != "undefined";
    };
    utils.isDefined = isDefined;
    var isUndefined = function isUndefined2(param) {
      return typeof param == "undefined";
    };
    utils.isUndefined = isUndefined;
    var isFunction = function isFunction2(param) {
      return typeof param == "function";
    };
    utils.isFunction = isFunction;
    var isNumber = function isNumber2(param) {
      return typeof param == "number" && !isNaN(param);
    };
    utils.isNumber = isNumber;
    var isString = function isString2(str) {
      return objectType(str) === "String";
    };
    utils.isString = isString;
    var isArray = function isArray2(arr) {
      return objectType(arr) === "Array";
    };
    utils.isArray = isArray;
    var closest = function closest2(target, selector) {
      while (target) {
        if (target.matches && target.matches(selector))
          return target;
        target = target.parentNode;
      }
      return null;
    };
    utils.closest = closest;
    var getOffsetRect = function getOffsetRect2(elem) {
      var box2 = elem.getBoundingClientRect();
      var body = document.body;
      var docElem = document.documentElement;
      var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
      var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
      var clientTop = docElem.clientTop || body.clientTop || 0;
      var clientLeft = docElem.clientLeft || body.clientLeft || 0;
      var top = box2.top + scrollTop - clientTop;
      var left = box2.left + scrollLeft - clientLeft;
      return {
        top: Math.round(top),
        left: Math.round(left)
      };
    };
    utils.getOffsetRect = getOffsetRect;
    var getTotalScroll = function getTotalScroll2(elem) {
      var top = 0;
      var left = 0;
      while (elem = elem.parentNode) {
        top += elem.scrollTop || 0;
        left += elem.scrollLeft || 0;
      }
      return {
        top,
        left
      };
    };
    utils.getTotalScroll = getTotalScroll;
    var getTransformProps = function getTransformProps2(x2, y2) {
      return {
        transform: "translate(" + x2 + "px, " + y2 + "px)"
      };
    };
    utils.getTransformProps = getTransformProps;
    var listWithChildren = function listWithChildren2(list2, childrenProp) {
      return list2.map(function(item) {
        return _objectSpread(_objectSpread({}, item), {}, _defineProperty({}, childrenProp, item[childrenProp] ? listWithChildren2(item[childrenProp], childrenProp) : []));
      });
    };
    utils.listWithChildren = listWithChildren;
    var getAllNonEmptyNodesIds = function getAllNonEmptyNodesIds2(items, _ref) {
      var idProp = _ref.idProp, childrenProp = _ref.childrenProp;
      var childrenIds = [];
      var ids = items.filter(function(item) {
        return item[childrenProp].length;
      }).map(function(item) {
        childrenIds = childrenIds.concat(getAllNonEmptyNodesIds2(item[childrenProp], {
          idProp,
          childrenProp
        }));
        return item[idProp];
      });
      return ids.concat(childrenIds);
    };
    utils.getAllNonEmptyNodesIds = getAllNonEmptyNodesIds;
    var NestableItem = {};
    var Icon$1 = {};
    var Icon = {};
    (function(exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2["default"] = void 0;
      var _react2 = _interopRequireWildcard2(reactExports);
      var _propTypes = _interopRequireDefault2(propTypesExports);
      var _classnames = _interopRequireDefault2(classnamesExports);
      var _excluded4 = ["children", "className"];
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _getRequireWildcardCache2(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache2 = function _getRequireWildcardCache3(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard2(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache2(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends2() {
        _extends2 = Object.assign || function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends2.apply(this, arguments);
      }
      function _objectWithoutProperties2(source, excluded) {
        if (source == null)
          return {};
        var target = _objectWithoutPropertiesLoose2(source, excluded);
        var key, i2;
        if (Object.getOwnPropertySymbols) {
          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
          for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
            key = sourceSymbolKeys[i2];
            if (excluded.indexOf(key) >= 0)
              continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key))
              continue;
            target[key] = source[key];
          }
        }
        return target;
      }
      function _objectWithoutPropertiesLoose2(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i2;
        for (i2 = 0; i2 < sourceKeys.length; i2++) {
          key = sourceKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o2, p2) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf2(o2, p2);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call2) {
        if (call2 && (_typeof2(call2) === "object" || typeof call2 === "function")) {
          return call2;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _getPrototypeOf2(o2) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o3) {
          return o3.__proto__ || Object.getPrototypeOf(o3);
        };
        return _getPrototypeOf2(o2);
      }
      var Icon2 = /* @__PURE__ */ function(_Component) {
        _inherits2(Icon3, _Component);
        var _super = _createSuper2(Icon3);
        function Icon3() {
          _classCallCheck2(this, Icon3);
          return _super.apply(this, arguments);
        }
        _createClass2(Icon3, [{
          key: "render",
          value: function render2() {
            var _this$props = this.props;
            _this$props.children;
            var className = _this$props.className, props = _objectWithoutProperties2(_this$props, _excluded4);
            return /* @__PURE__ */ _react2["default"].createElement("i", _extends2({
              className: (0, _classnames["default"])("nestable-icon", className)
            }, props));
          }
        }]);
        return Icon3;
      }(_react2.Component);
      Icon2.propTypes = {
        children: _propTypes["default"].any,
        className: _propTypes["default"].string
      };
      var _default2 = Icon2;
      exports2["default"] = _default2;
    })(Icon);
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2["default"] = void 0;
      var _Icon = _interopRequireDefault2(Icon);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _default2 = _Icon["default"];
      exports2["default"] = _default2;
    })(Icon$1);
    (function(exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2["default"] = void 0;
      var _react2 = _interopRequireWildcard2(reactExports);
      var _propTypes = _interopRequireDefault2(propTypesExports);
      var _classnames = _interopRequireDefault2(classnamesExports);
      var _Icon = _interopRequireDefault2(Icon$1);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _getRequireWildcardCache2(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache2 = function _getRequireWildcardCache3(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard2(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache2(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends2() {
        _extends2 = Object.assign || function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends2.apply(this, arguments);
      }
      function ownKeys2(object2, enumerableOnly) {
        var keys2 = Object.keys(object2);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object2);
          if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
            });
          }
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread3(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2] != null ? arguments[i2] : {};
          if (i2 % 2) {
            ownKeys2(Object(source), true).forEach(function(key) {
              _defineProperty2(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys2(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o2, p2) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf2(o2, p2);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call2) {
        if (call2 && (_typeof2(call2) === "object" || typeof call2 === "function")) {
          return call2;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _getPrototypeOf2(o2) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o3) {
          return o3.__proto__ || Object.getPrototypeOf(o3);
        };
        return _getPrototypeOf2(o2);
      }
      function _defineProperty2(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var NestableItem2 = /* @__PURE__ */ function(_Component) {
        _inherits2(NestableItem3, _Component);
        var _super = _createSuper2(NestableItem3);
        function NestableItem3() {
          var _this;
          _classCallCheck2(this, NestableItem3);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty2(_assertThisInitialized2(_this), "renderCollapseIcon", function(_ref) {
            var isCollapsed = _ref.isCollapsed;
            return /* @__PURE__ */ _react2["default"].createElement(_Icon["default"], {
              className: (0, _classnames["default"])("nestable-item-icon", {
                "icon-plus-gray": isCollapsed,
                "icon-minus-gray": !isCollapsed
              })
            });
          });
          return _this;
        }
        _createClass2(NestableItem3, [{
          key: "render",
          value: function render2() {
            var _cx;
            var _this$props = this.props, item = _this$props.item, isCopy = _this$props.isCopy, options = _this$props.options, index2 = _this$props.index, depth = _this$props.depth;
            var dragItem = options.dragItem, renderItem = options.renderItem, handler = options.handler, idProp = options.idProp, childrenProp = options.childrenProp, _options$renderCollap = options.renderCollapseIcon, renderCollapseIcon = _options$renderCollap === void 0 ? this.renderCollapseIcon : _options$renderCollap;
            var isCollapsed = options.isCollapsed(item);
            var isDragging = !isCopy && dragItem && dragItem[idProp] === item[idProp];
            var hasChildren = item[childrenProp] && item[childrenProp].length > 0;
            var rowProps = {};
            var handlerProps = {};
            var wrappedHandler;
            if (!isCopy) {
              if (dragItem) {
                rowProps = _objectSpread3(_objectSpread3({}, rowProps), {}, {
                  onMouseEnter: function onMouseEnter(e2) {
                    return options.onMouseEnter(e2, item);
                  }
                });
              } else {
                handlerProps = _objectSpread3(_objectSpread3({}, handlerProps), {}, {
                  draggable: true,
                  onDragStart: function onDragStart(e2) {
                    return options.onDragStart(e2, item);
                  }
                });
              }
            }
            if (handler) {
              wrappedHandler = /* @__PURE__ */ _react2["default"].createElement("span", _extends2({
                className: "nestable-item-handler"
              }, handlerProps), handler);
            } else {
              rowProps = _objectSpread3(_objectSpread3({}, rowProps), handlerProps);
            }
            var collapseIcon = hasChildren ? /* @__PURE__ */ _react2["default"].createElement("span", {
              onClick: function onClick() {
                return options.onToggleCollapse(item);
              }
            }, renderCollapseIcon({
              isCollapsed
            })) : null;
            var baseClassName = "nestable-item" + (isCopy ? "-copy" : "");
            var itemProps = {
              className: (0, _classnames["default"])(baseClassName, baseClassName + "-" + item[idProp], (_cx = {
                "is-dragging": isDragging
              }, _defineProperty2(_cx, baseClassName + "--with-children", hasChildren), _defineProperty2(_cx, baseClassName + "--children-open", hasChildren && !isCollapsed), _defineProperty2(_cx, baseClassName + "--children-collapsed", hasChildren && isCollapsed), _cx))
            };
            var content2 = renderItem({
              collapseIcon,
              depth,
              handler: wrappedHandler,
              index: index2,
              item
            });
            if (!content2)
              return null;
            return /* @__PURE__ */ _react2["default"].createElement("li", itemProps, /* @__PURE__ */ _react2["default"].createElement("div", _extends2({
              className: "nestable-item-name"
            }, rowProps), content2), hasChildren && !isCollapsed && /* @__PURE__ */ _react2["default"].createElement("ol", {
              className: "nestable-list"
            }, item[childrenProp].map(function(item2, i2) {
              return /* @__PURE__ */ _react2["default"].createElement(NestableItem3, {
                key: i2,
                index: i2,
                depth: depth + 1,
                item: item2,
                options,
                isCopy
              });
            })));
          }
        }]);
        return NestableItem3;
      }(_react2.Component);
      _defineProperty2(NestableItem2, "propTypes", {
        item: _propTypes["default"].object,
        isCopy: _propTypes["default"].bool,
        options: _propTypes["default"].object,
        index: _propTypes["default"].number,
        depth: _propTypes["default"].number
      });
      _defineProperty2(NestableItem2, "defaultProps", {
        depth: 0
      });
      var _default2 = NestableItem2;
      exports2["default"] = _default2;
    })(NestableItem);
    (function(exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2["default"] = void 0;
      var _react2 = _interopRequireWildcard2(reactExports);
      var _propTypes = _interopRequireDefault2(propTypesExports);
      var _reactAddonsShallowCompare = _interopRequireDefault2(reactAddonsShallowCompare);
      var _reactAddonsUpdate = _interopRequireDefault2(reactAddonsUpdate);
      var _classnames = _interopRequireDefault2(classnamesExports);
      var _utils = utils;
      var _NestableItem = _interopRequireDefault2(NestableItem);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _getRequireWildcardCache2(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache2 = function _getRequireWildcardCache3(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard2(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache2(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function ownKeys2(object2, enumerableOnly) {
        var keys2 = Object.keys(object2);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object2);
          if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
            });
          }
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread3(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2] != null ? arguments[i2] : {};
          if (i2 % 2) {
            ownKeys2(Object(source), true).forEach(function(key) {
              _defineProperty2(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys2(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _toConsumableArray2(arr) {
        return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
      }
      function _nonIterableSpread2() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray2(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray2(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray2(o2, minLen);
      }
      function _iterableToArray2(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
          return Array.from(iter);
      }
      function _arrayWithoutHoles2(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray2(arr);
      }
      function _arrayLikeToArray2(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o2, p2) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf2(o2, p2);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call2) {
        if (call2 && (_typeof2(call2) === "object" || typeof call2 === "function")) {
          return call2;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _getPrototypeOf2(o2) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o3) {
          return o3.__proto__ || Object.getPrototypeOf(o3);
        };
        return _getPrototypeOf2(o2);
      }
      function _defineProperty2(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var Nestable2 = /* @__PURE__ */ function(_Component) {
        _inherits2(Nestable3, _Component);
        var _super = _createSuper2(Nestable3);
        function Nestable3(props) {
          var _this;
          _classCallCheck2(this, Nestable3);
          _this = _super.call(this, props);
          _defineProperty2(_assertThisInitialized2(_this), "collapse", function(itemIds) {
            var _this$props = _this.props, idProp = _this$props.idProp, childrenProp = _this$props.childrenProp, collapsed = _this$props.collapsed;
            var items = _this.state.items;
            if (itemIds === "NONE") {
              _this.setState({
                collapsedGroups: collapsed ? (0, _utils.getAllNonEmptyNodesIds)(items, {
                  idProp,
                  childrenProp
                }) : []
              });
            } else if (itemIds === "ALL") {
              _this.setState({
                collapsedGroups: collapsed ? [] : (0, _utils.getAllNonEmptyNodesIds)(items, {
                  idProp,
                  childrenProp
                })
              });
            } else if ((0, _utils.isArray)(itemIds)) {
              _this.setState({
                collapsedGroups: (0, _utils.getAllNonEmptyNodesIds)(items, {
                  idProp,
                  childrenProp
                }).filter(function(id2) {
                  return itemIds.indexOf(id2) > -1 ^ collapsed;
                })
              });
            }
          });
          _defineProperty2(_assertThisInitialized2(_this), "startTrackMouse", function() {
            document.addEventListener("mousemove", _this.onMouseMove);
            document.addEventListener("mouseup", _this.onDragEnd);
            document.addEventListener("keydown", _this.onKeyDown);
          });
          _defineProperty2(_assertThisInitialized2(_this), "stopTrackMouse", function() {
            document.removeEventListener("mousemove", _this.onMouseMove);
            document.removeEventListener("mouseup", _this.onDragEnd);
            document.removeEventListener("keydown", _this.onKeyDown);
            _this.elCopyStyles = null;
          });
          _defineProperty2(_assertThisInitialized2(_this), "getItemDepth", function(item) {
            var childrenProp = _this.props.childrenProp;
            var level = 1;
            if (item[childrenProp].length > 0) {
              var childrenDepths = item[childrenProp].map(_this.getItemDepth);
              level += Math.max.apply(Math, _toConsumableArray2(childrenDepths));
            }
            return level;
          });
          _defineProperty2(_assertThisInitialized2(_this), "isCollapsed", function(item) {
            var _this$props2 = _this.props, collapsed = _this$props2.collapsed, idProp = _this$props2.idProp;
            var collapsedGroups = _this.state.collapsedGroups;
            return !!(collapsedGroups.indexOf(item[idProp]) > -1 ^ collapsed);
          });
          _defineProperty2(_assertThisInitialized2(_this), "onDragStart", function(e2, item) {
            if (e2) {
              e2.preventDefault();
              e2.stopPropagation();
            }
            _this.el = (0, _utils.closest)(e2.target, ".nestable-item");
            _this.startTrackMouse();
            _this.onMouseMove(e2);
            _this.setState({
              dragItem: item,
              itemsOld: _this.state.items
            });
          });
          _defineProperty2(_assertThisInitialized2(_this), "onDragEnd", function(e2, isCancel2) {
            e2 && e2.preventDefault();
            _this.stopTrackMouse();
            _this.el = null;
            isCancel2 ? _this.dragRevert() : _this.dragApply();
          });
          _defineProperty2(_assertThisInitialized2(_this), "onMouseMove", function(e2) {
            var _this$props3 = _this.props, group = _this$props3.group, threshold = _this$props3.threshold;
            var dragItem = _this.state.dragItem;
            var clientX = e2.clientX, clientY = e2.clientY;
            var transformProps = (0, _utils.getTransformProps)(clientX, clientY);
            var elCopy = document.querySelector(".nestable-" + group + " .nestable-drag-layer > .nestable-list");
            if (!_this.elCopyStyles) {
              var offset2 = (0, _utils.getOffsetRect)(_this.el);
              var scroll = (0, _utils.getTotalScroll)(_this.el);
              _this.elCopyStyles = _objectSpread3({
                marginTop: offset2.top - clientY - scroll.top,
                marginLeft: offset2.left - clientX - scroll.left
              }, transformProps);
            } else {
              _this.elCopyStyles = _objectSpread3(_objectSpread3({}, _this.elCopyStyles), transformProps);
              for (var key in transformProps) {
                if (transformProps.hasOwnProperty(key)) {
                  elCopy.style[key] = transformProps[key];
                }
              }
              var diffX = clientX - _this.mouse.last.x;
              if (diffX >= 0 && _this.mouse.shift.x >= 0 || diffX <= 0 && _this.mouse.shift.x <= 0) {
                _this.mouse.shift.x += diffX;
              } else {
                _this.mouse.shift.x = 0;
              }
              _this.mouse.last.x = clientX;
              if (Math.abs(_this.mouse.shift.x) > threshold) {
                if (_this.mouse.shift.x > 0) {
                  _this.tryIncreaseDepth(dragItem);
                } else {
                  _this.tryDecreaseDepth(dragItem);
                }
                _this.mouse.shift.x = 0;
              }
            }
          });
          _defineProperty2(_assertThisInitialized2(_this), "onMouseEnter", function(e2, item) {
            if (e2) {
              e2.preventDefault();
              e2.stopPropagation();
            }
            var _this$props4 = _this.props, collapsed = _this$props4.collapsed, idProp = _this$props4.idProp, childrenProp = _this$props4.childrenProp;
            var dragItem = _this.state.dragItem;
            if (dragItem[idProp] === item[idProp])
              return;
            var pathFrom = _this.getPathById(dragItem[idProp]);
            var pathTo = _this.getPathById(item[idProp]);
            var collapseProps = {};
            if (collapsed && pathFrom.length > 1) {
              var parent = _this.getItemByPath(pathFrom.slice(0, -1));
              if (parent[childrenProp].length === 1) {
                collapseProps = _this.onToggleCollapse(parent, true);
              }
            }
            _this.moveItem({
              dragItem,
              pathFrom,
              pathTo
            }, collapseProps);
          });
          _defineProperty2(_assertThisInitialized2(_this), "onToggleCollapse", function(item, isGetter) {
            var _this$props5 = _this.props, collapsed = _this$props5.collapsed, idProp = _this$props5.idProp;
            var collapsedGroups = _this.state.collapsedGroups;
            var isCollapsed = _this.isCollapsed(item);
            var newState = {
              collapsedGroups: isCollapsed ^ collapsed ? collapsedGroups.filter(function(id2) {
                return id2 !== item[idProp];
              }) : collapsedGroups.concat(item[idProp])
            };
            if (isGetter) {
              return newState;
            } else {
              _this.setState(newState);
            }
          });
          _defineProperty2(_assertThisInitialized2(_this), "onKeyDown", function(e2) {
            if (e2.which === 27) {
              _this.onDragEnd(null, true);
            }
          });
          _this.state = {
            items: [],
            itemsOld: null,
            // snap copy in case of canceling drag
            dragItem: null,
            isDirty: false,
            collapsedGroups: []
          };
          _this.el = null;
          _this.elCopyStyles = null;
          _this.mouse = {
            last: {
              x: 0
            },
            shift: {
              x: 0
            }
          };
          return _this;
        }
        _createClass2(Nestable3, [{
          key: "componentDidMount",
          value: function componentDidMount() {
            var _this$props6 = this.props, items = _this$props6.items, childrenProp = _this$props6.childrenProp;
            items = (0, _utils.listWithChildren)(items, childrenProp);
            this.setState({
              items
            });
          }
        }, {
          key: "componentDidUpdate",
          value: function componentDidUpdate(prevProps) {
            var _this$props7 = this.props, itemsNew = _this$props7.items, childrenProp = _this$props7.childrenProp;
            var isPropsUpdated = (0, _reactAddonsShallowCompare["default"])({
              props: prevProps,
              state: {}
            }, this.props, {});
            if (isPropsUpdated) {
              this.stopTrackMouse();
              var extra = {};
              if (prevProps.collapsed !== this.props.collapsed) {
                extra.collapsedGroups = [];
              }
              this.setState(_objectSpread3({
                items: (0, _utils.listWithChildren)(itemsNew, childrenProp),
                dragItem: null,
                isDirty: false
              }, extra));
            }
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.stopTrackMouse();
          }
          // ––––––––––––––––––––––––––––––––––––
          // Public Methods
          // ––––––––––––––––––––––––––––––––––––
        }, {
          key: "moveItem",
          value: function moveItem(_ref) {
            var dragItem = _ref.dragItem, pathFrom = _ref.pathFrom, pathTo = _ref.pathTo;
            var extraProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var _this$props8 = this.props, childrenProp = _this$props8.childrenProp, confirmChange = _this$props8.confirmChange;
            var dragItemSize = this.getItemDepth(dragItem);
            var items = this.state.items;
            var realPathTo = this.getRealNextPath(pathFrom, pathTo, dragItemSize);
            if (realPathTo.length === 0)
              return;
            var destinationPath = realPathTo.length > pathTo.length ? pathTo : pathTo.slice(0, -1);
            var destinationParent = this.getItemByPath(destinationPath);
            if (!confirmChange({
              dragItem,
              destinationParent
            }))
              return;
            var removePath = this.getSplicePath(pathFrom, {
              numToRemove: 1,
              childrenProp
            });
            var insertPath = this.getSplicePath(realPathTo, {
              numToRemove: 0,
              itemsToInsert: [dragItem],
              childrenProp
            });
            items = (0, _reactAddonsUpdate["default"])(items, removePath);
            items = (0, _reactAddonsUpdate["default"])(items, insertPath);
            this.setState(_objectSpread3({
              items,
              isDirty: true
            }, extraProps));
          }
        }, {
          key: "tryIncreaseDepth",
          value: function tryIncreaseDepth(dragItem) {
            var _this$props9 = this.props, maxDepth = _this$props9.maxDepth, idProp = _this$props9.idProp, childrenProp = _this$props9.childrenProp, collapsed = _this$props9.collapsed;
            var pathFrom = this.getPathById(dragItem[idProp]);
            var itemIndex = pathFrom[pathFrom.length - 1];
            var newDepth = pathFrom.length + this.getItemDepth(dragItem);
            if (itemIndex > 0 && newDepth <= maxDepth) {
              var prevSibling = this.getItemByPath(pathFrom.slice(0, -1).concat(itemIndex - 1));
              if (!prevSibling[childrenProp].length || !this.isCollapsed(prevSibling)) {
                var pathTo = pathFrom.slice(0, -1).concat(itemIndex - 1).concat(prevSibling[childrenProp].length);
                var collapseProps = {};
                if (collapsed && !prevSibling[childrenProp].length) {
                  collapseProps = this.onToggleCollapse(prevSibling, true);
                }
                this.moveItem({
                  dragItem,
                  pathFrom,
                  pathTo
                }, collapseProps);
              }
            }
          }
        }, {
          key: "tryDecreaseDepth",
          value: function tryDecreaseDepth(dragItem) {
            var _this$props10 = this.props, idProp = _this$props10.idProp, childrenProp = _this$props10.childrenProp, collapsed = _this$props10.collapsed;
            var pathFrom = this.getPathById(dragItem[idProp]);
            var itemIndex = pathFrom[pathFrom.length - 1];
            if (pathFrom.length > 1) {
              var parent = this.getItemByPath(pathFrom.slice(0, -1));
              if (itemIndex + 1 === parent[childrenProp].length) {
                var pathTo = pathFrom.slice(0, -1);
                pathTo[pathTo.length - 1] += 1;
                var collapseProps = {};
                if (collapsed && parent[childrenProp].length === 1) {
                  collapseProps = this.onToggleCollapse(parent, true);
                }
                this.moveItem({
                  dragItem,
                  pathFrom,
                  pathTo
                }, collapseProps);
              }
            }
          }
        }, {
          key: "dragApply",
          value: function dragApply() {
            var _this$props11 = this.props, onChange = _this$props11.onChange, idProp = _this$props11.idProp;
            var _this$state = this.state, items = _this$state.items, isDirty = _this$state.isDirty, dragItem = _this$state.dragItem;
            this.setState({
              itemsOld: null,
              dragItem: null,
              isDirty: false
            });
            if (onChange && isDirty) {
              var targetPath = this.getPathById(dragItem[idProp], items);
              onChange({
                items,
                dragItem,
                targetPath
              });
            }
          }
        }, {
          key: "dragRevert",
          value: function dragRevert() {
            var itemsOld = this.state.itemsOld;
            this.setState({
              items: itemsOld,
              itemsOld: null,
              dragItem: null,
              isDirty: false
            });
          }
          // ––––––––––––––––––––––––––––––––––––
          // Getter methods
          // ––––––––––––––––––––––––––––––––––––
        }, {
          key: "getPathById",
          value: function getPathById(id2) {
            var _this2 = this;
            var items = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.items;
            var _this$props12 = this.props, idProp = _this$props12.idProp, childrenProp = _this$props12.childrenProp;
            var path2 = [];
            items.every(function(item, i2) {
              if (item[idProp] === id2) {
                path2.push(i2);
              } else if (item[childrenProp]) {
                var childrenPath = _this2.getPathById(id2, item[childrenProp]);
                if (childrenPath.length) {
                  path2 = path2.concat(i2).concat(childrenPath);
                }
              }
              return path2.length === 0;
            });
            return path2;
          }
        }, {
          key: "getItemByPath",
          value: function getItemByPath(path2) {
            var items = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.items;
            var childrenProp = this.props.childrenProp;
            var item = null;
            path2.forEach(function(index2) {
              var list2 = item ? item[childrenProp] : items;
              item = list2[index2];
            });
            return item;
          }
        }, {
          key: "getSplicePath",
          value: function getSplicePath(path2) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var splicePath = {};
            var numToRemove = options.numToRemove || 0;
            var itemsToInsert = options.itemsToInsert || [];
            var lastIndex = path2.length - 1;
            var currentPath = splicePath;
            path2.forEach(function(index2, i2) {
              if (i2 === lastIndex) {
                currentPath.$splice = [[index2, numToRemove].concat(_toConsumableArray2(itemsToInsert))];
              } else {
                var nextPath = {};
                currentPath[index2] = _defineProperty2({}, options.childrenProp, nextPath);
                currentPath = nextPath;
              }
            });
            return splicePath;
          }
        }, {
          key: "getRealNextPath",
          value: function getRealNextPath(prevPath, nextPath, dragItemSize) {
            var _this$props13 = this.props, childrenProp = _this$props13.childrenProp, maxDepth = _this$props13.maxDepth;
            var ppLastIndex = prevPath.length - 1;
            var npLastIndex = nextPath.length - 1;
            var newDepth = nextPath.length + dragItemSize - 1;
            if (prevPath.length < nextPath.length) {
              var wasShifted = false;
              if (newDepth > maxDepth && nextPath.length) {
                return this.getRealNextPath(prevPath, nextPath.slice(0, -1), dragItemSize);
              }
              return nextPath.map(function(nextIndex, i2) {
                if (wasShifted) {
                  return i2 === npLastIndex ? nextIndex + 1 : nextIndex;
                }
                if (typeof prevPath[i2] !== "number") {
                  return nextIndex;
                }
                if (nextPath[i2] > prevPath[i2] && i2 === ppLastIndex) {
                  wasShifted = true;
                  return nextIndex - 1;
                }
                return nextIndex;
              });
            } else if (prevPath.length === nextPath.length) {
              if (nextPath[npLastIndex] > prevPath[npLastIndex]) {
                var target = this.getItemByPath(nextPath);
                if (newDepth < maxDepth && target[childrenProp] && target[childrenProp].length && !this.isCollapsed(target)) {
                  return nextPath.slice(0, -1).concat(nextPath[npLastIndex] - 1).concat(0);
                }
              }
            }
            return nextPath;
          }
        }, {
          key: "getItemOptions",
          value: function getItemOptions() {
            var _this$props14 = this.props, renderItem = _this$props14.renderItem, renderCollapseIcon = _this$props14.renderCollapseIcon, handler = _this$props14.handler, idProp = _this$props14.idProp, childrenProp = _this$props14.childrenProp;
            var dragItem = this.state.dragItem;
            return {
              dragItem,
              idProp,
              childrenProp,
              renderItem,
              renderCollapseIcon,
              handler,
              onDragStart: this.onDragStart,
              onMouseEnter: this.onMouseEnter,
              isCollapsed: this.isCollapsed,
              onToggleCollapse: this.onToggleCollapse
            };
          }
        }, {
          key: "renderDragLayer",
          value: (
            // ––––––––––––––––––––––––––––––––––––
            // Render methods
            // ––––––––––––––––––––––––––––––––––––
            function renderDragLayer() {
              var _this$props15 = this.props, group = _this$props15.group, idProp = _this$props15.idProp;
              var dragItem = this.state.dragItem;
              var el2 = document.querySelector(".nestable-" + group + " .nestable-item-" + dragItem[idProp]);
              var listStyles = {};
              if (el2) {
                listStyles.width = el2.clientWidth;
              }
              if (this.elCopyStyles) {
                listStyles = _objectSpread3(_objectSpread3({}, listStyles), this.elCopyStyles);
              }
              var options = this.getItemOptions();
              return /* @__PURE__ */ _react2["default"].createElement("div", {
                className: "nestable-drag-layer"
              }, /* @__PURE__ */ _react2["default"].createElement("ol", {
                className: "nestable-list",
                style: listStyles
              }, /* @__PURE__ */ _react2["default"].createElement(_NestableItem["default"], {
                item: dragItem,
                options,
                isCopy: true
              })));
            }
          )
        }, {
          key: "render",
          value: function render2() {
            var _this$props16 = this.props, group = _this$props16.group, className = _this$props16.className;
            var _this$state2 = this.state, items = _this$state2.items, dragItem = _this$state2.dragItem;
            var options = this.getItemOptions();
            return /* @__PURE__ */ _react2["default"].createElement("div", {
              className: (0, _classnames["default"])(className, "nestable", "nestable-" + group, {
                "is-drag-active": dragItem
              })
            }, /* @__PURE__ */ _react2["default"].createElement("ol", {
              className: "nestable-list nestable-group"
            }, items.map(function(item, i2) {
              return /* @__PURE__ */ _react2["default"].createElement(_NestableItem["default"], {
                key: i2,
                index: i2,
                item,
                options
              });
            })), dragItem && this.renderDragLayer());
          }
        }]);
        return Nestable3;
      }(_react2.Component);
      _defineProperty2(Nestable2, "propTypes", {
        childrenProp: _propTypes["default"].string,
        className: _propTypes["default"].string,
        collapsed: _propTypes["default"].bool,
        confirmChange: _propTypes["default"].func,
        group: _propTypes["default"].oneOfType([_propTypes["default"].number, _propTypes["default"].string]),
        handler: _propTypes["default"].node,
        idProp: _propTypes["default"].string,
        items: _propTypes["default"].array,
        maxDepth: _propTypes["default"].number,
        onChange: _propTypes["default"].func,
        renderCollapseIcon: _propTypes["default"].func,
        renderItem: _propTypes["default"].func,
        threshold: _propTypes["default"].number
      });
      _defineProperty2(Nestable2, "defaultProps", {
        childrenProp: "children",
        collapsed: false,
        confirmChange: function confirmChange() {
          return true;
        },
        group: Math.random().toString(36).slice(2),
        idProp: "id",
        items: [],
        maxDepth: 10,
        onChange: function onChange() {
        },
        renderItem: function renderItem(_ref2) {
          var item = _ref2.item;
          return String(item);
        },
        threshold: 30
      });
      var _default2 = Nestable2;
      exports2["default"] = _default2;
    })(Nestable$1);
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2["default"] = void 0;
      var _Nestable = _interopRequireDefault2(Nestable$1);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _default2 = _Nestable["default"];
      exports2["default"] = _default2;
    })(Nestable$2);
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2["default"] = void 0;
      var _Nestable = _interopRequireDefault2(Nestable$2);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _default2 = _Nestable["default"];
      exports2["default"] = _default2;
    })(dist);
    const Nestable = /* @__PURE__ */ getDefaultExportFromCjs(dist);
    var Role = /* @__PURE__ */ ((Role2) => {
      Role2["USER"] = "user";
      Role2["ADMIN"] = "admin";
      return Role2;
    })(Role || {});
    var WaitUntil = /* @__PURE__ */ ((WaitUntil2) => {
      WaitUntil2["load"] = "load";
      WaitUntil2["domContentLoaded"] = "domcontentloaded";
      WaitUntil2["networkIdle0"] = "networkidle0";
      WaitUntil2["networkIdle2"] = "networkidle2";
      return WaitUntil2;
    })(WaitUntil || {});
    var SelectorType = /* @__PURE__ */ ((SelectorType2) => {
      SelectorType2["Text"] = "text";
      SelectorType2["Link"] = "link";
      SelectorType2["PopupLink"] = "popupLink";
      SelectorType2["Image"] = "image";
      SelectorType2["Table"] = "table";
      SelectorType2["ElementAttribute"] = "attribute";
      SelectorType2["HTML"] = "html";
      SelectorType2["ElementScroll"] = "scrollDown";
      SelectorType2["ElementClick"] = "click";
      SelectorType2["Group"] = "grouped";
      SelectorType2["SitemapXmlLink"] = "sitemap";
      SelectorType2["Pagination"] = "pagination";
      return SelectorType2;
    })(SelectorType || {});
    var JobStatus = /* @__PURE__ */ ((JobStatus2) => {
      JobStatus2["Waiting"] = "waiting";
      JobStatus2["Running"] = "running";
      JobStatus2["Stopping"] = "stopping";
      JobStatus2["Stopped"] = "stopped";
      JobStatus2["Aborted"] = "aborted";
      JobStatus2["Success"] = "success";
      JobStatus2["Fail"] = "fail";
      return JobStatus2;
    })(JobStatus || {});
    var SchedulerType = /* @__PURE__ */ ((SchedulerType2) => {
      SchedulerType2["Daily"] = "daily";
      SchedulerType2["Interval"] = "interval";
      SchedulerType2["Custom"] = "custom";
      return SchedulerType2;
    })(SchedulerType || {});
    var IntervalType = /* @__PURE__ */ ((IntervalType2) => {
      IntervalType2["Minute"] = "minute";
      IntervalType2["Hour"] = "hour";
      return IntervalType2;
    })(IntervalType || {});
    const selectorTypeOptions = Object.values(SelectorType).map((value) => ({
      label: value,
      value
    }));
    const SelectorForm = ({ queryId, formProps }) => {
      return /* @__PURE__ */ jsxs(
        Form$1,
        {
          ...formProps,
          layout: "vertical",
          onFinish: (values) => formProps.onFinish && formProps.onFinish({
            ...values,
            queryId
          }),
          children: [
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "Name",
                name: "name",
                rules: [{ required: true }, { max: 20 }],
                children: /* @__PURE__ */ jsx(Input$1, {})
              }
            ),
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "Selector",
                name: "selector",
                rules: [{ required: true }, { max: 200 }],
                children: /* @__PURE__ */ jsx(Input$1, {})
              }
            ),
            /* @__PURE__ */ jsx(Form$1.Item, { label: "Type", name: "type", rules: [{ required: true }], children: /* @__PURE__ */ jsx(Select$1, { options: selectorTypeOptions }) }),
            /* @__PURE__ */ jsx(Form$1.Item, { label: "Multiply", name: "multiply", valuePropName: "checked", children: /* @__PURE__ */ jsx(Checkbox$1, {}) })
          ]
        }
      );
    };
    const buildTree = (sels, all2) => sels.map((sel) => {
      const node2 = {
        ...sel
      };
      const children = all2.filter(({ parentId }) => parentId === sel.id);
      if (children.length === 0) {
        return node2;
      }
      node2.children = buildTree(children, all2);
      return node2;
    });
    var immutabilityHelperExports = {};
    var immutabilityHelper = {
      get exports() {
        return immutabilityHelperExports;
      },
      set exports(v2) {
        immutabilityHelperExports = v2;
      }
    };
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      function stringifiable(obj) {
        return typeof obj === "object" && !("toString" in obj) ? Object.prototype.toString.call(obj).slice(8, -1) : obj;
      }
      var isProduction2 = typeof process === "object" && true;
      function invariant2(condition, message2) {
        if (!condition) {
          if (isProduction2) {
            throw new Error("Invariant failed");
          }
          throw new Error(message2());
        }
      }
      exports2.invariant = invariant2;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var splice2 = Array.prototype.splice;
      var toString2 = Object.prototype.toString;
      function type2(obj) {
        return toString2.call(obj).slice(8, -1);
      }
      var assign2 = Object.assign || /* istanbul ignore next */
      function(target, source) {
        getAllKeys2(source).forEach(function(key) {
          if (hasOwnProperty2.call(source, key)) {
            target[key] = source[key];
          }
        });
        return target;
      };
      var getAllKeys2 = typeof Object.getOwnPropertySymbols === "function" ? function(obj) {
        return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj));
      } : function(obj) {
        return Object.keys(obj);
      };
      function copy2(object2) {
        return Array.isArray(object2) ? assign2(object2.constructor(object2.length), object2) : type2(object2) === "Map" ? new Map(object2) : type2(object2) === "Set" ? new Set(object2) : object2 && typeof object2 === "object" ? assign2(Object.create(Object.getPrototypeOf(object2)), object2) : object2;
      }
      var Context2 = (
        /** @class */
        function() {
          function Context3() {
            this.commands = assign2({}, defaultCommands);
            this.update = this.update.bind(this);
            this.update.extend = this.extend = this.extend.bind(this);
            this.update.isEquals = function(x2, y2) {
              return x2 === y2;
            };
            this.update.newContext = function() {
              return new Context3().update;
            };
          }
          Object.defineProperty(Context3.prototype, "isEquals", {
            get: function() {
              return this.update.isEquals;
            },
            set: function(value) {
              this.update.isEquals = value;
            },
            enumerable: true,
            configurable: true
          });
          Context3.prototype.extend = function(directive, fn) {
            this.commands[directive] = fn;
          };
          Context3.prototype.update = function(object2, $spec) {
            var _this = this;
            var spec = typeof $spec === "function" ? { $apply: $spec } : $spec;
            if (!(Array.isArray(object2) && Array.isArray(spec))) {
              invariant2(!Array.isArray(spec), function() {
                return "update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value.";
              });
            }
            invariant2(typeof spec === "object" && spec !== null, function() {
              return "update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the " + ("following commands: " + Object.keys(_this.commands).join(", ") + ".");
            });
            var nextObject = object2;
            getAllKeys2(spec).forEach(function(key) {
              if (hasOwnProperty2.call(_this.commands, key)) {
                var objectWasNextObject = object2 === nextObject;
                nextObject = _this.commands[key](spec[key], nextObject, spec, object2);
                if (objectWasNextObject && _this.isEquals(nextObject, object2)) {
                  nextObject = object2;
                }
              } else {
                var nextValueForKey = type2(object2) === "Map" ? _this.update(object2.get(key), spec[key]) : _this.update(object2[key], spec[key]);
                var nextObjectValue = type2(nextObject) === "Map" ? nextObject.get(key) : nextObject[key];
                if (!_this.isEquals(nextValueForKey, nextObjectValue) || typeof nextValueForKey === "undefined" && !hasOwnProperty2.call(object2, key)) {
                  if (nextObject === object2) {
                    nextObject = copy2(object2);
                  }
                  if (type2(nextObject) === "Map") {
                    nextObject.set(key, nextValueForKey);
                  } else {
                    nextObject[key] = nextValueForKey;
                  }
                }
              }
            });
            return nextObject;
          };
          return Context3;
        }()
      );
      exports2.Context = Context2;
      var defaultCommands = {
        $push: function(value, nextObject, spec) {
          invariantPushAndUnshift(nextObject, spec, "$push");
          return value.length ? nextObject.concat(value) : nextObject;
        },
        $unshift: function(value, nextObject, spec) {
          invariantPushAndUnshift(nextObject, spec, "$unshift");
          return value.length ? value.concat(nextObject) : nextObject;
        },
        $splice: function(value, nextObject, spec, originalObject) {
          invariantSplices(nextObject, spec);
          value.forEach(function(args) {
            invariantSplice(args);
            if (nextObject === originalObject && args.length) {
              nextObject = copy2(originalObject);
            }
            splice2.apply(nextObject, args);
          });
          return nextObject;
        },
        $set: function(value, _nextObject, spec) {
          invariantSet(spec);
          return value;
        },
        $toggle: function(targets, nextObject) {
          invariantSpecArray(targets, "$toggle");
          var nextObjectCopy = targets.length ? copy2(nextObject) : nextObject;
          targets.forEach(function(target) {
            nextObjectCopy[target] = !nextObject[target];
          });
          return nextObjectCopy;
        },
        $unset: function(value, nextObject, _spec, originalObject) {
          invariantSpecArray(value, "$unset");
          value.forEach(function(key) {
            if (Object.hasOwnProperty.call(nextObject, key)) {
              if (nextObject === originalObject) {
                nextObject = copy2(originalObject);
              }
              delete nextObject[key];
            }
          });
          return nextObject;
        },
        $add: function(values, nextObject, _spec, originalObject) {
          invariantMapOrSet(nextObject, "$add");
          invariantSpecArray(values, "$add");
          if (type2(nextObject) === "Map") {
            values.forEach(function(_a) {
              var key = _a[0], value = _a[1];
              if (nextObject === originalObject && nextObject.get(key) !== value) {
                nextObject = copy2(originalObject);
              }
              nextObject.set(key, value);
            });
          } else {
            values.forEach(function(value) {
              if (nextObject === originalObject && !nextObject.has(value)) {
                nextObject = copy2(originalObject);
              }
              nextObject.add(value);
            });
          }
          return nextObject;
        },
        $remove: function(value, nextObject, _spec, originalObject) {
          invariantMapOrSet(nextObject, "$remove");
          invariantSpecArray(value, "$remove");
          value.forEach(function(key) {
            if (nextObject === originalObject && nextObject.has(key)) {
              nextObject = copy2(originalObject);
            }
            nextObject.delete(key);
          });
          return nextObject;
        },
        $merge: function(value, nextObject, _spec, originalObject) {
          invariantMerge(nextObject, value);
          getAllKeys2(value).forEach(function(key) {
            if (value[key] !== nextObject[key]) {
              if (nextObject === originalObject) {
                nextObject = copy2(originalObject);
              }
              nextObject[key] = value[key];
            }
          });
          return nextObject;
        },
        $apply: function(value, original) {
          invariantApply(value);
          return value(original);
        }
      };
      var defaultContext2 = new Context2();
      exports2.isEquals = defaultContext2.update.isEquals;
      exports2.extend = defaultContext2.extend;
      exports2.default = defaultContext2.update;
      exports2.default.default = module2.exports = assign2(exports2.default, exports2);
      function invariantPushAndUnshift(value, spec, command) {
        invariant2(Array.isArray(value), function() {
          return "update(): expected target of " + stringifiable(command) + " to be an array; got " + stringifiable(value) + ".";
        });
        invariantSpecArray(spec[command], command);
      }
      function invariantSpecArray(spec, command) {
        invariant2(Array.isArray(spec), function() {
          return "update(): expected spec of " + stringifiable(command) + " to be an array; got " + stringifiable(spec) + ". Did you forget to wrap your parameter in an array?";
        });
      }
      function invariantSplices(value, spec) {
        invariant2(Array.isArray(value), function() {
          return "Expected $splice target to be an array; got " + stringifiable(value);
        });
        invariantSplice(spec.$splice);
      }
      function invariantSplice(value) {
        invariant2(Array.isArray(value), function() {
          return "update(): expected spec of $splice to be an array of arrays; got " + stringifiable(value) + ". Did you forget to wrap your parameters in an array?";
        });
      }
      function invariantApply(fn) {
        invariant2(typeof fn === "function", function() {
          return "update(): expected spec of $apply to be a function; got " + stringifiable(fn) + ".";
        });
      }
      function invariantSet(spec) {
        invariant2(Object.keys(spec).length === 1, function() {
          return "Cannot have more than one key in an object with $set";
        });
      }
      function invariantMerge(target, specValue) {
        invariant2(specValue && typeof specValue === "object", function() {
          return "update(): $merge expects a spec of type 'object'; got " + stringifiable(specValue);
        });
        invariant2(target && typeof target === "object", function() {
          return "update(): $merge expects a target of type 'object'; got " + stringifiable(target);
        });
      }
      function invariantMapOrSet(target, command) {
        var typeOfTarget = type2(target);
        invariant2(typeOfTarget === "Map" || typeOfTarget === "Set", function() {
          return "update(): " + stringifiable(command) + " expects a target of type Set or Map; got " + stringifiable(typeOfTarget);
        });
      }
    })(immutabilityHelper, immutabilityHelperExports);
    const update = /* @__PURE__ */ getDefaultExportFromCjs(immutabilityHelperExports);
    var ParserType = /* @__PURE__ */ ((ParserType2) => {
      ParserType2["ReplaceText"] = "replaceText";
      ParserType2["AddText"] = "addText";
      ParserType2["StripHTML"] = "stripHtml";
      ParserType2["RemoveWhitespaces"] = "removeWhitespaces";
      return ParserType2;
    })(ParserType || {});
    const parserTitle = {
      [ParserType.ReplaceText]: "Replace Text",
      [ParserType.RemoveWhitespaces]: "Remove Whitespaces",
      [ParserType.AddText]: "Add Text",
      [ParserType.StripHTML]: "Strip HTML"
    };
    const parserColor = {
      [ParserType.ReplaceText]: "red",
      [ParserType.RemoveWhitespaces]: "pink",
      [ParserType.AddText]: "green",
      [ParserType.StripHTML]: "magenta"
    };
    const DragItemTypes = {
      CARD: "card"
    };
    const styleWrapper = {
      position: "relative",
      border: "1px dashed gray",
      padding: "0.5rem 1rem",
      margin: "0 .5rem .5rem 0",
      cursor: "move"
    };
    const styleRemoveBtn = {
      position: "absolute",
      border: 0,
      top: "2px",
      right: "2px",
      padding: "1px 0",
      cursor: "pointer",
      fontSize: "60%",
      height: "1rem",
      width: "1rem",
      background: "transparent"
    };
    const ParserItem = ({
      id: id2,
      type: type2,
      index: index2,
      moveItem,
      onRemove,
      onEdit
    }) => {
      const ref = reactExports.useRef(null);
      const [{ handlerId }, drop] = useDrop({
        accept: DragItemTypes.CARD,
        collect(monitor) {
          return {
            handlerId: monitor.getHandlerId()
          };
        },
        hover(item, monitor) {
          var _a;
          if (!ref.current) {
            return;
          }
          const dragIndex = item.index;
          const hoverIndex = index2;
          if (dragIndex === hoverIndex) {
            return;
          }
          const hoverBoundingRect = (_a = ref.current) == null ? void 0 : _a.getBoundingClientRect();
          const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;
          const clientOffset = monitor.getClientOffset();
          const hoverClientX = clientOffset.x - hoverBoundingRect.left;
          if (dragIndex < hoverIndex && hoverClientX < hoverMiddleX) {
            return;
          }
          if (dragIndex > hoverIndex && hoverClientX > hoverMiddleX) {
            return;
          }
          moveItem(dragIndex, hoverIndex);
          item.index = hoverIndex;
        }
      });
      const [{ isDragging }, drag] = useDrag({
        type: DragItemTypes.CARD,
        item: () => ({ id: id2, index: index2 }),
        collect: (monitor) => ({
          isDragging: monitor.isDragging()
        })
      });
      const opacity = isDragging ? 0 : 1;
      drag(drop(ref));
      return /* @__PURE__ */ jsxs(
        "div",
        {
          ref,
          style: { ...styleWrapper, opacity, backgroundColor: parserColor[type2] },
          "data-handler-id": handlerId,
          onClick: () => {
            onEdit(id2);
          },
          children: [
            parserTitle[type2],
            /* @__PURE__ */ jsx(
              Button$2,
              {
                icon: /* @__PURE__ */ jsx(CrownOutlined$1, {}),
                style: styleRemoveBtn,
                onClick: (e2) => {
                  e2.stopPropagation();
                  onRemove(id2);
                }
              }
            )
          ]
        }
      );
    };
    const ParserForm = ({ parserType }) => {
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        parserType === ParserType.ReplaceText && /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Form$1.Item, { label: "Pattern", name: "pattern", rules: [{ max: 64 }], children: /* @__PURE__ */ jsx(Input$1, {}) }),
          /* @__PURE__ */ jsx(
            Form$1.Item,
            {
              label: "Replacement",
              name: "replacement",
              rules: [{ max: 64 }],
              children: /* @__PURE__ */ jsx(Input$1, {})
            }
          ),
          /* @__PURE__ */ jsx(Form$1.Item, { label: "Use Regex", name: "isRegex", valuePropName: "checked", children: /* @__PURE__ */ jsx(Checkbox$1, {}) })
        ] }),
        parserType === ParserType.AddText && /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Form$1.Item, { label: "Text to append", name: "append", rules: [{ max: 64 }], children: /* @__PURE__ */ jsx(Input$1, {}) }),
          /* @__PURE__ */ jsx(
            Form$1.Item,
            {
              label: "Text to prepend",
              name: "prepend",
              rules: [{ max: 64 }],
              children: /* @__PURE__ */ jsx(Input$1, {})
            }
          )
        ] }),
        parserType === ParserType.StripHTML && /* @__PURE__ */ jsxs(Fragment, { children: [
          " ",
          /* @__PURE__ */ jsx(
            Form$1.Item,
            {
              label: "Strip HTML tags",
              name: "stripHtmlTags",
              valuePropName: "checked",
              children: /* @__PURE__ */ jsx(Checkbox$1, {})
            }
          ),
          /* @__PURE__ */ jsx(
            Form$1.Item,
            {
              label: "Decode HTML entities",
              name: "decodeHtmlEntities",
              valuePropName: "checked",
              children: /* @__PURE__ */ jsx(Checkbox$1, {})
            }
          )
        ] }),
        parserType === ParserType.RemoveWhitespaces && /* @__PURE__ */ jsxs(Fragment, { children: [
          " ",
          /* @__PURE__ */ jsx(
            Form$1.Item,
            {
              label: "Remove whitespaces",
              name: "removeWhitespaces",
              valuePropName: "checked",
              children: /* @__PURE__ */ jsx(Checkbox$1, {})
            }
          ),
          /* @__PURE__ */ jsx(
            Form$1.Item,
            {
              label: "Remove newlines",
              name: "removeNewlines",
              valuePropName: "checked",
              children: /* @__PURE__ */ jsx(Checkbox$1, {})
            }
          )
        ] })
      ] });
    };
    const { Text: Text$8, Title: Title$6 } = Typography$1;
    const EditParserForm = ({ formProps }) => {
      var _a;
      const parserType = (_a = formProps.initialValues) == null ? void 0 : _a.parserType;
      return /* @__PURE__ */ jsxs(Form$1, { ...formProps, layout: "vertical", children: [
        parserType && /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Divider$1, {}),
          /* @__PURE__ */ jsx(Title$6, { level: 5, children: "Type" }),
          /* @__PURE__ */ jsx(Text$8, { style: { color: parserColor[parserType] }, children: parserTitle[parserType] }),
          /* @__PURE__ */ jsx(Divider$1, {})
        ] }),
        /* @__PURE__ */ jsx(ParserForm, { parserType })
      ] });
    };
    const CreateParserForm = ({ formProps, selectorId }) => {
      const [parserType, setParserType] = reactExports.useState(
        ParserType.ReplaceText
      );
      if (!formProps.initialValues) {
        formProps.initialValues = {};
      }
      formProps.initialValues.parserType = parserType;
      const parserTypeOptions = Object.entries(parserTitle).map(
        ([value, label]) => ({ value, label })
      );
      return /* @__PURE__ */ jsxs(
        Form$1,
        {
          ...formProps,
          layout: "vertical",
          onFinish: (values) => formProps.onFinish && formProps.onFinish({ ...values, selectorId }),
          children: [
            /* @__PURE__ */ jsx(Divider$1, {}),
            /* @__PURE__ */ jsx(Form$1.Item, { label: "Type", name: "parserType", children: /* @__PURE__ */ jsx(
              Select$1,
              {
                options: parserTypeOptions,
                onChange: (value) => {
                  setParserType(value);
                }
              }
            ) }),
            /* @__PURE__ */ jsx(Divider$1, {}),
            /* @__PURE__ */ jsx(ParserForm, { parserType })
          ]
        }
      );
    };
    const containerStyle = {
      display: "flex",
      flexWrap: "wrap"
    };
    const ParserList = reactExports.forwardRef(({ selectorId, items }, ref) => {
      {
        const apiUrl = ts();
        const parsersResource = `selectors/${selectorId}/parsers`;
        const [parsers, setParsers] = reactExports.useState(items);
        const { mutate: mutateDelete } = Go();
        const removeParserItem = (id2) => {
          mutateDelete(
            {
              resource: parsersResource,
              id: id2
              // mutationMode: 'pessimistic',
            },
            {
              onSuccess: ({ data: { id: id22 } }) => {
                setParsers((prev2) => prev2.filter((item) => item.id !== id22));
              }
            }
          );
        };
        reactExports.useEffect(() => {
          const reorderParsers = async () => {
            if (!parsers.length) {
              return;
            }
            const dto = {
              items: parsers.map(({ id: id2 }, sortOrder) => [id2, sortOrder])
            };
            try {
              const res = await fetch(`${apiUrl}/parsers/reorder`, {
                credentials: "include",
                method: "POST",
                body: JSON.stringify(dto),
                headers: {
                  "Content-Type": "application/json"
                }
              });
              await validateResponse(res);
            } catch (err) {
              notification$1.error({
                message: "Error",
                description: err.toString()
              });
              console.error(err);
            }
          };
          reorderParsers();
        }, [parsers, items]);
        const moveParserItem = (dragIndex, hoverIndex) => {
          setParsers(
            (prev2) => update(prev2, {
              $splice: [
                [dragIndex, 1],
                [hoverIndex, 0, prev2[dragIndex]]
              ]
            })
          );
        };
        const {
          modalProps: editParserModalProps,
          formProps: editParserFormProps,
          show: showEditParserModal
        } = ur({
          action: "edit",
          resource: parsersResource,
          redirect: false,
          warnWhenUnsavedChanges: true,
          onMutationSuccess: ({ data: data2 }) => {
            setParsers((prev2) => {
              const index2 = prev2.findIndex(({ id: id2 }) => id2 === data2.id);
              const updated = [...prev2];
              updated.splice(index2, 1, data2);
              return updated;
            });
          }
        });
        const {
          modalProps: createParserModalProps,
          formProps: createParserFormProps,
          show: showCreateParserModal
        } = ur({
          action: "create",
          resource: parsersResource,
          redirect: false,
          warnWhenUnsavedChanges: true,
          onMutationSuccess: ({ data: data2 }) => {
            setParsers((prev2) => [...prev2, data2]);
          }
        });
        const renderItem = reactExports.useCallback(
          ({ id: id2, parserType }, index2) => {
            return /* @__PURE__ */ jsx(
              ParserItem,
              {
                index: index2,
                id: id2,
                type: parserType,
                moveItem: moveParserItem,
                onRemove: removeParserItem,
                onEdit: showEditParserModal
              },
              id2
            );
          },
          []
        );
        reactExports.useImperativeHandle(ref, () => ({
          showCreateParser() {
            console.log("child function");
            showCreateParserModal();
          }
        }));
        return /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Modal$1, { ...editParserModalProps, title: "Edit parser", children: /* @__PURE__ */ jsx(EditParserForm, { formProps: editParserFormProps }) }),
          /* @__PURE__ */ jsx(Modal$1, { ...createParserModalProps, title: "Create parser", children: /* @__PURE__ */ jsx(
            CreateParserForm,
            {
              formProps: createParserFormProps,
              selectorId
            }
          ) }),
          /* @__PURE__ */ jsx("div", { style: containerStyle, children: parsers.map((parser2, i2) => renderItem(parser2, i2)) })
        ] });
      }
    });
    const itemStyle = {
      position: "relative",
      padding: "10px 15px",
      fontSize: "20px",
      border: "1px solid #f9fafa",
      background: "#f9fafa",
      cursor: "pointer",
      width: "100%"
    };
    const fieldStyle = {
      marginRight: "1rem"
    };
    const SelectorItem = ({
      selectorId,
      name,
      selector,
      onEdit,
      resource,
      collapseIcon,
      handler
    }) => {
      const ref = reactExports.useRef();
      const parsersResource = `selectors/${selectorId}/parsers`;
      const { isError: isError2, error, isLoading, data: data2 } = St({
        resource: parsersResource,
        ids: []
      });
      if (isLoading) {
        return /* @__PURE__ */ jsx("div", { children: "Loading..." });
      }
      if (isError2) {
        return /* @__PURE__ */ jsx("div", { children: error.toString() });
      }
      return /* @__PURE__ */ jsxs("div", { style: itemStyle, children: [
        handler,
        /* @__PURE__ */ jsxs("div", { style: { display: "flex", justifyContent: "space-between" }, children: [
          collapseIcon,
          /* @__PURE__ */ jsx("div", { style: fieldStyle, children: selectorId }),
          /* @__PURE__ */ jsx("div", { style: fieldStyle, children: name }),
          /* @__PURE__ */ jsx("div", { style: fieldStyle, children: selector }),
          /* @__PURE__ */ jsx(
            ParserList,
            {
              ref,
              selectorId,
              items: (data2 == null ? void 0 : data2.data) || []
            }
          ),
          /* @__PURE__ */ jsxs(
            "div",
            {
              style: { display: "flex", flexWrap: "nowrap", marginLeft: "auto" },
              children: [
                /* @__PURE__ */ jsx(
                  Button$2,
                  {
                    icon: /* @__PURE__ */ jsx(PlusCircleOutlined$1, {}),
                    onClick: (e2) => {
                      e2.preventDefault();
                      if (ref.current) {
                        ref.current.showCreateParser();
                      }
                    },
                    children: "parser"
                  }
                ),
                /* @__PURE__ */ jsx(
                  Button$2,
                  {
                    icon: /* @__PURE__ */ jsx(vt, {}),
                    onClick: (e2) => {
                      e2.preventDefault();
                      onEdit(selectorId);
                    }
                  }
                ),
                /* @__PURE__ */ jsx(
                  ye,
                  {
                    recordItemId: selectorId,
                    resourceNameOrRouteName: resource,
                    hideText: true
                  }
                )
              ]
            }
          )
        ] })
      ] });
    };
    const handlerStyles = {
      position: "absolute",
      top: 0,
      left: 0,
      width: "10px",
      height: "100%",
      background: "steelblue",
      cursor: "pointer"
    };
    const SelectorTree = reactExports.forwardRef(
      ({ queryId, resource, selectors }, ref) => {
        const {
          modalProps: editModalProps,
          formProps: editFormProps,
          show: showEditSelectorModal
        } = ur({
          action: "edit",
          resource,
          redirect: false,
          warnWhenUnsavedChanges: true
        });
        const {
          modalProps: createModalProps,
          formProps: createFormProps,
          show: showCreateSelectorModal
        } = ur({
          action: "create",
          resource,
          redirect: false
        });
        const renderItem = ({
          collapseIcon,
          handler,
          item: { id: selectorId, name, selector }
        }) => /* @__PURE__ */ jsx(
          SelectorItem,
          {
            queryId,
            selectorId,
            name,
            selector,
            resource,
            onEdit: showEditSelectorModal,
            collapseIcon,
            handler
          }
        );
        return /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Modal$1, { ...createModalProps, title: "Create selector", children: /* @__PURE__ */ jsx(SelectorForm, { queryId, formProps: createFormProps }) }),
          /* @__PURE__ */ jsx(Modal$1, { ...editModalProps, title: "Edit selector", children: /* @__PURE__ */ jsx(SelectorForm, { queryId, formProps: editFormProps }) }),
          /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(
            je,
            {
              onClick: (e2) => {
                e2.preventDefault();
                showCreateSelectorModal();
              }
            }
          ) }),
          /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(DndProvider, { backend: HTML5Backend, children: /* @__PURE__ */ jsx(
            Nestable,
            {
              ref,
              items: buildTree(
                selectors.filter(({ parentId }) => !parentId),
                selectors
              ),
              renderItem,
              handler: /* @__PURE__ */ jsx("span", { style: handlerStyles }),
              onChange: (arg) => {
                console.log(arg);
              }
            }
          ) }) })
        ] });
      }
    );
    const { Title: Title$5, Text: Text$7 } = Typography$1;
    const ShowSelectors = () => {
      const ref = reactExports.useRef(null);
      const { id: id2 } = useParams();
      const queryId = id2 ? +id2 : 0;
      const parentResource = `queries/${queryId}`;
      const resource = `${parentResource}/selectors`;
      const invalidate = ie$1();
      const { data: data2, isLoading } = Ge({
        resource: "queries",
        id: queryId,
        queryOptions: {
          enabled: !!queryId
        }
      });
      const record = data2 == null ? void 0 : data2.data;
      const { data: selectorsData, isLoading: selectorsIsLoading } = St({
        resource,
        ids: [],
        queryOptions: {
          enabled: !!record
        }
      });
      const apiUrl = ts();
      const { mutate: mutate2, isLoading: mutateIsLoading } = as();
      const buttonDisabled = isLoading || selectorsIsLoading || mutateIsLoading;
      const items = [];
      const populateItems = (nodes, parentId) => {
        for (const { id: id22, children } of nodes) {
          items.push([id22, parentId]);
          if (children) {
            populateItems(children, id22);
          }
        }
      };
      return /* @__PURE__ */ jsxs(
        Ta,
        {
          title: "Selectors",
          resource: "queries",
          isLoading: isLoading || selectorsIsLoading,
          recordItemId: record == null ? void 0 : record.id,
          headerButtons: /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx(
              Pe,
              {
                ...buttonDisabled ? { disabled: true } : {},
                resourceNameOrRouteName: "queries"
              }
            ),
            /* @__PURE__ */ jsx(
              be,
              {
                ...buttonDisabled ? { disabled: true } : {},
                resourceNameOrRouteName: resource,
                recordItemId: queryId
              }
            )
          ] }),
          footerButtons: /* @__PURE__ */ jsx(Space$1, { style: { float: "right", marginRight: 24 }, children: /* @__PURE__ */ jsx(
            Button$2,
            {
              type: "primary",
              onClick: (e2) => {
                var _a;
                e2.preventDefault();
                items.length = 0;
                populateItems(
                  ((_a = ref.current) == null ? void 0 : _a.state).items,
                  null
                );
                console.log(items);
                mutate2({
                  url: `${apiUrl}/${resource}/updateTree`,
                  method: "post",
                  values: {
                    items
                  }
                });
                invalidate({
                  resource,
                  invalidates: ["many"]
                });
              }
            }
          ) }, "action-buttons"),
          children: [
            /* @__PURE__ */ jsx(Title$5, { level: 4, children: "Id" }),
            /* @__PURE__ */ jsx(Text$7, { children: record == null ? void 0 : record.id }),
            /* @__PURE__ */ jsx(Title$5, { level: 4, children: "Name" }),
            /* @__PURE__ */ jsx(Text$7, { children: record == null ? void 0 : record.name }),
            /* @__PURE__ */ jsx(Title$5, { level: 4, children: "Start Url" }),
            /* @__PURE__ */ jsx(Text$7, { children: /* @__PURE__ */ jsx(Ze, { value: record == null ? void 0 : record.startUrl }) }),
            /* @__PURE__ */ jsx(
              SelectorTree,
              {
                ref,
                queryId,
                resource,
                selectors: (selectorsData == null ? void 0 : selectorsData.data) || []
              }
            )
          ]
        }
      );
    };
    const systemTheme = () => window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    const getTheme = () => localStorage.getItem("theme") || systemTheme();
    const renderDate = (value) => /* @__PURE__ */ jsx(Na, { value, format: "LLL" });
    const CrudList = ({
      resource,
      children,
      tableProps,
      sorter,
      menuConfig
    }) => {
      const [selectedRowKeys, setSelectedRowKeys] = React$3.useState([]);
      const { show, edit } = q$2();
      const { mutate: mutateDelete } = Go();
      const { mutate: mutateDeleteMany, isLoading: isDeleting } = es$1();
      const moreMenu = (record) => {
        const items = [];
        if (!menuConfig || menuConfig.edit !== false) {
          items.push({
            key: "edit",
            label: "Edit",
            icon: /* @__PURE__ */ jsx(
              vt,
              {
                style: {
                  color: "#52c41a",
                  fontSize: 17
                }
              }
            ),
            onClick: (info2) => {
              info2.domEvent.stopPropagation();
              edit(resource, record.id);
            }
          });
        }
        if (!menuConfig || menuConfig.delete !== false) {
          items.push({
            key: "delete",
            label: "Delete",
            icon: /* @__PURE__ */ jsx(
              CloseCircleOutlined$1,
              {
                style: {
                  color: "#EE2A1E",
                  fontSize: 17
                }
              }
            ),
            onClick: (info2) => {
              info2.domEvent.stopPropagation();
              mutateDelete({
                resource,
                id: record.id,
                mutationMode: "pessimistic"
              });
            }
          });
        }
        if (menuConfig == null ? void 0 : menuConfig.itemsFn) {
          items.push(...menuConfig.itemsFn(record));
        }
        return {
          items
        };
      };
      const onSelectChange = (selectedRowKeys2) => {
        setSelectedRowKeys(selectedRowKeys2);
      };
      const rowSelection = {
        selectedRowKeys,
        onChange: onSelectChange
      };
      const hasSelected = selectedRowKeys.length > 0;
      const deleteSelectedItems = () => {
        mutateDeleteMany(
          {
            resource,
            ids: selectedRowKeys.map(Number),
            mutationMode: "pessimistic"
          },
          {
            onSuccess: () => {
              setSelectedRowKeys([]);
            }
          }
        );
      };
      return /* @__PURE__ */ jsx(
        Ws,
        {
          headerProps: {
            subTitle: hasSelected && /* @__PURE__ */ jsx(
              ye,
              {
                onClick: () => deleteSelectedItems(),
                loading: isDeleting,
                children: "Delete selected"
              }
            )
          },
          children: /* @__PURE__ */ jsxs(
            Table$1,
            {
              ...tableProps,
              rowKey: "id",
              rowSelection,
              onRow: (record) => {
                return {
                  onClick: () => {
                    show(resource, record.id);
                  }
                };
              },
              children: [
                /* @__PURE__ */ jsx(
                  Table$1.Column,
                  {
                    dataIndex: "id",
                    title: "ID",
                    sorter: true,
                    defaultSortOrder: no("id", sorter)
                  },
                  "id"
                ),
                children,
                /* @__PURE__ */ jsx(
                  Table$1.Column,
                  {
                    dataIndex: "createdAt",
                    title: "Created At",
                    sorter: true,
                    defaultSortOrder: no("createdAt", sorter),
                    render: renderDate
                  },
                  "createdAt"
                ),
                /* @__PURE__ */ jsx(
                  Table$1.Column,
                  {
                    dataIndex: "updatedAt",
                    title: "Updated At",
                    sorter: true,
                    defaultSortOrder: no("updatedAt", sorter),
                    render: renderDate
                  },
                  "updatedAt"
                ),
                /* @__PURE__ */ jsx(
                  Table$1.Column,
                  {
                    fixed: "right",
                    title: "Actions",
                    dataIndex: "actions",
                    render: (_, record) => /* @__PURE__ */ jsx(
                      Dropdown$1,
                      {
                        menu: moreMenu(record),
                        trigger: ["click"],
                        children: /* @__PURE__ */ jsx(
                          MoreOutlined$1,
                          {
                            onClick: (e2) => e2.stopPropagation(),
                            style: {
                              fontSize: 24
                            }
                          }
                        )
                      }
                    )
                  },
                  "actions"
                )
              ]
            }
          )
        }
      );
    };
    const roleOptions = Object.values(Role).map((value) => ({
      label: value,
      value
    }));
    const MIN_PASSWORD_LENGTH = 8;
    const PASSWORD_PATTERN = /^(?=.*\d)(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[()[\]{}<>`~!@#№%$^&*\-_=+:;"'\\|,.?/]).{8,}$/;
    const passwordValidator = (_, value) => {
      if (value) {
        if (value.length < MIN_PASSWORD_LENGTH) {
          return Promise.reject(
            new Error(
              `Password must be at least ${MIN_PASSWORD_LENGTH} chars length`
            )
          );
        }
        if (!PASSWORD_PATTERN.test(value)) {
          return Promise.reject(
            new Error(
              "Password must contain at least 1 lowercase, 1 uppercase, 1 digit and 1 special char"
            )
          );
        }
      }
      return Promise.resolve();
    };
    const { Text: Text$6 } = Typography$1;
    const SetPasswordModal = ({ user, modalProps, formProps }) => {
      if (!user) {
        return null;
      }
      return /* @__PURE__ */ jsx(Modal$1, { ...modalProps, title: "Set password", children: /* @__PURE__ */ jsxs(Form$1, { ...formProps, layout: "vertical", children: [
        /* @__PURE__ */ jsx(Divider$1, {}),
        /* @__PURE__ */ jsxs(Space$1, { direction: "vertical", children: [
          /* @__PURE__ */ jsxs(Text$6, { children: [
            "User Id: ",
            user.id
          ] }),
          /* @__PURE__ */ jsxs(Text$6, { children: [
            "E-mail: ",
            user.email
          ] }),
          /* @__PURE__ */ jsxs(Text$6, { children: [
            "Name: ",
            user.lastName,
            " ",
            user.firstName
          ] })
        ] }),
        /* @__PURE__ */ jsx(Divider$1, {}),
        /* @__PURE__ */ jsx(
          Form$1.Item,
          {
            label: "Password",
            name: "password",
            hasFeedback: true,
            rules: [
              { required: true },
              {
                validator: passwordValidator
              }
            ],
            children: /* @__PURE__ */ jsx(Input$1.Password, {})
          }
        ),
        /* @__PURE__ */ jsx(
          Form$1.Item,
          {
            label: "Confirm password",
            name: "confirmPassword",
            hasFeedback: true,
            rules: [
              { required: true },
              {
                validator: passwordValidator
              },
              ({ getFieldValue }) => ({
                validator(_, value) {
                  if (!value || getFieldValue("password") === value) {
                    return Promise.resolve();
                  }
                  return Promise.reject(
                    new Error("Password and confirmation must match!")
                  );
                }
              })
            ],
            children: /* @__PURE__ */ jsx(Input$1.Password, {})
          }
        )
      ] }) });
    };
    const sendPasswordResetToken = async (email, apiUrl) => {
      const url = `${apiUrl}/send_password_reset_token?email=${email}`;
      try {
        const response = await fetch(url, {
          credentials: "include"
        });
        if (!response.ok) {
          throw new Error(`${response.status}: ${response.statusText}`);
        }
        notification$1.success({
          message: "Password reset",
          description: `Password reset token was sent successfully to ${email}`
        });
      } catch (err) {
        notification$1.error({
          message: err.toString()
        });
      }
    };
    const sendEmailVerificationLink = async (email, apiUrl) => {
      const url = `${apiUrl}/send_email_verification_link?email=${email}`;
      try {
        const response = await fetch(url, {
          credentials: "include"
        });
        if (!response.ok) {
          throw new Error(`${response.status}: ${response.statusText}`);
        }
        notification$1.success({
          message: "E-mail verification",
          description: `E-mail verification link was sent successfully to ${email}`
        });
      } catch (err) {
        notification$1.error({
          message: err.toString()
        });
      }
    };
    const UserList = () => {
      const apiUrl = ts();
      const [currentRecord, setCurrentRecord] = reactExports.useState();
      const {
        formProps,
        modalProps,
        show: showChangePasswordModal
      } = ur({
        action: "edit",
        resource: "users/set-password",
        redirect: false
      });
      const {
        tableProps,
        sorter
        // filters
      } = Ie({
        initialSorter: [
          {
            field: "id",
            order: "desc"
          }
        ]
      });
      const extraMenuItems = (record) => [
        {
          key: 3,
          label: "Set password",
          icon: /* @__PURE__ */ jsx(
            LockOutlined$1,
            {
              style: {
                color: "blue",
                fontSize: 17
              }
            }
          ),
          onClick: (info2) => {
            setCurrentRecord(record);
            info2.domEvent.stopPropagation();
            showChangePasswordModal(record.id);
          }
        },
        {
          key: 4,
          label: "Send e-mail verification link",
          icon: /* @__PURE__ */ jsx(
            MailOutlined$1,
            {
              style: {
                color: "blue",
                fontSize: 17
              }
            }
          ),
          onClick: (info2) => {
            void (async () => {
              setCurrentRecord(record);
              info2.domEvent.stopPropagation();
              await sendEmailVerificationLink(record.email, apiUrl);
            })();
          }
        },
        {
          key: 5,
          label: "Send password reset token",
          icon: /* @__PURE__ */ jsx(
            KeyOutlined$1,
            {
              style: {
                color: "blue",
                fontSize: 17
              }
            }
          ),
          onClick: (info2) => {
            void (async () => {
              setCurrentRecord(record);
              info2.domEvent.stopPropagation();
              await sendPasswordResetToken(record.email, apiUrl);
            })();
          }
        }
      ];
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(
          SetPasswordModal,
          {
            user: currentRecord,
            modalProps,
            formProps
          }
        ),
        /* @__PURE__ */ jsxs(
          CrudList,
          {
            resource: "users",
            tableProps,
            sorter,
            menuConfig: { itemsFn: extraMenuItems },
            children: [
              /* @__PURE__ */ jsx(
                Table$1.Column,
                {
                  title: "Name",
                  sorter: true,
                  defaultSortOrder: no("lastName", sorter),
                  render: ({ lastName = "", firstName = "", avatar }) => /* @__PURE__ */ jsxs(Space$1, { children: [
                    /* @__PURE__ */ jsx(Avatar$1, { size: 74, src: avatar == null ? void 0 : avatar.url }),
                    /* @__PURE__ */ jsxs(Typography$1.Text, { style: { wordBreak: "inherit" }, children: [
                      lastName,
                      " ",
                      firstName
                    ] })
                  ] })
                },
                "name"
              ),
              /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "phone", title: "Phone" }),
              /* @__PURE__ */ jsx(
                Table$1.Column,
                {
                  dataIndex: "email",
                  title: "E-mail",
                  sorter: true,
                  defaultSortOrder: no("email", sorter),
                  render: (value) => /* @__PURE__ */ jsx(Ea, { value })
                },
                "email"
              ),
              /* @__PURE__ */ jsx(
                Table$1.Column,
                {
                  dataIndex: "username",
                  title: "username",
                  sorter: true,
                  defaultSortOrder: no("username", sorter)
                },
                "username"
              ),
              /* @__PURE__ */ jsx(
                Table$1.Column,
                {
                  dataIndex: "roles",
                  title: "Roles",
                  render: (roles) => roles.map((role) => /* @__PURE__ */ jsx(Sa, { value: role }, role)),
                  filterDropdown: (props) => /* @__PURE__ */ jsx(sn, { ...props, children: /* @__PURE__ */ jsx(
                    Select$1,
                    {
                      style: { minWidth: 200 },
                      mode: "multiple",
                      placeholder: "Select Role",
                      options: roleOptions
                    }
                  ) })
                }
              )
            ]
          }
        )
      ] });
    };
    const { Text: Text$5 } = Typography$1;
    const UserForm = ({ formProps }) => {
      var _a;
      const apiUrl = ts();
      const uploadAvatarApi = `${apiUrl}/local-files/upload-media`;
      const avatar = (_a = formProps.initialValues) == null ? void 0 : _a.avatar;
      const initialValues = avatar && !Array.isArray(avatar) ? { ...formProps.initialValues, avatar: [avatar] } : formProps.initialValues;
      return /* @__PURE__ */ jsx(
        Form$1,
        {
          ...formProps,
          initialValues,
          layout: "vertical",
          onFinish: (values) => {
            var _a2;
            let avatarId;
            const { avatar: avatar2 } = values;
            if (Array.isArray(avatar2) && avatar2.length) {
              avatarId = ((_a2 = avatar2[0].response) == null ? void 0 : _a2.id) || null;
            } else {
              avatarId = null;
            }
            return formProps.onFinish && formProps.onFinish({
              ...values,
              avatarId
            });
          },
          children: /* @__PURE__ */ jsxs(Row$1, { gutter: 20, children: [
            /* @__PURE__ */ jsx(Col$1, { xs: 24, lg: 8, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "Avatar", children: /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                name: "avatar",
                valuePropName: "fileList",
                getValueFromEvent: Oi,
                noStyle: true,
                children: /* @__PURE__ */ jsx(
                  Upload$1.Dragger,
                  {
                    name: "file",
                    action: uploadAvatarApi,
                    listType: "picture",
                    maxCount: 1,
                    multiple: true,
                    style: {
                      border: "none",
                      width: "100%",
                      background: "none"
                    },
                    children: /* @__PURE__ */ jsxs(Space$1, { direction: "vertical", size: 2, children: [
                      /* @__PURE__ */ jsx(
                        Avatar$1,
                        {
                          style: {
                            width: "100%",
                            height: "100%",
                            maxWidth: "200px"
                          },
                          src: "/images/user-default-img.png",
                          alt: "Store Location"
                        }
                      ),
                      /* @__PURE__ */ jsx(
                        Text$5,
                        {
                          style: {
                            fontWeight: 800,
                            fontSize: "16px",
                            marginTop: "8px"
                          },
                          children: "Add user picture"
                        }
                      ),
                      /* @__PURE__ */ jsx(Text$5, { style: { fontSize: "12px" }, children: "must be 480x480 px" })
                    ] })
                  }
                )
              }
            ) }) }),
            /* @__PURE__ */ jsxs(Col$1, { xs: 24, lg: 16, children: [
              /* @__PURE__ */ jsx(
                Form$1.Item,
                {
                  label: "E-mail",
                  name: "email",
                  rules: [
                    {
                      type: "email",
                      message: "The input is not valid E-mail!"
                    },
                    {
                      required: true,
                      message: "Please input E-mail!"
                    }
                  ],
                  children: /* @__PURE__ */ jsx(Input$1, { type: "email" })
                }
              ),
              /* @__PURE__ */ jsx(
                Form$1.Item,
                {
                  label: "Roles",
                  name: "roles",
                  rules: [
                    {
                      required: true
                    }
                  ],
                  children: /* @__PURE__ */ jsx(Select$1, { mode: "multiple", options: roleOptions })
                }
              ),
              /* @__PURE__ */ jsxs(Row$1, { gutter: 20, children: [
                /* @__PURE__ */ jsx(Col$1, { xs: 24, lg: 12, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "First Name", name: "firstName", children: /* @__PURE__ */ jsx(Input$1, {}) }) }),
                /* @__PURE__ */ jsx(Col$1, { xs: 24, lg: 12, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "Last Name", name: "lastName", children: /* @__PURE__ */ jsx(Input$1, {}) }) })
              ] }),
              /* @__PURE__ */ jsx(Form$1.Item, { label: "Phone", name: "phone", children: /* @__PURE__ */ jsx(Input$1, { type: "tel" }) }),
              /* @__PURE__ */ jsxs(Row$1, { gutter: 20, children: [
                /* @__PURE__ */ jsxs(Col$1, { xs: 24, lg: 4, children: [
                  " ",
                  /* @__PURE__ */ jsx(
                    Form$1.Item,
                    {
                      label: "Registered with Google",
                      name: "isRegisteredWithGoogle",
                      children: /* @__PURE__ */ jsx(
                        Radio$1.Group,
                        {
                          options: [
                            { label: "yes", value: true },
                            { label: "no", value: false }
                          ]
                        }
                      )
                    }
                  )
                ] }),
                /* @__PURE__ */ jsx(Col$1, { xs: 24, lg: 20, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "Google Id", name: "googleId", children: /* @__PURE__ */ jsx(Input$1, {}) }) })
              ] }),
              /* @__PURE__ */ jsxs(Row$1, { gutter: 20, children: [
                /* @__PURE__ */ jsxs(Col$1, { xs: 24, lg: 4, children: [
                  " ",
                  /* @__PURE__ */ jsx(
                    Form$1.Item,
                    {
                      label: "Registered with Facebook",
                      name: "isRegisteredWithFacebook",
                      children: /* @__PURE__ */ jsx(
                        Radio$1.Group,
                        {
                          options: [
                            { label: "yes", value: true },
                            { label: "no", value: false }
                          ]
                        }
                      )
                    }
                  )
                ] }),
                /* @__PURE__ */ jsx(Col$1, { xs: 24, lg: 20, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "Facebook Id", name: "facebookId", children: /* @__PURE__ */ jsx(Input$1, {}) }) })
              ] }),
              /* @__PURE__ */ jsx(
                Form$1.Item,
                {
                  label: "Verification Sent At",
                  name: "verificationCodeSentAt",
                  getValueProps: (value) => ({
                    value: value ? dayjs(value) : ""
                  }),
                  children: /* @__PURE__ */ jsx(DatePicker$1, {})
                }
              ),
              /* @__PURE__ */ jsx(
                Form$1.Item,
                {
                  label: "Verified At",
                  name: "verifiedAt",
                  getValueProps: (value) => ({
                    value: value ? dayjs(value) : ""
                  }),
                  children: /* @__PURE__ */ jsx(DatePicker$1, {})
                }
              )
            ] })
          ] })
        }
      );
    };
    const UserCreate = () => {
      const { formProps, saveButtonProps } = ee();
      return /* @__PURE__ */ jsx(Xs, { saveButtonProps, children: /* @__PURE__ */ jsx(UserForm, { formProps }) });
    };
    const UserEdit = () => {
      const { formProps, saveButtonProps } = ee({
        warnWhenUnsavedChanges: true
      });
      return /* @__PURE__ */ jsx(ia, { saveButtonProps, children: /* @__PURE__ */ jsx(UserForm, { formProps }) });
    };
    const { Title: Title$4, Text: Text$4 } = Typography$1;
    const { useBreakpoint } = Grid;
    const UserShow = () => {
      var _a;
      const { xl } = useBreakpoint();
      const { queryResult } = Md();
      const { data: data2, isLoading } = queryResult;
      const record = data2 == null ? void 0 : data2.data;
      return /* @__PURE__ */ jsx(Ta, { isLoading, children: /* @__PURE__ */ jsxs(Row$1, { gutter: 20, children: [
        /* @__PURE__ */ jsx(Col$1, { xs: 24, lg: 8, children: /* @__PURE__ */ jsxs(Card$1, { bordered: false, style: { height: "100%" }, children: [
          /* @__PURE__ */ jsxs(
            Space$1,
            {
              direction: "vertical",
              style: { width: "100%", height: "100%" },
              children: [
                /* @__PURE__ */ jsx(Avatar$1, { size: 120, src: (_a = record == null ? void 0 : record.avatar) == null ? void 0 : _a.url }),
                /* @__PURE__ */ jsxs(Typography$1.Title, { level: 3, children: [
                  record == null ? void 0 : record.firstName,
                  " ",
                  record == null ? void 0 : record.lastName
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxs(
            Space$1,
            {
              direction: "vertical",
              style: {
                width: "100%",
                textAlign: xl ? "unset" : "center"
              },
              children: [
                /* @__PURE__ */ jsxs(Typography$1.Text, { children: [
                  /* @__PURE__ */ jsx(MailOutlined$1, {}),
                  " ",
                  /* @__PURE__ */ jsx(Ea, { value: record == null ? void 0 : record.email })
                ] }),
                (record == null ? void 0 : record.phone) && /* @__PURE__ */ jsxs(Typography$1.Text, { children: [
                  /* @__PURE__ */ jsx(PhoneOutlined$1, {}),
                  " ",
                  record == null ? void 0 : record.phone
                ] }),
                (record == null ? void 0 : record.googleId) && /* @__PURE__ */ jsxs(Typography$1.Text, { children: [
                  /* @__PURE__ */ jsx(GoogleOutlined$1, {}),
                  " ",
                  record == null ? void 0 : record.googleId
                ] }),
                (record == null ? void 0 : record.facebookId) && /* @__PURE__ */ jsxs(Typography$1.Text, { children: [
                  /* @__PURE__ */ jsx(FacebookOutlined$1, {}),
                  " ",
                  record == null ? void 0 : record.facebookId
                ] })
              ]
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxs(Col$1, { xs: 24, lg: 16, children: [
          /* @__PURE__ */ jsx(Title$4, { level: 5, children: "Id" }),
          /* @__PURE__ */ jsx(Text$4, { children: record == null ? void 0 : record.id }),
          /* @__PURE__ */ jsx(Divider$1, {}),
          /* @__PURE__ */ jsx(Title$4, { level: 5, children: "Roles" }),
          /* @__PURE__ */ jsx(Text$4, { children: record == null ? void 0 : record.roles.map((role) => /* @__PURE__ */ jsx(Sa, { value: role }, role)) }),
          (record == null ? void 0 : record.isRegisteredWithGoogle) && /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx(Title$4, { level: 5, children: "Registered With Google" }),
            /* @__PURE__ */ jsx(Text$4, { children: "yes" })
          ] }),
          (record == null ? void 0 : record.isRegisteredWithFacebook) && /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx(Title$4, { level: 5, children: "Registered With Facebook" }),
            /* @__PURE__ */ jsx(Text$4, { children: "yes" })
          ] }),
          (record == null ? void 0 : record.verificationCodeSentAt) && /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx(Title$4, { level: 5, children: "Verification Sent At" }),
            /* @__PURE__ */ jsx(Text$4, { children: /* @__PURE__ */ jsx(
              Na,
              {
                value: record == null ? void 0 : record.verificationCodeSentAt,
                format: "LLL"
              }
            ) })
          ] }),
          (record == null ? void 0 : record.verifiedAt) && /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx(Title$4, { level: 5, children: "Verified At" }),
            /* @__PURE__ */ jsx(Text$4, { children: /* @__PURE__ */ jsx(Na, { value: record == null ? void 0 : record.verifiedAt, format: "LLL" }) })
          ] }),
          /* @__PURE__ */ jsx(Divider$1, {}),
          /* @__PURE__ */ jsx(Title$4, { level: 5, children: "Created At" }),
          /* @__PURE__ */ jsx(Text$4, { children: /* @__PURE__ */ jsx(Na, { value: record == null ? void 0 : record.createdAt, format: "LLL" }) }),
          /* @__PURE__ */ jsx(Title$4, { level: 5, children: "Updated At" }),
          /* @__PURE__ */ jsx(Text$4, { children: /* @__PURE__ */ jsx(Na, { value: record == null ? void 0 : record.updatedAt, format: "LLL" }) })
        ] })
      ] }) });
    };
    const CustomerList = () => {
      const { tableProps, sorter } = Ie({
        initialSorter: [
          {
            field: "id",
            order: "desc"
          }
        ]
      });
      return /* @__PURE__ */ jsx(CrudList, { resource: "customers", tableProps, sorter, children: /* @__PURE__ */ jsx(
        Table$1.Column,
        {
          title: "Name",
          sorter: true,
          defaultSortOrder: no("lastName", sorter),
          render: ({ lastName = "", firstName = "" }) => /* @__PURE__ */ jsx(Space$1, { children: /* @__PURE__ */ jsxs(Typography$1.Text, { style: { wordBreak: "inherit" }, children: [
            lastName,
            " ",
            firstName
          ] }) })
        },
        "name"
      ) });
    };
    const AUTH_COOKIE_LENGTH = 152;
    const CustomerForm = ({ formProps }) => {
      var _a, _b;
      return /* @__PURE__ */ jsxs(
        Form$1,
        {
          ...formProps,
          layout: "vertical",
          initialValues: {
            ...formProps.initialValues,
            authCookie: (_b = (_a = formProps.initialValues) == null ? void 0 : _a.linkedInProfile) == null ? void 0 : _b.authCookie
          },
          onFinish: (values) => {
            var _a2, _b2;
            const { authCookie, ...rest } = values;
            const dto = {
              linkedInProfile: {
                id: (_b2 = (_a2 = formProps.initialValues) == null ? void 0 : _a2.linkedInProfile) == null ? void 0 : _b2.id,
                authCookie
              },
              ...rest
            };
            return formProps.onFinish && formProps.onFinish(dto);
          },
          children: [
            /* @__PURE__ */ jsxs(Row$1, { gutter: 20, children: [
              /* @__PURE__ */ jsx(Col$1, { xs: 24, lg: 12, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "First Name", name: "firstName", children: /* @__PURE__ */ jsx(Input$1, {}) }) }),
              /* @__PURE__ */ jsx(Col$1, { xs: 24, lg: 12, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "Last Name", name: "lastName", children: /* @__PURE__ */ jsx(Input$1, {}) }) })
            ] }),
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "Authentication Cookie",
                name: "authCookie",
                rules: [
                  {
                    required: true
                  },
                  {
                    min: AUTH_COOKIE_LENGTH
                  },
                  {
                    max: AUTH_COOKIE_LENGTH
                  }
                ],
                children: /* @__PURE__ */ jsx(Input$1, {})
              }
            )
          ]
        }
      );
    };
    const CustomerCreate = () => {
      const { formProps, saveButtonProps } = ee();
      return /* @__PURE__ */ jsx(Xs, { saveButtonProps, children: /* @__PURE__ */ jsx(CustomerForm, { formProps }) });
    };
    const CustomerEdit = () => {
      const { formProps, saveButtonProps } = ee({
        warnWhenUnsavedChanges: true
      });
      return /* @__PURE__ */ jsx(ia, { saveButtonProps, children: /* @__PURE__ */ jsx(CustomerForm, { formProps }) });
    };
    const { Title: Title$3, Text: Text$3 } = Typography$1;
    const CustomerShow = () => {
      const { queryResult } = Md();
      const { data: data2, isLoading } = queryResult;
      const record = data2 == null ? void 0 : data2.data;
      return /* @__PURE__ */ jsxs(Ta, { isLoading, children: [
        /* @__PURE__ */ jsx(Title$3, { level: 5, children: "Id" }),
        /* @__PURE__ */ jsx(Text$3, { children: record == null ? void 0 : record.id }),
        /* @__PURE__ */ jsx(Divider$1, {}),
        /* @__PURE__ */ jsx(Title$3, { level: 5, children: "First Name" }),
        /* @__PURE__ */ jsx(Text$3, { children: record == null ? void 0 : record.firstName }),
        /* @__PURE__ */ jsx(Title$3, { level: 5, children: "Last Name" }),
        /* @__PURE__ */ jsx(Text$3, { children: record == null ? void 0 : record.lastName }),
        /* @__PURE__ */ jsx(Title$3, { level: 5, children: "Authentication Cookie" }),
        /* @__PURE__ */ jsx(Text$3, { children: record == null ? void 0 : record.authCookie }),
        /* @__PURE__ */ jsx(Divider$1, {}),
        /* @__PURE__ */ jsx(Title$3, { level: 5, children: "Created At" }),
        /* @__PURE__ */ jsx(Text$3, { children: /* @__PURE__ */ jsx(Na, { value: record == null ? void 0 : record.createdAt, format: "LLL" }) }),
        /* @__PURE__ */ jsx(Title$3, { level: 5, children: "Updated At" }),
        /* @__PURE__ */ jsx(Text$3, { children: /* @__PURE__ */ jsx(Na, { value: record == null ? void 0 : record.updatedAt, format: "LLL" }) })
      ] });
    };
    const ProxyList = () => {
      const { tableProps, sorter } = Ie({
        initialSorter: [
          {
            field: "id",
            order: "desc"
          }
        ]
      });
      return /* @__PURE__ */ jsxs(CrudList, { resource: "proxies", tableProps, sorter, children: [
        /* @__PURE__ */ jsx(
          Table$1.Column,
          {
            dataIndex: "name",
            title: "Name",
            sorter: true,
            defaultSortOrder: no("name", sorter)
          },
          "name"
        ),
        /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "region", title: "Region" }),
        /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "host", title: "Host" }),
        /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "port", title: "Port" }),
        /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "username", title: "Username" }),
        /* @__PURE__ */ jsx(Table$1.Column, { title: "Status" })
      ] });
    };
    const countryOptions = [
      { value: void 0, label: "Any Country" },
      { value: "us", label: "United States" },
      { value: "gb", label: "United Kingdom" },
      { value: "al", label: "Albania" },
      { value: "ar", label: "Argentina" },
      { value: "am", label: "Armenia" },
      { value: "au", label: "Australia" },
      { value: "at", label: "Austria" },
      { value: "az", label: "Azerbaijan" },
      { value: "bd", label: "Bangladesh" },
      { value: "by", label: "Belarus" },
      { value: "be", label: "Belgium" },
      { value: "bo", label: "Bolivia" },
      { value: "br", label: "Brazil" },
      { value: "bg", label: "Bulgaria" },
      { value: "kh", label: "Cambodia" },
      { value: "ca", label: "Canada" },
      { value: "cl", label: "Chile" },
      { value: "cn", label: "China" },
      { value: "co", label: "Colombia" },
      { value: "cr", label: "Costa Rica" },
      { value: "hr", label: "Croatia" },
      { value: "cy", label: "Cyprus" },
      { value: "cz", label: "Czech Republic" },
      { value: "dk", label: "Denmark" },
      { value: "do", label: "Dominican Republic" },
      { value: "ec", label: "Ecuador" },
      { value: "eg", label: "Egypt" },
      { value: "ee", label: "Estonia" },
      { value: "fi", label: "Finland" },
      { value: "fr", label: "France" },
      { value: "ge", label: "Georgia" },
      { value: "de", label: "Germany" },
      { value: "gr", label: "Greece" },
      { value: "gt", label: "Guatemala" },
      { value: "hk", label: "Hong Kong" },
      { value: "hu", label: "Hungary" },
      { value: "is", label: "Iceland" },
      { value: "in", label: "India" },
      { value: "id", label: "Indonesia" },
      { value: "ie", label: "Ireland" },
      { value: "im", label: "Isle of Man" },
      { value: "il", label: "Israel" },
      { value: "it", label: "Italy" },
      { value: "jm", label: "Jamaica" },
      { value: "jp", label: "Japan" },
      { value: "jo", label: "Jordan" },
      { value: "kz", label: "Kazakhstan" },
      { value: "kg", label: "Kyrgyzstan" },
      { value: "la", label: "Laos" },
      { value: "lv", label: "Latvia" },
      { value: "lt", label: "Lithuania" },
      { value: "lu", label: "Luxembourg" },
      { value: "my", label: "Malaysia" },
      { value: "mx", label: "Mexico" },
      { value: "md", label: "Moldova" },
      { value: "nl", label: "Netherlands" },
      { value: "nz", label: "New Zealand" },
      { value: "no", label: "Norway" },
      { value: "pe", label: "Peru" },
      { value: "ph", label: "Philippines" },
      { value: "ru", label: "Russia" },
      { value: "sa", label: "Saudi Arabia" },
      { value: "sg", label: "Singapore" },
      { value: "kr", label: "South Korea" },
      { value: "es", label: "Spain" },
      { value: "lk", label: "Sri Lanka" },
      { value: "se", label: "Sweden" },
      { value: "ch", label: "Switzerland" },
      { value: "tw", label: "Taiwan" },
      { value: "tj", label: "Tajikistan" },
      { value: "th", label: "Thailand" },
      { value: "tr", label: "Turkey" },
      { value: "tm", label: "Turkmenistan" },
      { value: "ua", label: "Ukraine" },
      { value: "ae", label: "United Arab Emirates" },
      { value: "uz", label: "Uzbekistan" },
      { value: "vn", label: "Vietnam" }
    ];
    const ProxyForm = ({ formProps }) => {
      return /* @__PURE__ */ jsxs(Form$1, { ...formProps, layout: "vertical", children: [
        /* @__PURE__ */ jsx(
          Form$1.Item,
          {
            label: "Name",
            name: "name",
            rules: [
              {
                required: true
              }
            ],
            children: /* @__PURE__ */ jsx(Input$1, {})
          }
        ),
        /* @__PURE__ */ jsx(Form$1.Item, { label: "API token", name: "token", children: /* @__PURE__ */ jsx(Input$1, {}) }),
        /* @__PURE__ */ jsx(
          Form$1.Item,
          {
            label: "Proxy access username",
            name: "username",
            rules: [
              {
                required: true
              }
            ],
            children: /* @__PURE__ */ jsx(Input$1, {})
          }
        ),
        /* @__PURE__ */ jsx(
          Form$1.Item,
          {
            label: "Proxy access password",
            name: "password",
            rules: [
              {
                required: true
              }
            ],
            children: /* @__PURE__ */ jsx(Input$1.Password, {})
          }
        ),
        /* @__PURE__ */ jsx(Form$1.Item, { label: "Limit proxy region", name: "region", children: /* @__PURE__ */ jsx(Select$1, { defaultValue: "", options: countryOptions }) }),
        /* @__PURE__ */ jsx(
          Form$1.Item,
          {
            label: "Parallel scraping job limit",
            name: "parallelScrapingJobLimit",
            children: /* @__PURE__ */ jsx(InputNumber$1, { min: 0 })
          }
        ),
        /* @__PURE__ */ jsx(Form$1.Item, { label: "Host", name: "host", children: /* @__PURE__ */ jsx(Input$1, {}) }),
        /* @__PURE__ */ jsx(Form$1.Item, { label: "Port", name: "port", children: /* @__PURE__ */ jsx(InputNumber$1, { min: 0 }) })
      ] });
    };
    const ProxyCreate = () => {
      const { formProps, saveButtonProps } = ee();
      return /* @__PURE__ */ jsx(Xs, { saveButtonProps, children: /* @__PURE__ */ jsx(ProxyForm, { formProps }) });
    };
    const ProxyEdit = () => {
      const { formProps, saveButtonProps } = ee({
        warnWhenUnsavedChanges: true
      });
      return /* @__PURE__ */ jsx(ia, { saveButtonProps, children: /* @__PURE__ */ jsx(ProxyForm, { formProps }) });
    };
    const { Title: Title$2, Text: Text$2 } = Typography$1;
    const ProxyShow = () => {
      const { queryResult } = Md();
      const { data: data2, isLoading } = queryResult;
      const record = data2 == null ? void 0 : data2.data;
      return /* @__PURE__ */ jsxs(Ta, { isLoading, children: [
        /* @__PURE__ */ jsx(Title$2, { level: 5, children: "Id" }),
        /* @__PURE__ */ jsx(Text$2, { children: record == null ? void 0 : record.id }),
        /* @__PURE__ */ jsx(Divider$1, {}),
        /* @__PURE__ */ jsx(Title$2, { level: 5, children: "Name" }),
        /* @__PURE__ */ jsx(Text$2, { children: record == null ? void 0 : record.name }),
        /* @__PURE__ */ jsx(Title$2, { level: 5, children: "Proxy access username" }),
        /* @__PURE__ */ jsx(Text$2, { children: record == null ? void 0 : record.region }),
        /* @__PURE__ */ jsx(Title$2, { level: 5, children: "Parallel scraping job limit" }),
        /* @__PURE__ */ jsx(Text$2, { children: record == null ? void 0 : record.parallelScrapingJobLimit }),
        /* @__PURE__ */ jsx(Title$2, { level: 5, children: "Host" }),
        /* @__PURE__ */ jsx(Text$2, { children: record == null ? void 0 : record.host }),
        /* @__PURE__ */ jsx(Title$2, { level: 5, children: "Port" }),
        /* @__PURE__ */ jsx(Text$2, { children: record == null ? void 0 : record.port }),
        /* @__PURE__ */ jsx(Divider$1, {}),
        /* @__PURE__ */ jsx(Title$2, { level: 5, children: "Created At" }),
        /* @__PURE__ */ jsx(Text$2, { children: /* @__PURE__ */ jsx(Na, { value: record == null ? void 0 : record.createdAt, format: "LLL" }) }),
        /* @__PURE__ */ jsx(Title$2, { level: 5, children: "Updated At" }),
        /* @__PURE__ */ jsx(Text$2, { children: /* @__PURE__ */ jsx(Na, { value: record == null ? void 0 : record.updatedAt, format: "LLL" }) })
      ] });
    };
    const QueryList = () => {
      const { push: push2 } = q$2();
      const { tableProps, sorter } = Ie({
        initialSorter: [
          {
            field: "id",
            order: "desc"
          }
        ]
      });
      const extraMenuItems = (record) => [
        {
          key: 6,
          label: "Selectors",
          icon: /* @__PURE__ */ jsx(
            SelectOutlined$1,
            {
              style: {
                color: "blue",
                fontSize: 17
              }
            }
          ),
          onClick: (info2) => {
            info2.domEvent.stopPropagation();
            push2(`/queries/${record.id}/selectors`);
          }
        }
      ];
      return /* @__PURE__ */ jsxs(
        CrudList,
        {
          resource: "queries",
          tableProps,
          sorter,
          menuConfig: { itemsFn: extraMenuItems },
          children: [
            /* @__PURE__ */ jsx(
              Table$1.Column,
              {
                dataIndex: "name",
                title: "Name",
                sorter: true,
                defaultSortOrder: no("name", sorter)
              }
            ),
            /* @__PURE__ */ jsx(
              Table$1.Column,
              {
                dataIndex: "startUrl",
                title: "Start Url",
                render: (value) => /* @__PURE__ */ jsx(Ze, { value })
              }
            ),
            /* @__PURE__ */ jsx(
              Table$1.Column,
              {
                dataIndex: "isList",
                title: "Is List?",
                render: (value) => value ? "yes" : ""
              }
            ),
            /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "itemCount", title: "Items count" }),
            /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "requestInterval", title: "Request Interval" }),
            /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "pageLoadDelay", title: "Page Load Delay" }),
            /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "timeout", title: "Timeout" }),
            /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "waitUntil", title: "Wait Until" }),
            /* @__PURE__ */ jsx(
              Table$1.Column,
              {
                dataIndex: "proxy",
                title: "Proxy",
                render: (value) => /* @__PURE__ */ jsx(Fa, { value: value == null ? void 0 : value.name })
              }
            )
          ]
        }
      );
    };
    const waitUntilOptions = Object.values(WaitUntil).map((value) => ({
      label: value,
      value
    }));
    const QueryForm = ({ formProps, queryResult }) => {
      var _a, _b, _c, _d;
      const [disabled, setDisabled] = reactExports.useState(
        !((_a = formProps.initialValues) == null ? void 0 : _a.isList)
      );
      const required2 = [{ required: true }];
      const { selectProps: proxySelectProps } = Zl({
        resource: "proxies",
        optionLabel: "name",
        defaultValue: (_d = (_c = (_b = queryResult == null ? void 0 : queryResult.data) == null ? void 0 : _b.data) == null ? void 0 : _c.proxy) == null ? void 0 : _d.id,
        sort: [
          {
            field: "name",
            order: "asc"
          }
        ]
      });
      return /* @__PURE__ */ jsxs(
        Form$1,
        {
          ...formProps,
          layout: "vertical",
          onFinish: (values) => {
            console.log(values);
            return formProps.onFinish && formProps.onFinish({
              ...values
            });
          },
          children: [
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "Name",
                name: "name",
                rules: [{ required: true }, { max: 20 }],
                children: /* @__PURE__ */ jsx(Input$1, {})
              }
            ),
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "Start Url",
                name: "startUrl",
                rules: [{ required: true }, { max: 200 }],
                children: /* @__PURE__ */ jsx(Input$1, {})
              }
            ),
            /* @__PURE__ */ jsx(Form$1.Item, { label: "Is List", name: "isList", valuePropName: "checked", children: /* @__PURE__ */ jsx(
              Checkbox$1,
              {
                onChange: (e2) => {
                  setDisabled(!e2.target.checked);
                }
              }
            ) }),
            /* @__PURE__ */ jsx(Form$1.Item, { label: "Items count", name: "itemCount", children: /* @__PURE__ */ jsx(InputNumber$1, { min: 0, disabled }) }),
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "Request Interval",
                name: "requestInterval",
                rules: required2,
                children: /* @__PURE__ */ jsx(InputNumber$1, { min: 0 })
              }
            ),
            /* @__PURE__ */ jsx(Form$1.Item, { label: "Page Load Delay", name: "pageLoadDelay", rules: required2, children: /* @__PURE__ */ jsx(InputNumber$1, { min: 0 }) }),
            /* @__PURE__ */ jsx(Form$1.Item, { label: "Timeout", name: "timeout", rules: required2, children: /* @__PURE__ */ jsx(InputNumber$1, { min: 0 }) }),
            /* @__PURE__ */ jsx(Form$1.Item, { label: "Wait Until", name: "waitUntil", rules: required2, children: /* @__PURE__ */ jsx(Select$1, { options: waitUntilOptions }) }),
            /* @__PURE__ */ jsx(Form$1.Item, { label: "Proxy", name: ["proxy", "id"], children: /* @__PURE__ */ jsx(Select$1, { ...proxySelectProps }) })
          ]
        }
      );
    };
    const QueryCreate = () => {
      const { formProps, saveButtonProps, queryResult } = ee();
      return /* @__PURE__ */ jsx(Xs, { saveButtonProps, children: /* @__PURE__ */ jsx(QueryForm, { formProps, queryResult }) });
    };
    const QueryEdit = () => {
      const { formProps, queryResult, saveButtonProps } = ee({
        warnWhenUnsavedChanges: true
      });
      return /* @__PURE__ */ jsx(ia, { saveButtonProps, children: /* @__PURE__ */ jsx(QueryForm, { formProps, queryResult }) });
    };
    const jobStatusOptions = Object.values(JobStatus).map((value) => ({
      label: value,
      value
    }));
    const Filter$1 = (props) => {
      const { selectProps: userSelectProps } = Zl({
        resource: "users",
        optionLabel: "email",
        sort: [
          {
            field: "email",
            order: "asc"
          }
        ]
      });
      const { selectProps: querySelectProps } = Zl({
        resource: "queries",
        optionLabel: "name",
        sort: [
          {
            field: "name",
            order: "asc"
          }
        ]
      });
      const { selectProps: customerSelectProps } = Zl({
        resource: "customers",
        optionLabel: "firstName",
        sort: [
          {
            field: "firstName",
            order: "asc"
          }
        ]
      });
      return /* @__PURE__ */ jsx(Card$1, { title: "Filters", children: /* @__PURE__ */ jsx(Form$1, { layout: "vertical", ...props.formProps, children: /* @__PURE__ */ jsxs(Row$1, { gutter: [10, 0], align: "bottom", children: [
        /* @__PURE__ */ jsx(Col$1, { xs: 24, xl: 24, md: 12, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "User", name: "userId", children: /* @__PURE__ */ jsx(Select$1, { allowClear: true, placeholder: "User", ...userSelectProps }) }) }),
        /* @__PURE__ */ jsx(Col$1, { xs: 24, xl: 24, md: 12, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "Query", name: "queryId", children: /* @__PURE__ */ jsx(Select$1, { allowClear: true, placeholder: "Query", ...querySelectProps }) }) }),
        /* @__PURE__ */ jsx(Col$1, { xs: 24, xl: 24, md: 8, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "Customer", name: "customerId", children: /* @__PURE__ */ jsx(
          Select$1,
          {
            allowClear: true,
            placeholder: "Customer",
            ...customerSelectProps
          }
        ) }) }),
        /* @__PURE__ */ jsx(Col$1, { xs: 24, xl: 24, md: 8, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "Status", name: "status", children: /* @__PURE__ */ jsx(
          Select$1,
          {
            allowClear: true,
            placeholder: "Job status",
            options: jobStatusOptions
          }
        ) }) }),
        /* @__PURE__ */ jsx(Col$1, { xs: 24, xl: 24, md: 8, children: /* @__PURE__ */ jsx(Form$1.Item, { children: /* @__PURE__ */ jsx(
          Button$2,
          {
            style: { width: "100%" },
            htmlType: "submit",
            type: "primary",
            children: "Filter"
          }
        ) }) })
      ] }) }) });
    };
    const JobList = () => {
      const { tableProps, sorter, searchFormProps } = Ie({
        initialSorter: [
          {
            field: "id",
            order: "desc"
          }
        ],
        onSearch: (params) => {
          const { userId, queryId, customerId, status } = params;
          return [
            {
              field: "userId",
              operator: "eq",
              value: userId
            },
            {
              field: "queryId",
              operator: "eq",
              value: queryId
            },
            {
              field: "customerId",
              operator: "eq",
              value: customerId
            },
            {
              field: "status",
              operator: "eq",
              value: status
            }
          ];
        },
        syncWithLocation: false
      });
      return /* @__PURE__ */ jsxs(Row$1, { gutter: [16, 16], children: [
        /* @__PURE__ */ jsx(
          Col$1,
          {
            xl: 4,
            lg: 24,
            xs: 24,
            style: {
              marginTop: "48px"
            },
            children: /* @__PURE__ */ jsx(Filter$1, { formProps: searchFormProps })
          }
        ),
        /* @__PURE__ */ jsx(Col$1, { xl: 20, xs: 24, children: /* @__PURE__ */ jsxs(CrudList, { resource: "jobs", tableProps, sorter, children: [
          /* @__PURE__ */ jsx(
            Table$1.Column,
            {
              dataIndex: "user",
              title: "User",
              render: (value) => /* @__PURE__ */ jsx(Fa, { value: value == null ? void 0 : value.email })
            }
          ),
          /* @__PURE__ */ jsx(
            Table$1.Column,
            {
              dataIndex: "query",
              title: "Query",
              render: (value) => /* @__PURE__ */ jsx(Fa, { value: value == null ? void 0 : value.name })
            }
          ),
          /* @__PURE__ */ jsx(
            Table$1.Column,
            {
              dataIndex: "customer",
              title: "Customer",
              render: (value) => /* @__PURE__ */ jsx(
                Fa,
                {
                  value: `${(value == null ? void 0 : value.firstName) || ""} ${(value == null ? void 0 : value.lastName) || ""}`
                }
              )
            }
          ),
          /* @__PURE__ */ jsx(
            Table$1.Column,
            {
              dataIndex: "status",
              title: "Status",
              sorter: true,
              defaultSortOrder: no("status", sorter)
            },
            "status"
          ),
          /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "requestInterval", title: "Request interval" }),
          /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "pageLoadDelay", title: "Page load delay" }),
          /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "timeout", title: "Timeout" }),
          /* @__PURE__ */ jsx(
            Table$1.Column,
            {
              dataIndex: "proxy",
              title: "Proxy",
              render: (value) => /* @__PURE__ */ jsx(Fa, { value: value == null ? void 0 : value.name })
            }
          )
        ] }) })
      ] });
    };
    const JobForm = ({ formProps }) => {
      var _a, _b, _c, _d, _e2;
      const { selectProps: userSelectProps } = Zl({
        resource: "users",
        optionLabel: "email",
        defaultValue: (_a = formProps.initialValues) == null ? void 0 : _a.userId,
        sort: [
          {
            field: "email",
            order: "asc"
          }
        ]
      });
      const { selectProps: querySelectProps } = Zl({
        resource: "queries",
        optionLabel: "name",
        defaultValue: (_b = formProps.initialValues) == null ? void 0 : _b.queryId,
        sort: [
          {
            field: "name",
            order: "asc"
          }
        ]
      });
      const { selectProps: customerSelectProps } = Zl({
        resource: "customers",
        optionLabel: "firstName",
        defaultValue: (_c = formProps.initialValues) == null ? void 0 : _c.customerId,
        sort: [
          {
            field: "firstName",
            order: "asc"
          }
        ]
      });
      const { selectProps: proxySelectProps } = Zl({
        resource: "proxies",
        optionLabel: "name",
        defaultValue: (_d = formProps.initialValues) == null ? void 0 : _d.proxyId,
        sort: [
          {
            field: "name",
            order: "asc"
          }
        ]
      });
      return /* @__PURE__ */ jsxs(
        Form$1,
        {
          ...formProps,
          layout: "vertical",
          onFinish: (values) => {
            console.log(values);
            return formProps.onFinish && formProps.onFinish(values);
          },
          children: [
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "User",
                name: "userId",
                rules: [
                  {
                    required: true
                  }
                ],
                children: /* @__PURE__ */ jsx(Select$1, { ...userSelectProps })
              }
            ),
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "Query",
                name: "queryId",
                rules: [
                  {
                    required: true
                  }
                ],
                children: /* @__PURE__ */ jsx(Select$1, { ...querySelectProps })
              }
            ),
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "Customer",
                name: "customerId",
                rules: [
                  {
                    required: true
                  }
                ],
                children: /* @__PURE__ */ jsx(Select$1, { ...customerSelectProps })
              }
            ),
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "Request interval",
                name: "requestInterval",
                rules: [
                  {
                    required: true
                  }
                ],
                children: /* @__PURE__ */ jsx(InputNumber$1, { min: 500 })
              }
            ),
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "Page load delay",
                name: "pageLoadDelay",
                rules: [
                  {
                    required: true
                  }
                ],
                children: /* @__PURE__ */ jsx(InputNumber$1, { min: 500 })
              }
            ),
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "Timeout",
                name: "timeout",
                rules: [
                  {
                    required: true
                  }
                ],
                children: /* @__PURE__ */ jsx(InputNumber$1, { min: 0 })
              }
            ),
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "Status",
                name: "status",
                rules: [
                  {
                    required: true
                  }
                ],
                children: /* @__PURE__ */ jsx(
                  Select$1,
                  {
                    defaultValue: (_e2 = formProps.initialValues) == null ? void 0 : _e2.status,
                    options: jobStatusOptions
                  }
                )
              }
            ),
            /* @__PURE__ */ jsx(Form$1.Item, { label: "Proxy", name: "proxyId", children: /* @__PURE__ */ jsx(Select$1, { ...proxySelectProps }) })
          ]
        }
      );
    };
    const JobCreate = () => {
      const { formProps, saveButtonProps } = ee();
      return /* @__PURE__ */ jsx(Xs, { saveButtonProps, children: /* @__PURE__ */ jsx(JobForm, { formProps }) });
    };
    const JobEdit = () => {
      const { formProps, saveButtonProps } = ee({
        warnWhenUnsavedChanges: true
      });
      return /* @__PURE__ */ jsx(ia, { saveButtonProps, children: /* @__PURE__ */ jsx(JobForm, { formProps }) });
    };
    const { Title: Title$1, Text: Text$1 } = Typography$1;
    const JobShow = () => {
      var _a, _b, _c, _d;
      const { queryResult } = Md();
      const { data: data2, isLoading } = queryResult;
      const record = data2 == null ? void 0 : data2.data;
      return /* @__PURE__ */ jsxs(Ta, { isLoading, children: [
        /* @__PURE__ */ jsx(Title$1, { level: 5, children: "Id" }),
        /* @__PURE__ */ jsx(Text$1, { children: record == null ? void 0 : record.id }),
        /* @__PURE__ */ jsx(Divider$1, {}),
        /* @__PURE__ */ jsx(Title$1, { level: 5, children: "Request interval" }),
        /* @__PURE__ */ jsx(Text$1, { children: record == null ? void 0 : record.requestInterval }),
        /* @__PURE__ */ jsx(Title$1, { level: 5, children: "Page load delay" }),
        /* @__PURE__ */ jsx(Text$1, { children: record == null ? void 0 : record.pageLoadDelay }),
        /* @__PURE__ */ jsx(Title$1, { level: 5, children: "Timeout" }),
        /* @__PURE__ */ jsx(Text$1, { children: record == null ? void 0 : record.timeout }),
        /* @__PURE__ */ jsx(Title$1, { level: 5, children: "Status" }),
        /* @__PURE__ */ jsx(Text$1, { children: record == null ? void 0 : record.status }),
        /* @__PURE__ */ jsx(Title$1, { level: 5, children: "Query" }),
        /* @__PURE__ */ jsx(Text$1, { children: (_a = record == null ? void 0 : record.query) == null ? void 0 : _a.name }),
        /* @__PURE__ */ jsx(Title$1, { level: 5, children: "Proxy" }),
        /* @__PURE__ */ jsx(Text$1, { children: ((_b = record == null ? void 0 : record.proxy) == null ? void 0 : _b.name) || "No proxy" }),
        /* @__PURE__ */ jsx(Title$1, { level: 5, children: "Customer" }),
        /* @__PURE__ */ jsx(Text$1, { children: (_c = record == null ? void 0 : record.customer) == null ? void 0 : _c.firstName }),
        /* @__PURE__ */ jsx(Title$1, { level: 5, children: "User" }),
        /* @__PURE__ */ jsx(Text$1, { children: (_d = record == null ? void 0 : record.user) == null ? void 0 : _d.email }),
        /* @__PURE__ */ jsx(Divider$1, {}),
        /* @__PURE__ */ jsx(Title$1, { level: 5, children: "Created At" }),
        /* @__PURE__ */ jsx(Text$1, { children: /* @__PURE__ */ jsx(Na, { value: record == null ? void 0 : record.createdAt, format: "LLL" }) }),
        /* @__PURE__ */ jsx(Title$1, { level: 5, children: "Updated At" }),
        /* @__PURE__ */ jsx(Text$1, { children: /* @__PURE__ */ jsx(Na, { value: record == null ? void 0 : record.updatedAt, format: "LLL" }) })
      ] });
    };
    const Filter = (props) => {
      const { selectProps: userSelectProps } = Zl({
        resource: "users",
        optionLabel: "email",
        sort: [
          {
            field: "email",
            order: "asc"
          }
        ]
      });
      const { selectProps: querySelectProps } = Zl({
        resource: "queries",
        optionLabel: "name",
        sort: [
          {
            field: "name",
            order: "asc"
          }
        ]
      });
      const { selectProps: customerSelectProps } = Zl({
        resource: "customers",
        optionLabel: "firstName",
        sort: [
          {
            field: "firstName",
            order: "asc"
          }
        ]
      });
      return /* @__PURE__ */ jsx(Card$1, { title: "Filters", children: /* @__PURE__ */ jsx(Form$1, { layout: "vertical", ...props.formProps, children: /* @__PURE__ */ jsxs(Row$1, { gutter: [10, 0], align: "bottom", children: [
        /* @__PURE__ */ jsx(Col$1, { xs: 24, xl: 24, md: 12, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "User", name: "userId", children: /* @__PURE__ */ jsx(Select$1, { allowClear: true, placeholder: "User", ...userSelectProps }) }) }),
        /* @__PURE__ */ jsx(Col$1, { xs: 24, xl: 24, md: 12, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "Query", name: "queryId", children: /* @__PURE__ */ jsx(Select$1, { allowClear: true, placeholder: "Query", ...querySelectProps }) }) }),
        /* @__PURE__ */ jsx(Col$1, { xs: 24, xl: 24, md: 8, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "Customer", name: "customerId", children: /* @__PURE__ */ jsx(
          Select$1,
          {
            allowClear: true,
            placeholder: "Customer",
            ...customerSelectProps
          }
        ) }) }),
        /* @__PURE__ */ jsx(Col$1, { xs: 24, xl: 24, md: 8, children: /* @__PURE__ */ jsx(Form$1.Item, { label: "Scheduler enabled", name: "schedulerEnabled", children: /* @__PURE__ */ jsx(
          Select$1,
          {
            allowClear: true,
            placeholder: "Scheduler status",
            options: [
              {
                label: "Yes",
                value: "true"
              },
              {
                label: "No",
                value: "false"
              }
            ]
          }
        ) }) }),
        /* @__PURE__ */ jsx(Col$1, { xs: 24, xl: 24, md: 8, children: /* @__PURE__ */ jsx(Form$1.Item, { children: /* @__PURE__ */ jsx(
          Button$2,
          {
            style: { width: "100%" },
            htmlType: "submit",
            type: "primary",
            children: "Filter"
          }
        ) }) })
      ] }) }) });
    };
    const ScheduleList = () => {
      const { tableProps, sorter, searchFormProps } = Ie({
        initialSorter: [
          {
            field: "id",
            order: "desc"
          }
        ],
        onSearch: (params) => {
          const { userId, queryId, customerId, schedulerEnabled } = params;
          return [
            {
              field: "userId",
              operator: "eq",
              value: userId
            },
            {
              field: "queryId",
              operator: "eq",
              value: queryId
            },
            {
              field: "customerId",
              operator: "eq",
              value: customerId
            },
            {
              field: "schedulerEnabled",
              operator: "eq",
              value: schedulerEnabled
            }
          ];
        },
        syncWithLocation: false
      });
      return /* @__PURE__ */ jsxs(Row$1, { gutter: [16, 16], children: [
        /* @__PURE__ */ jsx(
          Col$1,
          {
            xl: 4,
            lg: 24,
            xs: 24,
            style: {
              marginTop: "48px"
            },
            children: /* @__PURE__ */ jsx(Filter, { formProps: searchFormProps })
          }
        ),
        /* @__PURE__ */ jsx(Col$1, { xl: 20, xs: 24, children: /* @__PURE__ */ jsxs(CrudList, { resource: "schedules", tableProps, sorter, children: [
          /* @__PURE__ */ jsx(
            Table$1.Column,
            {
              dataIndex: "user",
              title: "User",
              render: (value) => /* @__PURE__ */ jsx(Fa, { value: value == null ? void 0 : value.email })
            }
          ),
          /* @__PURE__ */ jsx(
            Table$1.Column,
            {
              dataIndex: "query",
              title: "Query",
              render: (value) => /* @__PURE__ */ jsx(Fa, { value: value == null ? void 0 : value.name })
            }
          ),
          /* @__PURE__ */ jsx(
            Table$1.Column,
            {
              dataIndex: "customer",
              title: "Customer",
              render: (value) => /* @__PURE__ */ jsx(
                Fa,
                {
                  value: `${(value == null ? void 0 : value.firstName) || ""} ${(value == null ? void 0 : value.lastName) || ""}`
                }
              )
            }
          ),
          /* @__PURE__ */ jsx(
            Table$1.Column,
            {
              dataIndex: "schedulerEnabled",
              title: "Enabled",
              render: (value) => value ? "Yes" : null
            }
          ),
          /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "requestInterval", title: "Request interval" }),
          /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "pageLoadDelay", title: "Page load delay" }),
          /* @__PURE__ */ jsx(Table$1.Column, { dataIndex: "timeout", title: "Timeout" }),
          /* @__PURE__ */ jsx(
            Table$1.Column,
            {
              dataIndex: "proxy",
              title: "Proxy",
              render: (value) => (value == null ? void 0 : value.name) ? /* @__PURE__ */ jsx(Ua, { title: value == null ? void 0 : value.name }) : null
            }
          )
        ] }) })
      ] });
    };
    const dailyWeekdaysOptions = ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"].map((label, value) => ({
      label,
      value
    }));
    const acceptedHoursOptions = [1, 2, 3, 4, 6, 12].map(
      (value) => ({
        label: value,
        value
      })
    );
    const acceptedMinutesOptions = [1, 2, 3, 4, 5, 10, 15, 20, 30].map(
      (value) => ({
        label: value,
        value
      })
    );
    const intervalTypeOptions = Object.values(IntervalType).map((value) => ({
      label: value,
      value
    }));
    const schedulerTypeOptions = Object.values(SchedulerType).map(
      (value) => ({
        label: value === SchedulerType.Custom ? "custom cron options" : value,
        value
      })
    );
    const timeFormat = "HH:mm";
    const DEFAULT_SCHEDULER_ENABLED = false;
    const DEFAULT_INTERVAL = 1;
    const DEFAULT_SCHEDULER_TYPE = SchedulerType.Daily;
    const formItemLayout = {
      labelCol: {
        xs: { span: 24 },
        sm: { span: 4 }
      },
      wrapperCol: {
        xs: { span: 24 },
        sm: { span: 20 }
      }
    };
    const formItemLayout2 = {
      labelCol: {
        xs: { span: 24 },
        sm: { span: 8 }
      },
      wrapperCol: {
        xs: { span: 24 },
        sm: { span: 12 }
      }
    };
    const formItemLayoutCron = {
      labelCol: {
        xs: { span: 24 },
        sm: { span: 4 }
      },
      wrapperCol: {
        xs: { span: 24 },
        sm: { span: 8 }
      }
    };
    const formItemLayoutCombo = {
      labelCol: {
        xs: { span: 24 },
        sm: { span: 4 }
      },
      wrapperCol: {
        xs: { span: 24 },
        sm: { span: 4 }
      }
    };
    const dailyRequired = (form) => ({
      required: form.getFieldValue("schedulerType") === SchedulerType.Daily
    });
    const customRequired = (form) => ({
      required: form.getFieldValue("schedulerType") === SchedulerType.Custom
    });
    const ScheduleForm = ({ formProps }) => {
      var _a, _b, _c, _d, _e2, _f, _g;
      const [intervalOptions, setIntervalOptions] = reactExports.useState(
        ((_a = formProps.initialValues) == null ? void 0 : _a.intervalType) === IntervalType.Hour ? acceptedHoursOptions : acceptedMinutesOptions
      );
      const [interval, setInterval2] = reactExports.useState(
        ((_b = formProps.initialValues) == null ? void 0 : _b.interval) || DEFAULT_INTERVAL
      );
      if (!formProps.initialValues) {
        formProps.initialValues = {};
      }
      if (!formProps.initialValues.schedulerEnabled) {
        formProps.initialValues.schedulerEnabled = DEFAULT_SCHEDULER_ENABLED;
      }
      if (!formProps.initialValues.interval) {
        formProps.initialValues.interval = DEFAULT_INTERVAL;
      }
      if (!formProps.initialValues.schedulerType) {
        formProps.initialValues.schedulerType = DEFAULT_SCHEDULER_TYPE;
      }
      const { selectProps: userSelectProps } = Zl({
        resource: "users",
        optionLabel: "email",
        defaultValue: (_c = formProps.initialValues) == null ? void 0 : _c.userId,
        sort: [
          {
            field: "email",
            order: "asc"
          }
        ]
      });
      const { selectProps: querySelectProps } = Zl({
        resource: "queries",
        optionLabel: "name",
        defaultValue: formProps.initialValues.queryId,
        sort: [
          {
            field: "name",
            order: "asc"
          }
        ]
      });
      const { selectProps: customerSelectProps } = Zl({
        resource: "customers",
        optionLabel: "firstName",
        defaultValue: (_d = formProps.initialValues) == null ? void 0 : _d.customerId,
        sort: [
          {
            field: "firstName",
            order: "asc"
          }
        ]
      });
      const { selectProps: proxySelectProps } = Zl({
        resource: "proxies",
        optionLabel: "name",
        defaultValue: formProps.initialValues.proxyId,
        sort: [
          {
            field: "name",
            order: "asc"
          }
        ]
      });
      const { selectProps: timezoneSelectProps } = Zl({
        resource: "timezones",
        optionLabel: "code",
        defaultValue: (_e2 = formProps.initialValues) == null ? void 0 : _e2.timezoneId,
        // || 'UTC',
        sort: [
          {
            field: "code",
            order: "asc"
          }
        ],
        filters: [],
        pagination: { pageSize: 1e3 }
      });
      if (!formProps.initialValues.intervalType) {
        formProps.initialValues.intervalType = IntervalType.Minute;
      }
      const handleIntervalTypeChange = (value) => {
        setIntervalOptions(
          () => value === IntervalType.Hour ? acceptedHoursOptions : acceptedMinutesOptions
        );
        setInterval2(DEFAULT_INTERVAL);
      };
      const [
        minute = "*",
        hour = "*",
        dayOfMonth = "*",
        month = "*",
        dayOfWeek = "*"
      ] = ((_f = formProps.initialValues.cron) == null ? void 0 : _f.split(" ")) || [];
      formProps.initialValues.dailyTime = dayjs(
        formProps.initialValues.dailyTime || "00:00",
        timeFormat
      );
      formProps.initialValues = {
        ...formProps.initialValues,
        minute,
        hour,
        dayOfMonth,
        month,
        dayOfWeek
      };
      const schedulerType = (_g = formProps.form) == null ? void 0 : _g.getFieldValue("schedulerType");
      return /* @__PURE__ */ jsxs(
        Form$1,
        {
          ...formProps,
          ...formItemLayout,
          layout: "horizontal",
          onFinish: ({
            minute: minute2,
            hour: hour2,
            dayOfMonth: dayOfMonth2,
            month: month2,
            dayOfWeek: dayOfWeek2,
            dailyTime,
            timezoneId,
            ...rest
          }) => {
            var _a2;
            const cron = `${minute2 || "*"} ${hour2 || "*"} ${dayOfMonth2 || "*"} ${month2 || "*"} ${dayOfWeek2 || "*"}`;
            const dto = {
              cron,
              dailyTime: dayjs(dailyTime).format(timeFormat),
              timezoneId: timezoneId ? timezoneId : null,
              ...rest
            };
            return (_a2 = formProps.onFinish) == null ? void 0 : _a2.call(formProps, dto);
          },
          children: [
            /* @__PURE__ */ jsxs(Row$1, { gutter: [16, 16], children: [
              /* @__PURE__ */ jsxs(Col$1, { xs: 24, sm: 12, children: [
                /* @__PURE__ */ jsx(
                  Form$1.Item,
                  {
                    ...formItemLayout2,
                    label: "User",
                    name: "userId",
                    rules: [
                      {
                        required: true
                      }
                    ],
                    children: /* @__PURE__ */ jsx(Select$1, { ...userSelectProps })
                  }
                ),
                /* @__PURE__ */ jsx(
                  Form$1.Item,
                  {
                    ...formItemLayout2,
                    label: "Query",
                    name: "queryId",
                    rules: [
                      {
                        required: true
                      }
                    ],
                    children: /* @__PURE__ */ jsx(Select$1, { ...querySelectProps })
                  }
                ),
                /* @__PURE__ */ jsx(
                  Form$1.Item,
                  {
                    ...formItemLayout2,
                    label: "Customer",
                    name: "customerId",
                    rules: [
                      {
                        required: true
                      }
                    ],
                    children: /* @__PURE__ */ jsx(Select$1, { ...customerSelectProps })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxs(Col$1, { xs: 24, sm: 12, children: [
                /* @__PURE__ */ jsx(
                  Form$1.Item,
                  {
                    ...formItemLayout2,
                    label: "Request interval",
                    name: "requestInterval",
                    rules: [
                      {
                        required: true
                      }
                    ],
                    children: /* @__PURE__ */ jsx(InputNumber$1, { min: 500 })
                  }
                ),
                /* @__PURE__ */ jsx(
                  Form$1.Item,
                  {
                    ...formItemLayout2,
                    label: "Page load delay",
                    name: "pageLoadDelay",
                    rules: [
                      {
                        required: true
                      }
                    ],
                    children: /* @__PURE__ */ jsx(InputNumber$1, { min: 500 })
                  }
                ),
                /* @__PURE__ */ jsx(
                  Form$1.Item,
                  {
                    ...formItemLayout2,
                    label: "Timeout",
                    name: "timeout",
                    rules: [
                      {
                        required: true
                      }
                    ],
                    children: /* @__PURE__ */ jsx(InputNumber$1, { min: 0 })
                  }
                ),
                /* @__PURE__ */ jsx(Form$1.Item, { ...formItemLayout2, label: "Proxy", name: "proxyId", children: /* @__PURE__ */ jsx(
                  Select$1,
                  {
                    options: [
                      { value: null, label: "No Proxy" },
                      ...proxySelectProps.options || []
                    ]
                  }
                ) })
              ] })
            ] }),
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                label: "Enable scheduler",
                name: "schedulerEnabled",
                valuePropName: "checked",
                children: /* @__PURE__ */ jsx(Switch$1, {})
              }
            ),
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                ...formItemLayoutCombo,
                label: "Scheduler Time zone",
                name: "timezoneId",
                children: /* @__PURE__ */ jsx(
                  Select$1,
                  {
                    options: [
                      { value: null, label: "UTC" },
                      ...timezoneSelectProps.options || []
                    ]
                  }
                )
              }
            ),
            /* @__PURE__ */ jsx(
              Form$1.Item,
              {
                ...formItemLayoutCombo,
                label: "Scheduler Type",
                name: "schedulerType",
                rules: [
                  {
                    required: true
                  }
                ],
                children: /* @__PURE__ */ jsx(Select$1, { options: schedulerTypeOptions })
              }
            ),
            schedulerType === SchedulerType.Daily && /* @__PURE__ */ jsxs(Fragment, { children: [
              /* @__PURE__ */ jsx(
                Form$1.Item,
                {
                  label: "Run a job on",
                  name: "dailyWeekdays",
                  rules: [dailyRequired],
                  children: /* @__PURE__ */ jsx(
                    Select$1,
                    {
                      mode: "multiple",
                      allowClear: true,
                      style: { width: "100%" },
                      options: dailyWeekdaysOptions
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsx(Form$1.Item, { label: "At", name: "dailyTime", rules: [dailyRequired], children: /* @__PURE__ */ jsx(TimePicker$1, { format: timeFormat }) })
            ] }),
            schedulerType === SchedulerType.Interval && /* @__PURE__ */ jsxs(Form$1.Item, { label: "Run a job every", children: [
              /* @__PURE__ */ jsx(
                Form$1.Item,
                {
                  name: "interval",
                  style: { display: "inline-block", width: "calc(50% - 8px)" },
                  children: /* @__PURE__ */ jsx(Select$1, { options: intervalOptions, value: interval })
                }
              ),
              /* @__PURE__ */ jsx(
                Form$1.Item,
                {
                  name: "intervalType",
                  style: {
                    display: "inline-block",
                    width: "calc(50% - 8px)",
                    margin: "0 8px"
                  },
                  children: /* @__PURE__ */ jsx(
                    Select$1,
                    {
                      options: intervalTypeOptions,
                      onChange: handleIntervalTypeChange
                    }
                  )
                }
              )
            ] }),
            schedulerType === SchedulerType.Custom && /* @__PURE__ */ jsxs(Fragment, { children: [
              /* @__PURE__ */ jsx(
                Form$1.Item,
                {
                  ...formItemLayoutCron,
                  label: "Minute",
                  name: "minute",
                  rules: [customRequired],
                  children: /* @__PURE__ */ jsx(Input$1, {})
                }
              ),
              /* @__PURE__ */ jsx(
                Form$1.Item,
                {
                  ...formItemLayoutCron,
                  label: "Hour",
                  name: "hour",
                  rules: [customRequired],
                  children: /* @__PURE__ */ jsx(Input$1, {})
                }
              ),
              /* @__PURE__ */ jsx(
                Form$1.Item,
                {
                  ...formItemLayoutCron,
                  label: "Day Of Month",
                  name: "dayOfMonth",
                  rules: [customRequired],
                  children: /* @__PURE__ */ jsx(Input$1, {})
                }
              ),
              /* @__PURE__ */ jsx(
                Form$1.Item,
                {
                  ...formItemLayoutCron,
                  label: "Month",
                  name: "month",
                  rules: [customRequired],
                  children: /* @__PURE__ */ jsx(Input$1, {})
                }
              ),
              /* @__PURE__ */ jsx(
                Form$1.Item,
                {
                  ...formItemLayoutCron,
                  label: "Day Of Week",
                  name: "dayOfWeek",
                  rules: [customRequired],
                  children: /* @__PURE__ */ jsx(Input$1, {})
                }
              )
            ] })
          ]
        }
      );
    };
    const ScheduleCreate = () => {
      const { formProps, saveButtonProps } = ee();
      return /* @__PURE__ */ jsx(Xs, { saveButtonProps, children: /* @__PURE__ */ jsx(ScheduleForm, { formProps }) });
    };
    const ScheduleEdit = () => {
      const { formProps, saveButtonProps } = ee({
        warnWhenUnsavedChanges: true
      });
      return /* @__PURE__ */ jsx(ia, { saveButtonProps, children: /* @__PURE__ */ jsx(ScheduleForm, { formProps }) });
    };
    const { Title, Text } = Typography$1;
    const ScheduleShow = () => {
      var _a, _b, _c, _d;
      const { queryResult } = Md();
      const { data: data2, isLoading } = queryResult;
      const record = data2 == null ? void 0 : data2.data;
      return /* @__PURE__ */ jsxs(Ta, { isLoading, children: [
        /* @__PURE__ */ jsx(Title, { level: 5, children: "Id" }),
        /* @__PURE__ */ jsx(Text, { children: record == null ? void 0 : record.id }),
        /* @__PURE__ */ jsx(Divider$1, {}),
        /* @__PURE__ */ jsx(Title, { level: 5, children: "Request interval" }),
        /* @__PURE__ */ jsx(Text, { children: record == null ? void 0 : record.requestInterval }),
        /* @__PURE__ */ jsx(Title, { level: 5, children: "Page load delay" }),
        /* @__PURE__ */ jsx(Text, { children: record == null ? void 0 : record.pageLoadDelay }),
        /* @__PURE__ */ jsx(Title, { level: 5, children: "Timeout" }),
        /* @__PURE__ */ jsx(Text, { children: record == null ? void 0 : record.timeout }),
        /* @__PURE__ */ jsx(Title, { level: 5, children: "Query" }),
        /* @__PURE__ */ jsx(Text, { children: (_a = record == null ? void 0 : record.query) == null ? void 0 : _a.name }),
        /* @__PURE__ */ jsx(Title, { level: 5, children: "Proxy" }),
        /* @__PURE__ */ jsx(Text, { children: ((_b = record == null ? void 0 : record.proxy) == null ? void 0 : _b.name) || "No proxy" }),
        /* @__PURE__ */ jsx(Title, { level: 5, children: "Customer" }),
        /* @__PURE__ */ jsx(Text, { children: (_c = record == null ? void 0 : record.customer) == null ? void 0 : _c.firstName }),
        /* @__PURE__ */ jsx(Title, { level: 5, children: "User" }),
        /* @__PURE__ */ jsx(Text, { children: (_d = record == null ? void 0 : record.user) == null ? void 0 : _d.email }),
        /* @__PURE__ */ jsx(Divider$1, {}),
        /* @__PURE__ */ jsx(Title, { level: 5, children: "Created At" }),
        /* @__PURE__ */ jsx(Text, { children: /* @__PURE__ */ jsx(Na, { value: record == null ? void 0 : record.createdAt, format: "LLL" }) }),
        /* @__PURE__ */ jsx(Title, { level: 5, children: "Updated At" }),
        /* @__PURE__ */ jsx(Text, { children: /* @__PURE__ */ jsx(Na, { value: record == null ? void 0 : record.updatedAt, format: "LLL" }) })
      ] });
    };
    const axiosInstance = axios$4.create();
    axiosInstance.interceptors.request.use((request) => {
      const userData = localStorage.getItem("refine-auth");
      if (userData) {
        request.withCredentials = true;
      }
      return request;
    });
    axiosInstance.interceptors.response.use(
      (response) => {
        return response;
      },
      (error) => {
        var _a, _b, _c;
        const customError = {
          ...error,
          message: (_b = (_a = error.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message,
          statusCode: (_c = error.response) == null ? void 0 : _c.status
        };
        return Promise.reject(customError);
      }
    );
    function App() {
      const [currentTheme, setCurrentTheme] = reactExports.useState("dark");
      reactExports.useEffect(() => {
        setCurrentTheme(getTheme());
      }, []);
      return /* @__PURE__ */ jsx(
        ConfigProvider$1,
        {
          theme: {
            algorithm: currentTheme === "light" ? theme.defaultAlgorithm : theme.darkAlgorithm
          },
          children: /* @__PURE__ */ jsx(
            Ea$1,
            {
              dataProvider: H(
                "https://nes2.adaptable.app/api/v1",
                axiosInstance
              ),
              routerProvider: {
                ...ke,
                routes: [
                  {
                    path: "/register",
                    element: /* @__PURE__ */ jsx(AuthPage, { type: "register" })
                  },
                  {
                    path: "/forgot-password",
                    element: /* @__PURE__ */ jsx(AuthPage, { type: "forgotPassword" })
                  },
                  {
                    path: "/update-password",
                    element: /* @__PURE__ */ jsx(AuthPage, { type: "updatePassword" })
                  },
                  {
                    path: "/queries/:id/selectors",
                    element: /* @__PURE__ */ jsx(ShowSelectors, {}),
                    layout: true
                  }
                ]
              },
              authProvider: authProvider(axiosInstance),
              DashboardPage,
              LoginPage: () => /* @__PURE__ */ jsx(
                AuthPage,
                {
                  type: "login",
                  formProps: {
                    initialValues: {
                      email: "test@a.aa",
                      password: "Abc123!!"
                    }
                  }
                }
              ),
              resources: [
                {
                  name: "users",
                  list: UserList,
                  create: UserCreate,
                  edit: UserEdit,
                  show: UserShow
                },
                {
                  name: "customers",
                  list: CustomerList,
                  create: CustomerCreate,
                  edit: CustomerEdit,
                  show: CustomerShow
                },
                {
                  name: "proxies",
                  list: ProxyList,
                  create: ProxyCreate,
                  edit: ProxyEdit,
                  show: ProxyShow
                },
                {
                  name: "queries",
                  list: QueryList,
                  create: QueryCreate,
                  edit: QueryEdit
                  // show: QueryShow,
                },
                {
                  name: "jobs",
                  list: JobList,
                  create: JobCreate,
                  edit: JobEdit,
                  show: JobShow
                },
                {
                  name: "schedules",
                  list: ScheduleList,
                  create: ScheduleCreate,
                  edit: ScheduleEdit,
                  show: ScheduleShow
                }
              ],
              notificationProvider: wp,
              Title: Title$7,
              Header: () => /* @__PURE__ */ jsx(Header, { theme: currentTheme, setTheme: setCurrentTheme }),
              Layout: gt,
              Sider: CustomSider,
              ReadyPage: Nn,
              catchAll: /* @__PURE__ */ jsx(bn, {}),
              options: {
                syncWithLocation: true,
                warnWhenUnsavedChanges: true,
                disableTelemetry: true
              }
            }
          )
        }
      );
    }
    const container = document.getElementById("root");
    const root = createRoot$1(container);
    root.render(
      /* @__PURE__ */ jsx(React$3.StrictMode, { children: /* @__PURE__ */ jsx(React$3.Suspense, { fallback: "loading", children: /* @__PURE__ */ jsx(App, {}) }) })
    );
  }
});
export default require_index_001();
